{"meta":{"title":"Room of Equirement","subtitle":"pwn what you want","description":"pwn菜鸡一枚","author":"Sirius Whiter","url":"http://siriuswhiter.tk"},"pages":[{"title":"About Me","date":"2018-08-24T04:15:58.000Z","updated":"2018-08-24T05:21:32.074Z","comments":true,"path":"about/index.html","permalink":"http://siriuswhiter.tk/about/index.html","excerpt":"","text":"I’m Sirius Whiter,a sophomore at CUG,pwn noob.Bosses do light spray.contact me at github:siriuswhiterFor the pwn is long and full of terrors"},{"title":"archives","date":"2018-08-24T04:17:49.000Z","updated":"2018-08-24T04:17:49.342Z","comments":true,"path":"archives/index.html","permalink":"http://siriuswhiter.tk/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-08-24T04:17:06.000Z","updated":"2018-08-24T04:17:06.852Z","comments":true,"path":"categories/index.html","permalink":"http://siriuswhiter.tk/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-24T04:16:44.000Z","updated":"2018-08-25T02:05:49.548Z","comments":true,"path":"tags/index.html","permalink":"http://siriuswhiter.tk/tags/index.html","excerpt":"","text":"-skills -pwn -RE"}],"posts":[{"title":"pwn 入门n.n","slug":"pwn-入门n-n","date":"2018-08-28T03:10:56.000Z","updated":"2018-08-28T03:19:20.274Z","comments":true,"path":"2018/08/28/pwn-入门n-n/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门n-n/","excerpt":"","text":"堆的UAF(use after free)利用学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，只能看了下pwn的tips，开始现学现卖。 原理就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。 根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。 漏洞的简单利用1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);void evil_fuc(char command[])&#123;system(command);&#125;void echo(char content[])&#123;printf(&quot;%s&quot;,content);&#125;int main()&#123; func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(&quot;malloc addr: %p\\n&quot;,p1); p1[3]=echo; p1[3](&quot;hello world\\n&quot;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1[3](&quot;hello again\\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态 func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(&quot;malloc addr: %p\\n&quot;,p2); printf(&quot;malloc addr: %p\\n&quot;,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p1[3](&quot;/bin/sh&quot;); return 0;&#125; 最终运行效果： result 漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程 学习借鉴文章来源：https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]},{"title":"pwn.入门1.2","slug":"pwn-入门1-2","date":"2018-08-28T01:46:58.000Z","updated":"2018-08-28T01:55:07.624Z","comments":true,"path":"2018/08/28/pwn-入门1-2/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门1-2/","excerpt":"","text":"ret2libc学习 ret2libc使用原因程序不是静态编译，通常就不会有int 0x80 ret2syscall 就无法实现，因而使用 ret2library。 调用函数的栈结构布局 ： 调用函数的返回地址 函数调用完的返回地址 调用函数的参数1 调用函数的参数2 利用过程分析：ASLR使得每次载入的函数地址（base）都不同 实际地址 Address = base +offset 若地址为 0xf… 则其为实际地址； offset在libc库中是固定的； 查看libc库版本： 12ldd ./file 寻找偏移地址 ： 1readelf -a /lib32/libc.so.6 | grep gets@ 目标是寻找libc 的 base : 1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset 2.从stack残渣中获取libc地址信息 延迟绑定（没搞清楚，之后再写）函数调用方式： call func@plt –&gt; .got.plt –&gt;.got.plt的值为该func的实际地址（所需address） 使用调用函数的栈结构布局：1. 123456789101112gets()pop1_ret(pop&lt;buf&gt; 然后 return）&lt;buf&gt;system()xxx&lt;buf&gt; 2. 12345678gets()system()&lt;buf&gt;&lt;buf&gt;","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]},{"title":"软件保护/软件破解 及对抗","slug":"软件保护-软件破解-及对抗","date":"2018-08-25T01:30:41.000Z","updated":"2018-08-25T11:15:33.954Z","comments":true,"path":"2018/08/25/软件保护-软件破解-及对抗/","link":"","permalink":"http://siriuswhiter.tk/2018/08/25/软件保护-软件破解-及对抗/","excerpt":"","text":"软件保护简单算法注册保护：输入用户名序列号，计算并检测序列号； 简单算法注册保护的对抗：①修改关键指令：暴力破解；patcher②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机③还原本身算法；keygen 复杂算法注册保护：通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等； 复杂算法注册保护的对抗：①patch②补丁修改公钥，使用自己的公钥对； 网络加密及硬件加密：本质上与本地加密相同/运行前检测？？ 网络加密及硬件加密的对抗：①patch②模拟与远程端的通信，及模拟执行；③使用中转程序，从服务器获得远程执行结果； 复杂系统注册保护：以上内容混杂 附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测 软件破解及对抗程序分析及对抗： 代码变形mutation； 代码膨胀expansion； 花指令； 代码乱序； 平坦化； 程序调试及对抗： 系统API检测程序是否处于被调试状态； 检测调试器窗口信息、状态码； 检测调试器驱动，符号； 程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）； 利用驱动接管本身程序的中断，阻止被调试器接管； 利用驱动修改内核参数，阻止程序被调试； 双进程反调试； 程序修改及对抗：修改：文件补丁技术及工具；对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等； dnspy：.NET程序逆向工具","categories":[],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"hexo essay writing","slug":"hexo-essay-writing","date":"2018-08-15T15:33:24.000Z","updated":"2018-08-25T02:04:13.859Z","comments":true,"path":"2018/08/15/hexo-essay-writing/","link":"","permalink":"http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/","excerpt":"","text":"打开git,进入MyBlog目录； 输入 hexo new &quot;essay-name&quot;； 打开source文件夹，找到 essay-name.md，使用markdown语法写作； 执行命令 / hexo clean / hexo generate/ hexo deploy； over； 假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。","categories":[],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"markdown规范学习","slug":"markdown规范学习","date":"2018-08-13T14:46:46.000Z","updated":"2018-08-24T05:18:29.983Z","comments":true,"path":"2018/08/13/markdown规范学习/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/markdown规范学习/","excerpt":"","text":"MarkDown v1.01.1 全局规范 MarkDown 文件使用‘.md’结尾 （小写字母) 格式规范标题结构格式1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开2.’#’号和文字之间’一个空格’连接3.标题层级最多六级 ‘#’到’######’ 加强和强调规范一般统一使用第一种 12*emphasize*_emphasize_ 使用’~~’给文字添加删除线1~~strikethrough~~ 代码块规范 行内代码使用’一对波浪号’如：hello world! 块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下： 123&lt;?php echo &apos;看源码之三个波浪号&apos;;?&gt; &lt;?php echo &apos;看源码之四空格缩进&apos;; ?&gt; 列表写法 列号’1.’或者’*’后内容用空格隔开 列表块前后’整行隔开’ 如下： 1234561. Windows 2. Mac3. iOS * iPhone * iPad4. Android 实际预览： Windows Mac iOS iPhone iPad Android 123456* Windows * Mac* iOS* Android 1. v3.2 2. v4.1 实际预览： Windows Mac iOS Android v3.2 v4.1 其他标签规范链接和email Inline： 1An [example](http://url.com/ &quot;title&quot;) 实现效果：An example 引用样式标签（titles are optional）: An [example][id].Then,anywhere else in the doc,define the link: [id]:http://example.com/ &quot;title&quot; Email: 1An email &lt;example@example.com&gt; link. 插图Inline(titles are optional)： 1![alt text](/path/img.jpg &quot;title&quot;) 引用式插图： ![alt text][id] [id]:/url/to/img.jpg &quot;title&quot; 引用块及嵌套 Email-style angle bracketsare used for blockquotes. And, they can be nested. Headers in blockquotes You can quote a list. Etc. 内联代码 &lt;code&gt; 段落中的用法 也可以 `代码中包含波浪号`.代码块 Indent every line of a code block by at least 4 spaces or 1 tab.代码的每行都最少用4个空格或者一个制表符(tab) 我是普通文本块 我是一个预格式化的 代码块. 水平分割线三个连字符-: 表格规范一个简单的表格看起来如下： 第一个头部 第二个头部 第三个头部 内容格子 内容格子 内容格子 内容格子 内容格子 内容格子 每列的对齐可以通过在分割线上添加冒号来实现： 第一个头部 第二个头部 第三个头部 左对齐 居中 右对齐 左对齐 居中 右对齐 页内锚标记 点我跳转到顶部 // 利用 #,## 生成 id 锚标签 另一种锚标记 // 利用 &lt;a name=&quot;top&quot;&gt;&lt;/a&gt; 附：参考 Hello-World.md 源码，注意换行的使用 123456789101112131415# Hello-World这是一个范例文件格式我是普通换行## 我是&lt;h2&gt;标题我是`&lt;h2&gt;`的内容## 我是&lt;h3&gt;标题* Windows * Mac* iOS* Android","categories":[],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"pwn 入门1.1","slug":"pwn-入门1-1","date":"2018-08-13T14:35:13.000Z","updated":"2018-08-24T05:03:15.663Z","comments":true,"path":"2018/08/13/pwn-入门1-1/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/pwn-入门1-1/","excerpt":"","text":"各种变量的存储位置 stack：局部变量 heap: 动态分配内存的变量（malloc/new） bss section: 全局化的未初始化的变量 data section: 全局化的已初始化的变量 rodata: （只读data段）全局化的静态变量（const） 例如： 123456789int a = 0; //.dataint b; //.bssconst double PI = 3.1415 //rodataint main()&#123; int c = 2; //stack char *d = malloc(16); //heap return 0;&#125; linux下将shellcode运行1.手写简易shellcode 123456789101112jmp shrun: pop ebx mov BYTE [ebx+7],0 xor eax,eax mov al,11 xor ecx,ecx xor edx,edx int 0x80sh: call run db &quot;/bin/sh&quot; 2.一系列步骤 123Assembly: nasm a.asm -o a.o -felf32 Extract Shellcode: objcopy -O binary a.o code //将a.o中需要用内容的提取到code中 xxd -i code //将提取出来的code转换为机器码 3.带入调用shellcode的程序test.c #include &quot;code.h&quot; typedef int(*CODE)(); int main() { ((CODE)shellcode)(); } Run Shellcode: gcc test.c -o test -m32 -zexexstack syscalls.kernelgrok.com linux下的系统调用.","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]}]}