<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Room of Equirement</title>
  
  <subtitle>pwn what you want</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://siriuswhiter.tk/"/>
  <updated>2018-08-28T03:19:20.274Z</updated>
  <id>http://siriuswhiter.tk/</id>
  
  <author>
    <name>Sirius Whiter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pwn 入门n.n</title>
    <link href="http://siriuswhiter.tk/2018/08/28/pwn-%E5%85%A5%E9%97%A8n-n/"/>
    <id>http://siriuswhiter.tk/2018/08/28/pwn-入门n-n/</id>
    <published>2018-08-28T03:10:56.000Z</published>
    <updated>2018-08-28T03:19:20.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆的UAF-use-after-free-利用"><a href="#堆的UAF-use-after-free-利用" class="headerlink" title="堆的UAF(use after free)利用"></a>堆的UAF(use after free)利用</h1><p><em>学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，<br>先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，<br>只能看了下pwn的tips，开始现学现卖。</em></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；<br>而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。</p><ul><li>根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</li></ul><h2 id="漏洞的简单利用"><a href="#漏洞的简单利用" class="headerlink" title="漏洞的简单利用"></a>漏洞的简单利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef void (*func_ptr)(char *);</span><br><span class="line">void evil_fuc(char command[])</span><br><span class="line">&#123;</span><br><span class="line">system(command);</span><br><span class="line">&#125;</span><br><span class="line">void echo(char content[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s&quot;,content);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func_ptr *p1=(func_ptr*)malloc(4*sizeof(int));</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);</span><br><span class="line">    p1[3]=echo;</span><br><span class="line">    p1[3](&quot;hello world\n&quot;);</span><br><span class="line">    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针</span><br><span class="line">    p1[3](&quot;hello again\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态</span><br><span class="line">    func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p2);</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);//p2与p1指针指向的内存为同一地址</span><br><span class="line">    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.</span><br><span class="line">    p1[3](&quot;/bin/sh&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行效果：</p><figure class="image-box">                <img src="/2018/08/28/pwn-入门n-n/result.png" alt="result" title="" class="">                <p>result</p>            </figure><p><em>漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程</em></p><p>学习借鉴文章来源：<a href="https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆的UAF-use-after-free-利用&quot;&gt;&lt;a href=&quot;#堆的UAF-use-after-free-利用&quot; class=&quot;headerlink&quot; title=&quot;堆的UAF(use after free)利用&quot;&gt;&lt;/a&gt;堆的UAF(use after f
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn.入门1.2</title>
    <link href="http://siriuswhiter.tk/2018/08/28/pwn-%E5%85%A5%E9%97%A81-2/"/>
    <id>http://siriuswhiter.tk/2018/08/28/pwn-入门1-2/</id>
    <published>2018-08-28T01:46:58.000Z</published>
    <updated>2018-08-28T01:55:07.624Z</updated>
    
    <content type="html"><![CDATA[<p>ret2libc学习</p><h1 id="ret2libc使用原因"><a href="#ret2libc使用原因" class="headerlink" title="ret2libc使用原因"></a>ret2libc使用原因</h1><p>程序不是静态编译，通常就不会有int 0x80</p><p>ret2syscall 就无法实现，因而使用</p><p>ret2library。</p><h1 id="调用函数的栈结构布局-："><a href="#调用函数的栈结构布局-：" class="headerlink" title="调用函数的栈结构布局 ："></a>调用函数的栈结构布局 ：</h1><ul><li><p>调用函数的返回地址</p></li><li><p>函数调用完的返回地址</p></li><li><p>调用函数的参数1</p></li><li><p>调用函数的参数2</p></li></ul><h1 id="利用过程分析："><a href="#利用过程分析：" class="headerlink" title="利用过程分析："></a>利用过程分析：</h1><p>ASLR使得每次载入的函数地址（base）都不同</p><p>实际地址 Address = base +offset</p><p><em>若地址为 0xf…  则其为实际地址；</em></p><p>offset在libc库中是固定的；</p><ul><li>查看libc库版本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ldd  ./file</span><br></pre></td></tr></table></figure><ul><li>寻找偏移地址 ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a  /lib32/libc.so.6 | grep gets@</span><br></pre></td></tr></table></figure><ul><li>目标是寻找libc 的 base :</li></ul><p>1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset</p><p>2.从stack残渣中获取libc地址信息</p><h1 id="延迟绑定（没搞清楚，之后再写）"><a href="#延迟绑定（没搞清楚，之后再写）" class="headerlink" title="延迟绑定（没搞清楚，之后再写）"></a>延迟绑定（没搞清楚，之后再写）</h1><p>函数调用方式：</p><p>call  func@plt –&gt; .got.plt –&gt;.got.plt的值为该func的实际地址（所需address）</p><h1 id="使用调用函数的栈结构布局："><a href="#使用调用函数的栈结构布局：" class="headerlink" title="使用调用函数的栈结构布局："></a>使用调用函数的栈结构布局：</h1><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gets()</span><br><span class="line"></span><br><span class="line">pop1_ret(pop&lt;buf&gt; 然后 return）</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gets()</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ret2libc学习&lt;/p&gt;
&lt;h1 id=&quot;ret2libc使用原因&quot;&gt;&lt;a href=&quot;#ret2libc使用原因&quot; class=&quot;headerlink&quot; title=&quot;ret2libc使用原因&quot;&gt;&lt;/a&gt;ret2libc使用原因&lt;/h1&gt;&lt;p&gt;程序不是静态编译，通常就
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>软件保护/软件破解 及对抗</title>
    <link href="http://siriuswhiter.tk/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/"/>
    <id>http://siriuswhiter.tk/2018/08/25/软件保护-软件破解-及对抗/</id>
    <published>2018-08-25T01:30:41.000Z</published>
    <updated>2018-08-25T11:15:33.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h1><h2 id="简单算法注册保护："><a href="#简单算法注册保护：" class="headerlink" title="简单算法注册保护："></a>简单算法注册保护：</h2><p>输入用户名序列号，计算并检测序列号；</p><h2 id="简单算法注册保护的对抗："><a href="#简单算法注册保护的对抗：" class="headerlink" title="简单算法注册保护的对抗："></a>简单算法注册保护的对抗：</h2><p>①修改关键指令：暴力破解；patcher<br>②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机<br>③还原本身算法；keygen</p><h2 id="复杂算法注册保护："><a href="#复杂算法注册保护：" class="headerlink" title="复杂算法注册保护："></a>复杂算法注册保护：</h2><p>通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等；</p><h2 id="复杂算法注册保护的对抗："><a href="#复杂算法注册保护的对抗：" class="headerlink" title="复杂算法注册保护的对抗："></a>复杂算法注册保护的对抗：</h2><p>①patch<br>②补丁修改公钥，使用自己的公钥对；</p><h2 id="网络加密及硬件加密："><a href="#网络加密及硬件加密：" class="headerlink" title="网络加密及硬件加密："></a>网络加密及硬件加密：</h2><p>本质上与本地加密相同/运行前检测？？</p><h2 id="网络加密及硬件加密的对抗："><a href="#网络加密及硬件加密的对抗：" class="headerlink" title="网络加密及硬件加密的对抗："></a>网络加密及硬件加密的对抗：</h2><p>①patch<br>②模拟与远程端的通信，及模拟执行；<br>③使用中转程序，从服务器获得远程执行结果；</p><h2 id="复杂系统注册保护："><a href="#复杂系统注册保护：" class="headerlink" title="复杂系统注册保护："></a>复杂系统注册保护：</h2><p>以上内容混杂</p><p>附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测</p><h1 id="软件破解及对抗"><a href="#软件破解及对抗" class="headerlink" title="软件破解及对抗"></a>软件破解及对抗</h1><h2 id="程序分析及对抗："><a href="#程序分析及对抗：" class="headerlink" title="程序分析及对抗："></a>程序分析及对抗：</h2><ul><li>代码变形mutation；</li><li>代码膨胀expansion；</li><li>花指令；</li><li>代码乱序；</li><li>平坦化；</li></ul><h2 id="程序调试及对抗："><a href="#程序调试及对抗：" class="headerlink" title="程序调试及对抗："></a>程序调试及对抗：</h2><ul><li>系统API检测程序是否处于被调试状态；</li><li>检测调试器窗口信息、状态码；</li><li>检测调试器驱动，符号；</li><li>程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）；</li><li>利用驱动接管本身程序的中断，阻止被调试器接管；</li><li>利用驱动修改内核参数，阻止程序被调试；</li><li>双进程反调试；</li></ul><h2 id="程序修改及对抗："><a href="#程序修改及对抗：" class="headerlink" title="程序修改及对抗："></a>程序修改及对抗：</h2><p>修改：文件补丁技术及工具；<br>对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等；</p><p><em>dnspy：.NET程序逆向工具</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件保护&quot;&gt;&lt;a href=&quot;#软件保护&quot; class=&quot;headerlink&quot; title=&quot;软件保护&quot;&gt;&lt;/a&gt;软件保护&lt;/h1&gt;&lt;h2 id=&quot;简单算法注册保护：&quot;&gt;&lt;a href=&quot;#简单算法注册保护：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="RE" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>hexo essay writing</title>
    <link href="http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/"/>
    <id>http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/</id>
    <published>2018-08-15T15:33:24.000Z</published>
    <updated>2018-08-25T02:04:13.859Z</updated>
    
    <content type="html"><![CDATA[<ol><li>打开git,进入MyBlog目录；</li><li>输入 <code>hexo new &quot;essay-name&quot;</code>；</li><li>打开source文件夹，找到 essay-name.md，使用markdown语法写作；</li><li>执行命令 <code>/ hexo clean / hexo generate/ hexo deploy</code>；</li><li>over；</li></ol><p><strong>假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;打开git,进入MyBlog目录；&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;hexo new &amp;quot;essay-name&amp;quot;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;打开source文件夹，找到 essay-name.md，使用markdown语法写作；&lt;/
      
    
    </summary>
    
    
      <category term="skills" scheme="http://siriuswhiter.tk/tags/skills/"/>
    
  </entry>
  
  <entry>
    <title>markdown规范学习</title>
    <link href="http://siriuswhiter.tk/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/"/>
    <id>http://siriuswhiter.tk/2018/08/13/markdown规范学习/</id>
    <published>2018-08-13T14:46:46.000Z</published>
    <updated>2018-08-24T05:18:29.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MarkDown-v1-0"><a href="#MarkDown-v1-0" class="headerlink" title="MarkDown v1.0"></a>MarkDown v1.0</h1><h2 id="1-1-全局规范"><a href="#1-1-全局规范" class="headerlink" title="1.1 全局规范"></a>1.1 全局规范</h2><p><a name="top"></a></p><ul><li>MarkDown 文件使用‘.md’结尾 （<strong>小写字母</strong>)</li></ul><h2 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h2><h3 id="标题结构格式"><a href="#标题结构格式" class="headerlink" title="标题结构格式"></a>标题结构格式</h3><p>1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开<br>2.’#’号和文字之间’一个空格’连接<br>3.标题层级最多六级 ‘#’到’######’</p><h3 id="加强和强调规范"><a href="#加强和强调规范" class="headerlink" title="加强和强调规范"></a>加强和强调规范</h3><p>一般统一使用第一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*emphasize*</span><br><span class="line">_emphasize_</span><br></pre></td></tr></table></figure><p>使用’~~’给文字添加删除线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~strikethrough~~</span><br></pre></td></tr></table></figure></p><h3 id="代码块规范"><a href="#代码块规范" class="headerlink" title="代码块规范"></a>代码块规范</h3><ul><li>行内代码使用’一对波浪号’如：<code>hello world!</code></li><li>块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;看源码之三个波浪号&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><pre><code>&lt;?php    echo &apos;看源码之四空格缩进&apos;;?&gt;</code></pre><h3 id="列表写法"><a href="#列表写法" class="headerlink" title="列表写法"></a>列表写法</h3><ul><li>列号’1.’或者’*’后内容用空格隔开</li><li>列表块前后’整行隔开’ 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Windows  </span><br><span class="line">2. Mac</span><br><span class="line">3. iOS</span><br><span class="line">    * iPhone</span><br><span class="line">    * iPad</span><br><span class="line">4. Android</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ol><li>Windows  </li><li>Mac</li><li>iOS<ul><li>iPhone</li><li>iPad</li></ul></li><li>Android</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br><span class="line">    1. v3.2</span><br><span class="line">    2. v4.1</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ul><li>Windows  </li><li>Mac</li><li>iOS</li><li>Android<ol><li>v3.2</li><li>v4.1</li></ol></li></ul><h3 id="其他标签规范"><a href="#其他标签规范" class="headerlink" title="其他标签规范"></a>其他标签规范</h3><p>链接和email</p><p>Inline：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An [example](http://url.com/ &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>实现效果：<br>An <a href="http://url.com/" title="title" target="_blank" rel="noopener">example</a></p><p>引用样式标签（titles are optional）:</p><pre><code>An [example][id].Then,anywhereelse in the doc,define the link:[id]:http://example.com/ &quot;title&quot;</code></pre><p>Email:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An email &lt;example@example.com&gt; link.</span><br></pre></td></tr></table></figure><p>插图<br>Inline(titles are optional)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt text](/path/img.jpg &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>引用式插图：</p><pre><code>![alt text][id][id]:/url/to/img.jpg &quot;title&quot;</code></pre><p>引用块及嵌套</p><blockquote><p>Email-style angle brackets<br>are used for blockquotes.</p></blockquote><blockquote><blockquote><p>And, they can be nested.</p></blockquote></blockquote><blockquote><h4 id="Headers-in-blockquotes"><a href="#Headers-in-blockquotes" class="headerlink" title="Headers in blockquotes"></a>Headers in blockquotes</h4><ul><li>You can quote a list.</li><li>Etc.</li></ul></blockquote><p>内联代码</p><p><code>&lt;code&gt;</code> 段落中的用法</p><p>也可以 <code>`代码中包含波浪号`</code>.<br>代码块</p><p>Indent every line of a code block by at least 4 spaces or 1 tab.<br>代码的每行都最少用4个空格或者一个制表符(tab)</p><p>我是普通文本块</p><pre><code>我是一个预格式化的代码块.</code></pre><p>水平分割线<br>三个<code>连字符-</code>:</p><hr><h3 id="表格规范"><a href="#表格规范" class="headerlink" title="表格规范"></a>表格规范</h3><p>一个简单的表格看起来如下：</p><table><thead><tr><th>第一个头部</th><th>第二个头部</th><th>第三个头部</th></tr></thead><tbody><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr></tbody></table><p>每列的对齐可以通过在分割线上添加冒号来实现：</p><table><thead><tr><th style="text-align:left">第一个头部</th><th style="text-align:center">第二个头部</th><th style="text-align:right">第三个头部</th></tr></thead><tbody><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr></tbody></table><h3 id="页内锚标记"><a href="#页内锚标记" class="headerlink" title="页内锚标记"></a>页内锚标记</h3><ul><li><a href="#11全局规范">点我跳转到顶部</a>   // 利用 <code>#</code>,<code>##</code> 生成 <code>id</code> 锚标签  </li><li><a href="#top">另一种锚标记</a> // 利用 <code>&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;</code></li></ul><hr><p>附：参考 Hello-World.md 源码，<em>注意换行的使用</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Hello-World</span><br><span class="line"></span><br><span class="line">这是一个范例文件格式</span><br><span class="line">我是普通换行</span><br><span class="line"></span><br><span class="line">## 我是&lt;h2&gt;标题</span><br><span class="line"></span><br><span class="line">我是`&lt;h2&gt;`的内容</span><br><span class="line"></span><br><span class="line">## 我是&lt;h3&gt;标题</span><br><span class="line"></span><br><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MarkDown-v1-0&quot;&gt;&lt;a href=&quot;#MarkDown-v1-0&quot; class=&quot;headerlink&quot; title=&quot;MarkDown v1.0&quot;&gt;&lt;/a&gt;MarkDown v1.0&lt;/h1&gt;&lt;h2 id=&quot;1-1-全局规范&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
      <category term="skills" scheme="http://siriuswhiter.tk/tags/skills/"/>
    
  </entry>
  
  <entry>
    <title>pwn 入门1.1</title>
    <link href="http://siriuswhiter.tk/2018/08/13/pwn-%E5%85%A5%E9%97%A81-1/"/>
    <id>http://siriuswhiter.tk/2018/08/13/pwn-入门1-1/</id>
    <published>2018-08-13T14:35:13.000Z</published>
    <updated>2018-08-24T05:03:15.663Z</updated>
    
    <content type="html"><![CDATA[<h3 id="各种变量的存储位置"><a href="#各种变量的存储位置" class="headerlink" title="各种变量的存储位置"></a>各种变量的存储位置</h3><ol><li>stack：局部变量</li><li>heap: 动态分配内存的变量（malloc/new）</li><li>bss section: 全局化的未初始化的变量</li><li>data section: 全局化的已初始化的变量<ul><li>rodata: （只读data段）全局化的静态变量（const）</li></ul></li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;   //.data</span><br><span class="line">int b;       //.bss</span><br><span class="line">const double PI = 3.1415    //rodata</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int c = 2;    //stack</span><br><span class="line">char *d = malloc(16);    //heap</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linux下将shellcode运行"><a href="#linux下将shellcode运行" class="headerlink" title="linux下将shellcode运行"></a>linux下将shellcode运行</h3><p>1.手写简易shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmp sh</span><br><span class="line">run:</span><br><span class="line">    pop ebx</span><br><span class="line">    mov BYTE [ebx+7],0</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov al,11</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    xor edx,edx</span><br><span class="line">    int 0x80</span><br><span class="line">sh:</span><br><span class="line">    call run</span><br><span class="line">    db &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure><p>2.一系列步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Assembly:  nasm a.asm -o a.o -felf32   </span><br><span class="line">Extract Shellcode: objcopy -O binary a.o code   //将a.o中需要用内容的提取到code中</span><br><span class="line">                   xxd -i code        //将提取出来的code转换为机器码</span><br></pre></td></tr></table></figure><p>3.带入调用shellcode的程序test.c</p><pre><code>#include  &quot;code.h&quot;typedef int(*CODE)();int main(){    ((CODE)shellcode)();}Run Shellcode: gcc test.c -o test -m32 -zexexstack       </code></pre><p><em>syscalls.kernelgrok.com linux下的系统调用.</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;各种变量的存储位置&quot;&gt;&lt;a href=&quot;#各种变量的存储位置&quot; class=&quot;headerlink&quot; title=&quot;各种变量的存储位置&quot;&gt;&lt;/a&gt;各种变量的存储位置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;stack：局部变量&lt;/li&gt;
&lt;li&gt;heap: 动态分配内存的变量（
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
</feed>
